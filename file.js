/**
 *    _____ _________    __    ___    ____
 *   / ___// ____/   |  / /   /   |  / __ \
 *   \__ \/ /   / /| | / /   / /| | / /_/ /
 *  ___/ / /___/ ___ |/ /___/ ___ |/ _, _/
 * /____/\____/_/  |_/_____/_/  |_/_/ |_|
 *
 * {{ packageName }} {{ version }}
 *
 * Website: https://scalar.com
 * GitHub:  https://github.com/scalar/scalar
 * License: https://github.com/scalar/scalar/blob/main/LICENSE
**/

!function() {
    "use strict";
    try {
        if ("undefined" != typeof document) {
            var a = document.createElement("style");
            a.appendChild(document.createTextNode('.scalar-modal-layout[data-v-03b82fd9]{animation:modal-fade-03b82fd9 .2s forwards}.scalar-modal[data-v-03b82fd9]{animation:modal-pop-03b82fd9 .15s .15s forwards;height:calc(100% - 120px);width:calc(100% - 8px);max-width:1390px;position:fixed;left:0;top:0;bottom:0;right:0;margin:auto}.scalar-modal.scalar-modal-search[data-v-03b82fd9]{max-width:540px;background-color:transparent}.modal-content-search .modal-body[data-v-03b82fd9]{padding:0;overflow:hidden;display:flex;flex-direction:column;max-height:440px}@media (max-width: 1280px){.scalar-modal[data-v-03b82fd9]{height:calc(100% - 56px);top:46px}}@keyframes modal-fade-03b82fd9{0%{opacity:0}to{opacity:1}}@keyframes modal-pop-03b82fd9{0%{opacity:0}to{opacity:1}}@layer scalar-base,scalar-theme;:where(.scalar-app){font-family:var(--scalar-font);line-height:1.15;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4}:where(.scalar-app) *,:where(.scalar-app) *:before,:where(.scalar-app) *:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:var(--scalar-border-color);font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:unset;font-weight:inherit;line-height:inherit;color:inherit;margin:unset;padding:unset;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:where(.scalar-app) button,:where(.scalar-app) input,:where(.scalar-app) optgroup,:where(.scalar-app) select,:where(.scalar-app) textarea,:where(.scalar-app) ::file-selector-button{background:transparent}:where(.scalar-app) input:where(:not([type=button],[type=reset],[type=submit])),:where(.scalar-app) select,:where(.scalar-app) textarea{border-radius:var(--scalar-radius);border-width:1px}:where(.scalar-app) input::placeholder,:where(.scalar-app) input:-ms-input-placeholder,:where(.scalar-app) input::-webkit-input-placeholder{color:var(--scalar-color-3);font-family:var(--scalar-font)}:where(.scalar-app) input:-webkit-autofill{-webkit-background-clip:text!important;background-clip:text!important}.scalar-app .cm-scroller,.scalar-app .custom-scroll{overflow-y:auto;scrollbar-color:transparent transparent;scrollbar-width:thin;-webkit-overflow-scrolling:touch}.scalar-app .custom-scroll-self-contain-overflow{overscroll-behavior:contain}@supports (-moz-appearance: none){.scalar-app .cm-scroller,.scalar-app .custom-scroll{padding-right:12px}}.scalar-app .cm-scroller:hover,.scalar-app .custom-scroll:hover{scrollbar-color:var(--scalar-scrollbar-color, transparent)}.scalar-app .cm-scroller:hover::-webkit-scrollbar-thumb,.scalar-app .custom-scroll:hover::-webkit-scrollbar-thumb{background:var(--scalar-scrollbar-color);background-clip:content-box;border:3px solid transparent}.scalar-app .cm-scroller::-webkit-scrollbar-thumb:active,.scalar-app .custom-scroll::-webkit-scrollbar-thumb:active{background:var(--scalar-scrollbar-color-active);background-clip:content-box;border:3px solid transparent}.scalar-app .cm-scroller::-webkit-scrollbar-corner,.scalar-app .custom-scroll::-webkit-scrollbar-corner{background:transparent}.scalar-app .cm-scroller::-webkit-scrollbar,.scalar-app .custom-scroll::-webkit-scrollbar{height:12px;width:12px}.scalar-app .cm-scroller::-webkit-scrollbar-track,.scalar-app .custom-scroll::-webkit-scrollbar-track{background:transparent}.scalar-app .cm-scroller::-webkit-scrollbar-thumb,.scalar-app .custom-scroll::-webkit-scrollbar-thumb{border-radius:20px;background:transparent;background-clip:content-box;border:3px solid transparent}@media (pointer: coarse){.scalar-app .cm-scroller,.scalar-app .custom-scroll{padding-right:12px}}@layer scalar-base{:root{--scalar-border-width: 1px;--scalar-radius: 3px;--scalar-radius-lg: 6px;--scalar-radius-xl: 8px;--scalar-font: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;--scalar-font-code: "JetBrains Mono", ui-monospace, Menlo, Monaco, "Cascadia Mono", "Segoe UI Mono", "Roboto Mono", "Oxygen Mono", "Ubuntu Monospace", "Source Code Pro", "Fira Mono", "Droid Sans Mono", "Courier New", monospace;--scalar-heading-1: 40px;--scalar-page-description: 24px;--scalar-heading-2: 24px;--scalar-heading-3: 20px;--scalar-heading-4: 16px;--scalar-heading-5: 16px;--scalar-heading-6: 16px;--scalar-paragraph: 16px;--scalar-small: 14px;--scalar-mini: 13px;--scalar-micro: 12px;--scalar-bold: 600;--scalar-semibold: 500;--scalar-regular: 400;--scalar-font-size-1: 24px;--scalar-font-size-2: 16px;--scalar-font-size-3: 14px;--scalar-font-size-4: 13px;--scalar-font-size-5: 12px;--scalar-font-size-6: 12px;--scalar-font-size-7: 10px;--scalar-line-height-1: 32px;--scalar-line-height-2: 24px;--scalar-line-height-3: 20px;--scalar-line-height-4: 18px;--scalar-line-height-5: 16px;--scalar-font-medium: 500;--scalar-font-bold: 700;--scalar-text-decoration: none;--scalar-text-decoration-hover: underline}.dark-mode{color-scheme:dark;--scalar-scrollbar-color: rgba(255, 255, 255, .18);--scalar-scrollbar-color-active: rgba(255, 255, 255, .36);--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black;--scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, .1);--scalar-shadow-2: rgba(15, 15, 15, .2) 0px 3px 6px, rgba(15, 15, 15, .4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, .1);--scalar-sidebar-indent-border: transparent;--scalar-sidebar-indent-border-hover: transparent;--scalar-sidebar-indent-border-active: transparent}.light-mode{color-scheme:light;--scalar-scrollbar-color-active: rgba(0, 0, 0, .36);--scalar-scrollbar-color: rgba(0, 0, 0, .18);--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9);--scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, .11);--scalar-shadow-2: rgba(0, 0, 0, .08) 0px 13px 20px 0px, rgba(0, 0, 0, .08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;--scalar-sidebar-indent-border: transparent;--scalar-sidebar-indent-border-hover: transparent;--scalar-sidebar-indent-border-active: transparent}.light-mode .dark-mode{color-scheme:dark!important}@media (max-width: 460px){:root{--scalar-font-size-1: 22px;--scalar-font-size-2: 14px;--scalar-font-size-3: 12px}}@media (max-width: 720px){:root{--scalar-heading-1: 24px;--scalar-page-description: 20px}}.light-mode{--scalar-background-1: #fff;--scalar-background-2: #f6f6f6;--scalar-background-3: #e7e7e7;--scalar-background-accent: #8ab4f81f;--scalar-color-1: #2a2f45;--scalar-color-2: #757575;--scalar-color-3: #8e8e8e;--scalar-color-accent: #0099ff;--scalar-border-color: rgba(0, 0, 0, .1)}.dark-mode{--scalar-background-1: #0f0f0f;--scalar-background-2: #1a1a1a;--scalar-background-3: #272727;--scalar-color-1: rgba(255, 255, 255, .9);--scalar-color-2: rgba(255, 255, 255, .62);--scalar-color-3: rgba(255, 255, 255, .44);--scalar-color-accent: #3ea6ff;--scalar-background-accent: #3ea6ff1f;--scalar-border-color: rgba(255, 255, 255, .1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-active-background: var(--scalar-background-2);--scalar-sidebar-color-active: var(--scalar-color-1);--scalar-sidebar-search-background: transparent;--scalar-sidebar-search-color: var(--scalar-color-3);--scalar-sidebar-search-border-color: var(--scalar-border-color)}.light-mode{--scalar-color-green: #069061;--scalar-color-red: #ef0006;--scalar-color-yellow: #edbe20;--scalar-color-blue: #0082d0;--scalar-color-orange: #fb892c;--scalar-color-purple: #5203d1;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: #00b648;--scalar-color-red: #dc1b19;--scalar-color-yellow: #ffc90d;--scalar-color-blue: #4eb3ec;--scalar-color-orange: #ff8d4d;--scalar-color-purple: #b191f9;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}}*,:before,:after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / .5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / .5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }.scalar-app .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.scalar-app .pointer-events-none{pointer-events:none}.scalar-app .visible{visibility:visible}.scalar-app .fixed{position:fixed}.scalar-app .absolute{position:absolute}.scalar-app .relative{position:relative}.scalar-app .inset-0{top:0;right:0;bottom:0;left:0}.scalar-app .left-0{left:0}.scalar-app .top-0{top:0}.scalar-app .top-\\[0\\.5px\\]{top:.5px}.scalar-app .-z-1{z-index:-1}.scalar-app .z-\\[1001\\]{z-index:1001}.scalar-app .z-overlay{z-index:10000}.scalar-app .m-0{margin:0}.scalar-app .-mx-0{margin-left:-0px;margin-right:-0px}.scalar-app .-mx-0\\.75{margin-left:-3px;margin-right:-3px}.scalar-app .mx-2{margin-left:8px;margin-right:8px}.scalar-app .mx-auto{margin-left:auto;margin-right:auto}.scalar-app .my-0{margin-top:0;margin-bottom:0}.scalar-app .my-0\\.75{margin-top:3px;margin-bottom:3px}.scalar-app .my-3{margin-top:12px;margin-bottom:12px}.scalar-app .mb-0{margin-bottom:0}.scalar-app .ml-1{margin-left:4px}.scalar-app .ml-2{margin-left:8px}.scalar-app .mr-2{margin-right:8px}.scalar-app .mr-3{margin-right:12px}.scalar-app .mt-0{margin-top:0}.scalar-app .mt-1{margin-top:4px}.scalar-app .mt-1\\.5{margin-top:6px}.scalar-app .mt-20{margin-top:80px}.scalar-app .block{display:block}.scalar-app .inline-block{display:inline-block}.scalar-app .flex{display:flex}.scalar-app .grid{display:grid}.scalar-app .contents{display:contents}.scalar-app .hidden{display:none}.scalar-app .aspect-square{aspect-ratio:1 / 1}.scalar-app .size-10{width:40px;height:40px}.scalar-app .size-2{width:8px;height:8px}.scalar-app .size-2\\.5{width:10px;height:10px}.scalar-app .size-3{width:12px;height:12px}.scalar-app .size-3\\.5{width:14px;height:14px}.scalar-app .size-4{width:16px;height:16px}.scalar-app .size-5{width:20px;height:20px}.scalar-app .size-6{width:24px;height:24px}.scalar-app .size-8{width:32px;height:32px}.scalar-app .size-full{width:100%;height:100%}.scalar-app .h-10{height:40px}.scalar-app .h-4{height:16px}.scalar-app .h-\\[100dvh\\]{height:100dvh}.scalar-app .h-full{height:100%}.scalar-app .h-px{height:1px}.scalar-app .h-screen{height:100vh}.scalar-app .max-h-\\[440px\\]{max-height:440px}.scalar-app .max-h-\\[calc\\(100dvh-240px\\)\\]{max-height:calc(100dvh - 240px)}.scalar-app .min-h-\\[77px\\]{min-height:77px}.scalar-app .w-4{width:16px}.scalar-app .w-40{width:160px}.scalar-app .w-48{width:192px}.scalar-app .w-56{width:224px}.scalar-app .w-\\[100dvw\\]{width:100dvw}.scalar-app .w-full{width:100%}.scalar-app .min-w-0{min-width:0px}.scalar-app .max-w-screen-lg{max-width:800px}.scalar-app .max-w-screen-md{max-width:640px}.scalar-app .max-w-screen-sm{max-width:540px}.scalar-app .max-w-screen-xs{max-width:480px}.scalar-app .flex-1{flex:1 1 0%}.scalar-app .origin-top-left{transform-origin:top left}.scalar-app .rotate-90{--tw-rotate:90deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-app .transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.scalar-app .cursor-not-allowed{cursor:not-allowed}.scalar-app .cursor-pointer{cursor:pointer}.scalar-app .resize-none{resize:none}.scalar-app .resize{resize:both}.scalar-app .appearance-none{-webkit-appearance:none;-moz-appearance:none;appearance:none}.scalar-app .flex-col{flex-direction:column}.scalar-app .flex-wrap{flex-wrap:wrap}.scalar-app .items-start{align-items:flex-start}.scalar-app .items-center{align-items:center}.scalar-app .justify-center{justify-content:center}.scalar-app .justify-between{justify-content:space-between}.scalar-app .gap-0{gap:0px}.scalar-app .gap-0\\.75{gap:3px}.scalar-app .gap-1{gap:4px}.scalar-app .gap-1\\.5{gap:6px}.scalar-app .gap-2{gap:8px}.scalar-app .gap-3{gap:12px}.scalar-app .gap-4{gap:16px}.scalar-app .divide-y>:not([hidden])~:not([hidden]){--tw-divide-y-reverse:0;border-top-width:calc(var(--scalar-border-width) * calc(1 - var(--tw-divide-y-reverse)));border-bottom-width:calc(var(--scalar-border-width) * var(--tw-divide-y-reverse))}.scalar-app .self-center{align-self:center}.scalar-app .overflow-hidden{overflow:hidden}.scalar-app .overflow-y-auto{overflow-y:auto}.scalar-app .truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.scalar-app .text-wrap{text-wrap:wrap}.scalar-app .rounded{border-radius:var(--scalar-radius)}.scalar-app .rounded-full{border-radius:9999px}.scalar-app .rounded-lg{border-radius:var(--scalar-radius-lg)}.scalar-app .border{border-width:var(--scalar-border-width)}.scalar-app .border-0{border-width:0}.scalar-app .border-solid{border-style:solid}.scalar-app .border-none{border-style:none}.scalar-app .border-border{border-color:var(--scalar-border-color)}.scalar-app .border-c-3{border-color:var(--scalar-color-3)}.scalar-app .border-error{border-color:var(--scalar-error-color)}.scalar-app .bg-b-1{background-color:var(--scalar-background-1)}.scalar-app .bg-b-2{background-color:var(--scalar-background-2)}.scalar-app .bg-b-btn{background-color:var(--scalar-button-1)}.scalar-app .bg-backdrop{background-color:#00000070}.scalar-app .bg-blue{background-color:var(--scalar-color-blue)}.scalar-app .bg-border{background-color:var(--scalar-border-color)}.scalar-app .bg-error{background-color:var(--scalar-error-color)}.scalar-app .bg-transparent{background-color:transparent}.scalar-app .stroke-\\[0\\.92\\]{stroke-width:.92}.scalar-app .stroke-\\[0\\.96\\]{stroke-width:.96}.scalar-app .stroke-\\[0\\.9\\]{stroke-width:.9}.scalar-app .stroke-\\[1\\.1\\]{stroke-width:1.1}.scalar-app .stroke-\\[1\\.2\\]{stroke-width:1.2}.scalar-app .stroke-\\[1\\.4\\]{stroke-width:1.4}.scalar-app .stroke-\\[1\\.75\\]{stroke-width:1.75}.scalar-app .p-0{padding:0}.scalar-app .p-0\\.5{padding:2px}.scalar-app .p-0\\.75{padding:3px}.scalar-app .p-1{padding:4px}.scalar-app .p-2{padding:8px}.scalar-app .p-3{padding:12px}.scalar-app .p-\\[3px\\]{padding:3px}.scalar-app .px-1{padding-left:4px;padding-right:4px}.scalar-app .px-2{padding-left:8px;padding-right:8px}.scalar-app .px-2\\.5{padding-left:10px;padding-right:10px}.scalar-app .px-3{padding-left:12px;padding-right:12px}.scalar-app .px-4{padding-left:16px;padding-right:16px}.scalar-app .px-6{padding-left:24px;padding-right:24px}.scalar-app .px-9{padding-left:36px;padding-right:36px}.scalar-app .py-1{padding-top:4px;padding-bottom:4px}.scalar-app .py-1\\.5{padding-top:6px;padding-bottom:6px}.scalar-app .py-3{padding-top:12px;padding-bottom:12px}.scalar-app .py-4{padding-top:16px;padding-bottom:16px}.scalar-app .pb-0{padding-bottom:0}.scalar-app .pb-4{padding-bottom:16px}.scalar-app .pl-9{padding-left:36px}.scalar-app .pr-3{padding-right:12px}.scalar-app .pt-3{padding-top:12px}.scalar-app .pt-6{padding-top:24px}.scalar-app .text-left{text-align:left}.scalar-app .font-code{font-family:var(--scalar-font-code)}.scalar-app .text-lg{font-size:var(--scalar-font-size-2)}.scalar-app .text-sm{font-size:var(--scalar-font-size-4)}.scalar-app .text-xs{font-size:var(--scalar-font-size-5)}.scalar-app .text-xxs{font-size:var(--scalar-font-size-6)}.scalar-app .font-bold{font-weight:var(--scalar-bold)}.scalar-app .font-medium{font-weight:var(--scalar-semibold)}.scalar-app .leading-snug{line-height:1.375}.scalar-app .text-b-1{color:var(--scalar-background-1)}.scalar-app .text-c-1{color:var(--scalar-color-1)}.scalar-app .text-c-2{color:var(--scalar-color-2)}.scalar-app .text-c-3{color:var(--scalar-color-3)}.scalar-app .text-c-btn{color:var(--scalar-button-1-color)}.scalar-app .text-c-ghost{color:var(--scalar-color-ghost)}.scalar-app .text-error{color:var(--scalar-error-color)}.scalar-app .text-transparent{color:transparent}.scalar-app .text-white{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity))}.scalar-app .no-underline{text-decoration-line:none}.scalar-app .opacity-0{opacity:0}.scalar-app .opacity-50{opacity:.5}.scalar-app .shadow{--tw-shadow:var(--scalar-shadow-1);--tw-shadow-colored:var(--scalar-shadow-1);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.scalar-app .shadow-lg{--tw-shadow:var(--scalar-shadow-2);--tw-shadow-colored:var(--scalar-shadow-2);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.scalar-app .shadow-md{--tw-shadow:var(--scalar-shadow-1);--tw-shadow-colored:var(--scalar-shadow-1);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.scalar-app .shadow-none{--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.scalar-app .shadow-sm{--tw-shadow:rgba(0, 0, 0, .09) 0px 1px 4px;--tw-shadow-colored:0px 1px 4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.scalar-app .shadow-current{--tw-shadow-color:currentColor;--tw-shadow:var(--tw-shadow-colored)}.scalar-app .outline-none{outline:2px solid transparent;outline-offset:2px}.scalar-app .outline{outline-style:solid}.scalar-app .blur{--tw-blur:blur(8px);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.scalar-app .brightness-lifted{--tw-brightness:brightness(var(--scalar-lifted-brightness));filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.scalar-app .filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.scalar-app .transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.scalar-app .transition-colors{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.scalar-app .transition-opacity{transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.scalar-app .transition-transform{transition-property:transform;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.scalar-app .ease-in-out{transition-timing-function:cubic-bezier(.4,0,.2,1)}.scalar-app .bg-b-1{--tw-bg-base:var(--scalar-background-1)}.scalar-app .bg-b-2{--tw-bg-base:var(--scalar-background-2)}.scalar-app .bg-b-btn{--tw-bg-base:var(--scalar-button-1)}.scalar-app .bg-backdrop{--tw-bg-base:rgba(0, 0, 0, .44)}.scalar-app .bg-blue{--tw-bg-base:var(--scalar-color-blue)}.scalar-app .bg-border{--tw-bg-base:var(--scalar-border-color)}.scalar-app .bg-error{--tw-bg-base:var(--scalar-error-color)}.scalar-app .bg-transparent{--tw-bg-base:transparent}.scalar-app .row{display:flex;flex-direction:row}.scalar-app .col{display:flex;flex-direction:column}.before\\:mr-1:before{content:var(--tw-content);margin-right:4px}.before\\:mr-1\\.5:before{content:var(--tw-content);margin-right:6px}.before\\:block:before{content:var(--tw-content);display:block}.before\\:h-4:before{content:var(--tw-content);height:16px}.before\\:w-4:before{content:var(--tw-content);width:16px}.before\\:rounded-full:before{content:var(--tw-content);border-radius:9999px}.before\\:bg-error:before{content:var(--tw-content);background-color:var(--scalar-error-color)}.before\\:text-center:before{content:var(--tw-content);text-align:center}.before\\:text-xxs:before{content:var(--tw-content);font-size:var(--scalar-font-size-6)}.before\\:leading-4:before{content:var(--tw-content);line-height:var(--scalar-line-height-4)}.before\\:text-white:before{content:var(--tw-content);--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity))}.before\\:content-\\[\\\'\\!\\\'\\]:before{--tw-content:"!";content:var(--tw-content)}.before\\:bg-error:before{content:var(--tw-content);--tw-bg-base:var(--scalar-error-color)}.first-of-type\\:mt-0:first-of-type{margin-top:0}.first-of-type\\:mt-0\\.75:first-of-type{margin-top:3px}.last-of-type\\:mb-0:last-of-type{margin-bottom:0}.last-of-type\\:mb-0\\.75:last-of-type{margin-bottom:3px}.empty\\:hidden:empty{display:none}.focus-within\\:border-c-1:focus-within{border-color:var(--scalar-color-1)}.hover\\:bg-b-2:hover{background-color:var(--scalar-background-2)}.hover\\:text-c-1:hover{color:var(--scalar-color-1)}.hover\\:bg-b-2:hover{--tw-bg-base:var(--scalar-background-2)}.active\\:bg-b-btn:active{background-color:var(--scalar-button-1)}.active\\:text-c-1:active{color:var(--scalar-color-1)}.active\\:shadow-none:active{--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.active\\:brightness-90:active{--tw-brightness:brightness(.9);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.active\\:bg-b-btn:active{--tw-bg-base:var(--scalar-button-1)}.group:hover .group-hover\\:text-c-1{color:var(--scalar-color-1)}.group:hover .group-hover\\:shadow-border{--tw-shadow:inset 0 0 0 1px var(--scalar-border-color);--tw-shadow-colored:inset 0 0 0 1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow);--tw-shadow-color:var(--scalar-border-color);--tw-shadow:var(--tw-shadow-colored)}.ui-open\\:rotate-180[data-headlessui-state~=open]{--tw-rotate:180deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}:where([data-headlessui-state~=open]) .ui-open\\:rotate-180{--tw-rotate:180deg;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.has-actv-btn\\:border:has(button:active){border-width:var(--scalar-border-width)}.has-actv-btn\\:border-border:has(button:active){border-color:var(--scalar-border-color)}.\\!empty\\:flex:not(:empty){display:flex}.\\!empty\\:w-7:not(:empty){width:28px}.\\!empty\\:items-center:not(:empty){align-items:center}.\\!empty\\:pr-3:not(:empty){padding-right:12px}.hocus\\:bg-border:hover{background-color:var(--scalar-border-color)}.hocus\\:bg-h-btn:hover{background-color:var(--scalar-button-1-hover)}.hocus\\:text-c-1:hover{color:var(--scalar-color-1)}.hocus\\:brightness-90:hover{--tw-brightness:brightness(.9);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.hocus\\:bg-border:hover{--tw-bg-base:var(--scalar-border-color)}.hocus\\:bg-h-btn:hover{--tw-bg-base:var(--scalar-button-1-hover)}.hocus\\:bg-border:focus-visible{background-color:var(--scalar-border-color)}.hocus\\:bg-h-btn:focus-visible{background-color:var(--scalar-button-1-hover)}.hocus\\:text-c-1:focus-visible{color:var(--scalar-color-1)}.hocus\\:brightness-90:focus-visible{--tw-brightness:brightness(.9);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.hocus\\:bg-border:focus-visible{--tw-bg-base:var(--scalar-border-color)}.hocus\\:bg-h-btn:focus-visible{--tw-bg-base:var(--scalar-button-1-hover)}@media (min-width: 800px){.md\\:row{display:flex;flex-direction:row}}.loader-wrapper[data-v-47faceda]{position:relative;height:var(--d6cae758);width:var(--d6cae758);display:flex;align-items:center;justify-content:center;--loader-size: 50%}.svg-loader[data-v-47faceda]{width:var(--loader-size);height:var(--loader-size);top:1rem;right:.9rem;overflow:visible;fill:none;background-color:transparent;stroke:currentColor}.svg-path[data-v-47faceda]{stroke-width:14;fill:none;transition:.3s}.svg-x-mark[data-v-47faceda]{stroke-dasharray:57;stroke-dashoffset:57;transition-delay:0s}.svg-check-mark[data-v-47faceda]{stroke-dasharray:149;stroke-dashoffset:149;transition-delay:0s}.icon-is-invalid .svg-x-mark[data-v-47faceda],.icon-is-valid .svg-check-mark[data-v-47faceda]{stroke-dashoffset:0;transition-delay:.3s}.circular-loader[data-v-47faceda]{animation:rotate-47faceda .7s linear infinite,fade-in-47faceda .4s;transform-origin:center center;transform:scale(5);background:transparent}.loader-path[data-v-47faceda]{stroke-dasharray:50,200;stroke-dashoffset:-100;stroke-linecap:round}.loader-path-off[data-v-47faceda]{stroke-dasharray:50,200;stroke-dashoffset:-100;transition:opacity .3s;opacity:0}@keyframes fade-in-47faceda{0%{opacity:0}70%{opacity:0}to{opacity:1}}@keyframes rotate-47faceda{0%{transform:scale(5) rotate(0)}to{transform:scale(5) rotate(360deg)}}.scalar-codeblock-pre{margin:0;padding:.5rem;overflow:auto;background:transparent;text-wrap:nowrap;white-space-collapse:preserve;border-radius:0}.scalar-input-wrapper-focus .scalar-input-label[data-v-94574cc9]{color:var(--scalar-color-1)}.scalar-input-wrapper-error .scalar-input-label[data-v-94574cc9]{color:var(--scalar-color-error-color)}.scalar-input[data-v-94574cc9]::-moz-selection{color:var(--scalar-color-1);background:#ffa55859}.scalar-input[data-v-94574cc9]::selection{color:var(--scalar-color-1);background:#ffa55859}.scalar-input[data-v-94574cc9]:has(+.scalar-input-label){opacity:0}.scalar-input[data-v-94574cc9]:not(:-moz-placeholder-shown){opacity:1;-moz-transition:opacity .2s ease-in-out .15s;transition:opacity .2s ease-in-out .15s}.scalar-input[data-v-94574cc9]:not(:placeholder-shown),.scalar-input-wrapper-focus .scalar-input[data-v-94574cc9]{opacity:1;transition:opacity .2s ease-in-out .15s}.scalar-input[data-v-94574cc9]:-webkit-autofill,.scalar-input[data-v-94574cc9]:-webkit-autofill:hover,.scalar-input[data-v-94574cc9]:-webkit-autofill:focus,.scalar-input[data-v-94574cc9]:-webkit-autofill:active,.scalar-input[data-v-94574cc9]:focus-within:-webkit-autofill,.scalar-input[data-v-94574cc9]:focus-within:-webkit-autofill:hover,.scalar-input[data-v-94574cc9]:focus-within:-webkit-autofill:focus,.scalar-input[data-v-94574cc9]:focus-within:-webkit-autofill:active{-webkit-box-shadow:0 0 0px 1000px var(--scalar-background-1) inset!important;-webkit-text-fill-color:var(--scalar-color-1);color:var(--scalar-color-1);border-radius:var(--scalar-radius)}.scalar-input:not(:-moz-placeholder-shown)+.scalar-input-label[data-v-94574cc9]{transform:translate3d(0,-20px,0) scale(.8);transform-origin:top left}.scalar-input-wrapper-focus .scalar-input-label[data-v-94574cc9],.scalar-input:not(:placeholder-shown)+.scalar-input-label[data-v-94574cc9]{transform:translate3d(0,-20px,0) scale(.8);transform-origin:top left}.scalar-input-wrapper-focus:has(button:active) .scalar-input-label[data-v-94574cc9]{color:var(--scalar-color-3)!important}.scalar-app code.hljs *{font-size:var(--scalar-small);font-family:var(--scalar-font-code);text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:4;tab-size:4}.scalar-app code.hljs{font-size:var(--scalar-small);font-family:var(--scalar-font-code);display:inline-block;counter-reset:linenumber}.scalar-app .hljs{background:transparent;color:var(--scalar-color-2)}.scalar-app .hljs .line:before{color:var(--scalar-color-3);display:inline-block;counter-increment:linenumber;content:counter(linenumber);margin-right:.7em;min-width:calc(var(--line-digits) * 1ch);text-align:right}.scalar-app .hljs-comment,.scalar-app .hljs-quote{color:var(--scalar-color-3);font-style:italic}.scalar-app .hljs-number{color:var(--scalar-color-orange)}.scalar-app .hljs-regexp,.scalar-app .hljs-string,.scalar-app .hljs-built_in{color:var(--scalar-color-blue)}.scalar-app .hljs-title.class_{color:var(--scalar-color-1)}.scalar-app .hljs-keyword{color:var(--scalar-color-purple)}.scalar-app .hljs-title.function_{color:var(--scalar-color-orange)}.scalar-app .hljs-subst,.scalar-app .hljs-name{color:var(--scalar-color-blue)}.scalar-app .hljs-attr,.scalar-app .hljs-attribute{color:var(--scalar-color-1)}.scalar-app .hljs-addition,.scalar-app .hljs-literal,.scalar-app .hljs-selector-tag,.scalar-app .hljs-type{color:var(--scalar-color-green)}.scalar-app .hljs-selector-attr,.scalar-app .hljs-selector-pseudo{color:var(--scalar-color-orange)}.scalar-app .hljs-doctag,.scalar-app .hljs-section,.scalar-app .hljs-title{color:var(--scalar-color-blue)}.scalar-app .hljs-selector-id,.scalar-app .hljs-template-variable,.scalar-app .hljs-variable{color:var(--scalar-color-1)}.scalar-app .hljs-name,.scalar-app .hljs-section,.scalar-app .hljs-strong{font-weight:var(--scalar-semibold)}.scalar-app .hljs-bullet,.scalar-app .hljs-link,.scalar-app .hljs-meta,.scalar-app .hljs-symbol{color:var(--scalar-color-blue)}.scalar-app .hljs-deletion{color:var(--scalar-color-red)}.scalar-app .hljs-formula{background:var(--scalar-color-1)}.scalar-app .hljs-emphasis{font-style:italic}.scalar-app .credentials{font-size:0!important;color:transparent}.scalar-app .credentials:after{content:"·····";font-size:var(--scalar-small);color:var(--scalar-color-3);-webkit-user-select:none;user-select:none}.hljs.language-html{color:var(--scalar-color-1)}.hljs.language-html .hljs-attr{color:var(--scalar-color-2)}.hljs.language-curl .hljs-keyword{color:var(--scalar-color-orange)}.hljs.language-curl .hljs-string{color:var(--scalar-color-1)}.hljs.language-curl .hljs-literal,.hljs.language-php .hljs-variable{color:var(--scalar-color-blue)}.hljs.language-objectivec .hljs-meta{color:var(--scalar-color-1)}.hljs.language-objectivec .hljs-built_in,.hljs-built_in{color:var(--scalar-color-orange)}.scalar-app .markdown{font-family:var(--scalar-font);color:var(--scalar-color-1);word-break:break-word}.scalar-app .markdown h1,.scalar-app .markdown h2,.scalar-app .markdown h3,.scalar-app .markdown h4,.scalar-app .markdown h5,.scalar-app .markdown h6,.scalar-app .markdown p,.scalar-app .markdown div,.scalar-app .markdown img,.scalar-app .markdown details,.scalar-app .markdown summary,.scalar-app .markdown ul,.scalar-app .markdown ol,.scalar-app .markdown table,.scalar-app .markdown blockquote,.scalar-app .markdown code{margin:12px 0}.scalar-app .markdown details{margin:12px 0;color:var(--scalar-color-1)}.scalar-app .markdown summary{display:block;margin:12px 0;padding-left:20px;position:relative;font-weight:var(--scalar-semibold);cursor:pointer;-webkit-user-select:none;user-select:none}.scalar-app .markdown summary:after{display:block;content:"";position:absolute;top:1px;left:1px;width:16px;height:16px;background-color:var(--scalar-color-3);-webkit-mask-image:url(\'data:image/svg+xml,<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.25 19.5L15.75 12L8.25 4.5" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>\');mask-image:url(\'data:image/svg+xml,<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.25 19.5L15.75 12L8.25 4.5" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>\')}.scalar-app .markdown summary:hover:after{background-color:var(--scalar-color-1)}.scalar-app .markdown details[open] summary:after{transform:rotate(90deg)}.scalar-app .markdown summary::-webkit-details-marker{display:none}.scalar-app .markdown img{overflow:hidden;border-radius:var(--scalar-radius);max-width:100%}.scalar-app .markdown>:first-child{margin-top:0}.scalar-app .markdown h1{--font-size: 1.4em}.scalar-app .markdown h2{--font-size: 1.25em}.scalar-app .markdown h3{--font-size: 1.1em}.scalar-app .markdown h4,.scalar-app .markdown h6{--font-size: 1em}.scalar-app .markdown h1,.scalar-app .markdown h2,.scalar-app .markdown h3,.scalar-app .markdown h4,.scalar-app .markdown h5,.scalar-app .markdown h6{font-size:var(--font-size);margin:18px 0 6px;font-weight:var(--scalar-bold);display:block;line-height:1.45}.scalar-app .markdown b,.scalar-app .markdown strong{font-weight:var(--scalar-bold)}.scalar-app .markdown p{color:var(--scalar-color-1);font-weight:var(--font-weight, var(--scalar-regular));line-height:1.5;margin-bottom:0;display:block}.scalar-app .markdown ul,.scalar-app .markdown ol{padding-left:24px;line-height:1.5;margin:12px 0;display:block}.scalar-app .markdown ul{list-style:disc}.scalar-app .markdown ol{list-style:decimal}.scalar-app .markdown ul.contains-task-list{list-style:none;padding-left:0}.scalar-app .markdown li{margin:6px 0;display:list-item}.scalar-app .markdown a{color:var(--scalar-color-accent);text-decoration:var(--scalar-text-decoration);cursor:pointer}.scalar-app .markdown a:hover{text-decoration:var(--scalar-text-decoration-hover)}.scalar-app .markdown em{font-style:italic}.scalar-app .markdown sup{font-size:var(--scalar-micro);vertical-align:super;font-weight:450}.scalar-app .markdown sub{font-size:var(--scalar-micro);vertical-align:sub;font-weight:450}.scalar-app .markdown del{text-decoration:line-through}.scalar-app .markdown code{font-family:var(--scalar-font-code);background-color:var(--scalar-background-2);box-shadow:0 0 0 1px var(--scalar-border-color);font-size:var(--scalar-micro);border-radius:2px;padding:0 3px}.scalar-app .markdown pre code{display:block;white-space:pre;padding:12px;line-height:1.5;margin:12px 0;-webkit-overflow-scrolling:touch;overflow-x:auto;max-width:100%;min-width:100px}.scalar-app .markdown hr{border:none;border-bottom:1px solid var(--scalar-border-color)}.scalar-app .markdown img{max-height:150px;border-radius:var(--scalar-radius)}.scalar-app .markdown blockquote{border-left:3px solid var(--scalar-border-color);padding-left:12px;margin:0;display:block}.scalar-app .markdown table{display:block;overflow-x:auto;position:relative;border-collapse:collapse;width:max-content;max-width:100%;margin:1em 0;box-shadow:0 0 0 1px var(--scalar-border-color);border-radius:var(--scalar-radius-lg)}.scalar-app .markdown tbody{display:table-row-group;vertical-align:middle}.scalar-app .markdown thead{display:table-header-group;vertical-align:middle}.scalar-app .markdown tr{display:table-row;border-color:inherit;vertical-align:inherit}.scalar-app .markdown td,.scalar-app .markdown th{display:table-cell;vertical-align:inherit;min-width:1em;padding:6px 9px;vertical-align:top;line-height:1.5;position:relative;word-break:initial;font-size:var(--scalar-small);color:var(--scalar-color-1);font-weight:var(--font-weight, var(--scalar-regular));border-right:1px solid var(--scalar-border-color);border-bottom:1px solid var(--scalar-border-color)}.scalar-app .markdown td>*,.scalar-app .markdown th>*{margin-bottom:0}.scalar-app .markdown th:empty{display:none}.scalar-app .markdown td:first-of-type,.scalar-app .markdown th:first-of-type{border-left:none}.scalar-app .markdown td:last-of-type,.scalar-app .markdown th:last-of-type{border-right:none}.scalar-app .markdown tr:last-of-type td{border-bottom:none}.scalar-app .markdown th{font-weight:var(--scalar-semibold)!important;text-align:left;border-left-color:transparent;background:var(--scalar-background-2)}.scalar-app .markdown tr>[align=left]{text-align:left}.scalar-app .markdown tr>[align=right]{text-align:right}.scalar-app .markdown tr>[align=center]{text-align:center}.authentication-header[data-v-4ada77f4]{white-space:nowrap}.selector[data-v-4ada77f4]{margin-bottom:6px}.base-url-variable{color:var(--scalar-color-1)}.base-url[data-v-41c016dc]{color:var(--scalar-color-2);cursor:pointer;font-family:var(--scalar-font-code);display:inline-block;padding:10px 0;font-size:var(--scalar-micro);min-width:0;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.input select[data-v-2e5f4fe1]{position:absolute;top:0;left:0;right:0;bottom:0;opacity:0;-moz-appearance:none;-webkit-appearance:none;appearance:none}.input-value[data-v-2e5f4fe1]{color:var(--scalar-color-1);font-size:var(--scalar-micro);padding:9px}.variable-description[data-v-2e5f4fe1]{padding:6px 12px;font-size:var(--scalar-small)}.variable-description[data-v-2e5f4fe1] .markdown{font-size:var(--scalar-micro);font-weight:var(--scalar-semibold);color:var(--scalar-color--1);padding:4px 0;display:block}.variable-description[data-v-2e5f4fe1] .markdown>*:first-child{margin-top:0}.input[data-v-2e5f4fe1]{align-items:center}.input[data-v-2e5f4fe1]:first-of-type{border-radius:0;border-top:1px solid var(--scalar-border-color)}.server-item[data-v-2bf97807]{padding:0 9px}.server-selector[data-v-2bf97807]{position:relative;display:flex;align-items:center;min-width:0;overflow:hidden;gap:2px;color:var(--scalar-color-2)}.description[data-v-2bf97807]{padding:6px 12px;font-size:var(--scalar-small)}.description[data-v-2bf97807] .markdown{font-size:var(--scalar-micro);font-weight:var(--scalar-semibold);color:var(--scalar-color--1);padding:4px 0;display:block}.description[data-v-2bf97807] .markdown>*:first-child{margin-top:0}.server-selector select[data-v-2bf97807]{position:absolute;bottom:0;left:0;right:0;opacity:0;top:0;-moz-appearance:none;-webkit-appearance:none;appearance:none}.server-selector svg[data-v-2bf97807]{width:12px}.scalar-card-serverlist[data-v-2bf97807]{margin-top:6px}.scalar-card-serverlist-container[data-v-2bf97807]{box-shadow:0 0 0 1px var(--scalar-border-color);border-radius:var(--scalar-radius)}.scalar-card-serverlist-title[data-v-2bf97807]{font-weight:var(--scalar-semibold);font-size:var(--scalar-mini);color:var(--scalar-color-3);text-transform:uppercase;display:block}.client-libraries-content[data-v-ab6bf947]{container:client-libraries-content / inline-size;display:flex;justify-content:center;overflow:hidden;padding:3px;border:1px solid var(--scalar-border-color);border-radius:var(--scalar-radius) var(--scalar-radius) 0 0}.client-libraries[data-v-ab6bf947]{display:flex;align-items:center;justify-content:center;width:100%;position:relative;cursor:pointer;white-space:nowrap;padding:5px;gap:6px;color:var(--scalar-color-3);border-radius:var(--scalar-radius);border:.5px solid transparent;-webkit-user-select:none;user-select:none}.client-libraries[data-v-ab6bf947]:hover{color:var(--scalar-color-1)}@media screen and (max-width: 450px){.client-libraries[data-v-ab6bf947]:nth-of-type(4),.client-libraries[data-v-ab6bf947]:nth-of-type(5){display:none}}.client-libraries-icon[data-v-ab6bf947]{max-width:14px;max-height:14px;min-width:14px;width:100%;aspect-ratio:1;display:flex;align-items:center;justify-content:center;position:relative;box-sizing:border-box;color:currentColor}.client-libraries-icon__more svg[data-v-ab6bf947]{height:initial}@container client-libraries-content (width < 400px){.client-libraries__select[data-v-ab6bf947]{width:fit-content}.client-libraries__select .client-libraries-icon__more+span[data-v-ab6bf947]{display:none}}@container client-libraries-content (width < 380px){.client-libraries[data-v-ab6bf947]{width:100%}.client-libraries span[data-v-ab6bf947]{display:none}}.client-libraries__active[data-v-ab6bf947]{background-color:var(--scalar-background-2);color:var(--scalar-color-1);border-color:var(--scalar-border-color);filter:brightness(var(--scalar-lifted-brightness))}@keyframes codeloader-ab6bf947{0%{transform:rotate(0)}to{transform:rotate(1turn)}}.client-libraries span[data-v-ab6bf947]{font-size:var(--scalar-mini);font-weight:var(--scalar-semibold)}.client-libraries__active span[data-v-ab6bf947]{color:var(--scalar-color-1)}.client-libraries__select select[data-v-ab6bf947]{background:var(--scalar-background-3);color:var(--scalar-color-2);opacity:0;height:100%;width:100%;aspect-ratio:1;position:absolute;top:0;left:0;cursor:pointer;z-index:1;-moz-appearance:none;-webkit-appearance:none;appearance:none;border:none}.client-libraries__select span[data-v-ab6bf947]{position:relative;display:flex;align-items:center}@media screen and (max-width: 600px){.references-classic .client-libraries[data-v-ab6bf947]{flex-direction:column}}.selected-client[data-v-301043da]{color:var(--scalar-color-1);font-size:var(--scalar-mini);font-family:var(--scalar-font-code);padding:9px 12px;border:1px solid var(--scalar-border-color);border-top:none;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin-bottom:12px;border-radius:0 0 var(--scalar-radius) var(--scalar-radius)}.client-libraries-heading[data-v-301043da]{font-weight:var(--scalar-semibold);font-size:var(--scalar-mini);color:var(--scalar-color-3);text-transform:uppercase;margin-bottom:6px;display:block}.badge[data-v-190574ac]{color:var(--scalar-color-2);font-size:var(--scalar-micro);background:var(--scalar-background-2);padding:2px 6px;border-radius:12px;font-weight:var(--scalar-semibold);display:inline-block;text-transform:uppercase}.section[data-v-7bdc2dab]{position:relative;display:flex;flex-direction:column;max-width:var(--refs-content-max-width);margin:auto;padding:90px 0;scroll-margin-top:var(--refs-header-height)}.references-classic .section[data-v-7bdc2dab]{padding:48px 0;gap:24px}@container narrow-references-container (max-width: 900px){.references-classic .section[data-v-7bdc2dab],.section[data-v-7bdc2dab]{padding:48px 24px}}.section[data-v-7bdc2dab]:not(:last-of-type){border-bottom:1px solid var(--scalar-border-color)}.section-wrapper[data-v-07cabcb0]{color:var(--scalar-color-1);padding-top:12px;margin-top:-12px}.section-accordion[data-v-07cabcb0]{display:flex;flex-direction:column;border-radius:var(--scalar-radius-lg);background:var(--scalar-background-2)}.section-accordion-transparent[data-v-07cabcb0]{background:transparent;border:1px solid var(--scalar-border-color)}.section-accordion-button[data-v-07cabcb0]{padding:6px}.section-accordion-button[data-v-07cabcb0]{display:flex;align-items:center;gap:6px;cursor:pointer}.section-accordion-button-content[data-v-07cabcb0]{flex:1;min-width:0}.section-accordion-button-actions[data-v-07cabcb0]{display:flex;align-items:center;gap:6px;color:var(--scalar-color-3)}.section-accordion-chevron[data-v-07cabcb0]{margin-right:4px;width:20px;cursor:pointer;opacity:1;color:var(--scalar-color-3)}.section-accordion-button:hover .section-accordion-chevron[data-v-07cabcb0]{color:var(--scalar-color-1)}.section-accordion-content[data-v-07cabcb0]{border-top:1px solid var(--scalar-border-color);display:flex;flex-direction:column}.section-accordion-description[data-v-07cabcb0]{font-weight:var(--scalar-semibold);font-size:var(--scalar-mini);color:var(--scalar-color--1);padding:10px 12px 0}.section-accordion-content-card[data-v-07cabcb0] .property:last-of-type{padding-bottom:9px}.section-column[data-v-d64e7382]{flex:1;min-width:0}.section-column[data-v-d64e7382]:nth-of-type(2){padding-top:48px}@container narrow-references-container (max-width: 900px){.section-column[data-v-d64e7382]:nth-of-type(2){padding-top:0}}.section-columns[data-v-8b9602bf]{display:flex;gap:48px}@container narrow-references-container (max-width: 900px){.section-columns[data-v-8b9602bf]{flex-direction:column;gap:24px}}.section-container[data-v-34b26958]{position:relative;padding:0 60px;width:100%}.section-container[data-v-34b26958]:last-of-type{border-top:1px solid var(--scalar-border-color)}@container narrow-references-container (max-width: 900px){.section-container[data-v-34b26958]{padding:0}}.section-accordion-wrapper[data-v-2049975e]{padding:0 60px}.section-accordion[data-v-2049975e]{position:relative;width:100%;max-width:var(--refs-content-max-width);margin:auto}.section-accordion-content[data-v-2049975e]{display:flex;flex-direction:column;gap:12px;padding-top:12px}.section-accordion-button[data-v-2049975e]{width:100%;display:flex;cursor:pointer;padding:6px 0;margin:-6px 0;border-radius:var(--scalar-radius)}.section-accordion-chevron[data-v-2049975e]{width:24px;position:absolute;left:-24px;height:auto;top:10px;color:var(--scalar-color-3)}.section-accordion-button:hover .section-accordion-chevron[data-v-2049975e]{color:var(--scalar-color-1)}.section-accordion-title[data-v-2049975e]{display:flex;flex-direction:column;align-items:flex-start;flex:1;padding:0 6px}.section-accordion-title[data-v-2049975e] .section-header{margin-bottom:0}@container narrow-references-container (max-width: 900px){.section-accordion-chevron[data-v-2049975e]{width:16px;left:-16px;top:14px}.section-accordion-wrapper[data-v-2049975e]{padding:calc(var(--refs-header-height)) 24px 0 24px}}.loading[data-v-c90b2c46]{background:var(--scalar-background-3);animation:loading-skeleton-c90b2c46 1.5s infinite alternate;border-radius:var(--scalar-radius-lg);min-height:1.6em;margin:.6em 0;max-width:100%}.loading[data-v-c90b2c46]:first-of-type{min-height:3em;margin-bottom:24px;margin-top:0}.loading[data-v-c90b2c46]:last-of-type{width:60%}.loading.single-line[data-v-c90b2c46]{min-height:3em;margin:.6em 0;max-width:80%}@keyframes loading-skeleton-c90b2c46{0%{opacity:1}to{opacity:.33}}@container narrow-references-container (max-width: 900px){.section-content--with-columns[data-v-9735459e]{flex-direction:column;gap:24px}}.section-header[data-v-3bd1b9f0]{font-size:var(--font-size, var(--scalar-heading-2));font-weight:var(--font-weight, var(--scalar-bold));color:var(--scalar-color-1);word-wrap:break-word;line-height:1.45;margin-top:0;margin-bottom:12px}.section-header.tight[data-v-3bd1b9f0]{margin-bottom:6px}.section-header.loading[data-v-3bd1b9f0]{width:80%}.introduction-description-heading[data-v-764b63f7]{scroll-margin-top:64px}.introduction-description[data-v-764b63f7]{display:flex;flex-direction:column;gap:18px}.download-cta[data-v-810904a4]{margin-bottom:24px}.download-cta .download-button[data-v-810904a4]{color:var(--scalar-color-accent);text-decoration:var(--scalar-text-decoration)!important;font-size:var(--scalar-paragraph);cursor:pointer}.download-cta .download-button[data-v-810904a4]:hover{text-decoration:var(--scalar-text-decoration-hover)!important}.heading[data-v-83f73a98]{margin-top:0!important;word-wrap:break-word}.loading[data-v-83f73a98]{background:var(--scalar-background-3);animation:loading-skeleton 1.5s infinite alternate;border-radius:var(--scalar-radius-lg)}.badges[data-v-83f73a98]{display:flex;align-items:center;gap:4px;margin-bottom:3px}.heading.loading[data-v-83f73a98]{width:80%}.introduction-section[data-v-83f73a98]{gap:48px}.sticky-cards[data-v-83f73a98]{display:flex;flex-direction:column;position:sticky;top:calc(var(--refs-header-height) + 24px)}.screenreader-only[data-v-681ebf2c]{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.label[data-v-d9801d4e]{position:relative;display:inline-block}.anchor[data-v-d9801d4e]{position:relative;display:inline-block;opacity:0}.anchor-copy[data-v-d9801d4e]{position:absolute;left:0;top:50%;transform:translateY(-50%);cursor:pointer;padding:0 6px;color:var(--scalar-color-3);font-weight:var(--scalar-semibold);font-size:.8em}.anchor-copy[data-v-d9801d4e]:hover,.anchor-copy[data-v-d9801d4e]:focus-visible{color:var(--scalar-color-2)}.label:hover .anchor[data-v-d9801d4e]{opacity:1}.scalar-card[data-v-dcabb131]{all:unset;font-family:var(--scalar-font);border-radius:var(--scalar-radius-lg);overflow:hidden;border:1px solid var(--scalar-border-color);background:var(--scalar-background-2);display:flex;flex-direction:column;max-height:calc(((var(--full-height) - var(--refs-header-height)) - 60px) / 2);position:relative}.scalar-card-sticky[data-v-dcabb131]{position:sticky;top:calc(var(--refs-header-height) + 24px)}.scalar-card-content[data-v-5312c2e0]{overflow:auto;border-bottom:1px solid var(--scalar-border-color)}.scalar-card-content[data-v-5312c2e0] .simple-table .simple-header{display:none}.scalar-card-content[data-v-5312c2e0]:last-of-type,.scalar-card-content.scalar-card--borderless[data-v-5312c2e0]{border-bottom:none}.scalar-card--muted[data-v-5312c2e0]{background:var(--scalar-background-2)}.scalar-card--contrast[data-v-5312c2e0]{background:var(--scalar-background-3)}.scalar-card--frameless[data-v-5312c2e0]{padding:0}.scalar-card--transparent[data-v-5312c2e0]{background:var(--scalar-background-1)}.scalar-card-header[data-v-bbd0c20a]{font-weight:var(--scalar-semibold);font-size:var(--scalar-mini);color:var(--scalar-color-3);padding:9px 0 9px 12px;flex-shrink:0}.scalar-card-header.scalar-card--borderless[data-v-bbd0c20a]+.scalar-card-content{margin-top:-9px}.scalar-card-header-slots[data-v-bbd0c20a]{display:flex;justify-content:space-between;line-height:1.35}.scalar-card-header-title[data-v-bbd0c20a]{text-transform:uppercase;flex:1;min-width:0;text-overflow:ellipsis;overflow:hidden}.scalar-card-header-actions[data-v-bbd0c20a]{display:flex}.scalar-card-footer[data-v-918ab8d6]{flex-shrink:0}.tab-list[data-v-03fdb072]{display:flex;gap:6px;position:relative;flex:1;padding:9px 12px;overflow:auto}.scalar-card-header.scalar-card-header-tabs[data-v-03fdb072]{padding:0}.tab[data-v-f373ecc2]{background:none;border:none;font-size:var(--scalar-mini);font-family:var(--scalar-font);color:var(--scalar-color-2);font-weight:var(--scalar-semibold);line-height:calc(var(--scalar-mini) + 2px);white-space:nowrap;cursor:pointer;padding:0;margin-right:3px;text-transform:uppercase;position:relative;line-height:1.35}.tab[data-v-f373ecc2]:before{content:"";position:absolute;z-index:0;left:-6px;top:-6px;width:calc(100% + 12px);height:calc(100% + 12px);border-radius:var(--scalar-radius);background:var(--scalar-background-3);opacity:0}.tab[data-v-f373ecc2]:hover:before{opacity:1}.tab span[data-v-f373ecc2]{z-index:1;position:relative}.tab-selected[data-v-f373ecc2]{color:var(--scalar-color-1);text-decoration:underline;text-underline-offset:var(--scalar-micro)}.text-select{position:relative;height:fit-content}.text-select--single-option{pointer-events:none}.text-select select{border:none;outline:none;cursor:pointer;background:var(--scalar-background-3);box-shadow:-2px 0 0 0 var(--scalar-background-3);position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;-moz-appearance:none;-webkit-appearance:none;appearance:none}.text-select span{font-size:var(--scalar-mini);color:var(--scalar-color-2);font-weight:var(--scalar-semibold);white-space:nowrap;display:flex;align-items:center;justify-content:center}.text-select:hover span{color:var(--scalar-color-1)}.text-select:not(.text-select--single-option) span:after{content:"";width:7px;height:7px;transform:rotate(45deg) translate3d(-2px,-2px,0);display:block;margin-left:6px;box-shadow:1px 1px 0 currentColor}.text-select span:hover{background:var(--scalar-background-2)}.request[data-v-a6cfe179]{display:flex;flex-wrap:nowrap}.request-header[data-v-a6cfe179]{display:flex;gap:6px;text-transform:initial}.request-method[data-v-a6cfe179]{font-family:var(--scalar-font-code);text-transform:uppercase;white-space:nowrap}.request-client-picker[data-v-a6cfe179]{padding-left:12px;padding-right:9px;border-right:1px solid var(--scalar-border-color)}.copy-button[data-v-a6cfe179]{-moz-appearance:none;appearance:none;-webkit-appearance:none;outline:none;background:transparent;cursor:pointer;color:var(--scalar-color-3);margin-left:6px;margin-right:10.5px;border:none;border-radius:3px;padding:0;display:flex;align-items:center;height:fit-content}.copy-button[data-v-a6cfe179]:after{content:".";color:transparent;font-size:var(--scalar-mini);line-height:1.35;width:0px}.copy-button[data-v-a6cfe179]:hover{color:var(--scalar-color-1)}.copy-button svg[data-v-a6cfe179]{width:13px;height:13px}.scalar-card-header-actions[data-v-a6cfe179]{display:flex}.scalar-card-footer[data-v-a6cfe179]{display:flex;justify-content:flex-end;padding:6px}.request-editor-section[data-v-a6cfe179]{display:flex;flex:1}.schema-type-icon[data-v-c0a69ad0]{color:var(--scalar-color-1)}.schema-type[data-v-c0a69ad0]{font-family:var(--scalar-font-code)}.property-detail[data-v-16d94ef5]{display:inline-flex}.property-detail+.property-detail[data-v-16d94ef5]:before{display:block;content:"·";margin:0 .5ch}.property-detail-truncate[data-v-16d94ef5]{overflow:hidden}.property-detail-truncate>.property-detail-value[data-v-16d94ef5]{overflow:hidden;text-overflow:ellipsis}.property-detail-prefix[data-v-16d94ef5]{color:var(--scalar-color-3)}code.property-detail-value[data-v-16d94ef5]{font-family:var(--scalar-font-code);font-size:var(--scalar-font-size-3);color:var(--scalar-color-2);background:var(--scalar-background-3);padding:1px 3px;border-radius:var(--scalar-radius)}.property-heading[data-v-2489a259]{display:flex;align-items:center;gap:9px;white-space:nowrap}.property-name[data-v-2489a259]{font-family:var(--scalar-font-code)}.property-additional[data-v-2489a259]{font-size:var(--scalar-font-size-3)}.property-required[data-v-2489a259],.property-optional[data-v-2489a259]{color:var(--scalar-color-2)}.property-required[data-v-2489a259]{text-transform:capitalize;color:var(--scalar-color-orange)}.property-read-only[data-v-2489a259],.property-write-only[data-v-2489a259]{font-size:var(--scalar-font-size-3);color:var(--scalar-color-blue)}.property-details[data-v-2489a259]{font-size:var(--scalar-font-size-3);color:var(--scalar-color-2);display:flex;align-items:center;min-width:0}.property-const[data-v-2489a259]{color:var(--scalar-color-1)}.property[data-v-fb06e93b]{color:var(--scalar-color-1);padding:10px;font-size:var(--scalar-mini)}.property[data-v-fb06e93b]:last-of-type{padding-bottom:0}.property--compact.property--level-0[data-v-fb06e93b]{padding:10px 0}.property--deprecated[data-v-fb06e93b]{background:repeating-linear-gradient(-45deg,var(--scalar-background-2) 0,var(--scalar-background-2) 2px,transparent 2px,transparent 5px);background-size:100%}.property--deprecated[data-v-fb06e93b]>*{opacity:.75}.property-description[data-v-fb06e93b]{margin-top:6px;line-height:1.4;font-size:var(--scalar-small)}[data-v-fb06e93b] .property-description *{color:var(--scalar-color-2)!important}.property[data-v-fb06e93b]:not(:last-of-type){border-bottom:1px solid var(--scalar-border-color)}.children[data-v-fb06e93b]{display:flex;flex-direction:column;padding-top:8px}.property-example[data-v-fb06e93b]{display:flex;flex-direction:column;gap:6px;margin-top:6px;padding:6px;max-height:calc(((var(--full-height) - var(--refs-header-height))) / 2);font-size:var(--scalar-micro);border:1px solid var(--scalar-border-color);background:var(--scalar-background-2);border-radius:var(--scalar-radius-lg)}.property-example-label[data-v-fb06e93b]{font-weight:var(--scalar-semibold);color:var(--scalar-color-3)}.property-example-value[data-v-fb06e93b]{font-family:var(--scalar-font-code);white-space:pre}.property-rule[data-v-fb06e93b]{display:flex;flex-direction:column;gap:6px;margin-top:12px;border-radius:var(--scalar-radius-lg)}.property-enum-value[data-v-fb06e93b]{padding:3px 0;color:var(--scalar-color-2)}.property-enum-value[data-v-fb06e93b]:before{content:"◼";margin-right:6px;color:var(--scalar-color-3)}.property-enum-values[data-v-fb06e93b]{margin-top:8px;list-style:none}.property--compact .property-example[data-v-fb06e93b]{display:none}.property-list[data-v-fb06e93b]{border:1px solid var(--scalar-border-color);border-radius:var(--scalar-radius);margin-top:10px}.property-list .property[data-v-fb06e93b]:last-of-type{padding-bottom:10px}.property-name[data-v-fb06e93b]{font-family:var(--scalar-font-code)}.error[data-v-25443e6c]{background-color:var(--scalar-color-red)}.schema-card[data-v-25443e6c]{z-index:0;position:relative;font-size:var(--scalar-font-size-4);color:var(--scalar-color-1)}.schema-card-title[data-v-25443e6c]{--schema-title-height: 38px;height:var(--schema-title-height);padding:10px 12px;display:flex;align-items:center;gap:4px;color:var(--scalar-color-2);font-weight:var(--scalar-semibold);font-size:var(--scalar-micro);background:var(--scalar-background-1);border-radius:var(--scalar-radius-lg);border-bottom:1px solid transparent}button.schema-card-title[data-v-25443e6c]{cursor:pointer}button.schema-card-title[data-v-25443e6c]:hover{color:var(--scalar-color-1)}.schema-card-title-icon[data-v-25443e6c]{margin-left:-4px}.schema-card-title-icon--open[data-v-25443e6c]{transform:rotate(90deg)}.schema-properties-open>.schema-card-title[data-v-25443e6c]{z-index:1;position:sticky;top:var(--refs-header-height);border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom:1px solid var(--scalar-border-color)}.schema-properties-open>.schema-properties[data-v-25443e6c]{width:fit-content}.schema-card-description+.schema-properties[data-v-25443e6c]{width:fit-content}.schema-properties-open.schema-properties[data-v-25443e6c],.schema-properties-open>.schema-card--open[data-v-25443e6c]{width:100%}.schema-card .property[data-v-25443e6c]:last-of-type{padding-bottom:10px}.schema-properties[data-v-25443e6c]{display:flex;flex-direction:column;border:1px solid var(--scalar-border-color);border-radius:var(--scalar-radius-lg)}.schema-card--compact[data-v-25443e6c]{align-self:start}.schema-card--compact.schema-card--open[data-v-25443e6c]{align-self:initial}.schema-card-title--compact[data-v-25443e6c]{color:var(--scalar-color-3);padding:6px 10px;height:auto;border-bottom:none}.schema-card--compact>.schema-properties[data-v-25443e6c],.schema-card-title--compact[data-v-25443e6c]{border-radius:13.5px}.schema-card-title--compact>.schema-card-title-icon[data-v-25443e6c]{width:10px;height:10px;margin:0}.schema-card-title--compact>.schema-card-title-icon--open[data-v-25443e6c]{transform:rotate(45deg)}.schema-properties-open>.schema-card-title--compact[data-v-25443e6c]{position:static}.schema-card--compact.schema-card--level-0>.schema-properties[data-v-25443e6c]{border:none}[data-v-25443e6c] .schema-card-description p{font-size:var(--scalar-mini, var(--scalar-paragraph));color:var(--scalar-color-2);line-height:1.5;display:block;margin-bottom:6px}.schema-card-description[data-v-25443e6c]:first-of-type{padding-top:10px}.children .schema-card-description[data-v-25443e6c]:first-of-type{padding-top:0}.parameter-item[data-v-f70ee55c]{border-top:1px solid var(--scalar-border-color)}.parameter-item:last-of-type .parameter-schema[data-v-f70ee55c]{padding-bottom:0}.parameter-item-container[data-v-f70ee55c]{padding:0}.parameter-item-name[data-v-f70ee55c]{font-weight:500;margin-right:6px;font-family:var(--scalar-font-code);font-size:var(--scalar-mini);color:var(--scalar-color-1)}.parameter-item-type[data-v-f70ee55c],.parameter-item-required-optional[data-v-f70ee55c]{color:var(--scalar-color-3);font-weight:var(--scalar-semibold);margin-right:6px;position:relative}.parameter-item--required[data-v-f70ee55c]{text-transform:uppercase;font-size:var(--scalar-micro);font-weight:var(--scalar-semibold);color:var(--scalar-color-orange)}.parameter-item-description[data-v-f70ee55c]{margin-top:3px!important;font-size:var(--scalar-small);color:var(--scalar-color-2);line-height:1.4}.parameter-item-description[data-v-f70ee55c] p{margin-top:4px;font-size:var(--scalar-small);color:var(--scalar-color-2);line-height:1.4}.parameter-schema[data-v-f70ee55c]{padding-bottom:9px;margin-top:3px}.parameters[data-v-45fca787]{margin-top:24px}.parameters-title[data-v-45fca787]{font-size:var(--scalar-heading-4);font-weight:var(--scalar-semibold);color:var(--scalar-color-1);line-height:1.45;margin-top:12px;margin-bottom:12px}.parameter-list[data-v-45fca787]{list-style:none;padding:0;margin:0 0 12px;font-size:var(--scalar-small)}.request-body-title[data-v-23ed11af]{display:flex;align-items:center;font-size:var(--scalar-heading-4);font-weight:var(--scalar-semibold);color:var(--scalar-color-1);line-height:1.45;margin-top:24px;padding-bottom:12px;border-bottom:1px solid var(--scalar-border-color);flex-flow:wrap}.request-body-title-select[data-v-23ed11af]{position:relative;padding-left:9px;height:fit-content;color:var(--scalar-color-2);font-size:var(--scalar-font-size-3);display:flex;align-items:center}.request-body-title-no-select.request-body-title-select[data-v-23ed11af]{pointer-events:none}.request-body-title-no-select.request-body-title-select[data-v-23ed11af]:after{display:none}.request-body-title-select span[data-v-23ed11af]{display:flex;align-items:center}.request-body-title-select[data-v-23ed11af]:after{content:"";width:7px;height:7px;transform:rotate(45deg) translate3d(-2px,-4px,0);display:block;margin-left:7px;box-shadow:1px 1px 0 currentColor}.request-body-title-select select[data-v-23ed11af]{border:none;outline:none;cursor:pointer;background:var(--scalar-background-3);box-shadow:-2px 0 0 0 var(--scalar-background-3);position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;-webkit-appearance:none;-moz-appearance:none;appearance:none}.request-body-title-select[data-v-23ed11af]:hover{color:var(--scalar-color-1)}.request-body-description[data-v-23ed11af]{margin-top:6px;font-size:var(--scalar-small);width:100%}.request-body-description[data-v-23ed11af] .markdown *{color:var(--scalar-color-2)!important}@media (max-width: 460px){.request-body-title-select[data-v-23ed11af]{margin-left:auto;padding-right:3px}}.endpoint-path[data-v-a4eadd9b]{overflow:hidden;word-wrap:break-word;font-weight:var(--scalar-semibold)}.deprecated[data-v-a4eadd9b]{text-decoration:line-through}.example-selector[data-v-652a7e14]{padding:4px}.request[data-v-0981194a]{display:flex;flex-wrap:nowrap}.request-header[data-v-0981194a]{display:flex;gap:6px;text-transform:initial}.request-method[data-v-0981194a]{font-family:var(--scalar-font-code);text-transform:uppercase}.request-client-picker[data-v-0981194a]{padding-left:12px;padding-right:9px;border-right:1px solid var(--scalar-border-color)}.copy-button[data-v-0981194a]{-moz-appearance:none;appearance:none;-webkit-appearance:none;outline:none;background:transparent;cursor:pointer;color:var(--scalar-color-3);margin-left:6px;margin-right:10.5px;border:none;border-radius:3px;padding:0;display:flex;align-items:center;height:fit-content}.copy-button[data-v-0981194a]:after{content:".";color:transparent;font-size:var(--scalar-mini);line-height:1.35;width:0px}.copy-button[data-v-0981194a]:hover{color:var(--scalar-color-1)}.copy-button svg[data-v-0981194a]{width:13px;height:13px}.request-card-footer[data-v-0981194a]{display:flex;justify-content:flex-end;padding:6px;flex-shrink:0}.request-card-footer-addon[data-v-0981194a]{display:flex;align-items:center;flex:1;min-width:0}.request-editor-section[data-v-0981194a]{display:flex;flex:1}.code-snippet[data-v-0981194a]{display:flex;flex-direction:column;width:100%}.empty-state[data-v-a29f0b4f]{margin:10px 0 10px 12px;text-align:center;font-size:var(--scalar-micro);min-height:56px;display:flex;align-items:center;justify-content:center;border-radius:var(--scalar-radius-lg);color:var(--scalar-color-2)}.rule-title[data-v-a29f0b4f]{font-family:var(--scalar-font-code);color:var(--scalar-color-1);display:inline-block;margin:12px 0 6px;border-radius:var(--scalar-radius)}.rule[data-v-a29f0b4f]{margin:0 12px;border-radius:var(--scalar-radius-lg)}.rule-items[data-v-a29f0b4f]{counter-reset:list-number;display:flex;flex-direction:column;gap:12px;border-left:1px solid var(--scalar-border-color);padding:12px 0}.rule-item[data-v-a29f0b4f]{counter-increment:list-number;border:1px solid var(--scalar-border-color);border-radius:var(--scalar-radius-lg);overflow:hidden;margin-left:24px}.rule-item[data-v-a29f0b4f]:before{border:1px solid var(--scalar-border-color);border-top:0;border-right:0;content:" ";display:block;width:24px;height:6px;border-radius:0 0 0 var(--scalar-radius-lg);margin-top:6px;color:var(--scalar-color-2);transform:translate(-25px);color:var(--scalar-color-1);position:absolute}.markdown[data-v-357c6dd1] *{margin:0}.code-copy[data-v-357c6dd1]{display:flex;align-items:center;justify-content:center;-moz-appearance:none;appearance:none;-webkit-appearance:none;outline:none;background:transparent;cursor:pointer;color:var(--scalar-color-3);border:none;padding:0;margin-right:12px}.code-copy[data-v-357c6dd1]:hover{color:var(--scalar-color-1)}.code-copy svg[data-v-357c6dd1]{width:13px;height:13px}.response-card-footer[data-v-357c6dd1]{display:flex;flex-direction:column;flex-shrink:0;padding:10px 12px;gap:8px;border-top:1px solid var(--scalar-border-color)}.response-example-selector[data-v-357c6dd1]{align-self:start;margin:-4px}.response-description[data-v-357c6dd1]{font-weight:var(--scalar-semibold);font-size:var(--scalar-micro);color:var(--scalar-color--1);display:flex;align-items:center;box-sizing:border-box}.schema-type[data-v-357c6dd1]{font-size:var(--scalar-micro);color:var(--scalar-color-2);font-weight:var(--scalar-semibold);background:var(--scalar-background-3);padding:2px 4px;border-radius:4px;margin-right:4px}.schema-example[data-v-357c6dd1]{font-size:var(--scalar-micro);color:var(--scalar-color-2);font-weight:var(--scalar-semibold)}.example-response-tab[data-v-357c6dd1]{display:block;margin:6px}.scalar-card-container[data-v-357c6dd1]{flex:1;background:var(--scalar-background-2)}.scalar-card-container[data-v-357c6dd1] .cm-scroller{overflow-y:hidden}.scalar-card-checkbox[data-v-357c6dd1]{display:flex;align-items:center;justify-content:center;position:relative;min-height:17px;cursor:pointer;-webkit-user-select:none;user-select:none;font-weight:var(--scalar-semibold);font-size:var(--scalar-mini);color:var(--scalar-color-2);width:fit-content;white-space:nowrap;margin-right:9px;gap:6px}.scalar-card-checkbox[data-v-357c6dd1]:hover{color:var(--scalar-color--1)}.scalar-card-checkbox .scalar-card-checkbox-input[data-v-357c6dd1]{position:absolute;opacity:0;cursor:pointer;height:0;width:0}.scalar-card-checkbox-checkmark[data-v-357c6dd1]{height:17px;width:17px;border-radius:var(--scalar-radius);background-color:transparent;background-color:var(--scalar-background-3);box-shadow:inset 0 0 0 1px var(--scalar-border-color)}.scalar-card-checkbox[data-v-357c6dd1]:has(.scalar-card-checkbox-input:checked){color:var(--scalar-color-1)}.scalar-card-checkbox .scalar-card-checkbox-input:checked~.scalar-card-checkbox-checkmark[data-v-357c6dd1]{background-color:var(--scalar-button-1);box-shadow:none}.scalar-card-checkbox-checkmark[data-v-357c6dd1]:after{content:"";position:absolute;display:none}.scalar-card-checkbox .scalar-card-checkbox-input:checked~.scalar-card-checkbox-checkmark[data-v-357c6dd1]:after{display:block}.scalar-card-checkbox .scalar-card-checkbox-checkmark[data-v-357c6dd1]:after{right:6px;top:36.5%;width:5px;height:9px;border:solid 1px var(--scalar-button-1-color);border-width:0 1.5px 1.5px 0;transform:rotate(45deg)}.show-api-client-button[data-v-4b36d4bc]{-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;border:none;padding:4px 6px;white-space:nowrap;border-radius:var(--scalar-radius);display:flex;justify-content:center;align-items:center;font-weight:var(--scalar-semibold);font-size:var(--scalar-mini);color:var(--scalar-background-2);font-family:var(--scalar-font);background:var(--scalar-button-1);position:relative;cursor:pointer;box-sizing:border-box;box-shadow:inset 0 0 0 1px #0000001a}.show-api-client-button span[data-v-4b36d4bc],.show-api-client-button svg[data-v-4b36d4bc]{color:var(--scalar-button-1-color);z-index:1}.show-api-client-button[data-v-4b36d4bc]:hover{background:var(--scalar-button-1-hover)}.show-api-client-button svg[data-v-4b36d4bc]{height:12px;width:auto;margin-right:6px}.examples[data-v-b9dd22f0]{position:sticky;top:calc(var(--refs-header-height) + 24px)}.deprecated[data-v-b9dd22f0] *{text-decoration:line-through}.example-path[data-v-b9dd22f0]{color:var(--scalar-color-2);font-family:var(--scalar-font-code)}.example-path[data-v-b9dd22f0] em{color:var(--scalar-color-1)}.endpoint-details-card[data-v-f94bee14]{display:flex;flex-direction:column;gap:12px}.endpoint-details-card-item[data-v-f94bee14]{border:1px solid var(--scalar-border-color);border-radius:var(--scalar-radius-lg);margin-top:0}.endpoint-details-card[data-v-f94bee14] .parameter-list:first-of-type:last-of-type{margin:0}.endpoint-details-card[data-v-f94bee14] .parameter-item:last-of-type .parameter-schema{padding-bottom:12px}.endpoint-details-card[data-v-f94bee14] .parameter-list .parameter-list{margin-bottom:12px}.endpoint-details-card[data-v-f94bee14] .parameter-list li{margin:0;padding:0 9px}.endpoint-details-card[data-v-f94bee14] .property{padding:9px;margin:0}.endpoint-details-card[data-v-f94bee14] .endpoint-title,.endpoint-details-card[data-v-f94bee14] .parameters-title,.endpoint-details-card[data-v-f94bee14] .request-body-title{text-transform:uppercase;font-weight:var(--scalar-bold);font-size:var(--scalar-mini);color:var(--scalar-color-2);line-height:1.33;padding:9px;margin:0}.endpoint-details-card[data-v-f94bee14] .request-body-title-select{text-transform:initial;font-weight:initial;margin-left:auto}.endpoint-header[data-v-e54314ae]{display:flex;justify-content:space-between}.endpoint-details[data-v-e54314ae]{display:flex;align-items:center;margin-top:0;gap:9px;min-width:0;flex-shrink:1}.endpoint-type[data-v-e54314ae]{display:flex;align-items:center;justify-content:center;gap:6px;position:relative;z-index:0;width:60px;padding:6px;flex-shrink:0;font-size:var(--scalar-small);text-transform:uppercase;font-weight:var(--scalar-bold);font-family:var(--scalar-font)}.endpoint-type[data-v-e54314ae]:after{content:"";position:absolute;top:0;right:0;bottom:0;left:0;z-index:-1;background:currentColor;opacity:.15;border-radius:var(--scalar-radius-lg)}.endpoint-anchor[data-v-e54314ae]{display:flex;align-items:center;min-width:0;flex-shrink:1;font-size:20px}.endpoint-anchor.label[data-v-e54314ae]{display:flex}.endpoint-label[data-v-e54314ae]{display:flex;align-items:baseline;gap:9px;min-width:0;flex-shrink:1;color:var(--scalar-color-1)}.endpoint-label-path[data-v-e54314ae]{font-family:var(--scalar-font-code);font-size:var(--scalar-mini);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.endpoint-label-path[data-v-e54314ae] em{color:var(--scalar-color-2)}.endpoint-label-name[data-v-e54314ae]{color:var(--scalar-color-2);font-size:var(--scalar-small);flex-shrink:1000000000;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.endpoint-try-hint[data-v-e54314ae]{padding:6px;height:24px;width:24px;flex-shrink:0;opacity:.44}.endpoint-copy[data-v-e54314ae],.endpoint-copy[data-v-e54314ae]:hover{color:currentColor}.endpoint-copy[data-v-e54314ae]{opacity:.44}.endpoint-copy[data-v-e54314ae]:hover{opacity:1}.endpoint-content[data-v-e54314ae]{display:grid;grid-template-columns:repeat(3,1fr);gap:9px;padding:9px}@container (max-width: 900px){.endpoint-content[data-v-e54314ae]{grid-template-columns:1fr}}.endpoint-content[data-v-e54314ae]>*{max-height:unset}.show-more[data-v-60a9fbab]{background:var(--scalar-background-1);-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;border:1px solid var(--scalar-border-color);margin:-48px auto 48px;padding:8px 12px;border-radius:30px;color:var(--scalar-color-1);font-weight:var(--scalar-semibold);font-size:var(--scalar-small);display:flex;align-items:center;justify-content:center;position:relative}.show-more[data-v-60a9fbab]:hover{color:var(--scalar-color-2);cursor:pointer}.show-more-icon[data-v-60a9fbab]{width:14px;height:14px;margin-left:3px}.show-more[data-v-60a9fbab]:active{box-shadow:0 0 0 1px var(--scalar-border-color)}@container narrow-references-container (max-width: 900px){.show-more[data-v-60a9fbab]{margin-top:-25px;margin-bottom:25px}}@media (max-width: 1165px){.show-more[data-v-60a9fbab]{margin-top:-24px;margin-bottom:24px}}.endpoints[data-v-9fc68fdd]{overflow:auto;background:var(--scalar-background-2);padding:10px 12px}@media (max-width: 580px){.endpoints[data-v-9fc68fdd]{max-height:calc(100vh - 150px)}}.endpoints span+span[data-v-9fc68fdd]{text-align:left;margin-left:12px;text-transform:initial}.endpoint[data-v-9fc68fdd]{display:flex;white-space:nowrap;cursor:pointer}.endpoint span[data-v-9fc68fdd]:first-of-type{text-transform:uppercase}.endpoint .post[data-v-9fc68fdd],.endpoint .get[data-v-9fc68fdd],.endpoint .delete[data-v-9fc68fdd],.endpoint .put[data-v-9fc68fdd]{white-space:nowrap}.endpoint span[data-v-9fc68fdd]{color:var(--scalar-color-1);min-width:62px;display:inline-block;text-align:right;line-height:1.55;font-family:var(--scalar-font-code);font-size:var(--scalar-small);cursor:pointer}.section-container[data-v-f193be30]{border-top:1px solid var(--scalar-border-color)}.tag-section[data-v-2a212e36]{margin-bottom:48px}.tag-name[data-v-2a212e36]{text-transform:capitalize}.tag-description[data-v-2a212e36]{padding-bottom:4px}.references-loading{position:absolute;top:0;left:0;right:0;z-index:1;grid-area:rendered;background:var(--scalar-background-1)}.references-loading-top-spacer{top:-1px}@media (min-width: 1001px){.references-loading-top-spacer{top:calc(var(--refs-header-height) - 1px)}}.references-loading-hidden-tag .section-container .section:first-child{display:none}.show-more[data-v-f19478dd]{margin-top:24px}.reference-models[data-v-304ad700]{margin-bottom:48px}.reference-models-anchor[data-v-304ad700]{display:flex;align-items:center;font-size:20px;padding-left:6px;color:var(--scalar-color-1)}.reference-models-label[data-v-304ad700]{font-size:var(--scalar-mini)}.reference-models-label[data-v-304ad700] em{font-weight:var(--scalar-bold)}.narrow-references-container{container-name:narrow-references-container;container-type:inline-size}.render-loading[data-v-54f6ce8b]{height:calc(var(--full-height) - var(--refs-header-height));display:flex;align-items:center;justify-content:center}.introduction-card[data-v-54f6ce8b]{display:flex;flex-direction:column;gap:12px;padding:12px 12px 0;background:var(--scalar-background-1);border:1px solid var(--scalar-border-color);border-radius:var(--scalar-radius-lg)}.introduction-card-title[data-v-54f6ce8b]{font-weight:var(--scalar-semibold);font-size:var(--scalar-mini);color:var(--scalar-color-3)}.introduction-card-row[data-v-54f6ce8b]{flex-flow:row wrap;gap:24px}.introduction-card-row[data-v-54f6ce8b]>*{flex:1}@media (min-width: 600px){.introduction-card-row[data-v-54f6ce8b]>*{min-width:min-content}}@media (max-width: 600px){.introduction-card-row[data-v-54f6ce8b]>*{max-width:100%}}@container (max-width: 900px){.introduction-card-row[data-v-54f6ce8b]{flex-direction:column;align-items:stretch}}.introduction-card[data-v-54f6ce8b] .security-scheme-label{text-transform:uppercase;font-weight:var(--scalar-semibold)}.references-classic .introduction-card-row[data-v-54f6ce8b] .card-footer,.references-classic .introduction-card-row[data-v-54f6ce8b] .scalar-card,.references-classic .introduction-card-row[data-v-54f6ce8b] .scalar-card--muted{background:var(--scalar-background-1)}.references-classic .introduction-card-row[data-v-54f6ce8b] .scalar-card:nth-of-type(2) .scalar-card-header{display:none}.references-classic .introduction-card-row[data-v-54f6ce8b] .scalar-card:nth-of-type(2) .scalar-card-header.scalar-card--borderless+.scalar-card-content{margin-top:0}.section-flare[data-v-54f6ce8b]{position:absolute;top:0;right:0;pointer-events:none}.start[data-v-391b4e37]{padding:24px;display:flex;flex-flow:wrap;justify-content:space-between;position:relative;z-index:0}.swagger-editor .start[data-v-391b4e37]{padding-top:24px}.start-h1[data-v-391b4e37]{font-size:var(--scalar-heading-2);margin-top:0;line-height:1.45;margin-bottom:0;font-weight:var(--scalar-bold);color:var(--scalar-color-1);width:100%;position:relative}.start-h3[data-v-391b4e37]{font-size:var(--scalar-paragraph);margin-top:0;margin-bottom:6px;display:block;line-height:1.45;font-weight:var(--scalar-bold);color:var(--scalar-color-1);width:100%}.start-h1[data-v-391b4e37]:not(:first-of-type){margin-top:24px}.start-p[data-v-391b4e37]{font-size:var(--scalar-paragraph);color:var(--scalar-color-2);line-height:1.5;width:100%;margin-top:12px}.start-ul[data-v-391b4e37]{margin-top:12px;font-size:var(--scalar-paragraph);line-height:1.5;padding-left:0;list-style:initial;display:flex;flex-flow:wrap;gap:24px}.start-ul li[data-v-391b4e37]{margin:0;padding:0;list-style:none;width:calc(50% - 24px);color:var(--scalar-color-2)}.start-ul li[data-v-391b4e37]:first-of-type{margin-top:0}.start-section[data-v-391b4e37]{width:100%;margin-bottom:12px;display:flex;flex-flow:wrap}.start-section[data-v-391b4e37]:last-of-type{margin-bottom:48px}.start-h2[data-v-391b4e37]{background:var(--scalar-background-2);border-top-left-radius:var(--scalar-radius-lg);border-top-right-radius:var(--scalar-radius-lg);border:1px solid var(--scalar-border-color);color:var(--scalar-color-3);font-size:var(--scalar-mini);font-weight:var(--scalar-semibold);padding:9px;width:100%}.start-item[data-v-391b4e37]{align-items:center;background:var(--scalar-background-2);border-right:1px solid var(--scalar-border-color);border-bottom:1px solid var(--scalar-border-color);color:var(--scalar-color-1);cursor:pointer;display:flex;flex:1;font-size:var(--scalar-mini);font-weight:var(--scalar-semibold);padding:9px;text-transform:capitalize;-webkit-user-select:none;user-select:none}.start-section-integrations .start-item[data-v-391b4e37]:first-of-type{border-bottom-left-radius:var(--scalar-radius-lg);border-left:1px solid var(--scalar-border-color)}.start-section-integrations .start-item[data-v-391b4e37]:last-of-type{border-bottom-right-radius:var(--scalar-radius-lg)}.start-section-colors .start-item[data-v-391b4e37]{min-width:33.33%}.start-section-colors .start-item[data-v-391b4e37]:nth-child(3n+2){border-left:1px solid var(--scalar-border-color)}.start-section-colors .start-item[data-v-391b4e37]:last-of-type,.start-section-colors .start-item-active[data-v-391b4e37]:last-of-type:before{border-radius:0 0 var(--scalar-radius-lg) var(--scalar-radius-lg)}.start-item[data-v-391b4e37]:empty{pointer-events:none}.start-item svg[data-v-391b4e37]{width:14px;height:14px;margin-right:6px}.start-item[data-v-391b4e37]:hover{background:var(--scalar-background-3)}.start-item-active[data-v-391b4e37]{z-index:10;position:relative;color:var(--scalar-color-1)}.start-item-active[data-v-391b4e37]:before{border:1px solid var(--scalar-color-1);content:"";top:-1px;right:-1px;bottom:-1px;left:-1px;pointer-events:none;position:absolute}.start-section-color .start-item[data-v-391b4e37]{text-transform:capitalize}.start-cta[data-v-391b4e37]{display:flex;gap:12px;width:100%;margin-top:24px;margin-bottom:0}.start-row[data-v-391b4e37]{width:100%;margin-top:12px;overflow:hidden}.start-hero-copy[data-v-391b4e37]{background:var(--scalar-background-2);padding:12px;border-radius:var(--scalar-radius-lg)}.start-p-small[data-v-391b4e37]{font-weight:var(--scalar-semibold);font-size:var(--scalar-mini);color:var(--scalar-color-2);margin-bottom:12px;line-height:1.4}.start-cta[data-v-391b4e37]{margin-bottom:12px;width:fit-content;white-space:nowrap}.start-copy[data-v-391b4e37]{padding:76px 48px 48px;display:flex;justify-content:center;align-items:center;flex-direction:column;text-align:center}.start-logo[data-v-391b4e37]{color:var(--scalar-color-1);margin-bottom:24px;width:72px;aspect-ratio:1;position:relative;box-shadow:var(--scalar-shadow-2);border-radius:50%}.start-logo[data-v-391b4e37]:before{content:"";width:300%;aspect-ratio:1;left:-100%;top:-100%;position:absolute;z-index:-1;border-radius:50%;background-size:24px 24px;box-shadow:inset 0 0 50px var(--scalar-background-1),inset 0 0 50px var(--scalar-background-1);background-image:linear-gradient(to right,var(--scalar-border-color) 1px,transparent 1px),linear-gradient(to bottom,var(--scalar-border-color) 1px,transparent 1px)}.start-logo svg[data-v-391b4e37]{width:100%;height:auto;background:var(--scalar-background-1);padding:3px;border-radius:50%;position:relative}@media screen and (max-width: 600px){.start-section-colors .start-item[data-v-391b4e37],.start-item[data-v-391b4e37]{width:100%;border-radius:0;border-right:none;border-top:1px solid var(--scalar-border-color)}.start-item[data-v-391b4e37]:empty{display:none}.start-h2[data-v-391b4e37]{border-bottom:none}.start li[data-v-391b4e37]{width:100%}.start-copy[data-v-391b4e37]{padding:48px 0 24px}}@media screen and (max-width: 1000px){.start[data-v-391b4e37]{padding:0;overflow:auto}}.sidebar-heading-type[data-v-9e6d2bc7]{display:block;min-width:3.9em;overflow:hidden;line-height:14px;flex-shrink:0;color:#fff;color:color-mix(in srgb,var(--method-color, var(--scalar-color-1)),transparent 0%);text-transform:uppercase;font-size:10px;font-weight:700;text-align:right;position:relative;font-family:var(--scalar-font-code);white-space:nowrap;margin-left:3px}.sidebar-heading[data-v-5a18d101]{display:flex;gap:6px;color:var(--scalar-sidebar-color-2, var(--scalar-color-2));font-size:var(--scalar-mini);font-weight:var(--scalar-semibold);word-break:break-word;line-height:1.385;max-width:100%;position:relative;cursor:pointer;border-radius:var(--scalar-radius);flex:1;padding-right:9px;-webkit-user-select:none;user-select:none}.sidebar-heading-link-method[data-v-5a18d101]{margin:0}.sidebar-heading.deprecated .sidebar-heading-link-title[data-v-5a18d101]{text-decoration:line-through}.sidebar-heading-link-title[data-v-5a18d101]{margin:0}.sidebar-heading[data-v-5a18d101]:hover{background:var( --scalar-sidebar-item-hover-background, var(--scalar-background-2) )}.sidebar-heading:hover .sidebar-heading-link-title[data-v-5a18d101]{color:var(--scalar-sidebar-item-hover-color)}.active_page.sidebar-heading[data-v-5a18d101]:hover,.active_page.sidebar-heading[data-v-5a18d101]{color:var(--scalar-sidebar-color-active, var(--scalar-color-accent));background:var( --scalar-sidebar-item-active-background, var(--scalar-background-accent) )}.active_page.sidebar-heading:hover .sidebar-heading-link-title[data-v-5a18d101]{color:var(--scalar-sidebar-color-active, var(--scalar-color-accent))}.sidebar-indent-nested .sidebar-indent-nested .sidebar-heading[data-v-5a18d101]:before{content:"";position:absolute;top:0;left:calc((var(--scalar-sidebar-level) * 12px));width:1px;height:100%;background:var(--scalar-sidebar-indent-border)}.sidebar-indent-nested .sidebar-indent-nested .sidebar-heading[data-v-5a18d101]:hover:before{background:var(--scalar-sidebar-indent-border-hover)}.sidebar-indent-nested .sidebar-indent-nested .active_page.sidebar-heading[data-v-5a18d101]:before{background:var(--scalar-sidebar-indent-border-active)}.sidebar-heading-link[data-v-5a18d101]{text-decoration:none;color:inherit;padding:6px 0;display:flex;flex:1;justify-content:space-between;gap:2px}.sidebar-heading p[data-v-5a18d101]{height:fit-content;display:flex;align-items:center}.sidebar-heading p[data-v-5a18d101]:empty{display:none}.link-icon[data-v-5a18d101]{position:relative;left:4px}.sidebar-icon[data-v-5a18d101]{display:flex;align-items:center;justify-content:center;margin-right:6px;width:13px;height:13px}.sidebar-icon>svg[data-v-5a18d101]{width:13px;height:13px}.sidebar-group-item[data-v-5a18d101]{position:relative}.sidebar-heading-chevron[data-v-5a18d101]{margin:5px -5.5px 5px -9px}.toggle-nested-icon[data-v-5a18d101]{border:none;color:currentColor;padding:3px;color:var(--scalar-sidebar-color-2)}.active_page .toggle-nested-icon[data-v-5a18d101]{color:var(--scalar-sidebar-color-active, var(--scalar-color-accent))}.toggle-nested-icon[data-v-5a18d101]:hover,.toggle-nested-icon[data-v-5a18d101]:focus-visible{color:currentColor}.action-menu[data-v-5a18d101]{position:absolute;top:5px;right:5px;display:flex;gap:6px}.action-menu[data-v-5a18d101] .button-wrapper button{opacity:0;width:20px;height:20px;padding:4px}.action-menu[data-v-5a18d101]:hover .button-wrapper button,.action-menu[data-v-5a18d101] .button-wrapper button:hover,.sidebar-heading:hover~.action-menu[data-v-5a18d101] .button-wrapper button,.action-menu[data-v-5a18d101] .button-wrapper button[aria-expanded=true]{opacity:1}.sidebar-heading[data-v-5a18d101]:has(~.action-menu:hover){color:var(--scalar-sidebar-color-1, var(--scalar-color-1));background:var( --scalar-sidebar-item-hover-background, var(--scalar-background-2) )}.sidebar-group-item__folder[data-v-5a18d101]{color:var(--scalar-sidebar-color-1, var(--scalar-color-1));text-transform:var(--scalar-tag-text-transform, initial)}.sidebar-group[data-v-39c84840]{list-style:none;width:100%;margin:0;padding:0}.sidebar-indent-nested[data-v-39c84840] .sidebar-heading{padding-left:calc((var(--scalar-sidebar-level) * var(--scalar-sidebar-indent-base)) + 12px)!important}.sidebar-indent-nested[data-v-39c84840] .sidebar-heading .toggle-nested-icon{left:calc((var(--scalar-sidebar-level) * var(--scalar-sidebar-indent-base)) + 2px)!important}:where(.sidebar-indent-nested[data-v-39c84840]) .sidebar-heading{color:var(--scalar-sidebar-color-1, var(--scalar-color-1))}:where(.sidebar-indent-nested[data-v-39c84840]) :where(.sidebar-indent-nested) .sidebar-heading{color:var(--scalar-sidebar-color-2, var(--scalar-color-2))}.sidebar[data-v-31eb751b]{--scalar-sidebar-indent-base: 12px}.sidebar[data-v-31eb751b]{flex:1;height:100%;display:flex;flex-direction:column;border-right:1px solid var(--scalar-sidebar-border-color, var(--scalar-border-color));background:var(--scalar-sidebar-background-1, var(--scalar-background-1));--scalar-sidebar-level: 0}.sidebar-pages[data-v-31eb751b]{flex:1;padding:9px 12px}@media (max-width: 1000px){.sidebar[data-v-31eb751b]{min-height:0}.sidebar-pages[data-v-31eb751b]{padding-top:12px}}.sidebar-group-title[data-v-31eb751b]{color:var(--scalar-sidebar-color-1);font-size:var(--scalar-mini);padding:12px 6px 6px;font-weight:var(--scalar-semibold);text-transform:uppercase;word-break:break-word;line-height:1.385}.sidebar-group-item+.sidebar-group-title[data-v-31eb751b]{border-top:1px solid var(--scalar-sidebar-border-color);margin-top:9px}:root{--scalar-loaded-api-reference: true}@layer scalar-config{.scalar-api-reference[data-v-c4323729]{--refs-sidebar-width: var(--scalar-sidebar-width, 0px);--refs-header-height: var(--scalar-header-height, 0px);--refs-content-max-width: var(--scalar-content-max-width, 1540px)}.scalar-api-reference.references-classic[data-v-c4323729]{--refs-content-max-width: var(--scalar-content-max-width, 1420px);min-height:100dvh;--refs-sidebar-width: 0}}.references-layout[data-v-c4323729]{height:100dvh;max-height:100%;width:100dvw;max-width:100%;flex:1;overflow-y:auto;overflow-x:hidden;scrollbar-gutter:stable;--full-height: 100dvh;display:grid;grid-template-rows:var(--refs-header-height) repeat(2,auto);grid-template-columns:var(--refs-sidebar-width) 1fr;grid-template-areas:"header header" "navigation rendered" "footer footer";background:var(--scalar-background-1)}.references-header[data-v-c4323729]{grid-area:header;position:sticky;top:0;z-index:10;height:var(--refs-header-height)}.references-editor[data-v-c4323729]{grid-area:editor;display:flex;min-width:0;background:var(--scalar-background-1);z-index:1}.references-navigation[data-v-c4323729]{grid-area:navigation}.references-rendered[data-v-c4323729]{position:relative;grid-area:rendered;min-width:0;background:var(--scalar-background-1)}.scalar-api-reference.references-classic[data-v-c4323729],.references-classic .references-rendered[data-v-c4323729]{--full-height: fit-content !important;height:initial!important;max-height:initial!important}.references-navigation-list[data-v-c4323729]{position:sticky;top:var(--refs-header-height);height:calc(var(--full-height) - var(--refs-header-height));background:var(--scalar-sidebar-background-1 var(--scalar-background-1));overflow-y:auto;display:flex;flex-direction:column}.references-editor-textarea[data-v-c4323729]{position:sticky;top:var(--refs-header-height);height:calc(var(--full-height) - var(--refs-header-height));display:flex;min-width:0;flex:1}.references-editable[data-v-c4323729]{grid-template-columns:var(--refs-sidebar-width) 1fr 1fr;grid-template-areas:"header header header" "navigation editor rendered" "footer footer footer"}@layer scalar-config{.references-sidebar[data-v-c4323729]{--refs-sidebar-width: var(--scalar-sidebar-width, 280px)}}.references-footer[data-v-c4323729]{grid-area:footer}@media (max-width: 1150px){.references-layout[data-v-c4323729]{grid-template-columns:var(--refs-sidebar-width) 1fr 0px}}@media (max-width: 1000px){.references-layout[data-v-c4323729]{grid-template-columns:auto;grid-template-rows:var(--refs-header-height) 0px auto auto;grid-template-areas:"header" "navigation" "rendered" "footer"}.references-sidebar.references-sidebar-mobile-open[data-v-c4323729]{overflow-y:hidden}.references-editable[data-v-c4323729]{grid-template-areas:"header" "navigation" "editor"}.references-navigation[data-v-c4323729],.references-rendered[data-v-c4323729]{max-height:unset}.references-rendered[data-v-c4323729]{position:static}.references-navigation[data-v-c4323729]{display:none;position:sticky;top:var(--refs-header-height);height:0px;z-index:10}.references-sidebar-mobile-open .references-navigation[data-v-c4323729]{display:block}.references-navigation-list[data-v-c4323729]{position:absolute;top:-1px;height:calc(var(--full-height) - var(--refs-header-height) + 1px);width:100%;border-top:1px solid var(--scalar-border-color);display:flex;flex-direction:column}}.references-classic-header[data-v-a860f78f]{display:flex;align-items:center;justify-content:space-between;gap:12px;max-width:var(--refs-content-max-width);margin:auto;padding:12px 0}.references-classic-header-container[data-v-a860f78f]{padding:0 60px}@container narrow-references-container (max-width: 900px){.references-classic-header[data-v-a860f78f]{padding:12px 24px}.references-classic-header-container[data-v-a860f78f]{padding:0}}.references-classic-header-icon[data-v-a860f78f]{height:24px;color:var(--scalar-color-1)}.darklight[data-v-559a0a79]{font-family:var(--scalar-font);border:none;border-top:1px solid var(--scalar-sidebar-border-color, var(--scalar-border-color));color:var(--scalar-sidebar-color-2, var(--scalar-color-2));font-size:var(--scalar-mini);font-weight:var(--scalar-semibold);-webkit-appearance:none;-moz-appearance:none;appearance:none;background:transparent;outline:none;padding:18px 24px 0;display:flex;align-items:center;text-indent:9px;width:100%}.darklight-reference[data-v-559a0a79]{width:100%;margin-top:auto}.darklight[data-v-559a0a79]:hover{cursor:pointer;color:var(--scalar-sidebar-color-1, var(--scalar-color-1))}.darklight svg[data-v-559a0a79]{stroke:currentColor;height:12px;width:12px}.darklight-reference-promo[data-v-559a0a79]{padding:6px 24px 12px;display:flex;align-items:center;font-size:var(--scalar-mini);text-decoration:none;color:var(--scalar-sidebar-color-2, var(--scalar-color-2))}.darklight-reference-promo[data-v-559a0a79]:hover{text-decoration:underline}.darklight[data-v-8f61ca56]{color:var(--scalar-sidebar-color-2, var(--scalar-color-2));display:flex;align-items:center;height:24px;width:24px;padding:4px}.darklight[data-v-8f61ca56]:hover{cursor:pointer;color:var(--scalar-sidebar-color-1, var(--scalar-color-1))}a[data-v-9def0ef3]{text-decoration:none}.ref-search-container[data-v-9def0ef3]{display:flex;flex-direction:column;padding:12px 12px 0}.ref-search-results[data-v-9def0ef3]{padding:12px}.ref-search-meta[data-v-9def0ef3]{background:var(--scalar-background-3);padding:6px 12px;font-size:var(--scalar-font-size-4);color:var(--scalar-color-3);font-weight:var(--scalar-semibold);display:flex;gap:12px}.sidebar-search[data-v-af64a87b]{display:flex;align-items:center;position:relative;padding:0 3px 0 9px;min-width:254px;max-width:100%;font-family:var(--scalar-font);background:var( --scalar-sidebar-search-background, var(--scalar-background-1) );color:var(--scalar-sidebar-color-2, var(--scalar-color-2));outline:none;border-radius:var(--scalar-radius);box-shadow:0 0 0 1px var(--scalar-sidebar-search-border-color, var(--scalar-border-color));cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none}.sidebar-search-input[data-v-af64a87b]{font-size:var(--scalar-mini);font-weight:var(--scalar-semibold);height:31px;-webkit-user-select:none;user-select:none;z-index:10;position:relative;display:flex;width:100%;justify-content:space-between;align-items:center}.sidebar-search-shortcut[data-v-af64a87b]{text-transform:uppercase}.sidebar-search-key[data-v-af64a87b]{background-color:var(--scalar-background-2);padding:3px 5px;margin:2px;border-radius:var(--scalar-radius);color:var(--scalar-sidebar-color-2, var(--scalar-color-2))}.search-icon[data-v-af64a87b]{padding:0;margin-right:6px;width:12px}.references-mobile-header[data-v-0242e3de]{display:none;align-items:center;gap:12px;height:100%;width:100%;padding:0 8px;background:var(--scalar-background-1);border-bottom:1px solid var(--scalar-border-color)}.references-mobile-breadcrumbs[data-v-0242e3de]{flex:1;min-width:0;font-size:var(--scalar-small);font-weight:var(--scalar-semibold);color:var(--scalar-color-1);overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.references-mobile-header-actions[data-v-0242e3de]{display:flex;flex-direction:row;gap:4px;height:24px;align-items:center;padding-left:4px}@media (max-width: 1000px){.references-mobile-header[data-v-0242e3de]{display:flex}}@media (max-width: 1000px){.scalar-api-references-standalone-mobile{--scalar-header-height: 50px}}.scalar-api-references-standalone-search[data-v-333fecad]{display:flex;flex-direction:column;padding:12px 12px 6px}body{margin:0}.api-client-container .scalar-api-client[data-v-ad4018ae]{--refs-sidebar-width: 280px;width:calc(100% - var(--refs-sidebar-width))}@media screen and (max-width: 1000px){.api-client-container .scalar-api-client[data-v-ad4018ae]{width:100%}}.api-client-container[data-v-ad4018ae]{position:absolute;right:0;left:0;bottom:0;top:0;z-index:9;border-radius:0;box-shadow:none;opacity:1;pointer-events:all;background:var(--scalar-background-1)!important;border-radius:var(--scalar-radius-lg);height:100%;overflow:hidden;display:flex;flex-direction:column;--refs-sidebar-width: 280px}.scalar-api-client__navigation[data-v-ad4018ae]{width:100%;display:flex;align-items:center;padding:11px 12px;height:var(--refs-header-height);background-color:var(--scalar-background-1);z-index:10;position:sticky;border-bottom:1px solid var(--scalar-border-color);top:0}.scalar-api-client__close[data-v-ad4018ae]{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;outline:none;display:flex;align-items:center;background:transparent;font-size:var(--scalar-small);color:var(--scalar-color-1);font-weight:var(--scalar-semibold)}.scalar-api-client__close[data-v-ad4018ae]:hover{cursor:pointer}.api-client-drawer[data-v-ad4018ae]{background:var(--scalar-background-1);height:calc(100% - 120px);width:calc(100% - 8px);max-width:1390px;left:0;top:0;bottom:0;right:0;margin:auto;border-radius:var(--scalar-radius-lg);overflow:hidden;visibility:visible;position:fixed;z-index:1001;opacity:0;animation:apiclientfadein-ad4018ae .25s forwards .1s;box-shadow:#0000001f 0 4px 30px,#0000000a 0 3px 17px,#0000000a 0 2px 8px,#0000000a 0 1px 1px}.dark-mode .api-client-drawer[data-v-ad4018ae]{border:1px solid var(--scalar-border-color);box-shadow:#00000026 0 4px 40px,#0000002f 0 3px 20px,#0000002f 0 3px 12px,#0000002f 0 2px 8px,#0000002f 0 1px 1px}@media (min-width: 1520px){.api-client-drawer[data-v-ad4018ae]{width:92vw;max-width:1780px}}.api-client-drawer[data-v-ad4018ae]:before{content:"";display:block;width:100%;height:100%;position:absolute;z-index:0}.dark-mode .api-client-drawer[data-v-ad4018ae]:before{background:#1a1a1a}.light-mode .api-client-drawer[data-v-ad4018ae]:before{background:#fff}@keyframes apiclientfadein-ad4018ae{0%{opacity:0}to{opacity:1}}.api-client-drawer-exit[data-v-ad4018ae]{position:fixed;top:0;left:0;width:100vw;height:100vh;background:#00000040;z-index:1000;cursor:pointer;animation:drawerexitfadein-ad4018ae .35s forwards}.dark-mode .api-client-drawer-exit[data-v-ad4018ae]{background-color:color-mix(in srgb,rgba(0,0,0,.7),var(--scalar-background-1))}@keyframes drawerexitfadein-ad4018ae{0%{opacity:0}to{opacity:1}}.scalar-api-client-height[data-v-ad4018ae]{height:100%;display:flex}.scalar-api-client-height .sidebar[data-v-ad4018ae]{flex:1 1 0%;flex-grow:1;flex-shrink:1;flex-basis:0%;height:100%;display:flex;flex-direction:column;width:var(--refs-sidebar-width);max-width:var(--refs-sidebar-width);border-right:1px solid var(--scalar-sidebar-border-color, var(--scalar-border-color))}.scalar-api-client-states[data-v-ad4018ae]{display:flex;justify-content:space-between;padding:12px;z-index:1;position:absolute;top:0;width:100%}.scalar-api-client-states-button[data-v-ad4018ae]{-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;border:none;min-height:31px;display:flex;align-items:center;font-weight:var(--scalar-semibold);gap:6px;padding:6px;color:var(--scalar-color-3);cursor:pointer;border-radius:var(--scalar-radius);background:transparent}.scalar-api-client-states-button[data-v-ad4018ae]:hover{color:var(--scalar-color-1)}.scalar-api-client-states-button[data-v-ad4018ae]:focus{background:var(--scalar-background-2);box-shadow:0 0 0 1px var(--scalar-border-color)}@media (max-width: 1280px){.api-client-drawer[data-v-ad4018ae]{height:calc(100% - 56px);top:46px}}@media (max-width: 820px){.scalar-api-client-states-button__endpoints[data-v-ad4018ae]{opacity:0;pointer-events:none}}')),
            document.head.appendChild(a)
        }
    } catch (r) {
        console.error("vite-plugin-css-injected-by-js", r)
    }
}();
!function(e) {
    "function" == typeof define && define.amd ? define(e) : e()
}((function() {
    "use strict";
    /**
  * @vue/shared v3.4.29
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
    /*! #__NO_SIDE_EFFECTS__ */
    var e, t;
    function n(e, t) {
        const n = new Set(e.split(","));
        return e=>n.has(e)
    }
    const r = {}
      , o = []
      , i = ()=>{}
      , a = ()=>!1
      , s = e=>111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97)
      , l = e=>e.startsWith("onUpdate:")
      , c = Object.assign
      , u = (e,t)=>{
        const n = e.indexOf(t);
        n > -1 && e.splice(n, 1)
    }
      , d = Object.prototype.hasOwnProperty
      , p = (e,t)=>d.call(e, t)
      , h = Array.isArray
      , f = e=>"[object Map]" === k(e)
      , m = e=>"[object Set]" === k(e)
      , g = e=>"[object Date]" === k(e)
      , b = e=>"function" == typeof e
      , O = e=>"string" == typeof e
      , v = e=>"symbol" == typeof e
      , y = e=>null !== e && "object" == typeof e
      , w = e=>(y(e) || b(e)) && b(e.then) && b(e.catch)
      , _ = Object.prototype.toString
      , k = e=>_.call(e)
      , S = e=>k(e).slice(8, -1)
      , E = e=>"[object Object]" === k(e)
      , x = e=>O(e) && "NaN" !== e && "-" !== e[0] && "" + parseInt(e, 10) === e
      , T = n(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
      , A = e=>{
        const t = Object.create(null);
        return n=>t[n] || (t[n] = e(n))
    }
      , C = /-(\w)/g
      , P = A((e=>e.replace(C, ((e,t)=>t ? t.toUpperCase() : ""))))
      , D = /\B([A-Z])/g
      , R = A((e=>e.replace(D, "-$1").toLowerCase()))
      , N = A((e=>e.charAt(0).toUpperCase() + e.slice(1)))
      , $ = A((e=>e ? `on${N(e)}` : ""))
      , I = (e,t)=>!Object.is(e, t)
      , M = (e,...t)=>{
        for (let n = 0; n < e.length; n++)
            e[n](...t)
    }
      , L = (e,t,n,r=!1)=>{
        Object.defineProperty(e, t, {
            configurable: !0,
            enumerable: !1,
            writable: r,
            value: n
        })
    }
      , Q = e=>{
        const t = parseFloat(e);
        return isNaN(t) ? e : t
    }
    ;
    let B;
    const U = ()=>B || (B = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {});
    function F(e) {
        if (h(e)) {
            const t = {};
            for (let n = 0; n < e.length; n++) {
                const r = e[n]
                  , o = O(r) ? H(r) : F(r);
                if (o)
                    for (const e in o)
                        t[e] = o[e]
            }
            return t
        }
        if (O(e) || y(e))
            return e
    }
    const j = /;(?![^(]*\))/g
      , z = /:([^]+)/
      , q = /\/\*[^]*?\*\//g;
    function H(e) {
        const t = {};
        return e.replace(q, "").split(j).forEach((e=>{
            if (e) {
                const n = e.split(z);
                n.length > 1 && (t[n[0].trim()] = n[1].trim())
            }
        }
        )),
        t
    }
    function Z(e) {
        let t = "";
        if (O(e))
            t = e;
        else if (h(e))
            for (let n = 0; n < e.length; n++) {
                const r = Z(e[n]);
                r && (t += r + " ")
            }
        else if (y(e))
            for (const n in e)
                e[n] && (t += n + " ");
        return t.trim()
    }
    function W(e) {
        if (!e)
            return null;
        let {class: t, style: n} = e;
        return t && !O(t) && (e.class = Z(t)),
        n && (e.style = F(n)),
        e
    }
    const X = n("itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly");
    function V(e) {
        return !!e || "" === e
    }
    function G(e, t) {
        if (e === t)
            return !0;
        let n = g(e)
          , r = g(t);
        if (n || r)
            return !(!n || !r) && e.getTime() === t.getTime();
        if (n = v(e),
        r = v(t),
        n || r)
            return e === t;
        if (n = h(e),
        r = h(t),
        n || r)
            return !(!n || !r) && function(e, t) {
                if (e.length !== t.length)
                    return !1;
                let n = !0;
                for (let r = 0; n && r < e.length; r++)
                    n = G(e[r], t[r]);
                return n
            }(e, t);
        if (n = y(e),
        r = y(t),
        n || r) {
            if (!n || !r)
                return !1;
            if (Object.keys(e).length !== Object.keys(t).length)
                return !1;
            for (const n in e) {
                const r = e.hasOwnProperty(n)
                  , o = t.hasOwnProperty(n);
                if (r && !o || !r && o || !G(e[n], t[n]))
                    return !1
            }
        }
        return String(e) === String(t)
    }
    function Y(e, t) {
        return e.findIndex((e=>G(e, t)))
    }
    const K = e=>O(e) ? e : null == e ? "" : h(e) || y(e) && (e.toString === _ || !b(e.toString)) ? JSON.stringify(e, J, 2) : String(e)
      , J = (e,t)=>t && t.__v_isRef ? J(e, t.value) : f(t) ? {
        [`Map(${t.size})`]: [...t.entries()].reduce(((e,[t,n],r)=>(e[ee(t, r) + " =>"] = n,
        e)), {})
    } : m(t) ? {
        [`Set(${t.size})`]: [...t.values()].map((e=>ee(e)))
    } : v(t) ? ee(t) : !y(t) || h(t) || E(t) ? t : String(t)
      , ee = (e,t="")=>{
        var n;
        return v(e) ? `Symbol(${null != (n = e.description) ? n : t})` : e
    }
    ;
    /**
  * @vue/reactivity v3.4.29
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
    let te, ne;
    class re {
        constructor(e=!1) {
            this.detached = e,
            this._active = !0,
            this.effects = [],
            this.cleanups = [],
            this.parent = te,
            !e && te && (this.index = (te.scopes || (te.scopes = [])).push(this) - 1)
        }
        get active() {
            return this._active
        }
        run(e) {
            if (this._active) {
                const t = te;
                try {
                    return te = this,
                    e()
                } finally {
                    te = t
                }
            }
        }
        on() {
            te = this
        }
        off() {
            te = this.parent
        }
        stop(e) {
            if (this._active) {
                let t, n;
                for (t = 0,
                n = this.effects.length; t < n; t++)
                    this.effects[t].stop();
                for (t = 0,
                n = this.cleanups.length; t < n; t++)
                    this.cleanups[t]();
                if (this.scopes)
                    for (t = 0,
                    n = this.scopes.length; t < n; t++)
                        this.scopes[t].stop(!0);
                if (!this.detached && this.parent && !e) {
                    const e = this.parent.scopes.pop();
                    e && e !== this && (this.parent.scopes[this.index] = e,
                    e.index = this.index)
                }
                this.parent = void 0,
                this._active = !1
            }
        }
    }
    function oe() {
        return te
    }
    function ie(e) {
        te && te.cleanups.push(e)
    }
    class ae {
        constructor(e, t, n, r) {
            this.fn = e,
            this.trigger = t,
            this.scheduler = n,
            this.active = !0,
            this.deps = [],
            this._dirtyLevel = 5,
            this._trackId = 0,
            this._runnings = 0,
            this._shouldSchedule = !1,
            this._depsLength = 0,
            function(e, t=te) {
                t && t.active && t.effects.push(e)
            }(this, r)
        }
        get dirty() {
            if (2 === this._dirtyLevel)
                return !1;
            if (3 === this._dirtyLevel || 4 === this._dirtyLevel) {
                this._dirtyLevel = 1,
                he();
                for (let e = 0; e < this._depsLength; e++) {
                    const t = this.deps[e];
                    if (t.computed) {
                        if (2 === t.computed.effect._dirtyLevel)
                            return !0;
                        if (t.computed.value,
                        this._dirtyLevel >= 5)
                            break
                    }
                }
                1 === this._dirtyLevel && (this._dirtyLevel = 0),
                fe()
            }
            return this._dirtyLevel >= 5
        }
        set dirty(e) {
            this._dirtyLevel = e ? 5 : 0
        }
        run() {
            if (this._dirtyLevel = 0,
            !this.active)
                return this.fn();
            let e = ue
              , t = ne;
            try {
                return ue = !0,
                ne = this,
                this._runnings++,
                se(this),
                this.fn()
            } finally {
                le(this),
                this._runnings--,
                ne = t,
                ue = e
            }
        }
        stop() {
            this.active && (se(this),
            le(this),
            this.onStop && this.onStop(),
            this.active = !1)
        }
    }
    function se(e) {
        e._trackId++,
        e._depsLength = 0
    }
    function le(e) {
        if (e.deps.length > e._depsLength) {
            for (let t = e._depsLength; t < e.deps.length; t++)
                ce(e.deps[t], e);
            e.deps.length = e._depsLength
        }
    }
    function ce(e, t) {
        const n = e.get(t);
        void 0 !== n && t._trackId !== n && (e.delete(t),
        0 === e.size && e.cleanup())
    }
    let ue = !0
      , de = 0;
    const pe = [];
    function he() {
        pe.push(ue),
        ue = !1
    }
    function fe() {
        const e = pe.pop();
        ue = void 0 === e || e
    }
    function me() {
        de++
    }
    function ge() {
        for (de--; !de && Oe.length; )
            Oe.shift()()
    }
    function be(e, t, n) {
        if (t.get(e) !== e._trackId) {
            t.set(e, e._trackId);
            const n = e.deps[e._depsLength];
            n !== t ? (n && ce(n, e),
            e.deps[e._depsLength++] = t) : e._depsLength++
        }
    }
    const Oe = [];
    function ve(e, t, n) {
        me();
        for (const r of e.keys()) {
            if (!e.computed && r.computed && e.get(r) === r._trackId && r._runnings > 0) {
                r._dirtyLevel = 2;
                continue
            }
            let n;
            r._dirtyLevel < t && (null != n ? n : n = e.get(r) === r._trackId) && (r._shouldSchedule || (r._shouldSchedule = 0 === r._dirtyLevel),
            r.computed && 2 === r._dirtyLevel && (r._shouldSchedule = !0),
            r._dirtyLevel = t),
            r._shouldSchedule && (null != n ? n : n = e.get(r) === r._trackId) && (r.trigger(),
            r._runnings && !r.allowRecurse || 3 === r._dirtyLevel || (r._shouldSchedule = !1,
            r.scheduler && Oe.push(r.scheduler)))
        }
        ge()
    }
    const ye = (e,t)=>{
        const n = new Map;
        return n.cleanup = e,
        n.computed = t,
        n
    }
      , we = new WeakMap
      , _e = Symbol("")
      , ke = Symbol("");
    function Se(e, t, n) {
        if (ue && ne) {
            let t = we.get(e);
            t || we.set(e, t = new Map);
            let r = t.get(n);
            r || t.set(n, r = ye((()=>t.delete(n)))),
            be(ne, r)
        }
    }
    function Ee(e, t, n, r, o, i) {
        const a = we.get(e);
        if (!a)
            return;
        let s = [];
        if ("clear" === t)
            s = [...a.values()];
        else if ("length" === n && h(e)) {
            const e = Number(r);
            a.forEach(((t,n)=>{
                ("length" === n || !v(n) && n >= e) && s.push(t)
            }
            ))
        } else
            switch (void 0 !== n && s.push(a.get(n)),
            t) {
            case "add":
                h(e) ? x(n) && s.push(a.get("length")) : (s.push(a.get(_e)),
                f(e) && s.push(a.get(ke)));
                break;
            case "delete":
                h(e) || (s.push(a.get(_e)),
                f(e) && s.push(a.get(ke)));
                break;
            case "set":
                f(e) && s.push(a.get(_e))
            }
        me();
        for (const l of s)
            l && ve(l, 5);
        ge()
    }
    const xe = n("__proto__,__v_isRef,__isVue")
      , Te = new Set(Object.getOwnPropertyNames(Symbol).filter((e=>"arguments" !== e && "caller" !== e)).map((e=>Symbol[e])).filter(v))
      , Ae = Ce();
    function Ce() {
        const e = {};
        return ["includes", "indexOf", "lastIndexOf"].forEach((t=>{
            e[t] = function(...e) {
                const n = Ot(this);
                for (let t = 0, o = this.length; t < o; t++)
                    Se(n, 0, t + "");
                const r = n[t](...e);
                return -1 === r || !1 === r ? n[t](...e.map(Ot)) : r
            }
        }
        )),
        ["push", "pop", "shift", "unshift", "splice"].forEach((t=>{
            e[t] = function(...e) {
                he(),
                me();
                const n = Ot(this)[t].apply(this, e);
                return ge(),
                fe(),
                n
            }
        }
        )),
        e
    }
    function Pe(e) {
        v(e) || (e = String(e));
        const t = Ot(this);
        return Se(t, 0, e),
        t.hasOwnProperty(e)
    }
    class De {
        constructor(e=!1, t=!1) {
            this._isReadonly = e,
            this._isShallow = t
        }
        get(e, t, n) {
            const r = this._isReadonly
              , o = this._isShallow;
            if ("__v_isReactive" === t)
                return !r;
            if ("__v_isReadonly" === t)
                return r;
            if ("__v_isShallow" === t)
                return o;
            if ("__v_raw" === t)
                return n === (r ? o ? ct : lt : o ? st : at).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(n) ? e : void 0;
            const i = h(e);
            if (!r) {
                if (i && p(Ae, t))
                    return Reflect.get(Ae, t, n);
                if ("hasOwnProperty" === t)
                    return Pe
            }
            const a = Reflect.get(e, t, n);
            return (v(t) ? Te.has(t) : xe(t)) ? a : (r || Se(e, 0, t),
            o ? a : St(a) ? i && x(t) ? a : a.value : y(a) ? r ? dt(a) : ut(a) : a)
        }
    }
    class Re extends De {
        constructor(e=!1) {
            super(!1, e)
        }
        set(e, t, n, r) {
            let o = e[t];
            if (!this._isShallow) {
                const t = mt(o);
                if (gt(n) || mt(n) || (o = Ot(o),
                n = Ot(n)),
                !h(e) && St(o) && !St(n))
                    return !t && (o.value = n,
                    !0)
            }
            const i = h(e) && x(t) ? Number(t) < e.length : p(e, t)
              , a = Reflect.set(e, t, n, r);
            return e === Ot(r) && (i ? I(n, o) && Ee(e, "set", t, n) : Ee(e, "add", t, n)),
            a
        }
        deleteProperty(e, t) {
            const n = p(e, t);
            e[t];
            const r = Reflect.deleteProperty(e, t);
            return r && n && Ee(e, "delete", t, void 0),
            r
        }
        has(e, t) {
            const n = Reflect.has(e, t);
            return v(t) && Te.has(t) || Se(e, 0, t),
            n
        }
        ownKeys(e) {
            return Se(e, 0, h(e) ? "length" : _e),
            Reflect.ownKeys(e)
        }
    }
    class Ne extends De {
        constructor(e=!1) {
            super(!0, e)
        }
        set(e, t) {
            return !0
        }
        deleteProperty(e, t) {
            return !0
        }
    }
    const $e = new Re
      , Ie = new Ne
      , Me = new Re(!0)
      , Le = new Ne(!0)
      , Qe = e=>e
      , Be = e=>Reflect.getPrototypeOf(e);
    function Ue(e, t, n=!1, r=!1) {
        const o = Ot(e = e.__v_raw)
          , i = Ot(t);
        n || (I(t, i) && Se(o, 0, t),
        Se(o, 0, i));
        const {has: a} = Be(o)
          , s = r ? Qe : n ? yt : vt;
        return a.call(o, t) ? s(e.get(t)) : a.call(o, i) ? s(e.get(i)) : void (e !== o && e.get(t))
    }
    function Fe(e, t=!1) {
        const n = this.__v_raw
          , r = Ot(n)
          , o = Ot(e);
        return t || (I(e, o) && Se(r, 0, e),
        Se(r, 0, o)),
        e === o ? n.has(e) : n.has(e) || n.has(o)
    }
    function je(e, t=!1) {
        return e = e.__v_raw,
        !t && Se(Ot(e), 0, _e),
        Reflect.get(e, "size", e)
    }
    function ze(e) {
        e = Ot(e);
        const t = Ot(this);
        return Be(t).has.call(t, e) || (t.add(e),
        Ee(t, "add", e, e)),
        this
    }
    function qe(e, t) {
        t = Ot(t);
        const n = Ot(this)
          , {has: r, get: o} = Be(n);
        let i = r.call(n, e);
        i || (e = Ot(e),
        i = r.call(n, e));
        const a = o.call(n, e);
        return n.set(e, t),
        i ? I(t, a) && Ee(n, "set", e, t) : Ee(n, "add", e, t),
        this
    }
    function He(e) {
        const t = Ot(this)
          , {has: n, get: r} = Be(t);
        let o = n.call(t, e);
        o || (e = Ot(e),
        o = n.call(t, e)),
        r && r.call(t, e);
        const i = t.delete(e);
        return o && Ee(t, "delete", e, void 0),
        i
    }
    function Ze() {
        const e = Ot(this)
          , t = 0 !== e.size
          , n = e.clear();
        return t && Ee(e, "clear", void 0, void 0),
        n
    }
    function We(e, t) {
        return function(n, r) {
            const o = this
              , i = o.__v_raw
              , a = Ot(i)
              , s = t ? Qe : e ? yt : vt;
            return !e && Se(a, 0, _e),
            i.forEach(((e,t)=>n.call(r, s(e), s(t), o)))
        }
    }
    function Xe(e, t, n) {
        return function(...r) {
            const o = this.__v_raw
              , i = Ot(o)
              , a = f(i)
              , s = "entries" === e || e === Symbol.iterator && a
              , l = "keys" === e && a
              , c = o[e](...r)
              , u = n ? Qe : t ? yt : vt;
            return !t && Se(i, 0, l ? ke : _e),
            {
                next() {
                    const {value: e, done: t} = c.next();
                    return t ? {
                        value: e,
                        done: t
                    } : {
                        value: s ? [u(e[0]), u(e[1])] : u(e),
                        done: t
                    }
                },
                [Symbol.iterator]() {
                    return this
                }
            }
        }
    }
    function Ve(e) {
        return function(...t) {
            return "delete" !== e && ("clear" === e ? void 0 : this)
        }
    }
    function Ge() {
        const e = {
            get(e) {
                return Ue(this, e)
            },
            get size() {
                return je(this)
            },
            has: Fe,
            add: ze,
            set: qe,
            delete: He,
            clear: Ze,
            forEach: We(!1, !1)
        }
          , t = {
            get(e) {
                return Ue(this, e, !1, !0)
            },
            get size() {
                return je(this)
            },
            has: Fe,
            add: ze,
            set: qe,
            delete: He,
            clear: Ze,
            forEach: We(!1, !0)
        }
          , n = {
            get(e) {
                return Ue(this, e, !0)
            },
            get size() {
                return je(this, !0)
            },
            has(e) {
                return Fe.call(this, e, !0)
            },
            add: Ve("add"),
            set: Ve("set"),
            delete: Ve("delete"),
            clear: Ve("clear"),
            forEach: We(!0, !1)
        }
          , r = {
            get(e) {
                return Ue(this, e, !0, !0)
            },
            get size() {
                return je(this, !0)
            },
            has(e) {
                return Fe.call(this, e, !0)
            },
            add: Ve("add"),
            set: Ve("set"),
            delete: Ve("delete"),
            clear: Ve("clear"),
            forEach: We(!0, !0)
        };
        return ["keys", "values", "entries", Symbol.iterator].forEach((o=>{
            e[o] = Xe(o, !1, !1),
            n[o] = Xe(o, !0, !1),
            t[o] = Xe(o, !1, !0),
            r[o] = Xe(o, !0, !0)
        }
        )),
        [e, n, t, r]
    }
    const [Ye,Ke,Je,et] = Ge();
    function tt(e, t) {
        const n = t ? e ? et : Je : e ? Ke : Ye;
        return (t,r,o)=>"__v_isReactive" === r ? !e : "__v_isReadonly" === r ? e : "__v_raw" === r ? t : Reflect.get(p(n, r) && r in t ? n : t, r, o)
    }
    const nt = {
        get: tt(!1, !1)
    }
      , rt = {
        get: tt(!1, !0)
    }
      , ot = {
        get: tt(!0, !1)
    }
      , it = {
        get: tt(!0, !0)
    }
      , at = new WeakMap
      , st = new WeakMap
      , lt = new WeakMap
      , ct = new WeakMap;
    function ut(e) {
        return mt(e) ? e : ht(e, !1, $e, nt, at)
    }
    function dt(e) {
        return ht(e, !0, Ie, ot, lt)
    }
    function pt(e) {
        return ht(e, !0, Le, it, ct)
    }
    function ht(e, t, n, r, o) {
        if (!y(e))
            return e;
        if (e.__v_raw && (!t || !e.__v_isReactive))
            return e;
        const i = o.get(e);
        if (i)
            return i;
        const a = (s = e).__v_skip || !Object.isExtensible(s) ? 0 : function(e) {
            switch (e) {
            case "Object":
            case "Array":
                return 1;
            case "Map":
            case "Set":
            case "WeakMap":
            case "WeakSet":
                return 2;
            default:
                return 0
            }
        }(S(s));
        var s;
        if (0 === a)
            return e;
        const l = new Proxy(e,2 === a ? r : n);
        return o.set(e, l),
        l
    }
    function ft(e) {
        return mt(e) ? ft(e.__v_raw) : !(!e || !e.__v_isReactive)
    }
    function mt(e) {
        return !(!e || !e.__v_isReadonly)
    }
    function gt(e) {
        return !(!e || !e.__v_isShallow)
    }
    function bt(e) {
        return !!e && !!e.__v_raw
    }
    function Ot(e) {
        const t = e && e.__v_raw;
        return t ? Ot(t) : e
    }
    const vt = e=>y(e) ? ut(e) : e
      , yt = e=>y(e) ? dt(e) : e;
    class wt {
        constructor(e, t, n, r) {
            this.getter = e,
            this._setter = t,
            this.dep = void 0,
            this.__v_isRef = !0,
            this.__v_isReadonly = !1,
            this.effect = new ae((()=>e(this._value)),(()=>kt(this, 3 === this.effect._dirtyLevel ? 3 : 4))),
            this.effect.computed = this,
            this.effect.active = this._cacheable = !r,
            this.__v_isReadonly = n
        }
        get value() {
            const e = Ot(this);
            return e._cacheable && !e.effect.dirty || !I(e._value, e._value = e.effect.run()) || kt(e, 5),
            _t(e),
            e.effect._dirtyLevel >= 2 && kt(e, 3),
            e._value
        }
        set value(e) {
            this._setter(e)
        }
        get _dirty() {
            return this.effect.dirty
        }
        set _dirty(e) {
            this.effect.dirty = e
        }
    }
    function _t(e) {
        var t;
        ue && ne && (e = Ot(e),
        be(ne, null != (t = e.dep) ? t : e.dep = ye((()=>e.dep = void 0), e instanceof wt ? e : void 0)))
    }
    function kt(e, t=5, n, r) {
        const o = (e = Ot(e)).dep;
        o && ve(o, t)
    }
    function St(e) {
        return !(!e || !0 !== e.__v_isRef)
    }
    function Et(e) {
        return Tt(e, !1)
    }
    function xt(e) {
        return Tt(e, !0)
    }
    function Tt(e, t) {
        return St(e) ? e : new At(e,t)
    }
    class At {
        constructor(e, t) {
            this.__v_isShallow = t,
            this.dep = void 0,
            this.__v_isRef = !0,
            this._rawValue = t ? e : Ot(e),
            this._value = t ? e : vt(e)
        }
        get value() {
            return _t(this),
            this._value
        }
        set value(e) {
            const t = this.__v_isShallow || gt(e) || mt(e);
            e = t ? e : Ot(e),
            I(e, this._rawValue) && (this._rawValue,
            this._rawValue = e,
            this._value = t ? e : vt(e),
            kt(this, 5))
        }
    }
    function Ct(e) {
        return St(e) ? e.value : e
    }
    function Pt(e) {
        return b(e) ? e() : Ct(e)
    }
    const Dt = {
        get: (e,t,n)=>Ct(Reflect.get(e, t, n)),
        set: (e,t,n,r)=>{
            const o = e[t];
            return St(o) && !St(n) ? (o.value = n,
            !0) : Reflect.set(e, t, n, r)
        }
    };
    function Rt(e) {
        return ft(e) ? e : new Proxy(e,Dt)
    }
    class Nt {
        constructor(e, t, n) {
            this._object = e,
            this._key = t,
            this._defaultValue = n,
            this.__v_isRef = !0
        }
        get value() {
            const e = this._object[this._key];
            return void 0 === e ? this._defaultValue : e
        }
        set value(e) {
            this._object[this._key] = e
        }
        get dep() {
            return function(e, t) {
                const n = we.get(e);
                return n && n.get(t)
            }(Ot(this._object), this._key)
        }
    }
    class $t {
        constructor(e) {
            this._getter = e,
            this.__v_isRef = !0,
            this.__v_isReadonly = !0
        }
        get value() {
            return this._getter()
        }
    }
    function It(e, t, n) {
        return St(e) ? e : b(e) ? new $t(e) : y(e) && arguments.length > 1 ? function(e, t, n) {
            const r = e[t];
            return St(r) ? r : new Nt(e,t,n)
        }/**
  * @vue/runtime-core v3.4.29
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
        (e, t, n) : Et(e)
    }
    function Mt(e, t, n, r) {
        try {
            return r ? e(...r) : e()
        } catch (o) {
            Qt(o, t, n)
        }
    }
    function Lt(e, t, n, r) {
        if (b(e)) {
            const o = Mt(e, t, n, r);
            return o && w(o) && o.catch((e=>{
                Qt(e, t, n)
            }
            )),
            o
        }
        if (h(e)) {
            const o = [];
            for (let i = 0; i < e.length; i++)
                o.push(Lt(e[i], t, n, r));
            return o
        }
    }
    function Qt(e, t, n, r=!0) {
        t && t.vnode;
        if (t) {
            let r = t.parent;
            const o = t.proxy
              , i = `https://vuejs.org/error-reference/#runtime-${n}`;
            for (; r; ) {
                const t = r.ec;
                if (t)
                    for (let n = 0; n < t.length; n++)
                        if (!1 === t[n](e, o, i))
                            return;
                r = r.parent
            }
            const a = t.appContext.config.errorHandler;
            if (a)
                return he(),
                Mt(a, null, 10, [e, o, i]),
                void fe()
        }
        !function(e, t, n, r=!0) {
            console.error(e)
        }(e, 0, 0, r)
    }
    let Bt = !1
      , Ut = !1;
    const Ft = [];
    let jt = 0;
    const zt = [];
    let qt = null
      , Ht = 0;
    const Zt = Promise.resolve();
    let Wt = null;
    function Xt(e) {
        const t = Wt || Zt;
        return e ? t.then(this ? e.bind(this) : e) : t
    }
    function Vt(e) {
        Ft.length && Ft.includes(e, Bt && e.allowRecurse ? jt + 1 : jt) || (null == e.id ? Ft.push(e) : Ft.splice(function(e) {
            let t = jt + 1
              , n = Ft.length;
            for (; t < n; ) {
                const r = t + n >>> 1
                  , o = Ft[r]
                  , i = Jt(o);
                i < e || i === e && o.pre ? t = r + 1 : n = r
            }
            return t
        }(e.id), 0, e),
        Gt())
    }
    function Gt() {
        Bt || Ut || (Ut = !0,
        Wt = Zt.then(tn))
    }
    function Yt(e, t, n=(Bt ? jt + 1 : 0)) {
        for (; n < Ft.length; n++) {
            const t = Ft[n];
            if (t && t.pre) {
                if (e && t.id !== e.uid)
                    continue;
                Ft.splice(n, 1),
                n--,
                t()
            }
        }
    }
    function Kt(e) {
        if (zt.length) {
            const e = [...new Set(zt)].sort(((e,t)=>Jt(e) - Jt(t)));
            if (zt.length = 0,
            qt)
                return void qt.push(...e);
            for (qt = e,
            Ht = 0; Ht < qt.length; Ht++) {
                const e = qt[Ht];
                !1 !== e.active && e()
            }
            qt = null,
            Ht = 0
        }
    }
    const Jt = e=>null == e.id ? 1 / 0 : e.id
      , en = (e,t)=>{
        const n = Jt(e) - Jt(t);
        if (0 === n) {
            if (e.pre && !t.pre)
                return -1;
            if (t.pre && !e.pre)
                return 1
        }
        return n
    }
    ;
    function tn(e) {
        Ut = !1,
        Bt = !0,
        Ft.sort(en);
        try {
            for (jt = 0; jt < Ft.length; jt++) {
                const e = Ft[jt];
                e && !1 !== e.active && Mt(e, null, 14)
            }
        } finally {
            jt = 0,
            Ft.length = 0,
            Kt(),
            Bt = !1,
            Wt = null,
            (Ft.length || zt.length) && tn()
        }
    }
    function nn(e, t, ...n) {
        if (e.isUnmounted)
            return;
        const o = e.vnode.props || r;
        let i = n;
        const a = t.startsWith("update:")
          , s = a && t.slice(7);
        if (s && s in o) {
            const e = `${"modelValue" === s ? "model" : s}Modifiers`
              , {number: t, trim: a} = o[e] || r;
            a && (i = n.map((e=>O(e) ? e.trim() : e))),
            t && (i = n.map(Q))
        }
        let l, c = o[l = $(t)] || o[l = $(P(t))];
        !c && a && (c = o[l = $(R(t))]),
        c && Lt(c, e, 6, i);
        const u = o[l + "Once"];
        if (u) {
            if (e.emitted) {
                if (e.emitted[l])
                    return
            } else
                e.emitted = {};
            e.emitted[l] = !0,
            Lt(u, e, 6, i)
        }
    }
    function rn(e, t, n=!1) {
        const r = t.emitsCache
          , o = r.get(e);
        if (void 0 !== o)
            return o;
        const i = e.emits;
        let a = {}
          , s = !1;
        if (!b(e)) {
            const r = e=>{
                const n = rn(e, t, !0);
                n && (s = !0,
                c(a, n))
            }
            ;
            !n && t.mixins.length && t.mixins.forEach(r),
            e.extends && r(e.extends),
            e.mixins && e.mixins.forEach(r)
        }
        return i || s ? (h(i) ? i.forEach((e=>a[e] = null)) : c(a, i),
        y(e) && r.set(e, a),
        a) : (y(e) && r.set(e, null),
        null)
    }
    function on(e, t) {
        return !(!e || !s(t)) && (t = t.slice(2).replace(/Once$/, ""),
        p(e, t[0].toLowerCase() + t.slice(1)) || p(e, R(t)) || p(e, t))
    }
    let an = null
      , sn = null;
    function ln(e) {
        const t = an;
        return an = e,
        sn = e && e.type.__scopeId || null,
        t
    }
    function cn(e) {
        sn = e
    }
    function un() {
        sn = null
    }
    function dn(e, t=an, n) {
        if (!t)
            return e;
        if (e._n)
            return e;
        const r = (...n)=>{
            r._d && bo(-1);
            const o = ln(t);
            let i;
            try {
                i = e(...n)
            } finally {
                ln(o),
                r._d && bo(1)
            }
            return i
        }
        ;
        return r._n = !0,
        r._c = !0,
        r._d = !0,
        r
    }
    function pn(e) {
        const {type: t, vnode: n, proxy: r, withProxy: o, propsOptions: [i], slots: a, attrs: s, emit: c, render: u, renderCache: d, props: p, data: h, setupState: f, ctx: m, inheritAttrs: g} = e
          , b = ln(e);
        let O, v;
        try {
            if (4 & n.shapeFlag) {
                const e = o || r
                  , t = e;
                O = Ro(u.call(t, e, d, p, f, h, m)),
                v = s
            } else {
                const e = t;
                0,
                O = Ro(e.length > 1 ? e(p, {
                    attrs: s,
                    slots: a,
                    emit: c
                }) : e(p, null)),
                v = t.props ? s : hn(s)
            }
        } catch (w) {
            ho.length = 0,
            Qt(w, e, 1),
            O = xo(uo)
        }
        let y = O;
        if (v && !1 !== g) {
            const e = Object.keys(v)
              , {shapeFlag: t} = y;
            e.length && 7 & t && (i && e.some(l) && (v = fn(v, i)),
            y = Ao(y, v, !1, !0))
        }
        return n.dirs && (y = Ao(y, null, !1, !0),
        y.dirs = y.dirs ? y.dirs.concat(n.dirs) : n.dirs),
        n.transition && (y.transition = n.transition),
        O = y,
        ln(b),
        O
    }
    const hn = e=>{
        let t;
        for (const n in e)
            ("class" === n || "style" === n || s(n)) && ((t || (t = {}))[n] = e[n]);
        return t
    }
      , fn = (e,t)=>{
        const n = {};
        for (const r in e)
            l(r) && r.slice(9)in t || (n[r] = e[r]);
        return n
    }
    ;
    function mn(e, t, n) {
        const r = Object.keys(t);
        if (r.length !== Object.keys(e).length)
            return !0;
        for (let o = 0; o < r.length; o++) {
            const i = r[o];
            if (t[i] !== e[i] && !on(n, i))
                return !0
        }
        return !1
    }
    const gn = "components";
    const bn = Symbol.for("v-ndc");
    function On(e) {
        return O(e) ? vn(gn, e, !1) || e : e || bn
    }
    function vn(e, t, n=!0, r=!1) {
        const o = an || Bo;
        if (o) {
            const n = o.type;
            {
                const e = Jo(n, !1);
                if (e && (e === t || e === P(t) || e === N(P(t))))
                    return n
            }
            const i = yn(o[e] || n[e], t) || yn(o.appContext[e], t);
            return !i && r ? n : i
        }
    }
    function yn(e, t) {
        return e && (e[t] || e[P(t)] || e[N(P(t))])
    }
    function wn(e, t, n=Bo, r=!1) {
        if (n) {
            const o = n[e] || (n[e] = [])
              , i = t.__weh || (t.__weh = (...r)=>{
                he();
                const o = zo(n)
                  , i = Lt(t, n, e, r);
                return o(),
                fe(),
                i
            }
            );
            return r ? o.unshift(i) : o.push(i),
            i
        }
    }
    const _n = e=>(t,n=Bo)=>{
        Wo && "sp" !== e || wn(e, ((...e)=>t(...e)), n)
    }
      , kn = _n("bm")
      , Sn = _n("m")
      , En = _n("bu")
      , xn = _n("u")
      , Tn = _n("bum")
      , An = _n("um")
      , Cn = _n("sp")
      , Pn = _n("rtg")
      , Dn = _n("rtc");
    function Rn(e, t=Bo) {
        wn("ec", e, t)
    }
    function Nn(e, t) {
        if (null === an)
            return e;
        const n = Ko(an)
          , o = e.dirs || (e.dirs = []);
        for (let i = 0; i < t.length; i++) {
            let[e,a,s,l=r] = t[i];
            e && (b(e) && (e = {
                mounted: e,
                updated: e
            }),
            e.deep && Wr(a),
            o.push({
                dir: e,
                instance: n,
                value: a,
                oldValue: void 0,
                arg: s,
                modifiers: l
            }))
        }
        return e
    }
    function $n(e, t, n, r) {
        const o = e.dirs
          , i = t && t.dirs;
        for (let a = 0; a < o.length; a++) {
            const s = o[a];
            i && (s.oldValue = i[a].value);
            let l = s.dir[r];
            l && (he(),
            Lt(l, n, 8, [e.el, s, e, t]),
            fe())
        }
    }
    function In(e, t, n, r) {
        let o;
        const i = n;
        if (h(e) || O(e)) {
            o = new Array(e.length);
            for (let n = 0, r = e.length; n < r; n++)
                o[n] = t(e[n], n, void 0, i)
        } else if ("number" == typeof e) {
            o = new Array(e);
            for (let n = 0; n < e; n++)
                o[n] = t(n + 1, n, void 0, i)
        } else if (y(e))
            if (e[Symbol.iterator])
                o = Array.from(e, ((e,n)=>t(e, n, void 0, i)));
            else {
                const n = Object.keys(e);
                o = new Array(n.length);
                for (let r = 0, a = n.length; r < a; r++) {
                    const a = n[r];
                    o[r] = t(e[a], a, r, i)
                }
            }
        else
            o = [];
        return o
    }
    function Mn(e, t) {
        for (let n = 0; n < t.length; n++) {
            const r = t[n];
            if (h(r))
                for (let t = 0; t < r.length; t++)
                    e[r[t].name] = r[t].fn;
            else
                r && (e[r.name] = r.key ? (...e)=>{
                    const t = r.fn(...e);
                    return t && (t.key = r.key),
                    t
                }
                : r.fn)
        }
        return e
    }
    /*! #__NO_SIDE_EFFECTS__ */
    function Ln(e, t) {
        return b(e) ? (()=>c({
            name: e.name
        }, t, {
            setup: e
        }))() : e
    }
    const Qn = e=>!!e.type.__asyncLoader /*! #__NO_SIDE_EFFECTS__ */
    ;
    function Bn(e) {
        b(e) && (e = {
            loader: e
        });
        const {loader: t, loadingComponent: n, errorComponent: r, delay: o=200, timeout: i, suspensible: a=!0, onError: s} = e;
        let l, c = null, u = 0;
        const d = ()=>{
            let e;
            return c || (e = c = t().catch((e=>{
                if (e = e instanceof Error ? e : new Error(String(e)),
                s)
                    return new Promise(((t,n)=>{
                        s(e, (()=>t((u++,
                        c = null,
                        d()))), (()=>n(e)), u + 1)
                    }
                    ));
                throw e
            }
            )).then((t=>e !== c && c ? c : (t && (t.__esModule || "Module" === t[Symbol.toStringTag]) && (t = t.default),
            l = t,
            t))))
        }
        ;
        return Ln({
            name: "AsyncComponentWrapper",
            __asyncLoader: d,
            get __asyncResolved() {
                return l
            },
            setup() {
                const e = Bo;
                if (l)
                    return ()=>Un(l, e);
                const t = t=>{
                    c = null,
                    Qt(t, e, 13, !r)
                }
                ;
                if (a && e.suspense || Wo)
                    return d().then((t=>()=>Un(t, e))).catch((e=>(t(e),
                    ()=>r ? xo(r, {
                        error: e
                    }) : null)));
                const s = Et(!1)
                  , u = Et()
                  , p = Et(!!o);
                return o && setTimeout((()=>{
                    p.value = !1
                }
                ), o),
                null != i && setTimeout((()=>{
                    if (!s.value && !u.value) {
                        const e = new Error(`Async component timed out after ${i}ms.`);
                        t(e),
                        u.value = e
                    }
                }
                ), i),
                d().then((()=>{
                    s.value = !0,
                    e.parent && Xr(e.parent.vnode) && (e.parent.effect.dirty = !0,
                    Vt(e.parent.update))
                }
                )).catch((e=>{
                    t(e),
                    u.value = e
                }
                )),
                ()=>s.value && l ? Un(l, e) : u.value && r ? xo(r, {
                    error: u.value
                }) : n && !p.value ? xo(n) : void 0
            }
        })
    }
    function Un(e, t) {
        const {ref: n, props: r, children: o, ce: i} = t.vnode
          , a = xo(e, r, o);
        return a.ref = n,
        a.ce = i,
        delete t.vnode.ce,
        a
    }
    function Fn(e, t, n={}, r, o) {
        if (an.isCE || an.parent && Qn(an.parent) && an.parent.isCE)
            return "default" !== t && (n.name = t),
            xo("slot", n, r && r());
        let i = e[t];
        i && i._c && (i._d = !1),
        mo();
        const a = i && jn(i(n))
          , s = yo(lo, {
            key: n.key || a && a.key || `_${t}`
        }, a || (r ? r() : []), a && 1 === e._ ? 64 : -2);
        return !o && s.scopeId && (s.slotScopeIds = [s.scopeId + "-s"]),
        i && i._c && (i._d = !0),
        s
    }
    function jn(e) {
        return e.some((e=>!wo(e) || e.type !== uo && !(e.type === lo && !jn(e.children)))) ? e : null
    }
    const zn = e=>e ? Ho(e) ? Ko(e) : zn(e.parent) : null
      , qn = c(Object.create(null), {
        $: e=>e,
        $el: e=>e.vnode.el,
        $data: e=>e.data,
        $props: e=>e.props,
        $attrs: e=>e.attrs,
        $slots: e=>e.slots,
        $refs: e=>e.refs,
        $parent: e=>zn(e.parent),
        $root: e=>zn(e.root),
        $emit: e=>e.emit,
        $options: e=>Jn(e),
        $forceUpdate: e=>e.f || (e.f = ()=>{
            e.effect.dirty = !0,
            Vt(e.update)
        }
        ),
        $nextTick: e=>e.n || (e.n = Xt.bind(e.proxy)),
        $watch: e=>Hr.bind(e)
    })
      , Hn = (e,t)=>e !== r && !e.__isScriptSetup && p(e, t)
      , Zn = {
        get({_: e}, t) {
            if ("__v_skip" === t)
                return !0;
            const {ctx: n, setupState: o, data: i, props: a, accessCache: s, type: l, appContext: c} = e;
            let u;
            if ("$" !== t[0]) {
                const l = s[t];
                if (void 0 !== l)
                    switch (l) {
                    case 1:
                        return o[t];
                    case 2:
                        return i[t];
                    case 4:
                        return n[t];
                    case 3:
                        return a[t]
                    }
                else {
                    if (Hn(o, t))
                        return s[t] = 1,
                        o[t];
                    if (i !== r && p(i, t))
                        return s[t] = 2,
                        i[t];
                    if ((u = e.propsOptions[0]) && p(u, t))
                        return s[t] = 3,
                        a[t];
                    if (n !== r && p(n, t))
                        return s[t] = 4,
                        n[t];
                    Vn && (s[t] = 0)
                }
            }
            const d = qn[t];
            let h, f;
            return d ? ("$attrs" === t && Se(e.attrs, 0, ""),
            d(e)) : (h = l.__cssModules) && (h = h[t]) ? h : n !== r && p(n, t) ? (s[t] = 4,
            n[t]) : (f = c.config.globalProperties,
            p(f, t) ? f[t] : void 0)
        },
        set({_: e}, t, n) {
            const {data: o, setupState: i, ctx: a} = e;
            return Hn(i, t) ? (i[t] = n,
            !0) : o !== r && p(o, t) ? (o[t] = n,
            !0) : !p(e.props, t) && (("$" !== t[0] || !(t.slice(1)in e)) && (a[t] = n,
            !0))
        },
        has({_: {data: e, setupState: t, accessCache: n, ctx: o, appContext: i, propsOptions: a}}, s) {
            let l;
            return !!n[s] || e !== r && p(e, s) || Hn(t, s) || (l = a[0]) && p(l, s) || p(o, s) || p(qn, s) || p(i.config.globalProperties, s)
        },
        defineProperty(e, t, n) {
            return null != n.get ? e._.accessCache[t] = 0 : p(n, "value") && this.set(e, t, n.value, null),
            Reflect.defineProperty(e, t, n)
        }
    };
    function Wn() {
        return function() {
            const e = Uo();
            return e.setupContext || (e.setupContext = Yo(e))
        }().attrs
    }
    function Xn(e) {
        return h(e) ? e.reduce(((e,t)=>(e[t] = null,
        e)), {}) : e
    }
    let Vn = !0;
    function Gn(e) {
        const t = Jn(e)
          , n = e.proxy
          , r = e.ctx;
        Vn = !1,
        t.beforeCreate && Yn(t.beforeCreate, e, "bc");
        const {data: o, computed: a, methods: s, watch: l, provide: c, inject: u, created: d, beforeMount: p, mounted: f, beforeUpdate: m, updated: g, activated: O, deactivated: v, beforeDestroy: w, beforeUnmount: _, destroyed: k, unmounted: S, render: E, renderTracked: x, renderTriggered: T, errorCaptured: A, serverPrefetch: C, expose: P, inheritAttrs: D, components: R, directives: N, filters: $} = t;
        if (u && function(e, t, n=i) {
            h(e) && (e = rr(e));
            for (const r in e) {
                const n = e[r];
                let o;
                o = y(n) ? "default"in n ? pr(n.from || r, n.default, !0) : pr(n.from || r) : pr(n),
                St(o) ? Object.defineProperty(t, r, {
                    enumerable: !0,
                    configurable: !0,
                    get: ()=>o.value,
                    set: e=>o.value = e
                }) : t[r] = o
            }
        }(u, r, null),
        s)
            for (const i in s) {
                const e = s[i];
                b(e) && (r[i] = e.bind(n))
            }
        if (o) {
            const t = o.call(n, n);
            y(t) && (e.data = ut(t))
        }
        if (Vn = !0,
        a)
            for (const h in a) {
                const e = a[h]
                  , t = b(e) ? e.bind(n, n) : b(e.get) ? e.get.bind(n, n) : i
                  , o = !b(e) && b(e.set) ? e.set.bind(n) : i
                  , s = ei({
                    get: t,
                    set: o
                });
                Object.defineProperty(r, h, {
                    enumerable: !0,
                    configurable: !0,
                    get: ()=>s.value,
                    set: e=>s.value = e
                })
            }
        if (l)
            for (const i in l)
                Kn(l[i], r, n, i);
        if (c) {
            const e = b(c) ? c.call(n) : c;
            Reflect.ownKeys(e).forEach((t=>{
                dr(t, e[t])
            }
            ))
        }
        function I(e, t) {
            h(t) ? t.forEach((t=>e(t.bind(n)))) : t && e(t.bind(n))
        }
        if (d && Yn(d, e, "c"),
        I(kn, p),
        I(Sn, f),
        I(En, m),
        I(xn, g),
        I(Vr, O),
        I(Gr, v),
        I(Rn, A),
        I(Dn, x),
        I(Pn, T),
        I(Tn, _),
        I(An, S),
        I(Cn, C),
        h(P))
            if (P.length) {
                const t = e.exposed || (e.exposed = {});
                P.forEach((e=>{
                    Object.defineProperty(t, e, {
                        get: ()=>n[e],
                        set: t=>n[e] = t
                    })
                }
                ))
            } else
                e.exposed || (e.exposed = {});
        E && e.render === i && (e.render = E),
        null != D && (e.inheritAttrs = D),
        R && (e.components = R),
        N && (e.directives = N)
    }
    function Yn(e, t, n) {
        Lt(h(e) ? e.map((e=>e.bind(t.proxy))) : e.bind(t.proxy), t, n)
    }
    function Kn(e, t, n, r) {
        const o = r.includes(".") ? Zr(n, r) : ()=>n[r];
        if (O(e)) {
            const n = t[e];
            b(n) && zr(o, n)
        } else if (b(e))
            zr(o, e.bind(n));
        else if (y(e))
            if (h(e))
                e.forEach((e=>Kn(e, t, n, r)));
            else {
                const r = b(e.handler) ? e.handler.bind(n) : t[e.handler];
                b(r) && zr(o, r, e)
            }
    }
    function Jn(e) {
        const t = e.type
          , {mixins: n, extends: r} = t
          , {mixins: o, optionsCache: i, config: {optionMergeStrategies: a}} = e.appContext
          , s = i.get(t);
        let l;
        return s ? l = s : o.length || n || r ? (l = {},
        o.length && o.forEach((e=>er(l, e, a, !0))),
        er(l, t, a)) : l = t,
        y(t) && i.set(t, l),
        l
    }
    function er(e, t, n, r=!1) {
        const {mixins: o, extends: i} = t;
        i && er(e, i, n, !0),
        o && o.forEach((t=>er(e, t, n, !0)));
        for (const a in t)
            if (r && "expose" === a)
                ;
            else {
                const r = tr[a] || n && n[a];
                e[a] = r ? r(e[a], t[a]) : t[a]
            }
        return e
    }
    const tr = {
        data: nr,
        props: ar,
        emits: ar,
        methods: ir,
        computed: ir,
        beforeCreate: or,
        created: or,
        beforeMount: or,
        mounted: or,
        beforeUpdate: or,
        updated: or,
        beforeDestroy: or,
        beforeUnmount: or,
        destroyed: or,
        unmounted: or,
        activated: or,
        deactivated: or,
        errorCaptured: or,
        serverPrefetch: or,
        components: ir,
        directives: ir,
        watch: function(e, t) {
            if (!e)
                return t;
            if (!t)
                return e;
            const n = c(Object.create(null), e);
            for (const r in t)
                n[r] = or(e[r], t[r]);
            return n
        },
        provide: nr,
        inject: function(e, t) {
            return ir(rr(e), rr(t))
        }
    };
    function nr(e, t) {
        return t ? e ? function() {
            return c(b(e) ? e.call(this, this) : e, b(t) ? t.call(this, this) : t)
        }
        : t : e
    }
    function rr(e) {
        if (h(e)) {
            const t = {};
            for (let n = 0; n < e.length; n++)
                t[e[n]] = e[n];
            return t
        }
        return e
    }
    function or(e, t) {
        return e ? [...new Set([].concat(e, t))] : t
    }
    function ir(e, t) {
        return e ? c(Object.create(null), e, t) : t
    }
    function ar(e, t) {
        return e ? h(e) && h(t) ? [...new Set([...e, ...t])] : c(Object.create(null), Xn(e), Xn(null != t ? t : {})) : t
    }
    function sr() {
        return {
            app: null,
            config: {
                isNativeTag: a,
                performance: !1,
                globalProperties: {},
                optionMergeStrategies: {},
                errorHandler: void 0,
                warnHandler: void 0,
                compilerOptions: {}
            },
            mixins: [],
            components: {},
            directives: {},
            provides: Object.create(null),
            optionsCache: new WeakMap,
            propsCache: new WeakMap,
            emitsCache: new WeakMap
        }
    }
    let lr = 0;
    function cr(e, t) {
        return function(n, r=null) {
            b(n) || (n = c({}, n)),
            null == r || y(r) || (r = null);
            const o = sr()
              , i = new WeakSet;
            let a = !1;
            const s = o.app = {
                _uid: lr++,
                _component: n,
                _props: r,
                _container: null,
                _context: o,
                _instance: null,
                version: ni,
                get config() {
                    return o.config
                },
                set config(e) {},
                use: (e,...t)=>(i.has(e) || (e && b(e.install) ? (i.add(e),
                e.install(s, ...t)) : b(e) && (i.add(e),
                e(s, ...t))),
                s),
                mixin: e=>(o.mixins.includes(e) || o.mixins.push(e),
                s),
                component: (e,t)=>t ? (o.components[e] = t,
                s) : o.components[e],
                directive: (e,t)=>t ? (o.directives[e] = t,
                s) : o.directives[e],
                mount(i, l, c) {
                    if (!a) {
                        const u = xo(n, r);
                        return u.appContext = o,
                        !0 === c ? c = "svg" : !1 === c && (c = void 0),
                        l && t ? t(u, i) : e(u, i, c),
                        a = !0,
                        s._container = i,
                        i.__vue_app__ = s,
                        Ko(u.component)
                    }
                },
                unmount() {
                    a && (e(null, s._container),
                    delete s._container.__vue_app__)
                },
                provide: (e,t)=>(o.provides[e] = t,
                s),
                runWithContext(e) {
                    const t = ur;
                    ur = s;
                    try {
                        return e()
                    } finally {
                        ur = t
                    }
                }
            };
            return s
        }
    }
    let ur = null;
    function dr(e, t) {
        if (Bo) {
            let n = Bo.provides;
            const r = Bo.parent && Bo.parent.provides;
            r === n && (n = Bo.provides = Object.create(r)),
            n[e] = t
        } else
            ;
    }
    function pr(e, t, n=!1) {
        const r = Bo || an;
        if (r || ur) {
            const o = r ? null == r.parent ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : ur._context.provides;
            if (o && e in o)
                return o[e];
            if (arguments.length > 1)
                return n && b(t) ? t.call(r && r.proxy) : t
        }
    }
    const hr = {}
      , fr = ()=>Object.create(hr)
      , mr = e=>Object.getPrototypeOf(e) === hr;
    function gr(e, t, n, r=!1) {
        const o = {}
          , i = fr();
        e.propsDefaults = Object.create(null),
        br(e, t, o, i);
        for (const a in e.propsOptions[0])
            a in o || (o[a] = void 0);
        n ? e.props = r ? o : ht(o, !1, Me, rt, st) : e.type.props ? e.props = o : e.props = i,
        e.attrs = i
    }
    function br(e, t, n, o) {
        const [i,a] = e.propsOptions;
        let s, l = !1;
        if (t)
            for (let r in t) {
                if (T(r))
                    continue;
                const c = t[r];
                let u;
                i && p(i, u = P(r)) ? a && a.includes(u) ? (s || (s = {}))[u] = c : n[u] = c : on(e.emitsOptions, r) || r in o && c === o[r] || (o[r] = c,
                l = !0)
            }
        if (a) {
            const t = Ot(n)
              , o = s || r;
            for (let r = 0; r < a.length; r++) {
                const s = a[r];
                n[s] = Or(i, t, s, o[s], e, !p(o, s))
            }
        }
        return l
    }
    function Or(e, t, n, r, o, i) {
        const a = e[n];
        if (null != a) {
            const e = p(a, "default");
            if (e && void 0 === r) {
                const e = a.default;
                if (a.type !== Function && !a.skipFactory && b(e)) {
                    const {propsDefaults: i} = o;
                    if (n in i)
                        r = i[n];
                    else {
                        const a = zo(o);
                        r = i[n] = e.call(null, t),
                        a()
                    }
                } else
                    r = e
            }
            a[0] && (i && !e ? r = !1 : !a[1] || "" !== r && r !== R(n) || (r = !0))
        }
        return r
    }
    function vr(e, t, n=!1) {
        const i = t.propsCache
          , a = i.get(e);
        if (a)
            return a;
        const s = e.props
          , l = {}
          , u = [];
        let d = !1;
        if (!b(e)) {
            const r = e=>{
                d = !0;
                const [n,r] = vr(e, t, !0);
                c(l, n),
                r && u.push(...r)
            }
            ;
            !n && t.mixins.length && t.mixins.forEach(r),
            e.extends && r(e.extends),
            e.mixins && e.mixins.forEach(r)
        }
        if (!s && !d)
            return y(e) && i.set(e, o),
            o;
        if (h(s))
            for (let o = 0; o < s.length; o++) {
                const e = P(s[o]);
                yr(e) && (l[e] = r)
            }
        else if (s)
            for (const r in s) {
                const e = P(r);
                if (yr(e)) {
                    const t = s[r]
                      , n = l[e] = h(t) || b(t) ? {
                        type: t
                    } : c({}, t);
                    if (n) {
                        const t = kr(Boolean, n.type)
                          , r = kr(String, n.type);
                        n[0] = t > -1,
                        n[1] = r < 0 || t < r,
                        (t > -1 || p(n, "default")) && u.push(e)
                    }
                }
            }
        const f = [l, u];
        return y(e) && i.set(e, f),
        f
    }
    function yr(e) {
        return "$" !== e[0] && !T(e)
    }
    function wr(e) {
        if (null === e)
            return "null";
        if ("function" == typeof e)
            return e.name || "";
        if ("object" == typeof e) {
            return e.constructor && e.constructor.name || ""
        }
        return ""
    }
    function _r(e, t) {
        return wr(e) === wr(t)
    }
    function kr(e, t) {
        return h(t) ? t.findIndex((t=>_r(t, e))) : b(t) && _r(t, e) ? 0 : -1
    }
    const Sr = e=>"_" === e[0] || "$stable" === e
      , Er = e=>h(e) ? e.map(Ro) : [Ro(e)]
      , xr = (e,t,n)=>{
        if (t._n)
            return t;
        const r = dn(((...e)=>Er(t(...e))), n);
        return r._c = !1,
        r
    }
      , Tr = (e,t,n)=>{
        const r = e._ctx;
        for (const o in e) {
            if (Sr(o))
                continue;
            const n = e[o];
            if (b(n))
                t[o] = xr(0, n, r);
            else if (null != n) {
                const e = Er(n);
                t[o] = ()=>e
            }
        }
    }
      , Ar = (e,t)=>{
        const n = Er(t);
        e.slots.default = ()=>n
    }
      , Cr = (e,t)=>{
        const n = e.slots = fr();
        if (32 & e.vnode.shapeFlag) {
            const e = t._;
            e ? (c(n, t),
            L(n, "_", e, !0)) : Tr(t, n)
        } else
            t && Ar(e, t)
    }
      , Pr = (e,t,n)=>{
        const {vnode: o, slots: i} = e;
        let a = !0
          , s = r;
        if (32 & o.shapeFlag) {
            const e = t._;
            e ? n && 1 === e ? a = !1 : (c(i, t),
            n || 1 !== e || delete i._) : (a = !t.$stable,
            Tr(t, i)),
            s = t
        } else
            t && (Ar(e, t),
            s = {
                default: 1
            });
        if (a)
            for (const r in i)
                Sr(r) || null != s[r] || delete i[r]
    }
    ;
    function Dr(e, t, n, o, i=!1) {
        if (h(e))
            return void e.forEach(((e,r)=>Dr(e, t && (h(t) ? t[r] : t), n, o, i)));
        if (Qn(o) && !i)
            return;
        const a = 4 & o.shapeFlag ? Ko(o.component) : o.el
          , s = i ? null : a
          , {i: l, r: c} = e
          , d = t && t.r
          , f = l.refs === r ? l.refs = {} : l.refs
          , m = l.setupState;
        if (null != d && d !== c && (O(d) ? (f[d] = null,
        p(m, d) && (m[d] = null)) : St(d) && (d.value = null)),
        b(c))
            Mt(c, l, 12, [s, f]);
        else {
            const t = O(c)
              , r = St(c);
            if (t || r) {
                const o = ()=>{
                    if (e.f) {
                        const n = t ? p(m, c) ? m[c] : f[c] : c.value;
                        i ? h(n) && u(n, a) : h(n) ? n.includes(a) || n.push(a) : t ? (f[c] = [a],
                        p(m, c) && (m[c] = f[c])) : (c.value = [a],
                        e.k && (f[e.k] = c.value))
                    } else
                        t ? (f[c] = s,
                        p(m, c) && (m[c] = s)) : r && (c.value = s,
                        e.k && (f[e.k] = s))
                }
                ;
                s ? (o.id = -1,
                Rr(o, n)) : o()
            }
        }
    }
    const Rr = function(e, t) {
        var n;
        t && t.pendingBranch ? h(e) ? t.effects.push(...e) : t.effects.push(e) : (h(n = e) ? zt.push(...n) : qt && qt.includes(n, n.allowRecurse ? Ht + 1 : Ht) || zt.push(n),
        Gt())
    };
    function Nr(e) {
        return function(e, t) {
            U().__VUE__ = !0;
            const {insert: n, remove: a, patchProp: s, createElement: l, createText: c, createComment: u, setText: d, setElementText: h, parentNode: f, nextSibling: m, setScopeId: g=i, insertStaticContent: b} = e
              , O = (e,t,n,r=null,o=null,i=null,a=void 0,s=null,l=!!t.dynamicChildren)=>{
                if (e === t)
                    return;
                e && !_o(e, t) && (r = K(e),
                W(e, o, i, !0),
                e = null),
                -2 === t.patchFlag && (l = !1,
                t.dynamicChildren = null);
                const {type: c, ref: u, shapeFlag: d} = t;
                switch (c) {
                case co:
                    v(e, t, n, r);
                    break;
                case uo:
                    y(e, t, n, r);
                    break;
                case po:
                    null == e && _(t, n, r, a);
                    break;
                case lo:
                    I(e, t, n, r, o, i, a, s, l);
                    break;
                default:
                    1 & d ? E(e, t, n, r, o, i, a, s, l) : 6 & d ? L(e, t, n, r, o, i, a, s, l) : (64 & d || 128 & d) && c.process(e, t, n, r, o, i, a, s, l, te)
                }
                null != u && o && Dr(u, e && e.ref, i, t || e, !t)
            }
              , v = (e,t,r,o)=>{
                if (null == e)
                    n(t.el = c(t.children), r, o);
                else {
                    const n = t.el = e.el;
                    t.children !== e.children && d(n, t.children)
                }
            }
              , y = (e,t,r,o)=>{
                null == e ? n(t.el = u(t.children || ""), r, o) : t.el = e.el
            }
              , _ = (e,t,n,r)=>{
                [e.el,e.anchor] = b(e.children, t, n, r, e.el, e.anchor)
            }
              , k = ({el: e, anchor: t},r,o)=>{
                let i;
                for (; e && e !== t; )
                    i = m(e),
                    n(e, r, o),
                    e = i;
                n(t, r, o)
            }
              , S = ({el: e, anchor: t})=>{
                let n;
                for (; e && e !== t; )
                    n = m(e),
                    a(e),
                    e = n;
                a(t)
            }
              , E = (e,t,n,r,o,i,a,s,l)=>{
                "svg" === t.type ? a = "svg" : "math" === t.type && (a = "mathml"),
                null == e ? x(t, n, r, o, i, a, s, l) : D(e, t, o, i, a, s, l)
            }
              , x = (e,t,r,o,i,a,c,u)=>{
                let d, p;
                const {props: f, shapeFlag: m, transition: g, dirs: b} = e;
                if (d = e.el = l(e.type, a, f && f.is, f),
                8 & m ? h(d, e.children) : 16 & m && C(e.children, d, null, o, i, $r(e, a), c, u),
                b && $n(e, null, o, "created"),
                A(d, e, e.scopeId, c, o),
                f) {
                    for (const t in f)
                        "value" === t || T(t) || s(d, t, null, f[t], a, e.children, o, i, Y);
                    "value"in f && s(d, "value", null, f.value, a),
                    (p = f.onVnodeBeforeMount) && Mo(p, o, e)
                }
                b && $n(e, null, o, "beforeMount");
                const O = function(e, t) {
                    return (!e || e && !e.pendingBranch) && t && !t.persisted
                }(i, g);
                O && g.beforeEnter(d),
                n(d, t, r),
                ((p = f && f.onVnodeMounted) || O || b) && Rr((()=>{
                    p && Mo(p, o, e),
                    O && g.enter(d),
                    b && $n(e, null, o, "mounted")
                }
                ), i)
            }
              , A = (e,t,n,r,o)=>{
                if (n && g(e, n),
                r)
                    for (let i = 0; i < r.length; i++)
                        g(e, r[i]);
                if (o) {
                    if (t === o.subTree) {
                        const t = o.vnode;
                        A(e, t, t.scopeId, t.slotScopeIds, o.parent)
                    }
                }
            }
              , C = (e,t,n,r,o,i,a,s,l=0)=>{
                for (let c = l; c < e.length; c++) {
                    const l = e[c] = s ? No(e[c]) : Ro(e[c]);
                    O(null, l, t, n, r, o, i, a, s)
                }
            }
              , D = (e,t,n,o,i,a,l)=>{
                const c = t.el = e.el;
                let {patchFlag: u, dynamicChildren: d, dirs: p} = t;
                u |= 16 & e.patchFlag;
                const f = e.props || r
                  , m = t.props || r;
                let g;
                if (n && Ir(n, !1),
                (g = m.onVnodeBeforeUpdate) && Mo(g, n, t, e),
                p && $n(t, e, n, "beforeUpdate"),
                n && Ir(n, !0),
                d ? N(e.dynamicChildren, d, c, n, o, $r(t, i), a) : l || z(e, t, c, null, n, o, $r(t, i), a, !1),
                u > 0) {
                    if (16 & u)
                        $(c, t, f, m, n, o, i);
                    else if (2 & u && f.class !== m.class && s(c, "class", null, m.class, i),
                    4 & u && s(c, "style", f.style, m.style, i),
                    8 & u) {
                        const r = t.dynamicProps;
                        for (let t = 0; t < r.length; t++) {
                            const a = r[t]
                              , l = f[a]
                              , u = m[a];
                            u === l && "value" !== a || s(c, a, l, u, i, e.children, n, o, Y)
                        }
                    }
                    1 & u && e.children !== t.children && h(c, t.children)
                } else
                    l || null != d || $(c, t, f, m, n, o, i);
                ((g = m.onVnodeUpdated) || p) && Rr((()=>{
                    g && Mo(g, n, t, e),
                    p && $n(t, e, n, "updated")
                }
                ), o)
            }
              , N = (e,t,n,r,o,i,a)=>{
                for (let s = 0; s < t.length; s++) {
                    const l = e[s]
                      , c = t[s]
                      , u = l.el && (l.type === lo || !_o(l, c) || 70 & l.shapeFlag) ? f(l.el) : n;
                    O(l, c, u, null, r, o, i, a, !0)
                }
            }
              , $ = (e,t,n,o,i,a,l)=>{
                if (n !== o) {
                    if (n !== r)
                        for (const r in n)
                            T(r) || r in o || s(e, r, n[r], null, l, t.children, i, a, Y);
                    for (const r in o) {
                        if (T(r))
                            continue;
                        const c = o[r]
                          , u = n[r];
                        c !== u && "value" !== r && s(e, r, u, c, l, t.children, i, a, Y)
                    }
                    "value"in o && s(e, "value", n.value, o.value, l)
                }
            }
              , I = (e,t,r,o,i,a,s,l,u)=>{
                const d = t.el = e ? e.el : c("")
                  , p = t.anchor = e ? e.anchor : c("");
                let {patchFlag: h, dynamicChildren: f, slotScopeIds: m} = t;
                m && (l = l ? l.concat(m) : m),
                null == e ? (n(d, r, o),
                n(p, r, o),
                C(t.children || [], r, p, i, a, s, l, u)) : h > 0 && 64 & h && f && e.dynamicChildren ? (N(e.dynamicChildren, f, r, i, a, s, l),
                (null != t.key || i && t === i.subTree) && Mr(e, t, !0)) : z(e, t, r, p, i, a, s, l, u)
            }
              , L = (e,t,n,r,o,i,a,s,l)=>{
                t.slotScopeIds = s,
                null == e ? 512 & t.shapeFlag ? o.ctx.activate(t, n, r, a, l) : Q(t, n, r, o, i, a, l) : B(e, t, l)
            }
              , Q = (e,t,n,o,i,a,s)=>{
                const l = e.component = function(e, t, n) {
                    const o = e.type
                      , i = (t ? t.appContext : e.appContext) || Lo
                      , a = {
                        uid: Qo++,
                        vnode: e,
                        type: o,
                        parent: t,
                        appContext: i,
                        root: null,
                        next: null,
                        subTree: null,
                        effect: null,
                        update: null,
                        scope: new re(!0),
                        render: null,
                        proxy: null,
                        exposed: null,
                        exposeProxy: null,
                        withProxy: null,
                        provides: t ? t.provides : Object.create(i.provides),
                        accessCache: null,
                        renderCache: [],
                        components: null,
                        directives: null,
                        propsOptions: vr(o, i),
                        emitsOptions: rn(o, i),
                        emit: null,
                        emitted: null,
                        propsDefaults: r,
                        inheritAttrs: o.inheritAttrs,
                        ctx: r,
                        data: r,
                        props: r,
                        attrs: r,
                        slots: r,
                        refs: r,
                        setupState: r,
                        setupContext: null,
                        attrsProxy: null,
                        slotsProxy: null,
                        suspense: n,
                        suspenseId: n ? n.pendingId : 0,
                        asyncDep: null,
                        asyncResolved: !1,
                        isMounted: !1,
                        isUnmounted: !1,
                        isDeactivated: !1,
                        bc: null,
                        c: null,
                        bm: null,
                        m: null,
                        bu: null,
                        u: null,
                        um: null,
                        bum: null,
                        da: null,
                        a: null,
                        rtg: null,
                        rtc: null,
                        ec: null,
                        sp: null
                    };
                    a.ctx = {
                        _: a
                    },
                    a.root = t ? t.root : a,
                    a.emit = nn.bind(null, a),
                    e.ce && e.ce(a);
                    return a
                }(e, o, i);
                if (Xr(e) && (l.ctx.renderer = te),
                function(e, t=!1) {
                    t && jo(t);
                    const {props: n, children: r} = e.vnode
                      , o = Ho(e);
                    gr(e, n, o, t),
                    Cr(e, r);
                    const i = o ? function(e, t) {
                        const n = e.type;
                        e.accessCache = Object.create(null),
                        e.proxy = new Proxy(e.ctx,Zn);
                        const {setup: r} = n;
                        if (r) {
                            const n = e.setupContext = r.length > 1 ? Yo(e) : null
                              , o = zo(e);
                            he();
                            const i = Mt(r, e, 0, [e.props, n]);
                            if (fe(),
                            o(),
                            w(i)) {
                                if (i.then(qo, qo),
                                t)
                                    return i.then((n=>{
                                        Xo(e, n, t)
                                    }
                                    )).catch((t=>{
                                        Qt(t, e, 0)
                                    }
                                    ));
                                e.asyncDep = i
                            } else
                                Xo(e, i, t)
                        } else
                            Vo(e, t)
                    }(e, t) : void 0;
                    t && jo(!1)
                }(l),
                l.asyncDep) {
                    if (i && i.registerDep(l, F, s),
                    !e.el) {
                        const e = l.subTree = xo(uo);
                        y(null, e, t, n)
                    }
                } else
                    F(l, e, t, n, i, a, s)
            }
              , B = (e,t,n)=>{
                const r = t.component = e.component;
                if (function(e, t, n) {
                    const {props: r, children: o, component: i} = e
                      , {props: a, children: s, patchFlag: l} = t
                      , c = i.emitsOptions;
                    if (t.dirs || t.transition)
                        return !0;
                    if (!(n && l >= 0))
                        return !(!o && !s || s && s.$stable) || r !== a && (r ? !a || mn(r, a, c) : !!a);
                    if (1024 & l)
                        return !0;
                    if (16 & l)
                        return r ? mn(r, a, c) : !!a;
                    if (8 & l) {
                        const e = t.dynamicProps;
                        for (let t = 0; t < e.length; t++) {
                            const n = e[t];
                            if (a[n] !== r[n] && !on(c, n))
                                return !0
                        }
                    }
                    return !1
                }(e, t, n)) {
                    if (r.asyncDep && !r.asyncResolved)
                        return void j(r, t, n);
                    r.next = t,
                    function(e) {
                        const t = Ft.indexOf(e);
                        t > jt && Ft.splice(t, 1)
                    }(r.update),
                    r.effect.dirty = !0,
                    r.update()
                } else
                    t.el = e.el,
                    r.vnode = t
            }
              , F = (e,t,n,r,o,a,s)=>{
                const l = ()=>{
                    if (e.isMounted) {
                        let {next: t, bu: n, u: r, parent: i, vnode: c} = e;
                        {
                            const n = Lr(e);
                            if (n)
                                return t && (t.el = c.el,
                                j(e, t, s)),
                                void n.asyncDep.then((()=>{
                                    e.isUnmounted || l()
                                }
                                ))
                        }
                        let u, d = t;
                        Ir(e, !1),
                        t ? (t.el = c.el,
                        j(e, t, s)) : t = c,
                        n && M(n),
                        (u = t.props && t.props.onVnodeBeforeUpdate) && Mo(u, i, t, c),
                        Ir(e, !0);
                        const p = pn(e)
                          , h = e.subTree;
                        e.subTree = p,
                        O(h, p, f(h.el), K(h), e, o, a),
                        t.el = p.el,
                        null === d && function({vnode: e, parent: t}, n) {
                            for (; t; ) {
                                const r = t.subTree;
                                if (r.suspense && r.suspense.activeBranch === e && (r.el = e.el),
                                r !== e)
                                    break;
                                (e = t.vnode).el = n,
                                t = t.parent
                            }
                        }(e, p.el),
                        r && Rr(r, o),
                        (u = t.props && t.props.onVnodeUpdated) && Rr((()=>Mo(u, i, t, c)), o)
                    } else {
                        let i;
                        const {el: s, props: l} = t
                          , {bm: c, m: u, parent: d} = e
                          , p = Qn(t);
                        if (Ir(e, !1),
                        c && M(c),
                        !p && (i = l && l.onVnodeBeforeMount) && Mo(i, d, t),
                        Ir(e, !0),
                        s && oe) {
                            const n = ()=>{
                                e.subTree = pn(e),
                                oe(s, e.subTree, e, o, null)
                            }
                            ;
                            p ? t.type.__asyncLoader().then((()=>!e.isUnmounted && n())) : n()
                        } else {
                            const i = e.subTree = pn(e);
                            O(null, i, n, r, e, o, a),
                            t.el = i.el
                        }
                        if (u && Rr(u, o),
                        !p && (i = l && l.onVnodeMounted)) {
                            const e = t;
                            Rr((()=>Mo(i, d, e)), o)
                        }
                        (256 & t.shapeFlag || d && Qn(d.vnode) && 256 & d.vnode.shapeFlag) && e.a && Rr(e.a, o),
                        e.isMounted = !0,
                        t = n = r = null
                    }
                }
                  , c = e.effect = new ae(l,i,(()=>Vt(u)),e.scope)
                  , u = e.update = ()=>{
                    c.dirty && c.run()
                }
                ;
                u.id = e.uid,
                Ir(e, !0),
                u()
            }
              , j = (e,t,n)=>{
                t.component = e;
                const r = e.vnode.props;
                e.vnode = t,
                e.next = null,
                function(e, t, n, r) {
                    const {props: o, attrs: i, vnode: {patchFlag: a}} = e
                      , s = Ot(o)
                      , [l] = e.propsOptions;
                    let c = !1;
                    if (!(r || a > 0) || 16 & a) {
                        let r;
                        br(e, t, o, i) && (c = !0);
                        for (const i in s)
                            t && (p(t, i) || (r = R(i)) !== i && p(t, r)) || (l ? !n || void 0 === n[i] && void 0 === n[r] || (o[i] = Or(l, s, i, void 0, e, !0)) : delete o[i]);
                        if (i !== s)
                            for (const e in i)
                                t && p(t, e) || (delete i[e],
                                c = !0)
                    } else if (8 & a) {
                        const n = e.vnode.dynamicProps;
                        for (let r = 0; r < n.length; r++) {
                            let a = n[r];
                            if (on(e.emitsOptions, a))
                                continue;
                            const u = t[a];
                            if (l)
                                if (p(i, a))
                                    u !== i[a] && (i[a] = u,
                                    c = !0);
                                else {
                                    const t = P(a);
                                    o[t] = Or(l, s, t, u, e, !1)
                                }
                            else
                                u !== i[a] && (i[a] = u,
                                c = !0)
                        }
                    }
                    c && Ee(e.attrs, "set", "")
                }(e, t.props, r, n),
                Pr(e, t.children, n),
                he(),
                Yt(e),
                fe()
            }
              , z = (e,t,n,r,o,i,a,s,l=!1)=>{
                const c = e && e.children
                  , u = e ? e.shapeFlag : 0
                  , d = t.children
                  , {patchFlag: p, shapeFlag: f} = t;
                if (p > 0) {
                    if (128 & p)
                        return void H(c, d, n, r, o, i, a, s, l);
                    if (256 & p)
                        return void q(c, d, n, r, o, i, a, s, l)
                }
                8 & f ? (16 & u && Y(c, o, i),
                d !== c && h(n, d)) : 16 & u ? 16 & f ? H(c, d, n, r, o, i, a, s, l) : Y(c, o, i, !0) : (8 & u && h(n, ""),
                16 & f && C(d, n, r, o, i, a, s, l))
            }
              , q = (e,t,n,r,i,a,s,l,c)=>{
                t = t || o;
                const u = (e = e || o).length
                  , d = t.length
                  , p = Math.min(u, d);
                let h;
                for (h = 0; h < p; h++) {
                    const r = t[h] = c ? No(t[h]) : Ro(t[h]);
                    O(e[h], r, n, null, i, a, s, l, c)
                }
                u > d ? Y(e, i, a, !0, !1, p) : C(t, n, r, i, a, s, l, c, p)
            }
              , H = (e,t,n,r,i,a,s,l,c)=>{
                let u = 0;
                const d = t.length;
                let p = e.length - 1
                  , h = d - 1;
                for (; u <= p && u <= h; ) {
                    const r = e[u]
                      , o = t[u] = c ? No(t[u]) : Ro(t[u]);
                    if (!_o(r, o))
                        break;
                    O(r, o, n, null, i, a, s, l, c),
                    u++
                }
                for (; u <= p && u <= h; ) {
                    const r = e[p]
                      , o = t[h] = c ? No(t[h]) : Ro(t[h]);
                    if (!_o(r, o))
                        break;
                    O(r, o, n, null, i, a, s, l, c),
                    p--,
                    h--
                }
                if (u > p) {
                    if (u <= h) {
                        const e = h + 1
                          , o = e < d ? t[e].el : r;
                        for (; u <= h; )
                            O(null, t[u] = c ? No(t[u]) : Ro(t[u]), n, o, i, a, s, l, c),
                            u++
                    }
                } else if (u > h)
                    for (; u <= p; )
                        W(e[u], i, a, !0),
                        u++;
                else {
                    const f = u
                      , m = u
                      , g = new Map;
                    for (u = m; u <= h; u++) {
                        const e = t[u] = c ? No(t[u]) : Ro(t[u]);
                        null != e.key && g.set(e.key, u)
                    }
                    let b, v = 0;
                    const y = h - m + 1;
                    let w = !1
                      , _ = 0;
                    const k = new Array(y);
                    for (u = 0; u < y; u++)
                        k[u] = 0;
                    for (u = f; u <= p; u++) {
                        const r = e[u];
                        if (v >= y) {
                            W(r, i, a, !0);
                            continue
                        }
                        let o;
                        if (null != r.key)
                            o = g.get(r.key);
                        else
                            for (b = m; b <= h; b++)
                                if (0 === k[b - m] && _o(r, t[b])) {
                                    o = b;
                                    break
                                }
                        void 0 === o ? W(r, i, a, !0) : (k[o - m] = u + 1,
                        o >= _ ? _ = o : w = !0,
                        O(r, t[o], n, null, i, a, s, l, c),
                        v++)
                    }
                    const S = w ? function(e) {
                        const t = e.slice()
                          , n = [0];
                        let r, o, i, a, s;
                        const l = e.length;
                        for (r = 0; r < l; r++) {
                            const l = e[r];
                            if (0 !== l) {
                                if (o = n[n.length - 1],
                                e[o] < l) {
                                    t[r] = o,
                                    n.push(r);
                                    continue
                                }
                                for (i = 0,
                                a = n.length - 1; i < a; )
                                    s = i + a >> 1,
                                    e[n[s]] < l ? i = s + 1 : a = s;
                                l < e[n[i]] && (i > 0 && (t[r] = n[i - 1]),
                                n[i] = r)
                            }
                        }
                        i = n.length,
                        a = n[i - 1];
                        for (; i-- > 0; )
                            n[i] = a,
                            a = t[a];
                        return n
                    }(k) : o;
                    for (b = S.length - 1,
                    u = y - 1; u >= 0; u--) {
                        const e = m + u
                          , o = t[e]
                          , p = e + 1 < d ? t[e + 1].el : r;
                        0 === k[u] ? O(null, o, n, p, i, a, s, l, c) : w && (b < 0 || u !== S[b] ? Z(o, n, p, 2) : b--)
                    }
                }
            }
              , Z = (e,t,r,o,i=null)=>{
                const {el: a, type: s, transition: l, children: c, shapeFlag: u} = e;
                if (6 & u)
                    return void Z(e.component.subTree, t, r, o);
                if (128 & u)
                    return void e.suspense.move(t, r, o);
                if (64 & u)
                    return void s.move(e, t, r, te);
                if (s === lo) {
                    n(a, t, r);
                    for (let e = 0; e < c.length; e++)
                        Z(c[e], t, r, o);
                    return void n(e.anchor, t, r)
                }
                if (s === po)
                    return void k(e, t, r);
                if (2 !== o && 1 & u && l)
                    if (0 === o)
                        l.beforeEnter(a),
                        n(a, t, r),
                        Rr((()=>l.enter(a)), i);
                    else {
                        const {leave: e, delayLeave: o, afterLeave: i} = l
                          , s = ()=>n(a, t, r)
                          , c = ()=>{
                            e(a, (()=>{
                                s(),
                                i && i()
                            }
                            ))
                        }
                        ;
                        o ? o(a, s, c) : c()
                    }
                else
                    n(a, t, r)
            }
              , W = (e,t,n,r=!1,o=!1)=>{
                const {type: i, props: a, ref: s, children: l, dynamicChildren: c, shapeFlag: u, patchFlag: d, dirs: p, memoIndex: h} = e;
                if (null != s && Dr(s, null, n, e, !0),
                null != h && (t.renderCache[h] = void 0),
                256 & u)
                    return void t.ctx.deactivate(e);
                const f = 1 & u && p
                  , m = !Qn(e);
                let g;
                if (m && (g = a && a.onVnodeBeforeUnmount) && Mo(g, t, e),
                6 & u)
                    G(e.component, n, r);
                else {
                    if (128 & u)
                        return void e.suspense.unmount(n, r);
                    f && $n(e, null, t, "beforeUnmount"),
                    64 & u ? e.type.remove(e, t, n, o, te, r) : c && (i !== lo || d > 0 && 64 & d) ? Y(c, t, n, !1, !0) : (i === lo && 384 & d || !o && 16 & u) && Y(l, t, n),
                    r && X(e)
                }
                (m && (g = a && a.onVnodeUnmounted) || f) && Rr((()=>{
                    g && Mo(g, t, e),
                    f && $n(e, null, t, "unmounted")
                }
                ), n)
            }
              , X = e=>{
                const {type: t, el: n, anchor: r, transition: o} = e;
                if (t === lo)
                    return void V(n, r);
                if (t === po)
                    return void S(e);
                const i = ()=>{
                    a(n),
                    o && !o.persisted && o.afterLeave && o.afterLeave()
                }
                ;
                if (1 & e.shapeFlag && o && !o.persisted) {
                    const {leave: t, delayLeave: r} = o
                      , a = ()=>t(n, i);
                    r ? r(e.el, i, a) : a()
                } else
                    i()
            }
              , V = (e,t)=>{
                let n;
                for (; e !== t; )
                    n = m(e),
                    a(e),
                    e = n;
                a(t)
            }
              , G = (e,t,n)=>{
                const {bum: r, scope: o, update: i, subTree: a, um: s, m: l, a: c} = e;
                Qr(l),
                Qr(c),
                r && M(r),
                o.stop(),
                i && (i.active = !1,
                W(a, e, t, n)),
                s && Rr(s, t),
                Rr((()=>{
                    e.isUnmounted = !0
                }
                ), t),
                t && t.pendingBranch && !t.isUnmounted && e.asyncDep && !e.asyncResolved && e.suspenseId === t.pendingId && (t.deps--,
                0 === t.deps && t.resolve())
            }
              , Y = (e,t,n,r=!1,o=!1,i=0)=>{
                for (let a = i; a < e.length; a++)
                    W(e[a], t, n, r, o)
            }
              , K = e=>6 & e.shapeFlag ? K(e.component.subTree) : 128 & e.shapeFlag ? e.suspense.next() : m(e.anchor || e.el);
            let J = !1;
            const ee = (e,t,n)=>{
                null == e ? t._vnode && W(t._vnode, null, null, !0) : O(t._vnode || null, e, t, null, null, null, n),
                J || (J = !0,
                Yt(),
                Kt(),
                J = !1),
                t._vnode = e
            }
              , te = {
                p: O,
                um: W,
                m: Z,
                r: X,
                mt: Q,
                mc: C,
                pc: z,
                pbc: N,
                n: K,
                o: e
            };
            let ne, oe;
            return {
                render: ee,
                hydrate: ne,
                createApp: cr(ee, ne)
            }
        }(e)
    }
    function $r({type: e, props: t}, n) {
        return "svg" === n && "foreignObject" === e || "mathml" === n && "annotation-xml" === e && t && t.encoding && t.encoding.includes("html") ? void 0 : n
    }
    function Ir({effect: e, update: t}, n) {
        e.allowRecurse = t.allowRecurse = n
    }
    function Mr(e, t, n=!1) {
        const r = e.children
          , o = t.children;
        if (h(r) && h(o))
            for (let i = 0; i < r.length; i++) {
                const e = r[i];
                let t = o[i];
                1 & t.shapeFlag && !t.dynamicChildren && ((t.patchFlag <= 0 || 32 === t.patchFlag) && (t = o[i] = No(o[i]),
                t.el = e.el),
                n || -2 === t.patchFlag || Mr(e, t)),
                t.type === co && (t.el = e.el)
            }
    }
    function Lr(e) {
        const t = e.subTree.component;
        if (t)
            return t.asyncDep && !t.asyncResolved ? t : Lr(t)
    }
    function Qr(e) {
        if (e)
            for (let t = 0; t < e.length; t++)
                e[t].active = !1
    }
    const Br = Symbol.for("v-scx")
      , Ur = ()=>pr(Br);
    function Fr(e, t) {
        return qr(e, null, t)
    }
    const jr = {};
    function zr(e, t, n) {
        return qr(e, t, n)
    }
    function qr(e, t, {immediate: n, deep: o, flush: a, once: s, onTrack: l, onTrigger: c}=r) {
        if (t && s) {
            const e = t;
            t = (...t)=>{
                e(...t),
                x()
            }
        }
        const d = Bo
          , p = e=>!0 === o ? e : Wr(e, !1 === o ? 1 : void 0);
        let f, m, g = !1, O = !1;
        if (St(e) ? (f = ()=>e.value,
        g = gt(e)) : ft(e) ? (f = ()=>p(e),
        g = !0) : h(e) ? (O = !0,
        g = e.some((e=>ft(e) || gt(e))),
        f = ()=>e.map((e=>St(e) ? e.value : ft(e) ? p(e) : b(e) ? Mt(e, d, 2) : void 0))) : f = b(e) ? t ? ()=>Mt(e, d, 2) : ()=>(m && m(),
        Lt(e, d, 3, [y])) : i,
        t && o) {
            const e = f;
            f = ()=>Wr(e())
        }
        let v, y = e=>{
            m = S.onStop = ()=>{
                Mt(e, d, 4),
                m = S.onStop = void 0
            }
        }
        ;
        if (Wo) {
            if (y = i,
            t ? n && Lt(t, d, 3, [f(), O ? [] : void 0, y]) : f(),
            "sync" !== a)
                return i;
            {
                const e = Ur();
                v = e.__watcherHandles || (e.__watcherHandles = [])
            }
        }
        let w = O ? new Array(e.length).fill(jr) : jr;
        const _ = ()=>{
            if (S.active && S.dirty)
                if (t) {
                    const e = S.run();
                    (o || g || (O ? e.some(((e,t)=>I(e, w[t]))) : I(e, w))) && (m && m(),
                    Lt(t, d, 3, [e, w === jr ? void 0 : O && w[0] === jr ? [] : w, y]),
                    w = e)
                } else
                    S.run()
        }
        ;
        let k;
        _.allowRecurse = !!t,
        "sync" === a ? k = _ : "post" === a ? k = ()=>Rr(_, d && d.suspense) : (_.pre = !0,
        d && (_.id = d.uid),
        k = ()=>Vt(_));
        const S = new ae(f,i,k)
          , E = oe()
          , x = ()=>{
            S.stop(),
            E && u(E.effects, S)
        }
        ;
        return t ? n ? _() : w = S.run() : "post" === a ? Rr(S.run.bind(S), d && d.suspense) : S.run(),
        v && v.push(x),
        x
    }
    function Hr(e, t, n) {
        const r = this.proxy
          , o = O(e) ? e.includes(".") ? Zr(r, e) : ()=>r[e] : e.bind(r, r);
        let i;
        b(t) ? i = t : (i = t.handler,
        n = t);
        const a = zo(this)
          , s = qr(o, i.bind(r), n);
        return a(),
        s
    }
    function Zr(e, t) {
        const n = t.split(".");
        return ()=>{
            let t = e;
            for (let e = 0; e < n.length && t; e++)
                t = t[n[e]];
            return t
        }
    }
    function Wr(e, t=1 / 0, n) {
        if (t <= 0 || !y(e) || e.__v_skip)
            return e;
        if ((n = n || new Set).has(e))
            return e;
        if (n.add(e),
        t--,
        St(e))
            Wr(e.value, t, n);
        else if (h(e))
            for (let r = 0; r < e.length; r++)
                Wr(e[r], t, n);
        else if (m(e) || f(e))
            e.forEach((e=>{
                Wr(e, t, n)
            }
            ));
        else if (E(e)) {
            for (const r in e)
                Wr(e[r], t, n);
            for (const r of Object.getOwnPropertySymbols(e))
                Object.prototype.propertyIsEnumerable.call(e, r) && Wr(e[r], t, n)
        }
        return e
    }
    const Xr = e=>e.type.__isKeepAlive;
    function Vr(e, t) {
        Yr(e, "a", t)
    }
    function Gr(e, t) {
        Yr(e, "da", t)
    }
    function Yr(e, t, n=Bo) {
        const r = e.__wdc || (e.__wdc = ()=>{
            let t = n;
            for (; t; ) {
                if (t.isDeactivated)
                    return;
                t = t.parent
            }
            return e()
        }
        );
        if (wn(t, r, n),
        n) {
            let e = n.parent;
            for (; e && e.parent; )
                Xr(e.parent.vnode) && Kr(r, t, n, e),
                e = e.parent
        }
    }
    function Kr(e, t, n, r) {
        const o = wn(t, e, r, !0);
        An((()=>{
            u(r[t], o)
        }
        ), n)
    }
    function Jr(e, t) {
        6 & e.shapeFlag && e.component ? Jr(e.component.subTree, t) : 128 & e.shapeFlag ? (e.ssContent.transition = t.clone(e.ssContent),
        e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
    }
    const eo = e=>e && (e.disabled || "" === e.disabled)
      , to = e=>"undefined" != typeof SVGElement && e instanceof SVGElement
      , no = e=>"function" == typeof MathMLElement && e instanceof MathMLElement
      , ro = (e,t)=>{
        const n = e && e.to;
        if (O(n)) {
            if (t) {
                return t(n)
            }
            return null
        }
        return n
    }
      , oo = {
        name: "Teleport",
        __isTeleport: !0,
        process(e, t, n, r, o, i, a, s, l, c) {
            const {mc: u, pc: d, pbc: p, o: {insert: h, querySelector: f, createText: m, createComment: g}} = c
              , b = eo(t.props);
            let {shapeFlag: O, children: v, dynamicChildren: y} = t;
            if (null == e) {
                const e = t.el = m("")
                  , c = t.anchor = m("");
                h(e, n, r),
                h(c, n, r);
                const d = t.target = ro(t.props, f)
                  , p = t.targetAnchor = m("");
                d && (h(p, d),
                "svg" === a || to(d) ? a = "svg" : ("mathml" === a || no(d)) && (a = "mathml"));
                const g = (e,t)=>{
                    16 & O && u(v, e, t, o, i, a, s, l)
                }
                ;
                b ? g(n, c) : d && g(d, p)
            } else {
                t.el = e.el;
                const r = t.anchor = e.anchor
                  , u = t.target = e.target
                  , h = t.targetAnchor = e.targetAnchor
                  , m = eo(e.props)
                  , g = m ? n : u
                  , O = m ? r : h;
                if ("svg" === a || to(u) ? a = "svg" : ("mathml" === a || no(u)) && (a = "mathml"),
                y ? (p(e.dynamicChildren, y, g, o, i, a, s),
                Mr(e, t, !0)) : l || d(e, t, g, O, o, i, a, s, !1),
                b)
                    m ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : io(t, n, r, c, 1);
                else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
                    const e = t.target = ro(t.props, f);
                    e && io(t, e, null, c, 0)
                } else
                    m && io(t, u, h, c, 1)
            }
            so(t)
        },
        remove(e, t, n, r, {um: o, o: {remove: i}}, a) {
            const {shapeFlag: s, children: l, anchor: c, targetAnchor: u, target: d, props: p} = e;
            if (d && i(u),
            a && i(c),
            16 & s) {
                const e = a || !eo(p);
                for (let r = 0; r < l.length; r++) {
                    const i = l[r];
                    o(i, t, n, e, !!i.dynamicChildren)
                }
            }
        },
        move: io,
        hydrate: function(e, t, n, r, o, i, {o: {nextSibling: a, parentNode: s, querySelector: l}}, c) {
            const u = t.target = ro(t.props, l);
            if (u) {
                const l = u._lpa || u.firstChild;
                if (16 & t.shapeFlag)
                    if (eo(t.props))
                        t.anchor = c(a(e), t, s(e), n, r, o, i),
                        t.targetAnchor = l;
                    else {
                        t.anchor = a(e);
                        let s = l;
                        for (; s; )
                            if (s = a(s),
                            s && 8 === s.nodeType && "teleport anchor" === s.data) {
                                t.targetAnchor = s,
                                u._lpa = t.targetAnchor && a(t.targetAnchor);
                                break
                            }
                        c(l, t, u, n, r, o, i)
                    }
                so(t)
            }
            return t.anchor && a(t.anchor)
        }
    };
    function io(e, t, n, {o: {insert: r}, m: o}, i=2) {
        0 === i && r(e.targetAnchor, t, n);
        const {el: a, anchor: s, shapeFlag: l, children: c, props: u} = e
          , d = 2 === i;
        if (d && r(a, t, n),
        (!d || eo(u)) && 16 & l)
            for (let p = 0; p < c.length; p++)
                o(c[p], t, n, 2);
        d && r(s, t, n)
    }
    const ao = oo;
    function so(e) {
        const t = e.ctx;
        if (t && t.ut) {
            let n = e.children[0].el;
            for (; n && n !== e.targetAnchor; )
                1 === n.nodeType && n.setAttribute("data-v-owner", t.uid),
                n = n.nextSibling;
            t.ut()
        }
    }
    const lo = Symbol.for("v-fgt")
      , co = Symbol.for("v-txt")
      , uo = Symbol.for("v-cmt")
      , po = Symbol.for("v-stc")
      , ho = [];
    let fo = null;
    function mo(e=!1) {
        ho.push(fo = e ? null : [])
    }
    let go = 1;
    function bo(e) {
        go += e
    }
    function Oo(e) {
        return e.dynamicChildren = go > 0 ? fo || o : null,
        ho.pop(),
        fo = ho[ho.length - 1] || null,
        go > 0 && fo && fo.push(e),
        e
    }
    function vo(e, t, n, r, o, i) {
        return Oo(Eo(e, t, n, r, o, i, !0))
    }
    function yo(e, t, n, r, o) {
        return Oo(xo(e, t, n, r, o, !0))
    }
    function wo(e) {
        return !!e && !0 === e.__v_isVNode
    }
    function _o(e, t) {
        return e.type === t.type && e.key === t.key
    }
    const ko = ({key: e})=>null != e ? e : null
      , So = ({ref: e, ref_key: t, ref_for: n})=>("number" == typeof e && (e = "" + e),
    null != e ? O(e) || St(e) || b(e) ? {
        i: an,
        r: e,
        k: t,
        f: !!n
    } : e : null);
    function Eo(e, t=null, n=null, r=0, o=null, i=(e === lo ? 0 : 1), a=!1, s=!1) {
        const l = {
            __v_isVNode: !0,
            __v_skip: !0,
            type: e,
            props: t,
            key: t && ko(t),
            ref: t && So(t),
            scopeId: sn,
            slotScopeIds: null,
            children: n,
            component: null,
            suspense: null,
            ssContent: null,
            ssFallback: null,
            dirs: null,
            transition: null,
            el: null,
            anchor: null,
            target: null,
            targetAnchor: null,
            staticCount: 0,
            shapeFlag: i,
            patchFlag: r,
            dynamicProps: o,
            dynamicChildren: null,
            appContext: null,
            ctx: an
        };
        return s ? ($o(l, n),
        128 & i && e.normalize(l)) : n && (l.shapeFlag |= O(n) ? 8 : 16),
        go > 0 && !a && fo && (l.patchFlag > 0 || 6 & i) && 32 !== l.patchFlag && fo.push(l),
        l
    }
    const xo = function(e, t=null, n=null, r=0, o=null, i=!1) {
        e && e !== bn || (e = uo);
        if (wo(e)) {
            const r = Ao(e, t, !0);
            return n && $o(r, n),
            go > 0 && !i && fo && (6 & r.shapeFlag ? fo[fo.indexOf(e)] = r : fo.push(r)),
            r.patchFlag = -2,
            r
        }
        a = e,
        b(a) && "__vccOpts"in a && (e = e.__vccOpts);
        var a;
        if (t) {
            t = To(t);
            let {class: e, style: n} = t;
            e && !O(e) && (t.class = Z(e)),
            y(n) && (bt(n) && !h(n) && (n = c({}, n)),
            t.style = F(n))
        }
        const s = O(e) ? 1 : (e=>e.__isSuspense)(e) ? 128 : (e=>e.__isTeleport)(e) ? 64 : y(e) ? 4 : b(e) ? 2 : 0;
        return Eo(e, t, n, r, o, s, i, !0)
    };
    function To(e) {
        return e ? bt(e) || mr(e) ? c({}, e) : e : null
    }
    function Ao(e, t, n=!1, r=!1) {
        const {props: o, ref: i, patchFlag: a, children: s, transition: l} = e
          , c = t ? Io(o || {}, t) : o
          , u = {
            __v_isVNode: !0,
            __v_skip: !0,
            type: e.type,
            props: c,
            key: c && ko(c),
            ref: t && t.ref ? n && i ? h(i) ? i.concat(So(t)) : [i, So(t)] : So(t) : i,
            scopeId: e.scopeId,
            slotScopeIds: e.slotScopeIds,
            children: s,
            target: e.target,
            targetAnchor: e.targetAnchor,
            staticCount: e.staticCount,
            shapeFlag: e.shapeFlag,
            patchFlag: t && e.type !== lo ? -1 === a ? 16 : 16 | a : a,
            dynamicProps: e.dynamicProps,
            dynamicChildren: e.dynamicChildren,
            appContext: e.appContext,
            dirs: e.dirs,
            transition: l,
            component: e.component,
            suspense: e.suspense,
            ssContent: e.ssContent && Ao(e.ssContent),
            ssFallback: e.ssFallback && Ao(e.ssFallback),
            el: e.el,
            anchor: e.anchor,
            ctx: e.ctx,
            ce: e.ce
        };
        return l && r && Jr(u, l.clone(u)),
        u
    }
    function Co(e=" ", t=0) {
        return xo(co, null, e, t)
    }
    function Po(e, t) {
        const n = xo(po, null, e);
        return n.staticCount = t,
        n
    }
    function Do(e="", t=!1) {
        return t ? (mo(),
        yo(uo, null, e)) : xo(uo, null, e)
    }
    function Ro(e) {
        return null == e || "boolean" == typeof e ? xo(uo) : h(e) ? xo(lo, null, e.slice()) : "object" == typeof e ? No(e) : xo(co, null, String(e))
    }
    function No(e) {
        return null === e.el && -1 !== e.patchFlag || e.memo ? e : Ao(e)
    }
    function $o(e, t) {
        let n = 0;
        const {shapeFlag: r} = e;
        if (null == t)
            t = null;
        else if (h(t))
            n = 16;
        else if ("object" == typeof t) {
            if (65 & r) {
                const n = t.default;
                return void (n && (n._c && (n._d = !1),
                $o(e, n()),
                n._c && (n._d = !0)))
            }
            {
                n = 32;
                const r = t._;
                r || mr(t) ? 3 === r && an && (1 === an.slots._ ? t._ = 1 : (t._ = 2,
                e.patchFlag |= 1024)) : t._ctx = an
            }
        } else
            b(t) ? (t = {
                default: t,
                _ctx: an
            },
            n = 32) : (t = String(t),
            64 & r ? (n = 16,
            t = [Co(t)]) : n = 8);
        e.children = t,
        e.shapeFlag |= n
    }
    function Io(...e) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
            const r = e[n];
            for (const e in r)
                if ("class" === e)
                    t.class !== r.class && (t.class = Z([t.class, r.class]));
                else if ("style" === e)
                    t.style = F([t.style, r.style]);
                else if (s(e)) {
                    const n = t[e]
                      , o = r[e];
                    !o || n === o || h(n) && n.includes(o) || (t[e] = n ? [].concat(n, o) : o)
                } else
                    "" !== e && (t[e] = r[e])
        }
        return t
    }
    function Mo(e, t, n, r=null) {
        Lt(e, t, 7, [n, r])
    }
    const Lo = sr();
    let Qo = 0;
    let Bo = null;
    const Uo = ()=>Bo || an;
    let Fo, jo;
    {
        const e = U()
          , t = (t,n)=>{
            let r;
            return (r = e[t]) || (r = e[t] = []),
            r.push(n),
            e=>{
                r.length > 1 ? r.forEach((t=>t(e))) : r[0](e)
            }
        }
        ;
        Fo = t("__VUE_INSTANCE_SETTERS__", (e=>Bo = e)),
        jo = t("__VUE_SSR_SETTERS__", (e=>Wo = e))
    }
    const zo = e=>{
        const t = Bo;
        return Fo(e),
        e.scope.on(),
        ()=>{
            e.scope.off(),
            Fo(t)
        }
    }
      , qo = ()=>{
        Bo && Bo.scope.off(),
        Fo(null)
    }
    ;
    function Ho(e) {
        return 4 & e.vnode.shapeFlag
    }
    let Zo, Wo = !1;
    function Xo(e, t, n) {
        b(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : y(t) && (e.setupState = Rt(t)),
        Vo(e, n)
    }
    function Vo(e, t, n) {
        const r = e.type;
        if (!e.render) {
            if (!t && Zo && !r.render) {
                const t = r.template || Jn(e).template;
                if (t) {
                    const {isCustomElement: n, compilerOptions: o} = e.appContext.config
                      , {delimiters: i, compilerOptions: a} = r
                      , s = c(c({
                        isCustomElement: n,
                        delimiters: i
                    }, o), a);
                    r.render = Zo(t, s)
                }
            }
            e.render = r.render || i
        }
        {
            const t = zo(e);
            he();
            try {
                Gn(e)
            } finally {
                fe(),
                t()
            }
        }
    }
    const Go = {
        get: (e,t)=>(Se(e, 0, ""),
        e[t])
    };
    function Yo(e) {
        const t = t=>{
            e.exposed = t || {}
        }
        ;
        return {
            attrs: new Proxy(e.attrs,Go),
            slots: e.slots,
            emit: e.emit,
            expose: t
        }
    }
    function Ko(e) {
        return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(Rt((t = e.exposed,
        Object.isExtensible(t) && L(t, "__v_skip", !0),
        t)),{
            get: (t,n)=>n in t ? t[n] : n in qn ? qn[n](e) : void 0,
            has: (e,t)=>t in e || t in qn
        })) : e.proxy;
        var t
    }
    function Jo(e, t=!0) {
        return b(e) ? e.displayName || e.name : e.name || t && e.__name
    }
    const ei = (e,t)=>{
        const n = function(e, t, n=!1) {
            let r, o;
            const a = b(e);
            return a ? (r = e,
            o = i) : (r = e.get,
            o = e.set),
            new wt(r,o,a || !o,n)
        }(e, 0, Wo);
        return n
    }
    ;
    function ti(e, t, n) {
        const r = arguments.length;
        return 2 === r ? y(t) && !h(t) ? wo(t) ? xo(e, null, [t]) : xo(e, t) : xo(e, null, t) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : 3 === r && wo(n) && (n = [n]),
        xo(e, t, n))
    }
    const ni = "3.4.29"
      , ri = "undefined" != typeof document ? document : null
      , oi = ri && ri.createElement("template")
      , ii = {
        insert: (e,t,n)=>{
            t.insertBefore(e, n || null)
        }
        ,
        remove: e=>{
            const t = e.parentNode;
            t && t.removeChild(e)
        }
        ,
        createElement: (e,t,n,r)=>{
            const o = "svg" === t ? ri.createElementNS("http://www.w3.org/2000/svg", e) : "mathml" === t ? ri.createElementNS("http://www.w3.org/1998/Math/MathML", e) : n ? ri.createElement(e, {
                is: n
            }) : ri.createElement(e);
            return "select" === e && r && null != r.multiple && o.setAttribute("multiple", r.multiple),
            o
        }
        ,
        createText: e=>ri.createTextNode(e),
        createComment: e=>ri.createComment(e),
        setText: (e,t)=>{
            e.nodeValue = t
        }
        ,
        setElementText: (e,t)=>{
            e.textContent = t
        }
        ,
        parentNode: e=>e.parentNode,
        nextSibling: e=>e.nextSibling,
        querySelector: e=>ri.querySelector(e),
        setScopeId(e, t) {
            e.setAttribute(t, "")
        },
        insertStaticContent(e, t, n, r, o, i) {
            const a = n ? n.previousSibling : t.lastChild;
            if (o && (o === i || o.nextSibling))
                for (; t.insertBefore(o.cloneNode(!0), n),
                o !== i && (o = o.nextSibling); )
                    ;
            else {
                oi.innerHTML = "svg" === r ? `<svg>${e}</svg>` : "mathml" === r ? `<math>${e}</math>` : e;
                const o = oi.content;
                if ("svg" === r || "mathml" === r) {
                    const e = o.firstChild;
                    for (; e.firstChild; )
                        o.appendChild(e.firstChild);
                    o.removeChild(e)
                }
                t.insertBefore(o, n)
            }
            return [a ? a.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
        }
    }
      , ai = Symbol("_vtc");
    /**
  * @vue/runtime-dom v3.4.29
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
    const si = Symbol("_vod")
      , li = Symbol("_vsh")
      , ci = {
        beforeMount(e, {value: t}, {transition: n}) {
            e[si] = "none" === e.style.display ? "" : e.style.display,
            n && t ? n.beforeEnter(e) : ui(e, t)
        },
        mounted(e, {value: t}, {transition: n}) {
            n && t && n.enter(e)
        },
        updated(e, {value: t, oldValue: n}, {transition: r}) {
            !t != !n && (r ? t ? (r.beforeEnter(e),
            ui(e, !0),
            r.enter(e)) : r.leave(e, (()=>{
                ui(e, !1)
            }
            )) : ui(e, t))
        },
        beforeUnmount(e, {value: t}) {
            ui(e, t)
        }
    };
    function ui(e, t) {
        e.style.display = t ? e[si] : "none",
        e[li] = !t
    }
    const di = Symbol("");
    function pi(e) {
        const t = Uo();
        if (!t)
            return;
        const n = t.ut = (n=e(t.proxy))=>{
            Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach((e=>fi(e, n)))
        }
          , r = ()=>{
            const r = e(t.proxy);
            hi(t.subTree, r),
            n(r)
        }
        ;
        Sn((()=>{
            qr(r, null, {
                flush: "post"
            });
            const e = new MutationObserver(r);
            e.observe(t.subTree.el.parentNode, {
                childList: !0
            }),
            An((()=>e.disconnect()))
        }
        ))
    }
    function hi(e, t) {
        if (128 & e.shapeFlag) {
            const n = e.suspense;
            e = n.activeBranch,
            n.pendingBranch && !n.isHydrating && n.effects.push((()=>{
                hi(n.activeBranch, t)
            }
            ))
        }
        for (; e.component; )
            e = e.component.subTree;
        if (1 & e.shapeFlag && e.el)
            fi(e.el, t);
        else if (e.type === lo)
            e.children.forEach((e=>hi(e, t)));
        else if (e.type === po) {
            let {el: n, anchor: r} = e;
            for (; n && (fi(n, t),
            n !== r); )
                n = n.nextSibling
        }
    }
    function fi(e, t) {
        if (1 === e.nodeType) {
            const n = e.style;
            let r = "";
            for (const e in t)
                n.setProperty(`--${e}`, t[e]),
                r += `--${e}: ${t[e]};`;
            n[di] = r
        }
    }
    const mi = /(^|;)\s*display\s*:/;
    const gi = /\s*!important$/;
    function bi(e, t, n) {
        if (h(n))
            n.forEach((n=>bi(e, t, n)));
        else if (null == n && (n = ""),
        t.startsWith("--"))
            e.setProperty(t, n);
        else {
            const r = function(e, t) {
                const n = vi[t];
                if (n)
                    return n;
                let r = P(t);
                if ("filter" !== r && r in e)
                    return vi[t] = r;
                r = N(r);
                for (let o = 0; o < Oi.length; o++) {
                    const n = Oi[o] + r;
                    if (n in e)
                        return vi[t] = n
                }
                return t
            }(e, t);
            gi.test(n) ? e.setProperty(R(r), n.replace(gi, ""), "important") : e[r] = n
        }
    }
    const Oi = ["Webkit", "Moz", "ms"]
      , vi = {};
    const yi = "http://www.w3.org/1999/xlink";
    function wi(e, t, n, r, o, i=X(t)) {
        r && t.startsWith("xlink:") ? null == n ? e.removeAttributeNS(yi, t.slice(6, t.length)) : e.setAttributeNS(yi, t, n) : null == n || i && !V(n) ? e.removeAttribute(t) : e.setAttribute(t, i ? "" : String(n))
    }
    function _i(e, t, n, r) {
        e.addEventListener(t, n, r)
    }
    const ki = Symbol("_vei");
    function Si(e, t, n, r, o=null) {
        const i = e[ki] || (e[ki] = {})
          , a = i[t];
        if (r && a)
            a.value = r;
        else {
            const [n,s] = function(e) {
                let t;
                if (Ei.test(e)) {
                    let n;
                    for (t = {}; n = e.match(Ei); )
                        e = e.slice(0, e.length - n[0].length),
                        t[n[0].toLowerCase()] = !0
                }
                const n = ":" === e[2] ? e.slice(3) : R(e.slice(2));
                return [n, t]
            }(t);
            if (r) {
                const a = i[t] = function(e, t) {
                    const n = e=>{
                        if (e._vts) {
                            if (e._vts <= n.attached)
                                return
                        } else
                            e._vts = Date.now();
                        Lt(function(e, t) {
                            if (h(t)) {
                                const n = e.stopImmediatePropagation;
                                return e.stopImmediatePropagation = ()=>{
                                    n.call(e),
                                    e._stopped = !0
                                }
                                ,
                                t.map((e=>t=>!t._stopped && e && e(t)))
                            }
                            return t
                        }(e, n.value), t, 5, [e])
                    }
                    ;
                    return n.value = e,
                    n.attached = Ai(),
                    n
                }(r, o);
                _i(e, n, a, s)
            } else
                a && (!function(e, t, n, r) {
                    e.removeEventListener(t, n, r)
                }(e, n, a, s),
                i[t] = void 0)
        }
    }
    const Ei = /(?:Once|Passive|Capture)$/;
    let xi = 0;
    const Ti = Promise.resolve()
      , Ai = ()=>xi || (Ti.then((()=>xi = 0)),
    xi = Date.now());
    const Ci = e=>111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123;
    const Pi = e=>{
        const t = e.props["onUpdate:modelValue"] || !1;
        return h(t) ? e=>M(t, e) : t
    }
    ;
    function Di(e) {
        e.target.composing = !0
    }
    function Ri(e) {
        const t = e.target;
        t.composing && (t.composing = !1,
        t.dispatchEvent(new Event("input")))
    }
    const Ni = Symbol("_assign")
      , $i = {
        created(e, {modifiers: {lazy: t, trim: n, number: r}}, o) {
            e[Ni] = Pi(o);
            const i = r || o.props && "number" === o.props.type;
            _i(e, t ? "change" : "input", (t=>{
                if (t.target.composing)
                    return;
                let r = e.value;
                n && (r = r.trim()),
                i && (r = Q(r)),
                e[Ni](r)
            }
            )),
            n && _i(e, "change", (()=>{
                e.value = e.value.trim()
            }
            )),
            t || (_i(e, "compositionstart", Di),
            _i(e, "compositionend", Ri),
            _i(e, "change", Ri))
        },
        mounted(e, {value: t}) {
            e.value = null == t ? "" : t
        },
        beforeUpdate(e, {value: t, oldValue: n, modifiers: {lazy: r, trim: o, number: i}}, a) {
            if (e[Ni] = Pi(a),
            e.composing)
                return;
            const s = null == t ? "" : t;
            if ((!i && "number" !== e.type || /^0\d/.test(e.value) ? e.value : Q(e.value)) !== s) {
                if (document.activeElement === e && "range" !== e.type) {
                    if (r && t === n)
                        return;
                    if (o && e.value.trim() === s)
                        return
                }
                e.value = s
            }
        }
    }
      , Ii = {
        deep: !0,
        created(e, t, n) {
            e[Ni] = Pi(n),
            _i(e, "change", (()=>{
                const t = e._modelValue
                  , n = Bi(e)
                  , r = e.checked
                  , o = e[Ni];
                if (h(t)) {
                    const e = Y(t, n)
                      , i = -1 !== e;
                    if (r && !i)
                        o(t.concat(n));
                    else if (!r && i) {
                        const n = [...t];
                        n.splice(e, 1),
                        o(n)
                    }
                } else if (m(t)) {
                    const e = new Set(t);
                    r ? e.add(n) : e.delete(n),
                    o(e)
                } else
                    o(Ui(e, r))
            }
            ))
        },
        mounted: Mi,
        beforeUpdate(e, t, n) {
            e[Ni] = Pi(n),
            Mi(e, t, n)
        }
    };
    function Mi(e, {value: t, oldValue: n}, r) {
        e._modelValue = t,
        h(t) ? e.checked = Y(t, r.props.value) > -1 : m(t) ? e.checked = t.has(r.props.value) : t !== n && (e.checked = G(t, Ui(e, !0)))
    }
    const Li = {
        deep: !0,
        created(e, {value: t, modifiers: {number: n}}, r) {
            const o = m(t);
            _i(e, "change", (()=>{
                const t = Array.prototype.filter.call(e.options, (e=>e.selected)).map((e=>n ? Q(Bi(e)) : Bi(e)));
                e[Ni](e.multiple ? o ? new Set(t) : t : t[0]),
                e._assigning = !0,
                Xt((()=>{
                    e._assigning = !1
                }
                ))
            }
            )),
            e[Ni] = Pi(r)
        },
        mounted(e, {value: t, modifiers: {number: n}}) {
            Qi(e, t)
        },
        beforeUpdate(e, t, n) {
            e[Ni] = Pi(n)
        },
        updated(e, {value: t, modifiers: {number: n}}) {
            e._assigning || Qi(e, t)
        }
    };
    function Qi(e, t, n) {
        const r = e.multiple
          , o = h(t);
        if (!r || o || m(t)) {
            for (let n = 0, i = e.options.length; n < i; n++) {
                const i = e.options[n]
                  , a = Bi(i);
                if (r)
                    if (o) {
                        const e = typeof a;
                        i.selected = "string" === e || "number" === e ? t.some((e=>String(e) === String(a))) : Y(t, a) > -1
                    } else
                        i.selected = t.has(a);
                else if (G(Bi(i), t))
                    return void (e.selectedIndex !== n && (e.selectedIndex = n))
            }
            r || -1 === e.selectedIndex || (e.selectedIndex = -1)
        }
    }
    function Bi(e) {
        return "_value"in e ? e._value : e.value
    }
    function Ui(e, t) {
        const n = t ? "_trueValue" : "_falseValue";
        return n in e ? e[n] : t
    }
    const Fi = ["ctrl", "shift", "alt", "meta"]
      , ji = {
        stop: e=>e.stopPropagation(),
        prevent: e=>e.preventDefault(),
        self: e=>e.target !== e.currentTarget,
        ctrl: e=>!e.ctrlKey,
        shift: e=>!e.shiftKey,
        alt: e=>!e.altKey,
        meta: e=>!e.metaKey,
        left: e=>"button"in e && 0 !== e.button,
        middle: e=>"button"in e && 1 !== e.button,
        right: e=>"button"in e && 2 !== e.button,
        exact: (e,t)=>Fi.some((n=>e[`${n}Key`] && !t.includes(n)))
    }
      , zi = (e,t)=>{
        const n = e._withMods || (e._withMods = {})
          , r = t.join(".");
        return n[r] || (n[r] = (n,...r)=>{
            for (let e = 0; e < t.length; e++) {
                const r = ji[t[e]];
                if (r && r(n, t))
                    return
            }
            return e(n, ...r)
        }
        )
    }
      , qi = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
    }
      , Hi = (e,t)=>{
        const n = e._withKeys || (e._withKeys = {})
          , r = t.join(".");
        return n[r] || (n[r] = n=>{
            if (!("key"in n))
                return;
            const r = R(n.key);
            return t.some((e=>e === r || qi[e] === r)) ? e(n) : void 0
        }
        )
    }
      , Zi = c({
        patchProp: (e,t,n,r,o,i,a,c,u)=>{
            const d = "svg" === o;
            "class" === t ? function(e, t, n) {
                const r = e[ai];
                r && (t = (t ? [t, ...r] : [...r]).join(" ")),
                null == t ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t
            }(e, r, d) : "style" === t ? function(e, t, n) {
                const r = e.style
                  , o = O(n);
                let i = !1;
                if (n && !o) {
                    if (t)
                        if (O(t))
                            for (const e of t.split(";")) {
                                const t = e.slice(0, e.indexOf(":")).trim();
                                null == n[t] && bi(r, t, "")
                            }
                        else
                            for (const e in t)
                                null == n[e] && bi(r, e, "");
                    for (const e in n)
                        "display" === e && (i = !0),
                        bi(r, e, n[e])
                } else if (o) {
                    if (t !== n) {
                        const e = r[di];
                        e && (n += ";" + e),
                        r.cssText = n,
                        i = mi.test(n)
                    }
                } else
                    t && e.removeAttribute("style");
                si in e && (e[si] = i ? r.display : "",
                e[li] && (r.display = "none"))
            }(e, n, r) : s(t) ? l(t) || Si(e, t, 0, r, a) : ("." === t[0] ? (t = t.slice(1),
            1) : "^" === t[0] ? (t = t.slice(1),
            0) : function(e, t, n, r) {
                if (r)
                    return "innerHTML" === t || "textContent" === t || !!(t in e && Ci(t) && b(n));
                if ("spellcheck" === t || "draggable" === t || "translate" === t)
                    return !1;
                if ("form" === t)
                    return !1;
                if ("list" === t && "INPUT" === e.tagName)
                    return !1;
                if ("type" === t && "TEXTAREA" === e.tagName)
                    return !1;
                if ("width" === t || "height" === t) {
                    const t = e.tagName;
                    if ("IMG" === t || "VIDEO" === t || "CANVAS" === t || "SOURCE" === t)
                        return !1
                }
                if (Ci(t) && O(n))
                    return !1;
                return t in e
            }(e, t, r, d)) ? (!function(e, t, n, r, o, i, a) {
                if ("innerHTML" === t || "textContent" === t)
                    return r && a(r, o, i),
                    void (e[t] = null == n ? "" : n);
                const s = e.tagName;
                if ("value" === t && "PROGRESS" !== s && !s.includes("-")) {
                    const r = "OPTION" === s ? e.getAttribute("value") || "" : e.value
                      , o = null == n ? "" : String(n);
                    return r === o && "_value"in e || (e.value = o),
                    null == n && e.removeAttribute(t),
                    void (e._value = n)
                }
                let l = !1;
                if ("" === n || null == n) {
                    const r = typeof e[t];
                    "boolean" === r ? n = V(n) : null == n && "string" === r ? (n = "",
                    l = !0) : "number" === r && (n = 0,
                    l = !0)
                }
                try {
                    e[t] = n
                } catch (Aa) {}
                l && e.removeAttribute(t)
            }(e, t, r, i, a, c, u),
            "value" !== t && "checked" !== t && "selected" !== t || wi(e, t, r, d, 0, "value" !== t)) : ("true-value" === t ? e._trueValue = r : "false-value" === t && (e._falseValue = r),
            wi(e, t, r, d))
        }
    }, ii);
    let Wi;
    const Xi = (...e)=>{
        const t = (Wi || (Wi = Nr(Zi))).createApp(...e)
          , {mount: n} = t;
        return t.mount = e=>{
            const r = function(e) {
                if (O(e)) {
                    return document.querySelector(e)
                }
                return e
            }(e);
            if (!r)
                return;
            const o = t._component;
            b(o) || o.render || o.template || (o.template = r.innerHTML),
            r.innerHTML = "";
            const i = n(r, !1, function(e) {
                if (e instanceof SVGElement)
                    return "svg";
                if ("function" == typeof MathMLElement && e instanceof MathMLElement)
                    return "mathml"
            }(r));
            return r instanceof Element && (r.removeAttribute("v-cloak"),
            r.setAttribute("data-v-app", "")),
            i
        }
        ,
        t
    }
    ;
    function Vi(e) {
        "function" == typeof queueMicrotask ? queueMicrotask(e) : Promise.resolve().then(e).catch((e=>setTimeout((()=>{
            throw e
        }
        ))))
    }
    function Gi() {
        let e = []
          , t = {
            addEventListener: (e,n,r,o)=>(e.addEventListener(n, r, o),
            t.add((()=>e.removeEventListener(n, r, o)))),
            requestAnimationFrame(...e) {
                let n = requestAnimationFrame(...e);
                t.add((()=>cancelAnimationFrame(n)))
            },
            nextFrame(...e) {
                t.requestAnimationFrame((()=>{
                    t.requestAnimationFrame(...e)
                }
                ))
            },
            setTimeout(...e) {
                let n = setTimeout(...e);
                t.add((()=>clearTimeout(n)))
            },
            microTask(...e) {
                let n = {
                    current: !0
                };
                return Vi((()=>{
                    n.current && e[0]()
                }
                )),
                t.add((()=>{
                    n.current = !1
                }
                ))
            },
            style(e, t, n) {
                let r = e.style.getPropertyValue(t);
                return Object.assign(e.style, {
                    [t]: n
                }),
                this.add((()=>{
                    Object.assign(e.style, {
                        [t]: r
                    })
                }
                ))
            },
            group(e) {
                let t = Gi();
                return e(t),
                this.add((()=>t.dispose()))
            },
            add: t=>(e.push(t),
            ()=>{
                let n = e.indexOf(t);
                if (n >= 0)
                    for (let t of e.splice(n, 1))
                        t()
            }
            ),
            dispose() {
                for (let t of e.splice(0))
                    t()
            }
        };
        return t
    }
    let Yi = Symbol("headlessui.useid")
      , Ki = 0;
    function Ji() {
        return pr(Yi, (()=>"" + ++Ki))()
    }
    function ea(e) {
        var t;
        if (null == e || null == e.value)
            return null;
        let n = null != (t = e.value.$el) ? t : e.value;
        return n instanceof Node ? n : null
    }
    function ta(e, t, ...n) {
        if (e in t) {
            let r = t[e];
            return "function" == typeof r ? r(...n) : r
        }
        let r = new Error(`Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(t).map((e=>`"${e}"`)).join(", ")}.`);
        throw Error.captureStackTrace && Error.captureStackTrace(r, ta),
        r
    }
    var na = Object.defineProperty
      , ra = (e,t,n)=>(((e,t,n)=>{
        t in e ? na(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n
        }) : e[t] = n
    }
    )(e, "symbol" != typeof t ? t + "" : t, n),
    n);
    let oa = new class {
        constructor() {
            ra(this, "current", this.detect()),
            ra(this, "currentId", 0)
        }
        set(e) {
            this.current !== e && (this.currentId = 0,
            this.current = e)
        }
        reset() {
            this.set(this.detect())
        }
        nextId() {
            return ++this.currentId
        }
        get isServer() {
            return "server" === this.current
        }
        get isClient() {
            return "client" === this.current
        }
        detect() {
            return "undefined" == typeof window || "undefined" == typeof document ? "server" : "client"
        }
    }
    ;
    function ia(e) {
        if (oa.isServer)
            return null;
        if (e instanceof Node)
            return e.ownerDocument;
        if (null != e && e.hasOwnProperty("value")) {
            let t = ea(e);
            if (t)
                return t.ownerDocument
        }
        return document
    }
    let aa = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e=>`${e}:not([tabindex='-1'])`)).join(",");
    var sa, la, ca, ua = ((ca = ua || {})[ca.First = 1] = "First",
    ca[ca.Previous = 2] = "Previous",
    ca[ca.Next = 4] = "Next",
    ca[ca.Last = 8] = "Last",
    ca[ca.WrapAround = 16] = "WrapAround",
    ca[ca.NoScroll = 32] = "NoScroll",
    ca), da = ((la = da || {})[la.Error = 0] = "Error",
    la[la.Overflow = 1] = "Overflow",
    la[la.Success = 2] = "Success",
    la[la.Underflow = 3] = "Underflow",
    la), pa = ((sa = pa || {})[sa.Previous = -1] = "Previous",
    sa[sa.Next = 1] = "Next",
    sa);
    var ha = (e=>(e[e.Strict = 0] = "Strict",
    e[e.Loose = 1] = "Loose",
    e))(ha || {});
    function fa(e, t=0) {
        var n;
        return e !== (null == (n = ia(e)) ? void 0 : n.body) && ta(t, {
            0: ()=>e.matches(aa),
            1() {
                let t = e;
                for (; null !== t; ) {
                    if (t.matches(aa))
                        return !0;
                    t = t.parentElement
                }
                return !1
            }
        })
    }
    var ma = (e=>(e[e.Keyboard = 0] = "Keyboard",
    e[e.Mouse = 1] = "Mouse",
    e))(ma || {});
    function ga(e) {
        null == e || e.focus({
            preventScroll: !0
        })
    }
    "undefined" != typeof window && "undefined" != typeof document && (document.addEventListener("keydown", (e=>{
        e.metaKey || e.altKey || e.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "")
    }
    ), !0),
    document.addEventListener("click", (e=>{
        1 === e.detail ? delete document.documentElement.dataset.headlessuiFocusVisible : 0 === e.detail && (document.documentElement.dataset.headlessuiFocusVisible = "")
    }
    ), !0));
    let ba = ["textarea", "input"].join(",");
    function Oa(e, t=(e=>e)) {
        return e.slice().sort(((e,n)=>{
            let r = t(e)
              , o = t(n);
            if (null === r || null === o)
                return 0;
            let i = r.compareDocumentPosition(o);
            return i & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : i & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0
        }
        ))
    }
    function va(e, t, {sorted: n=!0, relativeTo: r=null, skipElements: o=[]}={}) {
        var i;
        let a = null != (i = Array.isArray(e) ? e.length > 0 ? e[0].ownerDocument : document : null == e ? void 0 : e.ownerDocument) ? i : document
          , s = Array.isArray(e) ? n ? Oa(e) : e : function(e=document.body) {
            return null == e ? [] : Array.from(e.querySelectorAll(aa)).sort(((e,t)=>Math.sign((e.tabIndex || Number.MAX_SAFE_INTEGER) - (t.tabIndex || Number.MAX_SAFE_INTEGER))))
        }(e);
        o.length > 0 && s.length > 1 && (s = s.filter((e=>!o.includes(e)))),
        r = null != r ? r : a.activeElement;
        let l, c = (()=>{
            if (5 & t)
                return 1;
            if (10 & t)
                return -1;
            throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")
        }
        )(), u = (()=>{
            if (1 & t)
                return 0;
            if (2 & t)
                return Math.max(0, s.indexOf(r)) - 1;
            if (4 & t)
                return Math.max(0, s.indexOf(r)) + 1;
            if (8 & t)
                return s.length - 1;
            throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")
        }
        )(), d = 32 & t ? {
            preventScroll: !0
        } : {}, p = 0, h = s.length;
        do {
            if (p >= h || p + h <= 0)
                return 0;
            let e = u + p;
            if (16 & t)
                e = (e + h) % h;
            else {
                if (e < 0)
                    return 3;
                if (e >= h)
                    return 1
            }
            l = s[e],
            null == l || l.focus(d),
            p += c
        } while (l !== a.activeElement);
        return 6 & t && function(e) {
            var t, n;
            return null != (n = null == (t = null == e ? void 0 : e.matches) ? void 0 : t.call(e, ba)) && n
        }(l) && l.select(),
        2
    }
    function ya() {
        return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0
    }
    function wa() {
        return ya() || /Android/gi.test(window.navigator.userAgent)
    }
    function _a(e, t, n) {
        oa.isServer || Fr((r=>{
            document.addEventListener(e, t, n),
            r((()=>document.removeEventListener(e, t, n)))
        }
        ))
    }
    function ka(e, t, n) {
        oa.isServer || Fr((r=>{
            window.addEventListener(e, t, n),
            r((()=>window.removeEventListener(e, t, n)))
        }
        ))
    }
    function Sa(e, t, n=ei((()=>!0))) {
        function r(r, o) {
            if (!n.value || r.defaultPrevented)
                return;
            let i = o(r);
            if (null === i || !i.getRootNode().contains(i))
                return;
            let a = function e(t) {
                return "function" == typeof t ? e(t()) : Array.isArray(t) || t instanceof Set ? t : [t]
            }(e);
            for (let e of a) {
                if (null === e)
                    continue;
                let t = e instanceof HTMLElement ? e : ea(e);
                if (null != t && t.contains(i) || r.composed && r.composedPath().includes(t))
                    return
            }
            return !fa(i, ha.Loose) && -1 !== i.tabIndex && r.preventDefault(),
            t(r, i)
        }
        let o = Et(null);
        _a("pointerdown", (e=>{
            var t, r;
            n.value && (o.value = (null == (r = null == (t = e.composedPath) ? void 0 : t.call(e)) ? void 0 : r[0]) || e.target)
        }
        ), !0),
        _a("mousedown", (e=>{
            var t, r;
            n.value && (o.value = (null == (r = null == (t = e.composedPath) ? void 0 : t.call(e)) ? void 0 : r[0]) || e.target)
        }
        ), !0),
        _a("click", (e=>{
            wa() || o.value && (r(e, (()=>o.value)),
            o.value = null)
        }
        ), !0),
        _a("touchend", (e=>r(e, (()=>e.target instanceof HTMLElement ? e.target : null))), !0),
        ka("blur", (e=>r(e, (()=>window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null))), !0)
    }
    function Ea(e, t) {
        if (e)
            return e;
        let n = null != t ? t : "button";
        return "string" == typeof n && "button" === n.toLowerCase() ? "button" : void 0
    }
    function xa(e, t) {
        let n = Et(Ea(e.value.type, e.value.as));
        return Sn((()=>{
            n.value = Ea(e.value.type, e.value.as)
        }
        )),
        Fr((()=>{
            var e;
            n.value || ea(t) && ea(t)instanceof HTMLButtonElement && (null == (e = ea(t)) || !e.hasAttribute("type")) && (n.value = "button")
        }
        )),
        n
    }
    function Ta(e) {
        return [e.screenX, e.screenY]
    }
    var Aa, Ca = (e=>(e[e.None = 0] = "None",
    e[e.RenderStrategy = 1] = "RenderStrategy",
    e[e.Static = 2] = "Static",
    e))(Ca || {}), Pa = ((Aa = Pa || {})[Aa.Unmount = 0] = "Unmount",
    Aa[Aa.Hidden = 1] = "Hidden",
    Aa);
    function Da({visible: e=!0, features: t=0, ourProps: n, theirProps: r, ...o}) {
        var i;
        let a = $a(r, n)
          , s = Object.assign(o, {
            props: a
        });
        if (e || 2 & t && a.static)
            return Ra(s);
        if (1 & t) {
            return ta(null == (i = a.unmount) || i ? 0 : 1, {
                0: ()=>null,
                1: ()=>Ra({
                    ...o,
                    props: {
                        ...a,
                        hidden: !0,
                        style: {
                            display: "none"
                        }
                    }
                })
            })
        }
        return Ra(s)
    }
    function Ra({props: e, attrs: t, slots: n, slot: r, name: o}) {
        var i, a;
        let {as: s, ...l} = Ia(e, ["unmount", "static"])
          , c = null == (i = n.default) ? void 0 : i.call(n, r)
          , u = {};
        if (r) {
            let e = !1
              , t = [];
            for (let[n,o] of Object.entries(r))
                "boolean" == typeof o && (e = !0),
                !0 === o && t.push(n);
            e && (u["data-headlessui-state"] = t.join(" "))
        }
        if ("template" === s) {
            if (c = Na(null != c ? c : []),
            Object.keys(l).length > 0 || Object.keys(t).length > 0) {
                let[e,...n] = null != c ? c : [];
                if (!function(e) {
                    return null != e && ("string" == typeof e.type || "object" == typeof e.type || "function" == typeof e.type)
                }(e) || n.length > 0)
                    throw new Error(['Passing props on "template"!', "", `The current component <${o} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(l).concat(Object.keys(t)).map((e=>e.trim())).filter(((e,t,n)=>n.indexOf(e) === t)).sort(((e,t)=>e.localeCompare(t))).map((e=>`  - ${e}`)).join("\n"), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map((e=>`  - ${e}`)).join("\n")].join("\n"));
                let r = $a(null != (a = e.props) ? a : {}, l, u)
                  , i = Ao(e, r, !0);
                for (let t in r)
                    t.startsWith("on") && (i.props || (i.props = {}),
                    i.props[t] = r[t]);
                return i
            }
            return Array.isArray(c) && 1 === c.length ? c[0] : c
        }
        return ti(s, Object.assign({}, l, u), {
            default: ()=>c
        })
    }
    function Na(e) {
        return e.flatMap((e=>e.type === lo ? Na(e.children) : [e]))
    }
    function $a(...e) {
        if (0 === e.length)
            return {};
        if (1 === e.length)
            return e[0];
        let t = {}
          , n = {};
        for (let r of e)
            for (let e in r)
                e.startsWith("on") && "function" == typeof r[e] ? (null != n[e] || (n[e] = []),
                n[e].push(r[e])) : t[e] = r[e];
        if (t.disabled || t["aria-disabled"])
            return Object.assign(t, Object.fromEntries(Object.keys(n).map((e=>[e, void 0]))));
        for (let r in n)
            Object.assign(t, {
                [r](e, ...t) {
                    let o = n[r];
                    for (let n of o) {
                        if (e instanceof Event && e.defaultPrevented)
                            return;
                        n(e, ...t)
                    }
                }
            });
        return t
    }
    function Ia(e, t=[]) {
        let n = Object.assign({}, e);
        for (let r of t)
            r in n && delete n[r];
        return n
    }
    var Ma = (e=>(e[e.None = 1] = "None",
    e[e.Focusable = 2] = "Focusable",
    e[e.Hidden = 4] = "Hidden",
    e))(Ma || {});
    let La = Ln({
        name: "Hidden",
        props: {
            as: {
                type: [Object, String],
                default: "div"
            },
            features: {
                type: Number,
                default: 1
            }
        },
        setup: (e,{slots: t, attrs: n})=>()=>{
            var r;
            let {features: o, ...i} = e;
            return Da({
                ourProps: {
                    "aria-hidden": !(2 & ~o) || (null != (r = i["aria-hidden"]) ? r : void 0),
                    hidden: !(4 & ~o) || void 0,
                    style: {
                        position: "fixed",
                        top: 1,
                        left: 1,
                        width: 1,
                        height: 0,
                        padding: 0,
                        margin: -1,
                        overflow: "hidden",
                        clip: "rect(0, 0, 0, 0)",
                        whiteSpace: "nowrap",
                        borderWidth: "0",
                        ...!(4 & ~o) && !!(2 & ~o) && {
                            display: "none"
                        }
                    }
                },
                theirProps: i,
                slot: {},
                attrs: n,
                slots: t,
                name: "Hidden"
            })
        }
    })
      , Qa = Symbol("Context");
    var Ba = (e=>(e[e.Open = 1] = "Open",
    e[e.Closed = 2] = "Closed",
    e[e.Closing = 4] = "Closing",
    e[e.Opening = 8] = "Opening",
    e))(Ba || {});
    function Ua() {
        return pr(Qa, null)
    }
    function Fa(e) {
        dr(Qa, e)
    }
    var ja, za = ((ja = za || {}).Space = " ",
    ja.Enter = "Enter",
    ja.Escape = "Escape",
    ja.Backspace = "Backspace",
    ja.Delete = "Delete",
    ja.ArrowLeft = "ArrowLeft",
    ja.ArrowUp = "ArrowUp",
    ja.ArrowRight = "ArrowRight",
    ja.ArrowDown = "ArrowDown",
    ja.Home = "Home",
    ja.End = "End",
    ja.PageUp = "PageUp",
    ja.PageDown = "PageDown",
    ja.Tab = "Tab",
    ja);
    let qa = [];
    !function(e) {
        function t() {
            "loading" !== document.readyState && (e(),
            document.removeEventListener("DOMContentLoaded", t))
        }
        "undefined" != typeof window && "undefined" != typeof document && (document.addEventListener("DOMContentLoaded", t),
        t())
    }((()=>{
        function e(e) {
            e.target instanceof HTMLElement && e.target !== document.body && qa[0] !== e.target && (qa.unshift(e.target),
            qa = qa.filter((e=>null != e && e.isConnected)),
            qa.splice(10))
        }
        window.addEventListener("click", e, {
            capture: !0
        }),
        window.addEventListener("mousedown", e, {
            capture: !0
        }),
        window.addEventListener("focus", e, {
            capture: !0
        }),
        document.body.addEventListener("click", e, {
            capture: !0
        }),
        document.body.addEventListener("mousedown", e, {
            capture: !0
        }),
        document.body.addEventListener("focus", e, {
            capture: !0
        })
    }
    ));
    var Ha, Za = ((Ha = Za || {})[Ha.First = 0] = "First",
    Ha[Ha.Previous = 1] = "Previous",
    Ha[Ha.Next = 2] = "Next",
    Ha[Ha.Last = 3] = "Last",
    Ha[Ha.Specific = 4] = "Specific",
    Ha[Ha.Nothing = 5] = "Nothing",
    Ha);
    function Wa(e, t) {
        let n = t.resolveItems();
        if (n.length <= 0)
            return null;
        let r = t.resolveActiveIndex()
          , o = null != r ? r : -1;
        switch (e.focus) {
        case 0:
            for (let e = 0; e < n.length; ++e)
                if (!t.resolveDisabled(n[e], e, n))
                    return e;
            return r;
        case 1:
            -1 === o && (o = n.length);
            for (let e = o - 1; e >= 0; --e)
                if (!t.resolveDisabled(n[e], e, n))
                    return e;
            return r;
        case 2:
            for (let e = o + 1; e < n.length; ++e)
                if (!t.resolveDisabled(n[e], e, n))
                    return e;
            return r;
        case 3:
            for (let e = n.length - 1; e >= 0; --e)
                if (!t.resolveDisabled(n[e], e, n))
                    return e;
            return r;
        case 4:
            for (let r = 0; r < n.length; ++r)
                if (t.resolveId(n[r], r, n) === e.id)
                    return r;
            return r;
        case 5:
            return null;
        default:
            !function(e) {
                throw new Error("Unexpected object: " + e)
            }(e)
        }
    }
    function Xa(e={}, t=null, n=[]) {
        for (let[r,o] of Object.entries(e))
            Ga(n, Va(t, r), o);
        return n
    }
    function Va(e, t) {
        return e ? e + "[" + t + "]" : t
    }
    function Ga(e, t, n) {
        if (Array.isArray(n))
            for (let[r,o] of n.entries())
                Ga(e, Va(t, r.toString()), o);
        else
            n instanceof Date ? e.push([t, n.toISOString()]) : "boolean" == typeof n ? e.push([t, n ? "1" : "0"]) : "string" == typeof n ? e.push([t, n]) : "number" == typeof n ? e.push([t, `${n}`]) : null == n ? e.push([t, ""]) : Xa(n, t, e)
    }
    function Ya(e, t, n, r) {
        oa.isServer || Fr((o=>{
            (e = null != e ? e : window).addEventListener(t, n, r),
            o((()=>e.removeEventListener(t, n, r)))
        }
        ))
    }
    var Ka = (e=>(e[e.Forwards = 0] = "Forwards",
    e[e.Backwards = 1] = "Backwards",
    e))(Ka || {});
    function Ja(e) {
        if (!e)
            return new Set;
        if ("function" == typeof e)
            return new Set(e());
        let t = new Set;
        for (let n of e.value) {
            let e = ea(n);
            e instanceof HTMLElement && t.add(e)
        }
        return t
    }
    var es = (e=>(e[e.None = 1] = "None",
    e[e.InitialFocus = 2] = "InitialFocus",
    e[e.TabLock = 4] = "TabLock",
    e[e.FocusLock = 8] = "FocusLock",
    e[e.RestoreFocus = 16] = "RestoreFocus",
    e[e.All = 30] = "All",
    e))(es || {});
    let ts = Object.assign(Ln({
        name: "FocusTrap",
        props: {
            as: {
                type: [Object, String],
                default: "div"
            },
            initialFocus: {
                type: Object,
                default: null
            },
            features: {
                type: Number,
                default: 30
            },
            containers: {
                type: [Object, Function],
                default: Et(new Set)
            }
        },
        inheritAttrs: !1,
        setup(e, {attrs: t, slots: n, expose: r}) {
            let o = Et(null);
            r({
                el: o,
                $el: o
            });
            let i = ei((()=>ia(o)))
              , a = Et(!1);
            Sn((()=>a.value = !0)),
            An((()=>a.value = !1)),
            function({ownerDocument: e}, t) {
                let n = function(e) {
                    let t = Et(qa.slice());
                    return zr([e], (([e],[n])=>{
                        !0 === n && !1 === e ? Vi((()=>{
                            t.value.splice(0)
                        }
                        )) : !1 === n && !0 === e && (t.value = qa.slice())
                    }
                    ), {
                        flush: "post"
                    }),
                    ()=>{
                        var e;
                        return null != (e = t.value.find((e=>null != e && e.isConnected))) ? e : null
                    }
                }(t);
                Sn((()=>{
                    Fr((()=>{
                        var r, o;
                        t.value || (null == (r = e.value) ? void 0 : r.activeElement) === (null == (o = e.value) ? void 0 : o.body) && ga(n())
                    }
                    ), {
                        flush: "post"
                    })
                }
                )),
                An((()=>{
                    t.value && ga(n())
                }
                ))
            }({
                ownerDocument: i
            }, ei((()=>a.value && Boolean(16 & e.features))));
            let s = function({ownerDocument: e, container: t, initialFocus: n}, r) {
                let o = Et(null)
                  , i = Et(!1);
                return Sn((()=>i.value = !0)),
                An((()=>i.value = !1)),
                Sn((()=>{
                    zr([t, n, r], ((a,s)=>{
                        if (a.every(((e,t)=>(null == s ? void 0 : s[t]) === e)) || !r.value)
                            return;
                        let l = ea(t);
                        l && Vi((()=>{
                            var t, r;
                            if (!i.value)
                                return;
                            let a = ea(n)
                              , s = null == (t = e.value) ? void 0 : t.activeElement;
                            if (a) {
                                if (a === s)
                                    return void (o.value = s)
                            } else if (l.contains(s))
                                return void (o.value = s);
                            a ? ga(a) : va(l, ua.First | ua.NoScroll) === da.Error && console.warn("There are no focusable elements inside the <FocusTrap />"),
                            o.value = null == (r = e.value) ? void 0 : r.activeElement
                        }
                        ))
                    }
                    ), {
                        immediate: !0,
                        flush: "post"
                    })
                }
                )),
                o
            }({
                ownerDocument: i,
                container: o,
                initialFocus: ei((()=>e.initialFocus))
            }, ei((()=>a.value && Boolean(2 & e.features))));
            !function({ownerDocument: e, container: t, containers: n, previousActiveElement: r}, o) {
                var i;
                Ya(null == (i = e.value) ? void 0 : i.defaultView, "focus", (e=>{
                    if (!o.value)
                        return;
                    let i = Ja(n);
                    ea(t)instanceof HTMLElement && i.add(ea(t));
                    let a = r.value;
                    if (!a)
                        return;
                    let s = e.target;
                    s && s instanceof HTMLElement ? ns(i, s) ? (r.value = s,
                    ga(s)) : (e.preventDefault(),
                    e.stopPropagation(),
                    ga(a)) : ga(r.value)
                }
                ), !0)
            }({
                ownerDocument: i,
                container: o,
                containers: e.containers,
                previousActiveElement: s
            }, ei((()=>a.value && Boolean(8 & e.features))));
            let l = function() {
                let e = Et(0);
                return ka("keydown", (t=>{
                    "Tab" === t.key && (e.value = t.shiftKey ? 1 : 0)
                }
                )),
                e
            }();
            function c(e) {
                let t = ea(o);
                t && ta(l.value, {
                    [Ka.Forwards]: ()=>{
                        va(t, ua.First, {
                            skipElements: [e.relatedTarget]
                        })
                    }
                    ,
                    [Ka.Backwards]: ()=>{
                        va(t, ua.Last, {
                            skipElements: [e.relatedTarget]
                        })
                    }
                })
            }
            let u = Et(!1);
            function d(e) {
                "Tab" === e.key && (u.value = !0,
                requestAnimationFrame((()=>{
                    u.value = !1
                }
                )))
            }
            function p(t) {
                if (!a.value)
                    return;
                let n = Ja(e.containers);
                ea(o)instanceof HTMLElement && n.add(ea(o));
                let r = t.relatedTarget;
                r instanceof HTMLElement && "true" !== r.dataset.headlessuiFocusGuard && (ns(n, r) || (u.value ? va(ea(o), ta(l.value, {
                    [Ka.Forwards]: ()=>ua.Next,
                    [Ka.Backwards]: ()=>ua.Previous
                }) | ua.WrapAround, {
                    relativeTo: t.target
                }) : t.target instanceof HTMLElement && ga(t.target)))
            }
            return ()=>{
                let r = {
                    ref: o,
                    onKeydown: d,
                    onFocusout: p
                }
                  , {features: i, initialFocus: a, containers: s, ...l} = e;
                return ti(lo, [Boolean(4 & i) && ti(La, {
                    as: "button",
                    type: "button",
                    "data-headlessui-focus-guard": !0,
                    onFocus: c,
                    features: Ma.Focusable
                }), Da({
                    ourProps: r,
                    theirProps: {
                        ...t,
                        ...l
                    },
                    slot: {},
                    attrs: t,
                    slots: n,
                    name: "FocusTrap"
                }), Boolean(4 & i) && ti(La, {
                    as: "button",
                    type: "button",
                    "data-headlessui-focus-guard": !0,
                    onFocus: c,
                    features: Ma.Focusable
                })])
            }
        }
    }), {
        features: es
    });
    function ns(e, t) {
        for (let n of e)
            if (n.contains(t))
                return !0;
        return !1
    }
    function rs() {
        let e;
        return {
            before({doc: t}) {
                var n;
                let r = t.documentElement;
                e = (null != (n = t.defaultView) ? n : window).innerWidth - r.clientWidth
            },
            after({doc: t, d: n}) {
                let r = t.documentElement
                  , o = r.clientWidth - r.offsetWidth
                  , i = e - o;
                n.style(r, "paddingRight", `${i}px`)
            }
        }
    }
    function os(e) {
        let t = {};
        for (let n of e)
            Object.assign(t, n(t));
        return t
    }
    let is = function(e, t) {
        let n = e()
          , r = new Set;
        return {
            getSnapshot: ()=>n,
            subscribe: e=>(r.add(e),
            ()=>r.delete(e)),
            dispatch(e, ...o) {
                let i = t[e].call(n, ...o);
                i && (n = i,
                r.forEach((e=>e())))
            }
        }
    }((()=>new Map), {
        PUSH(e, t) {
            var n;
            let r = null != (n = this.get(e)) ? n : {
                doc: e,
                count: 0,
                d: Gi(),
                meta: new Set
            };
            return r.count++,
            r.meta.add(t),
            this.set(e, r),
            this
        },
        POP(e, t) {
            let n = this.get(e);
            return n && (n.count--,
            n.meta.delete(t)),
            this
        },
        SCROLL_PREVENT({doc: e, d: t, meta: n}) {
            let r = {
                doc: e,
                d: t,
                meta: os(n)
            }
              , o = [ya() ? {
                before({doc: e, d: t, meta: n}) {
                    function r(e) {
                        return n.containers.flatMap((e=>e())).some((t=>t.contains(e)))
                    }
                    t.microTask((()=>{
                        var n;
                        if ("auto" !== window.getComputedStyle(e.documentElement).scrollBehavior) {
                            let n = Gi();
                            n.style(e.documentElement, "scrollBehavior", "auto"),
                            t.add((()=>t.microTask((()=>n.dispose()))))
                        }
                        let o = null != (n = window.scrollY) ? n : window.pageYOffset
                          , i = null;
                        t.addEventListener(e, "click", (t=>{
                            if (t.target instanceof HTMLElement)
                                try {
                                    let n = t.target.closest("a");
                                    if (!n)
                                        return;
                                    let {hash: o} = new URL(n.href)
                                      , a = e.querySelector(o);
                                    a && !r(a) && (i = a)
                                } catch {}
                        }
                        ), !0),
                        t.addEventListener(e, "touchstart", (e=>{
                            if (e.target instanceof HTMLElement)
                                if (r(e.target)) {
                                    let n = e.target;
                                    for (; n.parentElement && r(n.parentElement); )
                                        n = n.parentElement;
                                    t.style(n, "overscrollBehavior", "contain")
                                } else
                                    t.style(e.target, "touchAction", "none")
                        }
                        )),
                        t.addEventListener(e, "touchmove", (e=>{
                            if (e.target instanceof HTMLElement) {
                                if ("INPUT" === e.target.tagName)
                                    return;
                                if (r(e.target)) {
                                    let t = e.target;
                                    for (; t.parentElement && "" !== t.dataset.headlessuiPortal && !(t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth); )
                                        t = t.parentElement;
                                    "" === t.dataset.headlessuiPortal && e.preventDefault()
                                } else
                                    e.preventDefault()
                            }
                        }
                        ), {
                            passive: !1
                        }),
                        t.add((()=>{
                            var e;
                            let t = null != (e = window.scrollY) ? e : window.pageYOffset;
                            o !== t && window.scrollTo(0, o),
                            i && i.isConnected && (i.scrollIntoView({
                                block: "nearest"
                            }),
                            i = null)
                        }
                        ))
                    }
                    ))
                }
            } : {}, rs(), {
                before({doc: e, d: t}) {
                    t.style(e.documentElement, "overflow", "hidden")
                }
            }];
            o.forEach((({before: e})=>null == e ? void 0 : e(r))),
            o.forEach((({after: e})=>null == e ? void 0 : e(r)))
        },
        SCROLL_ALLOW({d: e}) {
            e.dispose()
        },
        TEARDOWN({doc: e}) {
            this.delete(e)
        }
    });
    function as(e, t, n) {
        let r = function(e) {
            let t = xt(e.getSnapshot());
            return An(e.subscribe((()=>{
                t.value = e.getSnapshot()
            }
            ))),
            t
        }(is)
          , o = ei((()=>{
            let t = e.value ? r.value.get(e.value) : void 0;
            return !!t && t.count > 0
        }
        ));
        return zr([e, t], (([e,t],[r],o)=>{
            if (!e || !t)
                return;
            is.dispatch("PUSH", e, n);
            let i = !1;
            o((()=>{
                i || (is.dispatch("POP", null != r ? r : e, n),
                i = !0)
            }
            ))
        }
        ), {
            immediate: !0
        }),
        o
    }
    is.subscribe((()=>{
        let e = is.getSnapshot()
          , t = new Map;
        for (let[n] of e)
            t.set(n, n.documentElement.style.overflow);
        for (let n of e.values()) {
            let e = "hidden" === t.get(n.doc)
              , r = 0 !== n.count;
            (r && !e || !r && e) && is.dispatch(n.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", n),
            0 === n.count && is.dispatch("TEARDOWN", n)
        }
    }
    ));
    let ss = new Map
      , ls = new Map;
    function cs(e, t=Et(!0)) {
        Fr((n=>{
            var r;
            if (!t.value)
                return;
            let o = ea(e);
            if (!o)
                return;
            n((function() {
                var e;
                if (!o)
                    return;
                let t = null != (e = ls.get(o)) ? e : 1;
                if (1 === t ? ls.delete(o) : ls.set(o, t - 1),
                1 !== t)
                    return;
                let n = ss.get(o);
                n && (null === n["aria-hidden"] ? o.removeAttribute("aria-hidden") : o.setAttribute("aria-hidden", n["aria-hidden"]),
                o.inert = n.inert,
                ss.delete(o))
            }
            ));
            let i = null != (r = ls.get(o)) ? r : 0;
            ls.set(o, i + 1),
            0 === i && (ss.set(o, {
                "aria-hidden": o.getAttribute("aria-hidden"),
                inert: o.inert
            }),
            o.setAttribute("aria-hidden", "true"),
            o.inert = !0)
        }
        ))
    }
    let us = Symbol("ForcePortalRootContext");
    let ds = Ln({
        name: "ForcePortalRoot",
        props: {
            as: {
                type: [Object, String],
                default: "template"
            },
            force: {
                type: Boolean,
                default: !1
            }
        },
        setup: (e,{slots: t, attrs: n})=>(dr(us, e.force),
        ()=>{
            let {force: r, ...o} = e;
            return Da({
                theirProps: o,
                ourProps: {},
                slot: {},
                slots: t,
                attrs: n,
                name: "ForcePortalRoot"
            })
        }
        )
    })
      , ps = Symbol("StackContext");
    var hs = (e=>(e[e.Add = 0] = "Add",
    e[e.Remove = 1] = "Remove",
    e))(hs || {});
    function fs({type: e, enabled: t, element: n, onUpdate: r}) {
        let o = pr(ps, (()=>{}
        ));
        function i(...e) {
            null == r || r(...e),
            o(...e)
        }
        Sn((()=>{
            zr(t, ((t,r)=>{
                t ? i(0, e, n) : !0 === r && i(1, e, n)
            }
            ), {
                immediate: !0,
                flush: "sync"
            })
        }
        )),
        An((()=>{
            t.value && i(1, e, n)
        }
        )),
        dr(ps, i)
    }
    let ms = Symbol("DescriptionContext");
    let gs = Ln({
        name: "Description",
        props: {
            as: {
                type: [Object, String],
                default: "p"
            },
            id: {
                type: String,
                default: null
            }
        },
        setup(e, {attrs: t, slots: n}) {
            var r;
            let o = null != (r = e.id) ? r : `headlessui-description-${Ji()}`
              , i = function() {
                let e = pr(ms, null);
                if (null === e)
                    throw new Error("Missing parent");
                return e
            }();
            return Sn((()=>An(i.register(o)))),
            ()=>{
                let {name: r="Description", slot: a=Et({}), props: s={}} = i
                  , {...l} = e;
                return Da({
                    ourProps: {
                        ...Object.entries(s).reduce(((e,[t,n])=>Object.assign(e, {
                            [t]: Ct(n)
                        })), {}),
                        id: o
                    },
                    theirProps: l,
                    slot: a.value,
                    attrs: t,
                    slots: n,
                    name: r
                })
            }
        }
    });
    const bs = new WeakMap;
    function Os(e, t) {
        let n = t(function(e) {
            var t;
            return null != (t = bs.get(e)) ? t : 0
        }(e));
        return n <= 0 ? bs.delete(e) : bs.set(e, n),
        n
    }
    let vs = Ln({
        name: "Portal",
        props: {
            as: {
                type: [Object, String],
                default: "div"
            }
        },
        setup(e, {slots: t, attrs: n}) {
            let r = Et(null)
              , o = ei((()=>ia(r)))
              , i = pr(us, !1)
              , a = pr(ws, null)
              , s = Et(!0 === i || null == a ? function(e) {
                let t = ia(e);
                if (!t) {
                    if (null === e)
                        return null;
                    throw new Error(`[Headless UI]: Cannot find ownerDocument for contextElement: ${e}`)
                }
                let n = t.getElementById("headlessui-portal-root");
                if (n)
                    return n;
                let r = t.createElement("div");
                return r.setAttribute("id", "headlessui-portal-root"),
                t.body.appendChild(r)
            }(r.value) : a.resolveTarget());
            s.value && Os(s.value, (e=>e + 1));
            let l = Et(!1);
            Sn((()=>{
                l.value = !0
            }
            )),
            Fr((()=>{
                i || null != a && (s.value = a.resolveTarget())
            }
            ));
            let c = pr(ys, null)
              , u = !1
              , d = Uo();
            return zr(r, (()=>{
                if (u || !c)
                    return;
                let e = ea(r);
                e && (An(c.register(e), d),
                u = !0)
            }
            )),
            An((()=>{
                var e, t;
                let n = null == (e = o.value) ? void 0 : e.getElementById("headlessui-portal-root");
                !n || s.value !== n || Os(s.value, (e=>e - 1)) || s.value.children.length > 0 || null == (t = s.value.parentElement) || t.removeChild(s.value)
            }
            )),
            ()=>{
                if (!l.value || null === s.value)
                    return null;
                let o = {
                    ref: r,
                    "data-headlessui-portal": ""
                };
                return ti(ao, {
                    to: s.value
                }, Da({
                    ourProps: o,
                    theirProps: e,
                    slot: {},
                    attrs: n,
                    slots: t,
                    name: "Portal"
                }))
            }
        }
    })
      , ys = Symbol("PortalParentContext");
    let ws = Symbol("PortalGroupContext")
      , _s = Ln({
        name: "PortalGroup",
        props: {
            as: {
                type: [Object, String],
                default: "template"
            },
            target: {
                type: Object,
                default: null
            }
        },
        setup(e, {attrs: t, slots: n}) {
            let r = ut({
                resolveTarget: ()=>e.target
            });
            return dr(ws, r),
            ()=>{
                let {target: r, ...o} = e;
                return Da({
                    theirProps: o,
                    ourProps: {},
                    slot: {},
                    attrs: t,
                    slots: n,
                    name: "PortalGroup"
                })
            }
        }
    });
    var ks, Ss = ((ks = Ss || {})[ks.Open = 0] = "Open",
    ks[ks.Closed = 1] = "Closed",
    ks);
    let Es = Symbol("DialogContext");
    function xs(e) {
        let t = pr(Es, null);
        if (null === t) {
            let t = new Error(`<${e} /> is missing a parent <Dialog /> component.`);
            throw Error.captureStackTrace && Error.captureStackTrace(t, xs),
            t
        }
        return t
    }
    let Ts = "DC8F892D-2EBD-447C-A4C8-A03058436FF4"
      , As = Ln({
        name: "Dialog",
        inheritAttrs: !1,
        props: {
            as: {
                type: [Object, String],
                default: "div"
            },
            static: {
                type: Boolean,
                default: !1
            },
            unmount: {
                type: Boolean,
                default: !0
            },
            open: {
                type: [Boolean, String],
                default: Ts
            },
            initialFocus: {
                type: Object,
                default: null
            },
            id: {
                type: String,
                default: null
            },
            role: {
                type: String,
                default: "dialog"
            }
        },
        emits: {
            close: e=>!0
        },
        setup(e, {emit: t, attrs: n, slots: r, expose: o}) {
            var i, a;
            let s = null != (i = e.id) ? i : `headlessui-dialog-${Ji()}`
              , l = Et(!1);
            Sn((()=>{
                l.value = !0
            }
            ));
            let c = !1
              , u = ei((()=>"dialog" === e.role || "alertdialog" === e.role ? e.role : (c || (c = !0,
            console.warn(`Invalid role [${u}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)),
            "dialog")))
              , d = Et(0)
              , p = Ua()
              , h = ei((()=>e.open === Ts && null !== p ? (p.value & Ba.Open) === Ba.Open : e.open))
              , f = Et(null)
              , m = ei((()=>ia(f)));
            if (o({
                el: f,
                $el: f
            }),
            e.open === Ts && null === p)
                throw new Error("You forgot to provide an `open` prop to the `Dialog`.");
            if ("boolean" != typeof h.value)
                throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${h.value === Ts ? void 0 : e.open}`);
            let g = ei((()=>l.value && h.value ? 0 : 1))
              , b = ei((()=>0 === g.value))
              , O = ei((()=>d.value > 1))
              , v = null !== pr(Es, null)
              , [y,w] = function() {
                let e = pr(ys, null)
                  , t = Et([]);
                function n(n) {
                    let r = t.value.indexOf(n);
                    -1 !== r && t.value.splice(r, 1),
                    e && e.unregister(n)
                }
                let r = {
                    register: function(r) {
                        return t.value.push(r),
                        e && e.register(r),
                        ()=>n(r)
                    },
                    unregister: n,
                    portals: t
                };
                return [t, Ln({
                    name: "PortalWrapper",
                    setup: (e,{slots: t})=>(dr(ys, r),
                    ()=>{
                        var e;
                        return null == (e = t.default) ? void 0 : e.call(t)
                    }
                    )
                })]
            }()
              , {resolveContainers: _, mainTreeNodeRef: k, MainTreeNode: S} = function({defaultContainers: e=[], portals: t, mainTreeNodeRef: n}={}) {
                let r = Et(null)
                  , o = ia(r);
                function i() {
                    var n, i, a;
                    let s = [];
                    for (let t of e)
                        null !== t && (t instanceof HTMLElement ? s.push(t) : "value"in t && t.value instanceof HTMLElement && s.push(t.value));
                    if (null != t && t.value)
                        for (let e of t.value)
                            s.push(e);
                    for (let e of null != (n = null == o ? void 0 : o.querySelectorAll("html > *, body > *")) ? n : [])
                        e !== document.body && e !== document.head && e instanceof HTMLElement && "headlessui-portal-root" !== e.id && (e.contains(ea(r)) || e.contains(null == (a = null == (i = ea(r)) ? void 0 : i.getRootNode()) ? void 0 : a.host) || s.some((t=>e.contains(t))) || s.push(e));
                    return s
                }
                return {
                    resolveContainers: i,
                    contains: e=>i().some((t=>t.contains(e))),
                    mainTreeNodeRef: r,
                    MainTreeNode: ()=>null != n ? null : ti(La, {
                        features: Ma.Hidden,
                        ref: r
                    })
                }
            }({
                portals: y,
                defaultContainers: [ei((()=>{
                    var e;
                    return null != (e = N.panelRef.value) ? e : f.value
                }
                ))]
            })
              , E = ei((()=>O.value ? "parent" : "leaf"))
              , x = ei((()=>null !== p && (p.value & Ba.Closing) === Ba.Closing))
              , T = ei((()=>!v && !x.value && b.value))
              , A = ei((()=>{
                var e, t, n;
                return null != (n = Array.from(null != (t = null == (e = m.value) ? void 0 : e.querySelectorAll("body > *")) ? t : []).find((e=>"headlessui-portal-root" !== e.id && (e.contains(ea(k)) && e instanceof HTMLElement)))) ? n : null
            }
            ));
            cs(A, T);
            let C = ei((()=>!!O.value || b.value))
              , P = ei((()=>{
                var e, t, n;
                return null != (n = Array.from(null != (t = null == (e = m.value) ? void 0 : e.querySelectorAll("[data-headlessui-portal]")) ? t : []).find((e=>e.contains(ea(k)) && e instanceof HTMLElement))) ? n : null
            }
            ));
            cs(P, C),
            fs({
                type: "Dialog",
                enabled: ei((()=>0 === g.value)),
                element: f,
                onUpdate: (e,t)=>{
                    if ("Dialog" === t)
                        return ta(e, {
                            [hs.Add]: ()=>d.value += 1,
                            [hs.Remove]: ()=>d.value -= 1
                        })
                }
            });
            let D = function({slot: e=Et({}), name: t="Description", props: n={}}={}) {
                let r = Et([]);
                return dr(ms, {
                    register: function(e) {
                        return r.value.push(e),
                        ()=>{
                            let t = r.value.indexOf(e);
                            -1 !== t && r.value.splice(t, 1)
                        }
                    },
                    slot: e,
                    name: t,
                    props: n
                }),
                ei((()=>r.value.length > 0 ? r.value.join(" ") : void 0))
            }({
                name: "DialogDescription",
                slot: ei((()=>({
                    open: h.value
                })))
            })
              , R = Et(null)
              , N = {
                titleId: R,
                panelRef: Et(null),
                dialogState: g,
                setTitleId(e) {
                    R.value !== e && (R.value = e)
                },
                close() {
                    t("close", !1)
                }
            };
            dr(Es, N);
            let $ = ei((()=>!(!b.value || O.value)));
            Sa(_, ((e,t)=>{
                e.preventDefault(),
                N.close(),
                Xt((()=>null == t ? void 0 : t.focus()))
            }
            ), $);
            let I = ei((()=>!(O.value || 0 !== g.value)));
            Ya(null == (a = m.value) ? void 0 : a.defaultView, "keydown", (e=>{
                I.value && (e.defaultPrevented || e.key === za.Escape && (e.preventDefault(),
                e.stopPropagation(),
                N.close()))
            }
            ));
            let M = ei((()=>!(x.value || 0 !== g.value || v)));
            return as(m, M, (e=>{
                var t;
                return {
                    containers: [...null != (t = e.containers) ? t : [], _]
                }
            }
            )),
            Fr((e=>{
                if (0 !== g.value)
                    return;
                let t = ea(f);
                if (!t)
                    return;
                let n = new ResizeObserver((e=>{
                    for (let t of e) {
                        let e = t.target.getBoundingClientRect();
                        0 === e.x && 0 === e.y && 0 === e.width && 0 === e.height && N.close()
                    }
                }
                ));
                n.observe(t),
                e((()=>n.disconnect()))
            }
            )),
            ()=>{
                let {open: t, initialFocus: o, ...i} = e
                  , a = {
                    ...n,
                    ref: f,
                    id: s,
                    role: u.value,
                    "aria-modal": 0 === g.value || void 0,
                    "aria-labelledby": R.value,
                    "aria-describedby": D.value
                }
                  , l = {
                    open: 0 === g.value
                };
                return ti(ds, {
                    force: !0
                }, (()=>[ti(vs, (()=>ti(_s, {
                    target: f.value
                }, (()=>ti(ds, {
                    force: !1
                }, (()=>ti(ts, {
                    initialFocus: o,
                    containers: _,
                    features: b.value ? ta(E.value, {
                        parent: ts.features.RestoreFocus,
                        leaf: ts.features.All & ~ts.features.FocusLock
                    }) : ts.features.None
                }, (()=>ti(w, {}, (()=>Da({
                    ourProps: a,
                    theirProps: {
                        ...i,
                        ...n
                    },
                    slot: l,
                    attrs: n,
                    slots: r,
                    visible: 0 === g.value,
                    features: Ca.RenderStrategy | Ca.Static,
                    name: "Dialog"
                }))))))))))), ti(S)]))
            }
        }
    })
      , Cs = Ln({
        name: "DialogPanel",
        props: {
            as: {
                type: [Object, String],
                default: "div"
            },
            id: {
                type: String,
                default: null
            }
        },
        setup(e, {attrs: t, slots: n, expose: r}) {
            var o;
            let i = null != (o = e.id) ? o : `headlessui-dialog-panel-${Ji()}`
              , a = xs("DialogPanel");
            function s(e) {
                e.stopPropagation()
            }
            return r({
                el: a.panelRef,
                $el: a.panelRef
            }),
            ()=>{
                let {...r} = e;
                return Da({
                    ourProps: {
                        id: i,
                        ref: a.panelRef,
                        onClick: s
                    },
                    theirProps: r,
                    slot: {
                        open: 0 === a.dialogState.value
                    },
                    attrs: t,
                    slots: n,
                    name: "DialogPanel"
                })
            }
        }
    })
      , Ps = Ln({
        name: "DialogTitle",
        props: {
            as: {
                type: [Object, String],
                default: "h2"
            },
            id: {
                type: String,
                default: null
            }
        },
        setup(e, {attrs: t, slots: n}) {
            var r;
            let o = null != (r = e.id) ? r : `headlessui-dialog-title-${Ji()}`
              , i = xs("DialogTitle");
            return Sn((()=>{
                i.setTitleId(o),
                An((()=>i.setTitleId(null)))
            }
            )),
            ()=>{
                let {...r} = e;
                return Da({
                    ourProps: {
                        id: o
                    },
                    theirProps: r,
                    slot: {
                        open: 0 === i.dialogState.value
                    },
                    attrs: t,
                    slots: n,
                    name: "DialogTitle"
                })
            }
        }
    })
      , Ds = gs;
    var Rs = (e=>(e[e.Open = 0] = "Open",
    e[e.Closed = 1] = "Closed",
    e))(Rs || {});
    let Ns = Symbol("DisclosureContext");
    function $s(e) {
        let t = pr(Ns, null);
        if (null === t) {
            let t = new Error(`<${e} /> is missing a parent <Disclosure /> component.`);
            throw Error.captureStackTrace && Error.captureStackTrace(t, $s),
            t
        }
        return t
    }
    let Is = Symbol("DisclosurePanelContext");
    let Ms = Ln({
        name: "Disclosure",
        props: {
            as: {
                type: [Object, String],
                default: "template"
            },
            defaultOpen: {
                type: [Boolean],
                default: !1
            }
        },
        setup(e, {slots: t, attrs: n}) {
            let r = Et(e.defaultOpen ? 0 : 1)
              , o = Et(null)
              , i = Et(null)
              , a = {
                buttonId: Et(`headlessui-disclosure-button-${Ji()}`),
                panelId: Et(`headlessui-disclosure-panel-${Ji()}`),
                disclosureState: r,
                panel: o,
                button: i,
                toggleDisclosure() {
                    r.value = ta(r.value, {
                        0: 1,
                        1: 0
                    })
                },
                closeDisclosure() {
                    1 !== r.value && (r.value = 1)
                },
                close(e) {
                    a.closeDisclosure();
                    let t = e ? e instanceof HTMLElement ? e : e.value instanceof HTMLElement ? ea(e) : ea(a.button) : ea(a.button);
                    null == t || t.focus()
                }
            };
            return dr(Ns, a),
            Fa(ei((()=>ta(r.value, {
                0: Ba.Open,
                1: Ba.Closed
            })))),
            ()=>{
                let {defaultOpen: o, ...i} = e;
                return Da({
                    theirProps: i,
                    ourProps: {},
                    slot: {
                        open: 0 === r.value,
                        close: a.close
                    },
                    slots: t,
                    attrs: n,
                    name: "Disclosure"
                })
            }
        }
    })
      , Ls = Ln({
        name: "DisclosureButton",
        props: {
            as: {
                type: [Object, String],
                default: "button"
            },
            disabled: {
                type: [Boolean],
                default: !1
            },
            id: {
                type: String,
                default: null
            }
        },
        setup(e, {attrs: t, slots: n, expose: r}) {
            let o = $s("DisclosureButton")
              , i = pr(Is, null)
              , a = ei((()=>null !== i && i.value === o.panelId.value));
            Sn((()=>{
                a.value || null !== e.id && (o.buttonId.value = e.id)
            }
            )),
            An((()=>{
                a.value || (o.buttonId.value = null)
            }
            ));
            let s = Et(null);
            r({
                el: s,
                $el: s
            }),
            a.value || Fr((()=>{
                o.button.value = s.value
            }
            ));
            let l = xa(ei((()=>({
                as: e.as,
                type: t.type
            }))), s);
            function c() {
                var t;
                e.disabled || (a.value ? (o.toggleDisclosure(),
                null == (t = ea(o.button)) || t.focus()) : o.toggleDisclosure())
            }
            function u(t) {
                var n;
                if (!e.disabled)
                    if (a.value)
                        switch (t.key) {
                        case za.Space:
                        case za.Enter:
                            t.preventDefault(),
                            t.stopPropagation(),
                            o.toggleDisclosure(),
                            null == (n = ea(o.button)) || n.focus()
                        }
                    else
                        switch (t.key) {
                        case za.Space:
                        case za.Enter:
                            t.preventDefault(),
                            t.stopPropagation(),
                            o.toggleDisclosure()
                        }
            }
            function d(e) {
                if (e.key === za.Space)
                    e.preventDefault()
            }
            return ()=>{
                var r;
                let i = {
                    open: 0 === o.disclosureState.value
                }
                  , {id: p, ...h} = e;
                return Da({
                    ourProps: a.value ? {
                        ref: s,
                        type: l.value,
                        onClick: c,
                        onKeydown: u
                    } : {
                        id: null != (r = o.buttonId.value) ? r : p,
                        ref: s,
                        type: l.value,
                        "aria-expanded": 0 === o.disclosureState.value,
                        "aria-controls": 0 === o.disclosureState.value || ea(o.panel) ? o.panelId.value : void 0,
                        disabled: !!e.disabled || void 0,
                        onClick: c,
                        onKeydown: u,
                        onKeyup: d
                    },
                    theirProps: h,
                    slot: i,
                    attrs: t,
                    slots: n,
                    name: "DisclosureButton"
                })
            }
        }
    })
      , Qs = Ln({
        name: "DisclosurePanel",
        props: {
            as: {
                type: [Object, String],
                default: "div"
            },
            static: {
                type: Boolean,
                default: !1
            },
            unmount: {
                type: Boolean,
                default: !0
            },
            id: {
                type: String,
                default: null
            }
        },
        setup(e, {attrs: t, slots: n, expose: r}) {
            let o = $s("DisclosurePanel");
            Sn((()=>{
                null !== e.id && (o.panelId.value = e.id)
            }
            )),
            An((()=>{
                o.panelId.value = null
            }
            )),
            r({
                el: o.panel,
                $el: o.panel
            }),
            dr(Is, o.panelId);
            let i = Ua()
              , a = ei((()=>null !== i ? (i.value & Ba.Open) === Ba.Open : 0 === o.disclosureState.value));
            return ()=>{
                var r;
                let i = {
                    open: 0 === o.disclosureState.value,
                    close: o.close
                }
                  , {id: s, ...l} = e;
                return Da({
                    ourProps: {
                        id: null != (r = o.panelId.value) ? r : s,
                        ref: o.panel
                    },
                    theirProps: l,
                    slot: i,
                    attrs: t,
                    slots: n,
                    features: Ca.RenderStrategy | Ca.Static,
                    visible: a.value,
                    name: "DisclosurePanel"
                })
            }
        }
    })
      , Bs = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
    function Us(e) {
        var t, n;
        let r = null != (t = e.innerText) ? t : ""
          , o = e.cloneNode(!0);
        if (!(o instanceof HTMLElement))
            return r;
        let i = !1;
        for (let s of o.querySelectorAll('[hidden],[aria-hidden],[role="img"]'))
            s.remove(),
            i = !0;
        let a = i ? null != (n = o.innerText) ? n : "" : r;
        return Bs.test(a) && (a = a.replace(Bs, "")),
        a
    }
    function Fs(e) {
        let t = Et("")
          , n = Et("");
        return ()=>{
            let r = ea(e);
            if (!r)
                return "";
            let o = r.innerText;
            if (t.value === o)
                return n.value;
            let i = function(e) {
                let t = e.getAttribute("aria-label");
                if ("string" == typeof t)
                    return t.trim();
                let n = e.getAttribute("aria-labelledby");
                if (n) {
                    let e = n.split(" ").map((e=>{
                        let t = document.getElementById(e);
                        if (t) {
                            let e = t.getAttribute("aria-label");
                            return "string" == typeof e ? e.trim() : Us(t).trim()
                        }
                        return null
                    }
                    )).filter(Boolean);
                    if (e.length > 0)
                        return e.join(", ")
                }
                return Us(e).trim()
            }(r).trim().toLowerCase();
            return t.value = o,
            n.value = i,
            i
        }
    }
    function js(e, t) {
        return e === t
    }
    var zs = (e=>(e[e.Open = 0] = "Open",
    e[e.Closed = 1] = "Closed",
    e))(zs || {})
      , qs = (e=>(e[e.Single = 0] = "Single",
    e[e.Multi = 1] = "Multi",
    e))(qs || {})
      , Hs = (e=>(e[e.Pointer = 0] = "Pointer",
    e[e.Other = 1] = "Other",
    e))(Hs || {});
    let Zs = Symbol("ListboxContext");
    function Ws(e) {
        let t = pr(Zs, null);
        if (null === t) {
            let t = new Error(`<${e} /> is missing a parent <Listbox /> component.`);
            throw Error.captureStackTrace && Error.captureStackTrace(t, Ws),
            t
        }
        return t
    }
    let Xs = Ln({
        name: "Listbox",
        emits: {
            "update:modelValue": e=>!0
        },
        props: {
            as: {
                type: [Object, String],
                default: "template"
            },
            disabled: {
                type: [Boolean],
                default: !1
            },
            by: {
                type: [String, Function],
                default: ()=>js
            },
            horizontal: {
                type: [Boolean],
                default: !1
            },
            modelValue: {
                type: [Object, String, Number, Boolean],
                default: void 0
            },
            defaultValue: {
                type: [Object, String, Number, Boolean],
                default: void 0
            },
            form: {
                type: String,
                optional: !0
            },
            name: {
                type: String,
                optional: !0
            },
            multiple: {
                type: [Boolean],
                default: !1
            }
        },
        inheritAttrs: !1,
        setup(e, {slots: t, attrs: n, emit: r}) {
            let o = Et(1)
              , i = Et(null)
              , a = Et(null)
              , s = Et(null)
              , l = Et([])
              , c = Et("")
              , u = Et(null)
              , d = Et(1);
            function p(e=(e=>e)) {
                let t = null !== u.value ? l.value[u.value] : null
                  , n = Oa(e(l.value.slice()), (e=>ea(e.dataRef.domRef)))
                  , r = t ? n.indexOf(t) : null;
                return -1 === r && (r = null),
                {
                    options: n,
                    activeOptionIndex: r
                }
            }
            let h = ei((()=>e.multiple ? 1 : 0))
              , [f,m] = function(e, t, n) {
                let r = Et(null == n ? void 0 : n.value)
                  , o = ei((()=>void 0 !== e.value));
                return [ei((()=>o.value ? e.value : r.value)), function(e) {
                    return o.value || (r.value = e),
                    null == t ? void 0 : t(e)
                }
                ]
            }(ei((()=>e.modelValue)), (e=>r("update:modelValue", e)), ei((()=>e.defaultValue)))
              , g = ei((()=>void 0 === f.value ? ta(h.value, {
                1: [],
                0: void 0
            }) : f.value))
              , b = {
                listboxState: o,
                value: g,
                mode: h,
                compare(t, n) {
                    if ("string" == typeof e.by) {
                        let r = e.by;
                        return (null == t ? void 0 : t[r]) === (null == n ? void 0 : n[r])
                    }
                    return e.by(t, n)
                },
                orientation: ei((()=>e.horizontal ? "horizontal" : "vertical")),
                labelRef: i,
                buttonRef: a,
                optionsRef: s,
                disabled: ei((()=>e.disabled)),
                options: l,
                searchQuery: c,
                activeOptionIndex: u,
                activationTrigger: d,
                closeListbox() {
                    e.disabled || 1 !== o.value && (o.value = 1,
                    u.value = null)
                },
                openListbox() {
                    e.disabled || 0 !== o.value && (o.value = 0)
                },
                goToOption(t, n, r) {
                    if (e.disabled || 1 === o.value)
                        return;
                    let i = p()
                      , a = Wa(t === Za.Specific ? {
                        focus: Za.Specific,
                        id: n
                    } : {
                        focus: t
                    }, {
                        resolveItems: ()=>i.options,
                        resolveActiveIndex: ()=>i.activeOptionIndex,
                        resolveId: e=>e.id,
                        resolveDisabled: e=>e.dataRef.disabled
                    });
                    c.value = "",
                    u.value = a,
                    d.value = null != r ? r : 1,
                    l.value = i.options
                },
                search(t) {
                    if (e.disabled || 1 === o.value)
                        return;
                    let n = "" !== c.value ? 0 : 1;
                    c.value += t.toLowerCase();
                    let r = (null !== u.value ? l.value.slice(u.value + n).concat(l.value.slice(0, u.value + n)) : l.value).find((e=>e.dataRef.textValue.startsWith(c.value) && !e.dataRef.disabled))
                      , i = r ? l.value.indexOf(r) : -1;
                    -1 === i || i === u.value || (u.value = i,
                    d.value = 1)
                },
                clearSearch() {
                    e.disabled || 1 !== o.value && "" !== c.value && (c.value = "")
                },
                registerOption(e, t) {
                    let n = p((n=>[...n, {
                        id: e,
                        dataRef: t
                    }]));
                    l.value = n.options,
                    u.value = n.activeOptionIndex
                },
                unregisterOption(e) {
                    let t = p((t=>{
                        let n = t.findIndex((t=>t.id === e));
                        return -1 !== n && t.splice(n, 1),
                        t
                    }
                    ));
                    l.value = t.options,
                    u.value = t.activeOptionIndex,
                    d.value = 1
                },
                theirOnChange(t) {
                    e.disabled || m(t)
                },
                select(t) {
                    e.disabled || m(ta(h.value, {
                        0: ()=>t,
                        1: ()=>{
                            let e = Ot(b.value.value).slice()
                              , n = Ot(t)
                              , r = e.findIndex((e=>b.compare(n, Ot(e))));
                            return -1 === r ? e.push(n) : e.splice(r, 1),
                            e
                        }
                    }))
                }
            };
            Sa([a, s], ((e,t)=>{
                var n;
                b.closeListbox(),
                fa(t, ha.Loose) || (e.preventDefault(),
                null == (n = ea(a)) || n.focus())
            }
            ), ei((()=>0 === o.value))),
            dr(Zs, b),
            Fa(ei((()=>ta(o.value, {
                0: Ba.Open,
                1: Ba.Closed
            }))));
            let O = ei((()=>{
                var e;
                return null == (e = ea(a)) ? void 0 : e.closest("form")
            }
            ));
            return Sn((()=>{
                zr([O], (()=>{
                    if (O.value && void 0 !== e.defaultValue)
                        return O.value.addEventListener("reset", t),
                        ()=>{
                            var e;
                            null == (e = O.value) || e.removeEventListener("reset", t)
                        }
                        ;
                    function t() {
                        b.theirOnChange(e.defaultValue)
                    }
                }
                ), {
                    immediate: !0
                })
            }
            )),
            ()=>{
                let {name: r, modelValue: i, disabled: a, form: s, ...l} = e
                  , c = {
                    open: 0 === o.value,
                    disabled: a,
                    value: g.value
                };
                return ti(lo, [...null != r && null != g.value ? Xa({
                    [r]: g.value
                }).map((([e,t])=>ti(La, function(e) {
                    let t = Object.assign({}, e);
                    for (let n in t)
                        void 0 === t[n] && delete t[n];
                    return t
                }({
                    features: Ma.Hidden,
                    key: e,
                    as: "input",
                    type: "hidden",
                    hidden: !0,
                    readOnly: !0,
                    form: s,
                    disabled: a,
                    name: e,
                    value: t
                })))) : [], Da({
                    ourProps: {},
                    theirProps: {
                        ...n,
                        ...Ia(l, ["defaultValue", "onUpdate:modelValue", "horizontal", "multiple", "by"])
                    },
                    slot: c,
                    slots: t,
                    attrs: n,
                    name: "Listbox"
                })])
            }
        }
    })
      , Vs = Ln({
        name: "ListboxButton",
        props: {
            as: {
                type: [Object, String],
                default: "button"
            },
            id: {
                type: String,
                default: null
            }
        },
        setup(e, {attrs: t, slots: n, expose: r}) {
            var o;
            let i = null != (o = e.id) ? o : `headlessui-listbox-button-${Ji()}`
              , a = Ws("ListboxButton");
            function s(e) {
                switch (e.key) {
                case za.Space:
                case za.Enter:
                case za.ArrowDown:
                    e.preventDefault(),
                    a.openListbox(),
                    Xt((()=>{
                        var e;
                        null == (e = ea(a.optionsRef)) || e.focus({
                            preventScroll: !0
                        }),
                        a.value.value || a.goToOption(Za.First)
                    }
                    ));
                    break;
                case za.ArrowUp:
                    e.preventDefault(),
                    a.openListbox(),
                    Xt((()=>{
                        var e;
                        null == (e = ea(a.optionsRef)) || e.focus({
                            preventScroll: !0
                        }),
                        a.value.value || a.goToOption(Za.Last)
                    }
                    ))
                }
            }
            function l(e) {
                if (e.key === za.Space)
                    e.preventDefault()
            }
            function c(e) {
                a.disabled.value || (0 === a.listboxState.value ? (a.closeListbox(),
                Xt((()=>{
                    var e;
                    return null == (e = ea(a.buttonRef)) ? void 0 : e.focus({
                        preventScroll: !0
                    })
                }
                ))) : (e.preventDefault(),
                a.openListbox(),
                function(e) {
                    requestAnimationFrame((()=>requestAnimationFrame(e)))
                }((()=>{
                    var e;
                    return null == (e = ea(a.optionsRef)) ? void 0 : e.focus({
                        preventScroll: !0
                    })
                }
                ))))
            }
            r({
                el: a.buttonRef,
                $el: a.buttonRef
            });
            let u = xa(ei((()=>({
                as: e.as,
                type: t.type
            }))), a.buttonRef);
            return ()=>{
                var r, o;
                let d = {
                    open: 0 === a.listboxState.value,
                    disabled: a.disabled.value,
                    value: a.value.value
                }
                  , {...p} = e;
                return Da({
                    ourProps: {
                        ref: a.buttonRef,
                        id: i,
                        type: u.value,
                        "aria-haspopup": "listbox",
                        "aria-controls": null == (r = ea(a.optionsRef)) ? void 0 : r.id,
                        "aria-expanded": 0 === a.listboxState.value,
                        "aria-labelledby": a.labelRef.value ? [null == (o = ea(a.labelRef)) ? void 0 : o.id, i].join(" ") : void 0,
                        disabled: !0 === a.disabled.value || void 0,
                        onKeydown: s,
                        onKeyup: l,
                        onClick: c
                    },
                    theirProps: p,
                    slot: d,
                    attrs: t,
                    slots: n,
                    name: "ListboxButton"
                })
            }
        }
    })
      , Gs = Ln({
        name: "ListboxOptions",
        props: {
            as: {
                type: [Object, String],
                default: "ul"
            },
            static: {
                type: Boolean,
                default: !1
            },
            unmount: {
                type: Boolean,
                default: !0
            },
            id: {
                type: String,
                default: null
            }
        },
        setup(e, {attrs: t, slots: n, expose: r}) {
            var o;
            let i = null != (o = e.id) ? o : `headlessui-listbox-options-${Ji()}`
              , a = Ws("ListboxOptions")
              , s = Et(null);
            function l(e) {
                switch (s.value && clearTimeout(s.value),
                e.key) {
                case za.Space:
                    if ("" !== a.searchQuery.value)
                        return e.preventDefault(),
                        e.stopPropagation(),
                        a.search(e.key);
                case za.Enter:
                    if (e.preventDefault(),
                    e.stopPropagation(),
                    null !== a.activeOptionIndex.value) {
                        let e = a.options.value[a.activeOptionIndex.value];
                        a.select(e.dataRef.value)
                    }
                    0 === a.mode.value && (a.closeListbox(),
                    Xt((()=>{
                        var e;
                        return null == (e = ea(a.buttonRef)) ? void 0 : e.focus({
                            preventScroll: !0
                        })
                    }
                    )));
                    break;
                case ta(a.orientation.value, {
                    vertical: za.ArrowDown,
                    horizontal: za.ArrowRight
                }):
                    return e.preventDefault(),
                    e.stopPropagation(),
                    a.goToOption(Za.Next);
                case ta(a.orientation.value, {
                    vertical: za.ArrowUp,
                    horizontal: za.ArrowLeft
                }):
                    return e.preventDefault(),
                    e.stopPropagation(),
                    a.goToOption(Za.Previous);
                case za.Home:
                case za.PageUp:
                    return e.preventDefault(),
                    e.stopPropagation(),
                    a.goToOption(Za.First);
                case za.End:
                case za.PageDown:
                    return e.preventDefault(),
                    e.stopPropagation(),
                    a.goToOption(Za.Last);
                case za.Escape:
                    e.preventDefault(),
                    e.stopPropagation(),
                    a.closeListbox(),
                    Xt((()=>{
                        var e;
                        return null == (e = ea(a.buttonRef)) ? void 0 : e.focus({
                            preventScroll: !0
                        })
                    }
                    ));
                    break;
                case za.Tab:
                    e.preventDefault(),
                    e.stopPropagation();
                    break;
                default:
                    1 === e.key.length && (a.search(e.key),
                    s.value = setTimeout((()=>a.clearSearch()), 350))
                }
            }
            r({
                el: a.optionsRef,
                $el: a.optionsRef
            });
            let c = Ua()
              , u = ei((()=>null !== c ? (c.value & Ba.Open) === Ba.Open : 0 === a.listboxState.value));
            return ()=>{
                var r, o;
                let s = {
                    open: 0 === a.listboxState.value
                }
                  , {...c} = e;
                return Da({
                    ourProps: {
                        "aria-activedescendant": null === a.activeOptionIndex.value || null == (r = a.options.value[a.activeOptionIndex.value]) ? void 0 : r.id,
                        "aria-multiselectable": 1 === a.mode.value || void 0,
                        "aria-labelledby": null == (o = ea(a.buttonRef)) ? void 0 : o.id,
                        "aria-orientation": a.orientation.value,
                        id: i,
                        onKeydown: l,
                        role: "listbox",
                        tabIndex: 0,
                        ref: a.optionsRef
                    },
                    theirProps: c,
                    slot: s,
                    attrs: t,
                    slots: n,
                    features: Ca.RenderStrategy | Ca.Static,
                    visible: u.value,
                    name: "ListboxOptions"
                })
            }
        }
    })
      , Ys = Ln({
        name: "ListboxOption",
        props: {
            as: {
                type: [Object, String],
                default: "li"
            },
            value: {
                type: [Object, String, Number, Boolean]
            },
            disabled: {
                type: Boolean,
                default: !1
            },
            id: {
                type: String,
                default: null
            }
        },
        setup(e, {slots: t, attrs: n, expose: r}) {
            var o;
            let i = null != (o = e.id) ? o : `headlessui-listbox-option-${Ji()}`
              , a = Ws("ListboxOption")
              , s = Et(null);
            r({
                el: s,
                $el: s
            });
            let l = ei((()=>null !== a.activeOptionIndex.value && a.options.value[a.activeOptionIndex.value].id === i))
              , c = ei((()=>ta(a.mode.value, {
                0: ()=>a.compare(Ot(a.value.value), Ot(e.value)),
                1: ()=>Ot(a.value.value).some((t=>a.compare(Ot(t), Ot(e.value))))
            })))
              , u = ei((()=>ta(a.mode.value, {
                1: ()=>{
                    var e;
                    let t = Ot(a.value.value);
                    return (null == (e = a.options.value.find((e=>t.some((t=>a.compare(Ot(t), Ot(e.dataRef.value))))))) ? void 0 : e.id) === i
                }
                ,
                0: ()=>c.value
            })))
              , d = Fs(s)
              , p = ei((()=>({
                disabled: e.disabled,
                value: e.value,
                get textValue() {
                    return d()
                },
                domRef: s
            })));
            function h(t) {
                if (e.disabled)
                    return t.preventDefault();
                a.select(e.value),
                0 === a.mode.value && (a.closeListbox(),
                Xt((()=>{
                    var e;
                    return null == (e = ea(a.buttonRef)) ? void 0 : e.focus({
                        preventScroll: !0
                    })
                }
                )))
            }
            function f() {
                if (e.disabled)
                    return a.goToOption(Za.Nothing);
                a.goToOption(Za.Specific, i)
            }
            Sn((()=>a.registerOption(i, p))),
            An((()=>a.unregisterOption(i))),
            Sn((()=>{
                zr([a.listboxState, c], (()=>{
                    0 === a.listboxState.value && c.value && ta(a.mode.value, {
                        1: ()=>{
                            u.value && a.goToOption(Za.Specific, i)
                        }
                        ,
                        0: ()=>{
                            a.goToOption(Za.Specific, i)
                        }
                    })
                }
                ), {
                    immediate: !0
                })
            }
            )),
            Fr((()=>{
                0 === a.listboxState.value && l.value && 0 !== a.activationTrigger.value && Xt((()=>{
                    var e, t;
                    return null == (t = null == (e = ea(s)) ? void 0 : e.scrollIntoView) ? void 0 : t.call(e, {
                        block: "nearest"
                    })
                }
                ))
            }
            ));
            let m = function() {
                let e = Et([-1, -1]);
                return {
                    wasMoved(t) {
                        let n = Ta(t);
                        return (e.value[0] !== n[0] || e.value[1] !== n[1]) && (e.value = n,
                        !0)
                    },
                    update(t) {
                        e.value = Ta(t)
                    }
                }
            }();
            function g(e) {
                m.update(e)
            }
            function b(t) {
                m.wasMoved(t) && (e.disabled || l.value || a.goToOption(Za.Specific, i, 0))
            }
            function O(t) {
                m.wasMoved(t) && (e.disabled || l.value && a.goToOption(Za.Nothing))
            }
            return ()=>{
                let {disabled: r} = e
                  , o = {
                    active: l.value,
                    selected: c.value,
                    disabled: r
                }
                  , {value: a, disabled: u, ...d} = e;
                return Da({
                    ourProps: {
                        id: i,
                        ref: s,
                        role: "option",
                        tabIndex: !0 === r ? void 0 : -1,
                        "aria-disabled": !0 === r || void 0,
                        "aria-selected": c.value,
                        disabled: void 0,
                        onClick: h,
                        onFocus: f,
                        onPointerenter: g,
                        onMouseenter: g,
                        onPointermove: b,
                        onMousemove: b,
                        onPointerleave: O,
                        onMouseleave: O
                    },
                    theirProps: d,
                    slot: o,
                    attrs: n,
                    slots: t,
                    name: "ListboxOption"
                })
            }
        }
    })
      , Ks = Ln({
        props: {
            onFocus: {
                type: Function,
                required: !0
            }
        },
        setup(e) {
            let t = Et(!0);
            return ()=>t.value ? ti(La, {
                as: "button",
                type: "button",
                features: Ma.Focusable,
                onFocus(n) {
                    n.preventDefault();
                    let r, o = 50;
                    r = requestAnimationFrame((function n() {
                        var i;
                        if (!(o-- <= 0))
                            return null != (i = e.onFocus) && i.call(e) ? (t.value = !1,
                            void cancelAnimationFrame(r)) : void (r = requestAnimationFrame(n));
                        r && cancelAnimationFrame(r)
                    }
                    ))
                }
            }) : null
        }
    });
    var Js, el, tl = ((el = tl || {})[el.Forwards = 0] = "Forwards",
    el[el.Backwards = 1] = "Backwards",
    el), nl = ((Js = nl || {})[Js.Less = -1] = "Less",
    Js[Js.Equal = 0] = "Equal",
    Js[Js.Greater = 1] = "Greater",
    Js);
    let rl = Symbol("TabsContext");
    function ol(e) {
        let t = pr(rl, null);
        if (null === t) {
            let t = new Error(`<${e} /> is missing a parent <TabGroup /> component.`);
            throw Error.captureStackTrace && Error.captureStackTrace(t, ol),
            t
        }
        return t
    }
    let il = Symbol("TabsSSRContext")
      , al = Ln({
        name: "TabGroup",
        emits: {
            change: e=>!0
        },
        props: {
            as: {
                type: [Object, String],
                default: "template"
            },
            selectedIndex: {
                type: [Number],
                default: null
            },
            defaultIndex: {
                type: [Number],
                default: 0
            },
            vertical: {
                type: [Boolean],
                default: !1
            },
            manual: {
                type: [Boolean],
                default: !1
            }
        },
        inheritAttrs: !1,
        setup(e, {slots: t, attrs: n, emit: r}) {
            var o;
            let i = Et(null != (o = e.selectedIndex) ? o : e.defaultIndex)
              , a = Et([])
              , s = Et([])
              , l = ei((()=>null !== e.selectedIndex))
              , c = ei((()=>l.value ? e.selectedIndex : i.value));
            function u(e) {
                var t;
                let n = Oa(d.tabs.value, ea)
                  , r = Oa(d.panels.value, ea)
                  , o = n.filter((e=>{
                    var t;
                    return !(null != (t = ea(e)) && t.hasAttribute("disabled"))
                }
                ));
                if (e < 0 || e > n.length - 1) {
                    let t = ta(null === i.value ? 0 : Math.sign(e - i.value), {
                        [-1]: ()=>1,
                        0: ()=>ta(Math.sign(e), {
                            [-1]: ()=>0,
                            0: ()=>0,
                            1: ()=>1
                        }),
                        1: ()=>0
                    })
                      , a = ta(t, {
                        0: ()=>n.indexOf(o[0]),
                        1: ()=>n.indexOf(o[o.length - 1])
                    });
                    -1 !== a && (i.value = a),
                    d.tabs.value = n,
                    d.panels.value = r
                } else {
                    let a = n.slice(0, e)
                      , s = [...n.slice(e), ...a].find((e=>o.includes(e)));
                    if (!s)
                        return;
                    let l = null != (t = n.indexOf(s)) ? t : d.selectedIndex.value;
                    -1 === l && (l = d.selectedIndex.value),
                    i.value = l,
                    d.tabs.value = n,
                    d.panels.value = r
                }
            }
            let d = {
                selectedIndex: ei((()=>{
                    var t, n;
                    return null != (n = null != (t = i.value) ? t : e.defaultIndex) ? n : null
                }
                )),
                orientation: ei((()=>e.vertical ? "vertical" : "horizontal")),
                activation: ei((()=>e.manual ? "manual" : "auto")),
                tabs: a,
                panels: s,
                setSelectedIndex(e) {
                    c.value !== e && r("change", e),
                    l.value || u(e)
                },
                registerTab(e) {
                    var t;
                    if (a.value.includes(e))
                        return;
                    let n = a.value[i.value];
                    if (a.value.push(e),
                    a.value = Oa(a.value, ea),
                    !l.value) {
                        let e = null != (t = a.value.indexOf(n)) ? t : i.value;
                        -1 !== e && (i.value = e)
                    }
                },
                unregisterTab(e) {
                    let t = a.value.indexOf(e);
                    -1 !== t && a.value.splice(t, 1)
                },
                registerPanel(e) {
                    s.value.includes(e) || (s.value.push(e),
                    s.value = Oa(s.value, ea))
                },
                unregisterPanel(e) {
                    let t = s.value.indexOf(e);
                    -1 !== t && s.value.splice(t, 1)
                }
            };
            dr(rl, d);
            let p = Et({
                tabs: [],
                panels: []
            })
              , h = Et(!1);
            Sn((()=>{
                h.value = !0
            }
            )),
            dr(il, ei((()=>h.value ? null : p.value)));
            let f = ei((()=>e.selectedIndex));
            return Sn((()=>{
                zr([f], (()=>{
                    var t;
                    return u(null != (t = e.selectedIndex) ? t : e.defaultIndex)
                }
                ), {
                    immediate: !0
                })
            }
            )),
            Fr((()=>{
                if (!l.value || null == c.value || d.tabs.value.length <= 0)
                    return;
                let e = Oa(d.tabs.value, ea);
                e.some(((e,t)=>ea(d.tabs.value[t]) !== ea(e))) && d.setSelectedIndex(e.findIndex((e=>ea(e) === ea(d.tabs.value[c.value]))))
            }
            )),
            ()=>{
                let r = {
                    selectedIndex: i.value
                };
                return ti(lo, [a.value.length <= 0 && ti(Ks, {
                    onFocus: ()=>{
                        for (let e of a.value) {
                            let t = ea(e);
                            if (0 === (null == t ? void 0 : t.tabIndex))
                                return t.focus(),
                                !0
                        }
                        return !1
                    }
                }), Da({
                    theirProps: {
                        ...n,
                        ...Ia(e, ["selectedIndex", "defaultIndex", "manual", "vertical", "onChange"])
                    },
                    ourProps: {},
                    slot: r,
                    slots: t,
                    attrs: n,
                    name: "TabGroup"
                })])
            }
        }
    })
      , sl = Ln({
        name: "TabList",
        props: {
            as: {
                type: [Object, String],
                default: "div"
            }
        },
        setup(e, {attrs: t, slots: n}) {
            let r = ol("TabList");
            return ()=>{
                let o = {
                    selectedIndex: r.selectedIndex.value
                };
                return Da({
                    ourProps: {
                        role: "tablist",
                        "aria-orientation": r.orientation.value
                    },
                    theirProps: e,
                    slot: o,
                    attrs: t,
                    slots: n,
                    name: "TabList"
                })
            }
        }
    })
      , ll = Ln({
        name: "Tab",
        props: {
            as: {
                type: [Object, String],
                default: "button"
            },
            disabled: {
                type: [Boolean],
                default: !1
            },
            id: {
                type: String,
                default: null
            }
        },
        setup(e, {attrs: t, slots: n, expose: r}) {
            var o;
            let i = null != (o = e.id) ? o : `headlessui-tabs-tab-${Ji()}`
              , a = ol("Tab")
              , s = Et(null);
            r({
                el: s,
                $el: s
            }),
            Sn((()=>a.registerTab(s))),
            An((()=>a.unregisterTab(s)));
            let l = pr(il)
              , c = ei((()=>{
                if (l.value) {
                    let e = l.value.tabs.indexOf(i);
                    return -1 === e ? l.value.tabs.push(i) - 1 : e
                }
                return -1
            }
            ))
              , u = ei((()=>{
                let e = a.tabs.value.indexOf(s);
                return -1 === e ? c.value : e
            }
            ))
              , d = ei((()=>u.value === a.selectedIndex.value));
            function p(e) {
                var t;
                let n = e();
                if (n === da.Success && "auto" === a.activation.value) {
                    let e = null == (t = ia(s)) ? void 0 : t.activeElement
                      , n = a.tabs.value.findIndex((t=>ea(t) === e));
                    -1 !== n && a.setSelectedIndex(n)
                }
                return n
            }
            function h(e) {
                let t = a.tabs.value.map((e=>ea(e))).filter(Boolean);
                if (e.key === za.Space || e.key === za.Enter)
                    return e.preventDefault(),
                    e.stopPropagation(),
                    void a.setSelectedIndex(u.value);
                switch (e.key) {
                case za.Home:
                case za.PageUp:
                    return e.preventDefault(),
                    e.stopPropagation(),
                    p((()=>va(t, ua.First)));
                case za.End:
                case za.PageDown:
                    return e.preventDefault(),
                    e.stopPropagation(),
                    p((()=>va(t, ua.Last)))
                }
                return p((()=>ta(a.orientation.value, {
                    vertical: ()=>e.key === za.ArrowUp ? va(t, ua.Previous | ua.WrapAround) : e.key === za.ArrowDown ? va(t, ua.Next | ua.WrapAround) : da.Error,
                    horizontal: ()=>e.key === za.ArrowLeft ? va(t, ua.Previous | ua.WrapAround) : e.key === za.ArrowRight ? va(t, ua.Next | ua.WrapAround) : da.Error
                }))) === da.Success ? e.preventDefault() : void 0
            }
            let f = Et(!1);
            function m() {
                var t;
                f.value || (f.value = !0,
                !e.disabled && (null == (t = ea(s)) || t.focus({
                    preventScroll: !0
                }),
                a.setSelectedIndex(u.value),
                Vi((()=>{
                    f.value = !1
                }
                ))))
            }
            function g(e) {
                e.preventDefault()
            }
            let b = xa(ei((()=>({
                as: e.as,
                type: t.type
            }))), s);
            return ()=>{
                var r, o;
                let l = {
                    selected: d.value,
                    disabled: null != (r = e.disabled) && r
                }
                  , {...c} = e;
                return Da({
                    ourProps: {
                        ref: s,
                        onKeydown: h,
                        onMousedown: g,
                        onClick: m,
                        id: i,
                        role: "tab",
                        type: b.value,
                        "aria-controls": null == (o = ea(a.panels.value[u.value])) ? void 0 : o.id,
                        "aria-selected": d.value,
                        tabIndex: d.value ? 0 : -1,
                        disabled: !!e.disabled || void 0
                    },
                    theirProps: c,
                    slot: l,
                    attrs: t,
                    slots: n,
                    name: "Tab"
                })
            }
        }
    })
      , cl = Ln({
        name: "TabPanels",
        props: {
            as: {
                type: [Object, String],
                default: "div"
            }
        },
        setup(e, {slots: t, attrs: n}) {
            let r = ol("TabPanels");
            return ()=>{
                let o = {
                    selectedIndex: r.selectedIndex.value
                };
                return Da({
                    theirProps: e,
                    ourProps: {},
                    slot: o,
                    attrs: n,
                    slots: t,
                    name: "TabPanels"
                })
            }
        }
    })
      , ul = Ln({
        name: "TabPanel",
        props: {
            as: {
                type: [Object, String],
                default: "div"
            },
            static: {
                type: Boolean,
                default: !1
            },
            unmount: {
                type: Boolean,
                default: !0
            },
            id: {
                type: String,
                default: null
            },
            tabIndex: {
                type: Number,
                default: 0
            }
        },
        setup(e, {attrs: t, slots: n, expose: r}) {
            var o;
            let i = null != (o = e.id) ? o : `headlessui-tabs-panel-${Ji()}`
              , a = ol("TabPanel")
              , s = Et(null);
            r({
                el: s,
                $el: s
            }),
            Sn((()=>a.registerPanel(s))),
            An((()=>a.unregisterPanel(s)));
            let l = pr(il)
              , c = ei((()=>{
                if (l.value) {
                    let e = l.value.panels.indexOf(i);
                    return -1 === e ? l.value.panels.push(i) - 1 : e
                }
                return -1
            }
            ))
              , u = ei((()=>{
                let e = a.panels.value.indexOf(s);
                return -1 === e ? c.value : e
            }
            ))
              , d = ei((()=>u.value === a.selectedIndex.value));
            return ()=>{
                var r;
                let o = {
                    selected: d.value
                }
                  , {tabIndex: l, ...c} = e
                  , p = {
                    ref: s,
                    id: i,
                    role: "tabpanel",
                    "aria-labelledby": null == (r = ea(a.tabs.value[u.value])) ? void 0 : r.id,
                    tabIndex: d.value ? l : -1
                };
                return d.value || !e.unmount || e.static ? Da({
                    ourProps: p,
                    theirProps: c,
                    slot: o,
                    attrs: t,
                    slots: n,
                    features: Ca.Static | Ca.RenderStrategy,
                    visible: d.value,
                    name: "TabPanel"
                }) : ti(La, {
                    as: "span",
                    "aria-hidden": !0,
                    ...p
                })
            }
        }
    });
    const dl = ".light-mode{--scalar-background-1: #fff;--scalar-background-2: #f6f6f6;--scalar-background-3: #e7e7e7;--scalar-background-accent: #8ab4f81f;--scalar-color-1: #2a2f45;--scalar-color-2: #757575;--scalar-color-3: #8e8e8e;--scalar-color-accent: #0099ff;--scalar-border-color: rgba(0, 0, 0, .1)}.dark-mode{--scalar-background-1: #0f0f0f;--scalar-background-2: #1a1a1a;--scalar-background-3: #272727;--scalar-color-1: rgba(255, 255, 255, .9);--scalar-color-2: rgba(255, 255, 255, .62);--scalar-color-3: rgba(255, 255, 255, .44);--scalar-color-accent: #3ea6ff;--scalar-background-accent: #3ea6ff1f;--scalar-border-color: rgba(255, 255, 255, .1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-active-background: var(--scalar-background-2);--scalar-sidebar-color-active: var(--scalar-color-1);--scalar-sidebar-search-background: transparent;--scalar-sidebar-search-color: var(--scalar-color-3);--scalar-sidebar-search-border-color: var(--scalar-border-color)}.light-mode{--scalar-color-green: #069061;--scalar-color-red: #ef0006;--scalar-color-yellow: #edbe20;--scalar-color-blue: #0082d0;--scalar-color-orange: #fb892c;--scalar-color-purple: #5203d1;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: #00b648;--scalar-color-red: #dc1b19;--scalar-color-yellow: #ffc90d;--scalar-color-blue: #4eb3ec;--scalar-color-orange: #ff8d4d;--scalar-color-purple: #b191f9;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}"
      , pl = [["--theme-", "--scalar-"], ["--sidebar-", "--scalar-sidebar-"]]
      , hl = pl.map((([e])=>e));
    const fl = {
        default: "Default",
        alternate: "Alternate",
        moon: "Moon",
        purple: "Purple",
        solarized: "Solarized",
        bluePlanet: "Blue Planet",
        saturn: "Saturn",
        kepler: "Kepler-11e",
        mars: "Mars",
        deepSpace: "Deep Space",
        none: ""
    }
      , ml = {
        alternate: ":root{--scalar-text-decoration: underline;--scalar-text-decoration-hover: underline}.light-mode,.light-mode .dark-mode{--scalar-background-1: #f9f9f9;--scalar-background-2: #f1f1f1;--scalar-background-3: #e7e7e7;--scalar-background-card: #fff;--scalar-color-1: #2a2f45;--scalar-color-2: #757575;--scalar-color-3: #8e8e8e;--scalar-color-accent: var(--scalar-color-1);--scalar-background-accent: var(--scalar-background-3);--scalar-border-color: rgba(0, 0, 0, .1)}.dark-mode{--scalar-background-1: #131313;--scalar-background-2: #1d1d1d;--scalar-background-3: #272727;--scalar-background-card: #1d1d1d;--scalar-color-1: rgba(255, 255, 255, .9);--scalar-color-2: rgba(255, 255, 255, .62);--scalar-color-3: rgba(255, 255, 255, .44);--scalar-color-accent: var(--scalar-color-1);--scalar-background-accent: var(--scalar-background-3);--scalar-border-color: rgba(255, 255, 255, .1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-active-background: var(--scalar-background-accent);--scalar-sidebar-color-active: var(--scalar-color-accent);--scalar-sidebar-search-background: transparent;--scalar-sidebar-search-color: var(--scalar-color-3);--scalar-sidebar-search-border-color: var(--scalar-border-color);--scalar-sidebar-indent-border: var(--scalar-sidebar-border-color);--scalar-sidebar-indent-border-hover: var(--scalar-sidebar-border-color);--scalar-sidebar-indent-border-active: var(--scalar-sidebar-border-color)}.light-mode .dark-mode,.light-mode{--scalar-color-green: #069061;--scalar-color-red: #ef0006;--scalar-color-yellow: #edbe20;--scalar-color-blue: #0082d0;--scalar-color-orange: #fb892c;--scalar-color-purple: #5203d1;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: #00b648;--scalar-color-red: #dd2f2c;--scalar-color-yellow: #ffc90d;--scalar-color-blue: #4eb3ec;--scalar-color-orange: #ff8d4d;--scalar-color-purple: #b191f9;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}.scalar-api-client__item,.scalar-card,.dark-mode .dark-mode.scalar-card{--scalar-background-1: var(--scalar-background-card);--scalar-background-2: var(--scalar-background-1);--scalar-background-3: var(--scalar-background-1)}.dark-mode .dark-mode.scalar-card{--scalar-background-3: var(--scalar-background-3)}.t-doc__sidebar{--scalar-color-green: var(--scalar-color-1);--scalar-color-red: var(--scalar-color-1);--scalar-color-yellow: var(--scalar-color-1);--scalar-color-blue: var(--scalar-color-1);--scalar-color-orange: var(--scalar-color-1);--scalar-color-purple: var(--scalar-color-1)}",
        default: dl,
        moon: ".light-mode{color-scheme:light;--scalar-color-1: #000000;--scalar-color-2: #000000;--scalar-color-3: #000000;--scalar-color-accent: #645b0f;--scalar-background-1: #ccc9b3;--scalar-background-2: #c2bfaa;--scalar-background-3: #b8b5a1;--scalar-background-accent: #000000;--scalar-border-color: rgba(0, 0, 0, .2);--scalar-scrollbar-color: rgba(0, 0, 0, .18);--scalar-scrollbar-color-active: rgba(0, 0, 0, .36);--scalar-lifted-brightness: 1;--scalar-backdrop-brightness: 1;--scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, .11);--scalar-shadow-2: rgba(0, 0, 0, .08) 0px 13px 20px 0px, rgba(0, 0, 0, .08) 0px 3px 8px 0px, var(--scalar-border-color) 0px 0 0 1px;--scalar-button-1: rgb(49 53 56);--scalar-button-1-color: #fff;--scalar-button-1-hover: rgb(28 31 33);--scalar-color-red: #b91c1c;--scalar-color-orange: #a16207;--scalar-color-green: #047857;--scalar-color-blue: #1d4ed8;--scalar-color-orange: #c2410c;--scalar-color-purple: #6d28d9}.dark-mode{color-scheme:dark;--scalar-color-1: #fffef3;--scalar-color-2: #fffef3;--scalar-color-3: #fffef3;--scalar-color-accent: #c3b531;--scalar-background-1: #313332;--scalar-background-2: #393b3a;--scalar-background-3: #414342;--scalar-background-accent: #fffef3;--scalar-border-color: rgba(255, 255, 255, .1);--scalar-scrollbar-color: rgba(255, 255, 255, .24);--scalar-scrollbar-color-active: rgba(255, 255, 255, .48);--scalar-lifted-brightness: 1.45;--scalar-backdrop-brightness: .5;--scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, .11);--scalar-shadow-2: rgba(15, 15, 15, .2) 0px 3px 6px, rgba(15, 15, 15, .4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, .1);--scalar-button-1: #f6f6f6;--scalar-button-1-color: #000;--scalar-button-1-hover: #e7e7e7;--scalar-color-green: #00b648;--scalar-color-red: #dc1b19;--scalar-color-yellow: #ffc90d;--scalar-color-blue: #4eb3ec;--scalar-color-orange: #ff8d4d;--scalar-color-purple: #b191f9}.light-mode .t-doc__sidebar,.dark-mode .sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-active-background: var(--scalar-background-accent);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-color-active: var(--scalar-sidebar-background-1);--scalar-sidebar-search-background: var(--scalar-background-3);--scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);--scalar-sidebar-search--color: var(--scalar-color-3)}",
        purple: ".light-mode{--scalar-background-1: #fff;--scalar-background-2: #f5f6f8;--scalar-background-3: #eceef1;--scalar-color-1: #2a2f45;--scalar-color-2: #757575;--scalar-color-3: #8e8e8e;--scalar-color-accent: #5469d4;--scalar-background-accent: #5469d41f;--scalar-border-color: rgba(215, 215, 206, .5)}.dark-mode{--scalar-background-1: #15171c;--scalar-background-2: #1c1e24;--scalar-background-3: #22252b;--scalar-color-1: #fafafa;--scalar-color-2: #c9ced8;--scalar-color-3: #8c99ad;--scalar-color-accent: #5469d4;--scalar-background-accent: #5469d41f;--scalar-border-color: rgba(255, 255, 255, .12)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-hover-background: var(--scalar-background-3);--scalar-sidebar-item-active-background: var(--scalar-background-accent);--scalar-sidebar-color-active: var(--scalar-color-accent);--scalar-sidebar-search-background: var(--scalar-background-1);--scalar-sidebar-search-color: var(--scalar-color-3);--scalar-sidebar-search-border-color: var(--scalar-border-color)}.light-mode{--scalar-color-green: #17803d;--scalar-color-red: #e10909;--scalar-color-yellow: #edbe20;--scalar-color-blue: #1763a6;--scalar-color-orange: #e25b09;--scalar-color-purple: #5c3993;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: #30a159;--scalar-color-red: #dc1b19;--scalar-color-yellow: #eec644;--scalar-color-blue: #2b7abf;--scalar-color-orange: #f07528;--scalar-color-purple: #7a59b1;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}",
        solarized: ".light-mode{color-scheme:light;--scalar-color-1: #584c27;--scalar-color-2: #616161;--scalar-color-3: #a89f84;--scalar-color-accent: #b58900;--scalar-background-1: #fdf6e3;--scalar-background-2: #eee8d5;--scalar-background-3: #ddd6c1;--scalar-background-accent: #b589001f;--scalar-border-color: #ded8c8;--scalar-scrollbar-color: rgba(0, 0, 0, .18);--scalar-scrollbar-color-active: rgba(0, 0, 0, .36);--scalar-lifted-brightness: 1;--scalar-backdrop-brightness: 1;--scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, .11);--scalar-shadow-2: rgba(0, 0, 0, .08) 0px 13px 20px 0px, rgba(0, 0, 0, .08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;--scalar-button-1: rgb(49 53 56);--scalar-button-1-color: #fff;--scalar-button-1-hover: rgb(28 31 33);--scalar-color-red: #b91c1c;--scalar-color-orange: #a16207;--scalar-color-green: #047857;--scalar-color-blue: #1d4ed8;--scalar-color-orange: #c2410c;--scalar-color-purple: #6d28d9}.dark-mode{color-scheme:dark;--scalar-color-1: #fff;--scalar-color-2: #cccccc;--scalar-color-3: #6d8890;--scalar-color-accent: #007acc;--scalar-background-1: #00212b;--scalar-background-2: #012b36;--scalar-background-3: #004052;--scalar-background-accent: #015a6f;--scalar-border-color: rgba(255, 255, 255, .1);--scalar-scrollbar-color: rgba(255, 255, 255, .24);--scalar-scrollbar-color-active: rgba(255, 255, 255, .48);--scalar-lifted-brightness: 1.45;--scalar-backdrop-brightness: .5;--scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, .1);--scalar-shadow-2: rgba(15, 15, 15, .2) 0px 3px 6px, rgba(15, 15, 15, .4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, .1);--scalar-button-1: #f6f6f6;--scalar-button-1-color: #000;--scalar-button-1-hover: #e7e7e7;--scalar-color-green: #00b648;--scalar-color-red: #dc1b19;--scalar-color-yellow: #ffc90d;--scalar-color-blue: #4eb3ec;--scalar-color-orange: #ff8d4d;--scalar-color-purple: #b191f9}.light-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-active-background: var(--scalar-background-accent);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-color-active: var(--scalar-color-accent);--scalar-sidebar-search-background: var(--scalar-background-2);--scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);--scalar-sidebar-search--color: var(--scalar-color-3)}.dark-mode .sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-active-background: var(--scalar-background-accent);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-color-active: var(--scalar-sidebar-color-1);--scalar-sidebar-search-background: var(--scalar-background-2);--scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);--scalar-sidebar-search--color: var(--scalar-color-3)}",
        bluePlanet: ":root{--scalar-text-decoration: underline;--scalar-text-decoration-hover: underline}.light-mode{--scalar-background-1: #f0f2f5;--scalar-background-2: #eaecf0;--scalar-background-3: #e0e2e6;--scalar-border-color: rgb(228, 228, 231);--scalar-color-1: rgb(9, 9, 11);--scalar-color-2: rgb(113, 113, 122);--scalar-color-3: rgba(25, 25, 28, .5);--scalar-color-accent: var(--scalar-color-1);--scalar-background-accent: #8ab4f81f;--scalar-code-language-color-supersede: var(--scalar-color-1)}.light-mode .scalar-card.dark-mode,.dark-mode{--scalar-background-1: #000e23;--scalar-background-2: #01132e;--scalar-background-3: #03193b;--scalar-border-color: rgba(255, 255, 255, .12);--scalar-color-1: #fafafa;--scalar-color-2: rgb(161, 161, 170);--scalar-color-3: rgba(255, 255, 255, .533);--scalar-color-accent: var(--scalar-color-1);--scalar-background-accent: #8ab4f81f;--scalar-code-language-color-supersede: var(--scalar-color-1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-active-background: var(--scalar-background-3);--scalar-sidebar-color-active: var(--scalar-color-accent);--scalar-sidebar-search-background: rgba(255, 255, 255, .1);--scalar-sidebar-search-border-color: var(--scalar-border-color);--scalar-sidebar-search-color: var(--scalar-color-3);z-index:1}.light-mode .t-doc__sidebar{--scalar-sidebar-search-background: white}.light-mode{--scalar-color-green: #069061;--scalar-color-red: #ef0006;--scalar-color-yellow: #edbe20;--scalar-color-blue: #0082d0;--scalar-color-orange: #fb892c;--scalar-color-purple: #5203d1;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: rgba(69, 255, 165, .823);--scalar-color-red: #ff8589;--scalar-color-yellow: #ffcc4d;--scalar-color-blue: #6bc1fe;--scalar-color-orange: #f98943;--scalar-color-purple: #b191f9;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}@keyframes headerbackground{0%{background:transparent;-webkit-backdrop-filter:none;backdrop-filter:none}to{background:var(--header-background-1);-webkit-backdrop-filter:blur(12px);backdrop-filter:blur(12px)}}.dark-mode h2.t-editor__heading,.dark-mode .t-editor__page-title h1,.dark-mode h1.section-header,.dark-mode .markdown h1,.dark-mode .markdown h2,.dark-mode .markdown h3,.dark-mode .markdown h4,.dark-mode .markdown h5,.dark-mode .markdown h6{-webkit-text-fill-color:transparent;background-image:linear-gradient(to right bottom,#fff 30%,#ffffff61);-webkit-background-clip:text;background-clip:text}.section-flare-item:nth-of-type(1){--c1: #ffffff;--c2: #babfd8;--c3: #2e8bb2;--c4: #1a8593;--c5: #0a143e;--c6: #0a0f52;--c7: #2341b8;--solid: var(--c1), var(--c2), var(--c3), var(--c4), var(--c5), var(--c6), var(--c7);--solid-wrap: var(--solid), var(--c1);--trans: var(--c1), transparent, var(--c2), transparent, var(--c3), transparent, var(--c4), transparent, var(--c5), transparent, var(--c6), transparent, var(--c7);--trans-wrap: var(--trans), transparent, var(--c1);background:radial-gradient(circle,var(--trans)),conic-gradient(from 180deg,var(--trans-wrap)),radial-gradient(circle,var(--trans)),conic-gradient(var(--solid-wrap));width:70vw;height:700px;border-radius:50%;filter:blur(100px);z-index:0;right:0;position:absolute;transform:rotate(-45deg);top:-300px;opacity:.3}.section-flare-item:nth-of-type(3){--star-color: #6b9acc;--star-color2: #446b8d;--star-color3: #3e5879;background-image:radial-gradient(2px 2px at 20px 30px,var(--star-color2),rgba(0,0,0,0)),radial-gradient(2px 2px at 40px 70px,var(--star-color),rgba(0,0,0,0)),radial-gradient(2px 2px at 50px 160px,var(--star-color3),rgba(0,0,0,0)),radial-gradient(2px 2px at 90px 40px,var(--star-color),rgba(0,0,0,0)),radial-gradient(2px 2px at 130px 80px,var(--star-color),rgba(0,0,0,0)),radial-gradient(2px 2px at 160px 120px,var(--star-color3),rgba(0,0,0,0));background-repeat:repeat;background-size:200px 200px;width:100%;height:100%;-webkit-mask-image:radial-gradient(ellipse at 100% 0%,black 40%,transparent 70%);mask-image:radial-gradient(ellipse at 100% 0%,black 40%,transparent 70%)}.section-flare{top:-150px!important;height:100vh;background:linear-gradient(#000,var(--scalar-background-1));width:100vw}.light-mode .section-flare{display:none}.light-mode .scalar-card{--scalar-background-1: #fff;--scalar-background-2: #fff;--scalar-background-3: #fff}",
        deepSpace: ':root{--scalar-text-decoration: underline;--scalar-text-decoration-hover: underline}.light-mode{--scalar-color-1: rgb(9, 9, 11);--scalar-color-2: rgb(113, 113, 122);--scalar-color-3: rgba(25, 25, 28, .5);--scalar-color-accent: var(--scalar-color-1);--scalar-background-1: #fff;--scalar-background-2: #f4f4f5;--scalar-background-3: #e3e3e6;--scalar-background-accent: #8ab4f81f;--scalar-border-color: rgb(228, 228, 231);--scalar-code-language-color-supersede: var(--scalar-color-1)}.dark-mode{--scalar-color-1: #fafafa;--scalar-color-2: rgb(161, 161, 170);--scalar-color-3: rgba(255, 255, 255, .533);--scalar-color-accent: var(--scalar-color-1);--scalar-background-1: #09090b;--scalar-background-2: #18181b;--scalar-background-3: #2c2c30;--scalar-background-accent: #8ab4f81f;--scalar-border-color: rgba(255, 255, 255, .12);--scalar-code-language-color-supersede: var(--scalar-color-1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-active-background: var(--scalar-background-3);--scalar-sidebar-color-active: var(--scalar-color-accent);--scalar-sidebar-search-background: transparent;--scalar-sidebar-search-border-color: var(--scalar-border-color);--scalar-sidebar-search-color: var(--scalar-color-3)}.light-mode .t-doc__sidebar{--scalar-sidebar-item-active-background: var(--scalar-background-2)}.light-mode{--scalar-color-green: #069061;--scalar-color-red: #ef0006;--scalar-color-yellow: #edbe20;--scalar-color-blue: #0082d0;--scalar-color-orange: #fb892c;--scalar-color-purple: #5203d1;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: rgba(69, 255, 165, .823);--scalar-color-red: #ff8589;--scalar-color-yellow: #ffcc4d;--scalar-color-blue: #6bc1fe;--scalar-color-orange: #f98943;--scalar-color-purple: #b191f9;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}.dark-mode h2.t-editor__heading,.dark-mode .t-editor__page-title h1,.dark-mode h1.section-header,.dark-mode .markdown h1,.dark-mode .markdown h2,.dark-mode .markdown h3,.dark-mode .markdown h4,.dark-mode .markdown h5,.dark-mode .markdown h6{-webkit-text-fill-color:transparent;background-image:linear-gradient(to right bottom,#fff 30%,#ffffff61);-webkit-background-clip:text;background-clip:text}.examples .scalar-card-footer{--scalar-background-3: transparent;padding-top:0}.section-flare{width:100vw;height:550px;position:relative}.section-flare-item:nth-of-type(1){position:absolute;width:100vw;height:550px;--stripesDark: repeating-linear-gradient( 100deg, #000 0%, #000 7%, transparent 10%, transparent 12%, #000 16% );--rainbow: repeating-linear-gradient( 100deg, #fff 10%, #fff 16%, #fff 22%, #fff 30% );background-image:var(--stripesDark),var(--rainbow);background-size:300%,200%;background-position:50% 50%,50% 50%;filter:invert(100%);-webkit-mask-image:radial-gradient(ellipse at 100% 0%,black 40%,transparent 70%);mask-image:radial-gradient(ellipse at 100% 0%,black 40%,transparent 70%);pointer-events:none;opacity:.07}.dark-mode .section-flare-item:nth-of-type(1){background-image:var(--stripesDark),var(--rainbow);filter:opacity(50%) saturate(200%);opacity:.25;height:350px}.section-flare-item:nth-of-type(1):after{content:"";position:absolute;top:0;right:0;bottom:0;left:0;background-image:var(--stripesDark),var(--rainbow);background-size:200%,100%;background-attachment:fixed;mix-blend-mode:difference}.dark-mode .section-flare:after{background-image:var(--stripesDark),var(--rainbow)}.section-flare-item:nth-of-type(2){--star-color: #fff;--star-color2: #fff;--star-color3: #fff;width:100%;height:100%;position:absolute;background-image:radial-gradient(2px 2px at 20px 30px,var(--star-color2),rgba(0,0,0,0)),radial-gradient(2px 2px at 40px 70px,var(--star-color),rgba(0,0,0,0)),radial-gradient(2px 2px at 50px 160px,var(--star-color3),rgba(0,0,0,0)),radial-gradient(2px 2px at 90px 40px,var(--star-color),rgba(0,0,0,0)),radial-gradient(2px 2px at 130px 80px,var(--star-color),rgba(0,0,0,0)),radial-gradient(2px 2px at 160px 120px,var(--star-color3),rgba(0,0,0,0));background-repeat:repeat;background-size:200px 200px;-webkit-mask-image:radial-gradient(ellipse at 100% 0%,black 40%,transparent 70%);mask-image:radial-gradient(ellipse at 100% 0%,black 40%,transparent 70%);opacity:.2}',
        saturn: ".light-mode{--scalar-background-1: #f3f3ee;--scalar-background-2: #e8e8e3;--scalar-background-3: #e4e4df;--scalar-border-color: rgba(215, 215, 206, .5);--scalar-color-1: #2a2f45;--scalar-color-2: #757575;--scalar-color-3: #8e8e8e;--scalar-color-accent: #1763a6;--scalar-background-accent: #1f648e1f}.dark-mode{--scalar-background-1: #09090b;--scalar-background-2: #18181b;--scalar-background-3: #2c2c30;--scalar-border-color: rgba(255, 255, 255, .12);--scalar-color-1: #fafafa;--scalar-color-2: rgb(161, 161, 170);--scalar-color-3: rgba(255, 255, 255, .533);--scalar-color-accent: #4eb3ec;--scalar-background-accent: #8ab4f81f}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-active-background: var(--scalar-background-3);--scalar-sidebar-color-active: var(--scalar-color-1);--scalar-sidebar-search-background: var(--scalar-background-1);--scalar-sidebar-search-border-color: var(--scalar-border-color);--scalar-sidebar-search-color: var(--scalar-color-3)}.light-mode{--scalar-color-green: #17803d;--scalar-color-red: #e10909;--scalar-color-yellow: #edbe20;--scalar-color-blue: #1763a6;--scalar-color-orange: #e25b09;--scalar-color-purple: #5c3993;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: #30a159;--scalar-color-red: #dc1b19;--scalar-color-yellow: #eec644;--scalar-color-blue: #2b7abf;--scalar-color-orange: #f07528;--scalar-color-purple: #7a59b1;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}.dark-mode h2.t-editor__heading,.dark-mode .t-editor__page-title h1,.dark-mode h1.section-header,.dark-mode .markdown h1,.dark-mode .markdown h2,.dark-mode .markdown h3,.dark-mode .markdown h4,.dark-mode .markdown h5,.dark-mode .markdown h6{-webkit-text-fill-color:transparent;background-image:linear-gradient(to right bottom,#fff 30%,#ffffff61);-webkit-background-clip:text;background-clip:text}",
        kepler: ".light-mode{--scalar-color-1: #2a2f45;--scalar-color-2: #757575;--scalar-color-3: #8e8e8e;--scalar-color-accent: #7070ff;--scalar-background-1: #fff;--scalar-background-2: #f6f6f6;--scalar-background-3: #e7e7e7;--scalar-background-accent: #7070ff1f;--scalar-border-color: rgba(0, 0, 0, .1);--scalar-code-language-color-supersede: var(--scalar-color-3)}.dark-mode{--scalar-color-1: #f7f8f8;--scalar-color-2: rgb(180, 188, 208);--scalar-color-3: #b4bcd099;--scalar-color-accent: #828fff;--scalar-background-1: #000212;--scalar-background-2: #0d0f1e;--scalar-background-3: #232533;--scalar-background-accent: #8ab4f81f;--scalar-border-color: #242537;--scalar-code-language-color-supersede: var(--scalar-color-3)}.light-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-active-background: var(--scalar-background-accent);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-color-active: var(--scalar-color-accent);--scalar-sidebar-search-background: rgba(0, 0, 0, .05);--scalar-sidebar-search-border-color: 1px solid rgba(0, 0, 0, .05);--scalar-sidebar-search-color: var(--scalar-color-3);--scalar-background-2: rgba(0, 0, 0, .03)}.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-active-background: rgba(255, 255, 255, .1);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-color-active: var(--scalar-color-accent);--scalar-sidebar-search-background: rgba(255, 255, 255, .1);--scalar-sidebar-search-border-color: 1px solid rgba(255, 255, 255, .05);--scalar-sidebar-search-color: var(--scalar-color-3)}.light-mode{--scalar-color-green: #069061;--scalar-color-red: #ef0006;--scalar-color-yellow: #edbe20;--scalar-color-blue: #0082d0;--scalar-color-orange: #fb892c;--scalar-color-purple: #5203d1;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: #00b648;--scalar-color-red: #dc1b19;--scalar-color-yellow: #ffc90d;--scalar-color-blue: #4eb3ec;--scalar-color-orange: #ff8d4d;--scalar-color-purple: #b191f9;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}.dark-mode h2.t-editor__heading,.dark-mode .t-editor__page-title h1,.dark-mode h1.section-header,.dark-mode .markdown h1,.dark-mode .markdown h2,.dark-mode .markdown h3,.dark-mode .markdown h4,.dark-mode .markdown h5,.dark-mode .markdown h6{-webkit-text-fill-color:transparent;background-image:linear-gradient(to right bottom,#fff 30%,#ffffff61);-webkit-background-clip:text;background-clip:text}.sidebar-search{-webkit-backdrop-filter:blur(12px);backdrop-filter:blur(12px)}@keyframes headerbackground{0%{background:transparent;-webkit-backdrop-filter:none;backdrop-filter:none}to{background:var(--header-background-1);-webkit-backdrop-filter:blur(12px);backdrop-filter:blur(12px)}}.dark-mode .scalar-card{background:#ffffff0d!important}.dark-mode .scalar-card *{--scalar-background-2: transparent !important;--scalar-background-1: transparent !important}.light-mode .dark-mode.scalar-card *,.light-mode .dark-mode.scalar-card{--scalar-background-1: #0d0f1e !important;--scalar-background-2: #0d0f1e !important;--scalar-background-3: #191b29 !important}.light-mode .dark-mode.scalar-card{background:#191b29!important}.badge{box-shadow:0 0 0 1px var(--scalar-border-color);margin-right:6px}.table-row.required-parameter .table-row-item:nth-of-type(2):after{background:transparent;box-shadow:none}.section-flare{width:100vw;background:radial-gradient(ellipse 80% 50% at 50% -20%,rgba(120,119,198,.3),transparent);height:100vh}",
        mars: ":root{--scalar-text-decoration: underline;--scalar-text-decoration-hover: underline}.light-mode{--scalar-background-1: #f9f6f0;--scalar-background-2: #f2efe8;--scalar-background-3: #e9e7e2;--scalar-border-color: rgba(203, 165, 156, .6);--scalar-color-1: #c75549;--scalar-color-2: #c75549;--scalar-color-3: #c75549;--scalar-color-accent: #c75549;--scalar-background-accent: #dcbfa81f;--scalar-code-language-color-supersede: var(--scalar-color-1)}.dark-mode{--scalar-background-1: #140507;--scalar-background-2: #20090c;--scalar-background-3: #321116;--scalar-border-color: rgba(255, 255, 255, .1);--scalar-color-1: rgba(255, 255, 255, .9);--scalar-color-2: rgba(255, 255, 255, .62);--scalar-color-3: rgba(255, 255, 255, .44);--scalar-color-accent: rgba(255, 255, 255, .9);--scalar-background-accent: #441313;--scalar-code-language-color-supersede: var(--scalar-color-1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--scalar-sidebar-background-1: var(--scalar-background-1);--scalar-sidebar-color-1: var(--scalar-color-1);--scalar-sidebar-color-2: var(--scalar-color-2);--scalar-sidebar-border-color: var(--scalar-border-color);--scalar-sidebar-item-hover-color: currentColor;--scalar-sidebar-item-hover-background: var(--scalar-background-2);--scalar-sidebar-item-active-background: var(--scalar-background-3);--scalar-sidebar-color-active: var(--scalar-color-accent);--scalar-sidebar-search-background: rgba(255, 255, 255, .1);--scalar-sidebar-search-color: var(--scalar-color-3);--scalar-sidebar-search-border-color: var(--scalar-border-color);z-index:1}.light-mode{--scalar-color-green: #09533a;--scalar-color-red: #aa181d;--scalar-color-yellow: #ab8d2b;--scalar-color-blue: #19689a;--scalar-color-orange: #b26c34;--scalar-color-purple: #4c2191;--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9)}.dark-mode{--scalar-color-green: rgba(69, 255, 165, .823);--scalar-color-red: #ff8589;--scalar-color-yellow: #ffcc4d;--scalar-color-blue: #6bc1fe;--scalar-color-orange: #f98943;--scalar-color-purple: #b191f9;--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black}.dark-mode h2.t-editor__heading,.dark-mode .t-editor__page-title h1,.dark-mode h1.section-header,.dark-mode .markdown h1,.dark-mode .markdown h2,.dark-mode .markdown h3,.dark-mode .markdown h4,.dark-mode .markdown h5,.dark-mode .markdown h6{-webkit-text-fill-color:transparent;background-image:linear-gradient(to right bottom,#fff 30%,#ffffff61);-webkit-background-clip:text;background-clip:text}.light-mode .t-doc__sidebar{--scalar-sidebar-search-background: white}.examples .scalar-card-footer{--scalar-background-3: transparent;padding-top:0}.section-flare-item:nth-of-type(1){background:#d25019;width:80vw;height:500px;margin-top:-150px;border-radius:50%;filter:blur(100px);z-index:0}.light-mode .section-flare{display:none}.section-flare{top:-150px!important;height:100vh;right:-400px!important;left:initial}"
    }
      , gl = e=>"none" === e ? "" : ml[e || "default"] ?? dl
      , bl = (e,t)=>{
        const {variables: n=!0, fonts: r=!0, layer: o="scalar-theme"} = t ?? {}
          , i = [gl(e), n ? ':root{--scalar-border-width: 1px;--scalar-radius: 3px;--scalar-radius-lg: 6px;--scalar-radius-xl: 8px;--scalar-font: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;--scalar-font-code: "JetBrains Mono", ui-monospace, Menlo, Monaco, "Cascadia Mono", "Segoe UI Mono", "Roboto Mono", "Oxygen Mono", "Ubuntu Monospace", "Source Code Pro", "Fira Mono", "Droid Sans Mono", "Courier New", monospace;--scalar-heading-1: 40px;--scalar-page-description: 24px;--scalar-heading-2: 24px;--scalar-heading-3: 20px;--scalar-heading-4: 16px;--scalar-heading-5: 16px;--scalar-heading-6: 16px;--scalar-paragraph: 16px;--scalar-small: 14px;--scalar-mini: 13px;--scalar-micro: 12px;--scalar-bold: 600;--scalar-semibold: 500;--scalar-regular: 400;--scalar-font-size-1: 24px;--scalar-font-size-2: 16px;--scalar-font-size-3: 14px;--scalar-font-size-4: 13px;--scalar-font-size-5: 12px;--scalar-font-size-6: 12px;--scalar-font-size-7: 10px;--scalar-line-height-1: 32px;--scalar-line-height-2: 24px;--scalar-line-height-3: 20px;--scalar-line-height-4: 18px;--scalar-line-height-5: 16px;--scalar-font-medium: 500;--scalar-font-bold: 700;--scalar-text-decoration: none;--scalar-text-decoration-hover: underline}.dark-mode{color-scheme:dark;--scalar-scrollbar-color: rgba(255, 255, 255, .18);--scalar-scrollbar-color-active: rgba(255, 255, 255, .36);--scalar-button-1: rgba(255, 255, 255, 1);--scalar-button-1-hover: rgba(255, 255, 255, .9);--scalar-button-1-color: black;--scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, .1);--scalar-shadow-2: rgba(15, 15, 15, .2) 0px 3px 6px, rgba(15, 15, 15, .4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, .1);--scalar-sidebar-indent-border: transparent;--scalar-sidebar-indent-border-hover: transparent;--scalar-sidebar-indent-border-active: transparent}.light-mode{color-scheme:light;--scalar-scrollbar-color-active: rgba(0, 0, 0, .36);--scalar-scrollbar-color: rgba(0, 0, 0, .18);--scalar-button-1: rgba(0, 0, 0, 1);--scalar-button-1-hover: rgba(0, 0, 0, .8);--scalar-button-1-color: rgba(255, 255, 255, .9);--scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, .11);--scalar-shadow-2: rgba(0, 0, 0, .08) 0px 13px 20px 0px, rgba(0, 0, 0, .08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;--scalar-sidebar-indent-border: transparent;--scalar-sidebar-indent-border-hover: transparent;--scalar-sidebar-indent-border-active: transparent}.light-mode .dark-mode{color-scheme:dark!important}@media (max-width: 460px){:root{--scalar-font-size-1: 22px;--scalar-font-size-2: 14px;--scalar-font-size-3: 12px}}@media (max-width: 720px){:root{--scalar-heading-1: 24px;--scalar-page-description: 20px}}' : "", r ? '@font-face{font-family:Inter;font-style:normal;font-weight:100 900;font-display:swap;src:url(https://fonts.scalar.com/inter-cyrillic-ext.woff2) format("woff2");unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:Inter;font-style:normal;font-weight:100 900;font-display:swap;src:url(https://fonts.scalar.com/inter-cyrillic.woff2) format("woff2");unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:Inter;font-style:normal;font-weight:100 900;font-display:swap;src:url(https://fonts.scalar.com/inter-greek-ext.woff2) format("woff2");unicode-range:U+1F00-1FFF}@font-face{font-family:Inter;font-style:normal;font-weight:100 900;font-display:swap;src:url(https://fonts.scalar.com/inter-greek.woff2) format("woff2");unicode-range:U+0370-0377,U+037A-037F,U+0384-038A,U+038C,U+038E-03A1,U+03A3-03FF}@font-face{font-family:Inter;font-style:normal;font-weight:100 900;font-display:swap;src:url(https://fonts.scalar.com/inter-vietnamese.woff2) format("woff2");unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:Inter;font-style:normal;font-weight:100 900;font-display:swap;src:url(https://fonts.scalar.com/inter-latin-ext.woff2) format("woff2");unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:Inter;font-style:normal;font-weight:100 900;font-display:swap;src:url(https://fonts.scalar.com/inter-latin.woff2) format("woff2");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:JetBrains Mono;font-style:normal;font-weight:400;src:url(https://fonts.scalar.com/mono-cyrillic-ext.woff2) format("woff2");unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:JetBrains Mono;font-style:normal;font-weight:400;src:url(https://fonts.scalar.com/mono-cyrillic.woff2) format("woff2");unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:JetBrains Mono;font-style:normal;font-weight:400;src:url(https://fonts.scalar.com/mono-greek.woff2) format("woff2");unicode-range:U+0370-0377,U+037A-037F,U+0384-038A,U+038C,U+038E-03A1,U+03A3-03FF}@font-face{font-family:JetBrains Mono;font-style:normal;font-weight:400;src:url(https://fonts.scalar.com/mono-vietnamese.woff2) format("woff2");unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:JetBrains Mono;font-style:normal;font-weight:400;src:url(https://fonts.scalar.com/mono-latin-ext.woff2) format("woff2");unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20C0,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:JetBrains Mono;font-style:normal;font-weight:400;src:url(https://fonts.scalar.com/mono-latin.woff2) format("woff2");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}' : ""].join("");
        return o ? `@layer ${o} {\n${i}}` : i
    }
    ;
    function Ol(e) {
        return !!oe() && (ie(e),
        !0)
    }
    function vl(e) {
        return "function" == typeof e ? e() : Ct(e)
    }
    const yl = "undefined" != typeof window && "undefined" != typeof document;
    "undefined" != typeof WorkerGlobalScope && (globalThis,
    WorkerGlobalScope);
    const wl = e=>null != e
      , _l = Object.prototype.toString
      , kl = e=>"[object Object]" === _l.call(e)
      , Sl = ()=>{}
    ;
    function El(e, t=200, n={}) {
        return function(e, t) {
            return function(...n) {
                return new Promise(((r,o)=>{
                    Promise.resolve(e((()=>t.apply(this, n)), {
                        fn: t,
                        thisArg: this,
                        args: n
                    })).then(r).catch(o)
                }
                ))
            }
        }(function(e, t={}) {
            let n, r, o = Sl;
            const i = e=>{
                clearTimeout(e),
                o(),
                o = Sl
            }
            ;
            return a=>{
                const s = vl(e)
                  , l = vl(t.maxWait);
                return n && i(n),
                s <= 0 || void 0 !== l && l <= 0 ? (r && (i(r),
                r = null),
                Promise.resolve(a())) : new Promise(((e,c)=>{
                    o = t.rejectOnCancel ? c : e,
                    l && !r && (r = setTimeout((()=>{
                        n && i(n),
                        r = null,
                        e(a())
                    }
                    ), l)),
                    n = setTimeout((()=>{
                        r && i(r),
                        r = null,
                        e(a())
                    }
                    ), s)
                }
                ))
            }
        }(t, n), e)
    }
    function xl(e, t, n) {
        return zr(e, ((e,n,r)=>{
            e && t(e, n, r)
        }
        ), {
            ...n,
            once: !1
        })
    }
    function Tl(e, t, n) {
        let r;
        r = St(n) ? {
            evaluating: n
        } : {};
        const {lazy: o=!1, evaluating: i, shallow: a=!0, onError: s=Sl} = r
          , l = Et(!o)
          , c = a ? xt(t) : Et(t);
        let u = 0;
        return Fr((async t=>{
            if (!l.value)
                return;
            u++;
            const n = u;
            let r = !1;
            i && Promise.resolve().then((()=>{
                i.value = !0
            }
            ));
            try {
                const o = await e((e=>{
                    t((()=>{
                        i && (i.value = !1),
                        r || e()
                    }
                    ))
                }
                ));
                n === u && (c.value = o)
            } catch (Aa) {
                s(Aa)
            } finally {
                i && n === u && (i.value = !1),
                r = !0
            }
        }
        )),
        o ? ei((()=>(l.value = !0,
        c.value))) : c
    }
    function Al(e) {
        var t;
        const n = vl(e);
        return null != (t = null == n ? void 0 : n.$el) ? t : n
    }
    const Cl = yl ? window : void 0;
    function Pl(...e) {
        let t, n, r, o;
        if ("string" == typeof e[0] || Array.isArray(e[0]) ? ([n,r,o] = e,
        t = Cl) : [t,n,r,o] = e,
        !t)
            return Sl;
        Array.isArray(n) || (n = [n]),
        Array.isArray(r) || (r = [r]);
        const i = []
          , a = ()=>{
            i.forEach((e=>e())),
            i.length = 0
        }
          , s = zr((()=>[Al(t), vl(o)]), (([e,t])=>{
            if (a(),
            !e)
                return;
            const o = kl(t) ? {
                ...t
            } : t;
            i.push(...n.flatMap((t=>r.map((n=>((e,t,n,r)=>(e.addEventListener(t, n, r),
            ()=>e.removeEventListener(t, n, r)))(e, t, n, o))))))
        }
        ), {
            immediate: !0,
            flush: "post"
        })
          , l = ()=>{
            s(),
            a()
        }
        ;
        return Ol(l),
        l
    }
    function Dl(e) {
        const t = function() {
            const e = Et(!1)
              , t = Uo();
            return t && Sn((()=>{
                e.value = !0
            }
            ), t),
            e
        }();
        return ei((()=>(t.value,
        Boolean(e()))))
    }
    function Rl(e, t={}) {
        const {window: n=Cl} = t
          , r = Dl((()=>n && "matchMedia"in n && "function" == typeof n.matchMedia));
        let o;
        const i = Et(!1)
          , a = e=>{
            i.value = e.matches
        }
          , s = ()=>{
            o && ("removeEventListener"in o ? o.removeEventListener("change", a) : o.removeListener(a))
        }
          , l = Fr((()=>{
            r.value && (s(),
            o = n.matchMedia(vl(e)),
            "addEventListener"in o ? o.addEventListener("change", a) : o.addListener(a),
            i.value = o.matches)
        }
        ));
        return Ol((()=>{
            l(),
            s(),
            o = void 0
        }
        )),
        i
    }
    const Nl = new Map;
    function $l(e) {
        const t = oe();
        function n(n) {
            var o;
            const i = Nl.get(e) || new Set;
            i.add(n),
            Nl.set(e, i);
            const a = ()=>r(n);
            return null == (o = null == t ? void 0 : t.cleanups) || o.push(a),
            a
        }
        function r(t) {
            const n = Nl.get(e);
            n && (n.delete(t),
            n.size || o())
        }
        function o() {
            Nl.delete(e)
        }
        return {
            on: n,
            once: function(e) {
                return n((function t(...n) {
                    r(t),
                    e(...n)
                }
                ))
            },
            off: r,
            emit: function(t, n) {
                var r;
                null == (r = Nl.get(e)) || r.forEach((e=>e(t, n)))
            },
            reset: o
        }
    }
    const Il = {
        ctrl: "control",
        command: "meta",
        cmd: "meta",
        option: "alt",
        up: "arrowup",
        down: "arrowdown",
        left: "arrowleft",
        right: "arrowright"
    };
    function Ml(e={}) {
        const {reactive: t=!1, target: n=Cl, aliasMap: r=Il, passive: o=!0, onEventFired: i=Sl} = e
          , a = ut(new Set)
          , s = {
            toJSON: ()=>({}),
            current: a
        }
          , l = t ? ut(s) : s
          , c = new Set
          , u = new Set;
        function d(e, n) {
            e in l && (t ? l[e] = n : l[e].value = n)
        }
        function p() {
            a.clear();
            for (const e of u)
                d(e, !1)
        }
        function h(e, t) {
            var n, r;
            const o = null == (n = e.key) ? void 0 : n.toLowerCase()
              , i = [null == (r = e.code) ? void 0 : r.toLowerCase(), o].filter(Boolean);
            o && (t ? a.add(o) : a.delete(o));
            for (const a of i)
                u.add(a),
                d(a, t);
            "meta" !== o || t ? "function" == typeof e.getModifierState && e.getModifierState("Meta") && t && [...a, ...i].forEach((e=>c.add(e))) : (c.forEach((e=>{
                a.delete(e),
                d(e, !1)
            }
            )),
            c.clear())
        }
        Pl(n, "keydown", (e=>(h(e, !0),
        i(e))), {
            passive: o
        }),
        Pl(n, "keyup", (e=>(h(e, !1),
        i(e))), {
            passive: o
        }),
        Pl("blur", p, {
            passive: !0
        }),
        Pl("focus", p, {
            passive: !0
        });
        const f = new Proxy(l,{
            get(e, n, o) {
                if ("string" != typeof n)
                    return Reflect.get(e, n, o);
                if ((n = n.toLowerCase())in r && (n = r[n]),
                !(n in l))
                    if (/[+_-]/.test(n)) {
                        const e = n.split(/[+_-]/g).map((e=>e.trim()));
                        l[n] = ei((()=>e.every((e=>vl(f[e])))))
                    } else
                        l[n] = Et(!1);
                const i = Reflect.get(e, n, o);
                return t ? vl(i) : i
            }
        });
        return f
    }
    const Ll = ["GET", "POST", "PUT", "HEAD", "DELETE", "PATCH", "OPTIONS", "CONNECT", "TRACE"];
    function Ql(e) {
        return Ll.includes(e)
    }
    const Bl = {
        POST: "var(--scalar-color-green)",
        DELETE: "var(--scalar-color-red)",
        PATCH: "var(--scalar-color-yellow)",
        GET: "var(--scalar-color-blue)",
        PUT: "var(--scalar-color-orange)",
        OPTIONS: "var(--scalar-color-purple)",
        HEAD: "var(--scalar-color-2)",
        CONNECT: "var(--scalar-color-2)",
        TRACE: "var(--scalar-color-2)"
    }
      , Ul = {
        POST: "POST",
        DELETE: "DEL",
        PATCH: "PATCH",
        GET: "GET",
        PUT: "PUT",
        OPTIONS: "OPTS",
        HEAD: "HEAD",
        CONNECT: "CONN",
        TRACE: "TRACE"
    }
      , Fl = Ln({
        __name: "HttpMethod",
        props: {
            as: {},
            property: {},
            short: {
                type: Boolean
            },
            method: {}
        },
        setup(e) {
            const t = e
              , n = ei((()=>t.method.trim().toUpperCase()))
              , r = ei((()=>Ql(n.value) ? Ul[n.value] : n.value.slice(0, 4)))
              , o = ei((()=>Ql(n.value) ? Bl[n.value] : "var(--scalar-color-ghost)"));
            return (e,t)=>(mo(),
            yo(On(e.as ?? "span"), {
                style: F({
                    [e.property || "color"]: o.value
                })
            }, {
                default: dn((()=>[Fn(e.$slots, "default", W(To({
                    normalized: n.value,
                    abbreviated: r.value,
                    color: o.value
                })), (()=>[Co(K(e.short ? r.value : n.value), 1)]))])),
                _: 3
            }, 8, ["style"]))
        }
    });
    function jl(e) {
        var t, n, r = "";
        if ("string" == typeof e || "number" == typeof e)
            r += e;
        else if ("object" == typeof e)
            if (Array.isArray(e))
                for (t = 0; t < e.length; t++)
                    e[t] && (n = jl(e[t])) && (r && (r += " "),
                    r += n);
            else
                for (t in e)
                    e[t] && (r && (r += " "),
                    r += t);
        return r
    }
    function zl() {
        for (var e, t, n = 0, r = ""; n < arguments.length; )
            (e = arguments[n++]) && (t = jl(e)) && (r && (r += " "),
            r += t);
        return r
    }
    const ql = e=>"boolean" == typeof e ? "".concat(e) : 0 === e ? "0" : e
      , Hl = "-";
    function Zl(e) {
        const t = function(e) {
            const {theme: t, prefix: n} = e
              , r = {
                nextPart: new Map,
                validators: []
            }
              , o = function(e, t) {
                if (!t)
                    return e;
                return e.map((([e,n])=>[e, n.map((e=>"string" == typeof e ? t + e : "object" == typeof e ? Object.fromEntries(Object.entries(e).map((([e,n])=>[t + e, n]))) : e))]))
            }(Object.entries(e.classGroups), n);
            return o.forEach((([e,n])=>{
                Vl(n, r, e, t)
            }
            )),
            r
        }(e)
          , {conflictingClassGroups: n, conflictingClassGroupModifiers: r} = e;
        return {
            getClassGroupId: function(e) {
                const n = e.split(Hl);
                return "" === n[0] && 1 !== n.length && n.shift(),
                Wl(n, t) || function(e) {
                    if (Xl.test(e)) {
                        const t = Xl.exec(e)[1]
                          , n = null == t ? void 0 : t.substring(0, t.indexOf(":"));
                        if (n)
                            return "arbitrary.." + n
                    }
                }(e)
            },
            getConflictingClassGroupIds: function(e, t) {
                const o = n[e] || [];
                return t && r[e] ? [...o, ...r[e]] : o
            }
        }
    }
    function Wl(e, t) {
        var n;
        if (0 === e.length)
            return t.classGroupId;
        const r = e[0]
          , o = t.nextPart.get(r)
          , i = o ? Wl(e.slice(1), o) : void 0;
        if (i)
            return i;
        if (0 === t.validators.length)
            return;
        const a = e.join(Hl);
        return null == (n = t.validators.find((({validator: e})=>e(a)))) ? void 0 : n.classGroupId
    }
    const Xl = /^\[(.+)\]$/;
    function Vl(e, t, n, r) {
        e.forEach((e=>{
            if ("string" != typeof e) {
                if ("function" == typeof e)
                    return e.isThemeGetter ? void Vl(e(r), t, n, r) : void t.validators.push({
                        validator: e,
                        classGroupId: n
                    });
                Object.entries(e).forEach((([e,o])=>{
                    Vl(o, Gl(t, e), n, r)
                }
                ))
            } else {
                ("" === e ? t : Gl(t, e)).classGroupId = n
            }
        }
        ))
    }
    function Gl(e, t) {
        let n = e;
        return t.split(Hl).forEach((e=>{
            n.nextPart.has(e) || n.nextPart.set(e, {
                nextPart: new Map,
                validators: []
            }),
            n = n.nextPart.get(e)
        }
        )),
        n
    }
    function Yl(e) {
        if (e < 1)
            return {
                get: ()=>{}
                ,
                set: ()=>{}
            };
        let t = 0
          , n = new Map
          , r = new Map;
        function o(o, i) {
            n.set(o, i),
            t++,
            t > e && (t = 0,
            r = n,
            n = new Map)
        }
        return {
            get(e) {
                let t = n.get(e);
                return void 0 !== t ? t : void 0 !== (t = r.get(e)) ? (o(e, t),
                t) : void 0
            },
            set(e, t) {
                n.has(e) ? n.set(e, t) : o(e, t)
            }
        }
    }
    const Kl = "!";
    function Jl(e) {
        const t = e.separator
          , n = 1 === t.length
          , r = t[0]
          , o = t.length;
        return function(e) {
            const i = [];
            let a, s = 0, l = 0;
            for (let d = 0; d < e.length; d++) {
                let c = e[d];
                if (0 === s) {
                    if (c === r && (n || e.slice(d, d + o) === t)) {
                        i.push(e.slice(l, d)),
                        l = d + o;
                        continue
                    }
                    if ("/" === c) {
                        a = d;
                        continue
                    }
                }
                "[" === c ? s++ : "]" === c && s--
            }
            const c = 0 === i.length ? e : e.substring(l)
              , u = c.startsWith(Kl);
            return {
                modifiers: i,
                hasImportantModifier: u,
                baseClassName: u ? c.substring(1) : c,
                maybePostfixModifierPosition: a && a > l ? a - l : void 0
            }
        }
    }
    const ec = /\s+/;
    function tc() {
        let e, t, n = 0, r = "";
        for (; n < arguments.length; )
            (e = arguments[n++]) && (t = nc(e)) && (r && (r += " "),
            r += t);
        return r
    }
    function nc(e) {
        if ("string" == typeof e)
            return e;
        let t, n = "";
        for (let r = 0; r < e.length; r++)
            e[r] && (t = nc(e[r])) && (n && (n += " "),
            n += t);
        return n
    }
    function rc(e, ...t) {
        let n, r, o, i = function(s) {
            const l = t.reduce(((e,t)=>t(e)), e());
            return n = function(e) {
                return {
                    cache: Yl(e.cacheSize),
                    splitModifiers: Jl(e),
                    ...Zl(e)
                }
            }(l),
            r = n.cache.get,
            o = n.cache.set,
            i = a,
            a(s)
        };
        function a(e) {
            const t = r(e);
            if (t)
                return t;
            const i = function(e, t) {
                const {splitModifiers: n, getClassGroupId: r, getConflictingClassGroupIds: o} = t
                  , i = new Set;
                return e.trim().split(ec).map((e=>{
                    const {modifiers: t, hasImportantModifier: o, baseClassName: i, maybePostfixModifierPosition: a} = n(e);
                    let s = r(a ? i.substring(0, a) : i)
                      , l = Boolean(a);
                    if (!s) {
                        if (!a)
                            return {
                                isTailwindClass: !1,
                                originalClassName: e
                            };
                        if (s = r(i),
                        !s)
                            return {
                                isTailwindClass: !1,
                                originalClassName: e
                            };
                        l = !1
                    }
                    const c = function(e) {
                        if (e.length <= 1)
                            return e;
                        const t = [];
                        let n = [];
                        return e.forEach((e=>{
                            "[" === e[0] ? (t.push(...n.sort(), e),
                            n = []) : n.push(e)
                        }
                        )),
                        t.push(...n.sort()),
                        t
                    }(t).join(":");
                    return {
                        isTailwindClass: !0,
                        modifierId: o ? c + Kl : c,
                        classGroupId: s,
                        originalClassName: e,
                        hasPostfixModifier: l
                    }
                }
                )).reverse().filter((e=>{
                    if (!e.isTailwindClass)
                        return !0;
                    const {modifierId: t, classGroupId: n, hasPostfixModifier: r} = e
                      , a = t + n;
                    return !i.has(a) && (i.add(a),
                    o(n, r).forEach((e=>i.add(t + e))),
                    !0)
                }
                )).reverse().map((e=>e.originalClassName)).join(" ")
            }(e, n);
            return o(e, i),
            i
        }
        return function() {
            return i(tc.apply(null, arguments))
        }
    }
    function oc(e) {
        const t = t=>t[e] || [];
        return t.isThemeGetter = !0,
        t
    }
    const ic = /^\[(?:([a-z-]+):)?(.+)\]$/i
      , ac = /^\d+\/\d+$/
      , sc = new Set(["px", "full", "screen"])
      , lc = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/
      , cc = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/
      , uc = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/
      , dc = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/
      , pc = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
    function hc(e) {
        return mc(e) || sc.has(e) || ac.test(e)
    }
    function fc(e) {
        return Ac(e, "length", Cc)
    }
    function mc(e) {
        return Boolean(e) && !Number.isNaN(Number(e))
    }
    function gc(e) {
        return Ac(e, "number", mc)
    }
    function bc(e) {
        return Boolean(e) && Number.isInteger(Number(e))
    }
    function Oc(e) {
        return e.endsWith("%") && mc(e.slice(0, -1))
    }
    function vc(e) {
        return ic.test(e)
    }
    function yc(e) {
        return lc.test(e)
    }
    const wc = new Set(["length", "size", "percentage"]);
    function _c(e) {
        return Ac(e, wc, Pc)
    }
    function kc(e) {
        return Ac(e, "position", Pc)
    }
    const Sc = new Set(["image", "url"]);
    function Ec(e) {
        return Ac(e, Sc, Rc)
    }
    function xc(e) {
        return Ac(e, "", Dc)
    }
    function Tc() {
        return !0
    }
    function Ac(e, t, n) {
        const r = ic.exec(e);
        return !!r && (r[1] ? "string" == typeof t ? r[1] === t : t.has(r[1]) : n(r[2]))
    }
    function Cc(e) {
        return cc.test(e) && !uc.test(e)
    }
    function Pc() {
        return !1
    }
    function Dc(e) {
        return dc.test(e)
    }
    function Rc(e) {
        return pc.test(e)
    }
    function Nc() {
        const e = oc("colors")
          , t = oc("spacing")
          , n = oc("blur")
          , r = oc("brightness")
          , o = oc("borderColor")
          , i = oc("borderRadius")
          , a = oc("borderSpacing")
          , s = oc("borderWidth")
          , l = oc("contrast")
          , c = oc("grayscale")
          , u = oc("hueRotate")
          , d = oc("invert")
          , p = oc("gap")
          , h = oc("gradientColorStops")
          , f = oc("gradientColorStopPositions")
          , m = oc("inset")
          , g = oc("margin")
          , b = oc("opacity")
          , O = oc("padding")
          , v = oc("saturate")
          , y = oc("scale")
          , w = oc("sepia")
          , _ = oc("skew")
          , k = oc("space")
          , S = oc("translate")
          , E = ()=>["auto", vc, t]
          , x = ()=>[vc, t]
          , T = ()=>["", hc, fc]
          , A = ()=>["auto", mc, vc]
          , C = ()=>["", "0", vc]
          , P = ()=>[mc, gc]
          , D = ()=>[mc, vc];
        return {
            cacheSize: 500,
            separator: ":",
            theme: {
                colors: [Tc],
                spacing: [hc, fc],
                blur: ["none", "", yc, vc],
                brightness: P(),
                borderColor: [e],
                borderRadius: ["none", "", "full", yc, vc],
                borderSpacing: x(),
                borderWidth: T(),
                contrast: P(),
                grayscale: C(),
                hueRotate: D(),
                invert: C(),
                gap: x(),
                gradientColorStops: [e],
                gradientColorStopPositions: [Oc, fc],
                inset: E(),
                margin: E(),
                opacity: P(),
                padding: x(),
                saturate: P(),
                scale: P(),
                sepia: C(),
                skew: D(),
                space: x(),
                translate: x()
            },
            classGroups: {
                aspect: [{
                    aspect: ["auto", "square", "video", vc]
                }],
                container: ["container"],
                columns: [{
                    columns: [yc]
                }],
                "break-after": [{
                    "break-after": ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"]
                }],
                "break-before": [{
                    "break-before": ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"]
                }],
                "break-inside": [{
                    "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
                }],
                "box-decoration": [{
                    "box-decoration": ["slice", "clone"]
                }],
                box: [{
                    box: ["border", "content"]
                }],
                display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
                float: [{
                    float: ["right", "left", "none", "start", "end"]
                }],
                clear: [{
                    clear: ["left", "right", "both", "none", "start", "end"]
                }],
                isolation: ["isolate", "isolation-auto"],
                "object-fit": [{
                    object: ["contain", "cover", "fill", "none", "scale-down"]
                }],
                "object-position": [{
                    object: ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top", vc]
                }],
                overflow: [{
                    overflow: ["auto", "hidden", "clip", "visible", "scroll"]
                }],
                "overflow-x": [{
                    "overflow-x": ["auto", "hidden", "clip", "visible", "scroll"]
                }],
                "overflow-y": [{
                    "overflow-y": ["auto", "hidden", "clip", "visible", "scroll"]
                }],
                overscroll: [{
                    overscroll: ["auto", "contain", "none"]
                }],
                "overscroll-x": [{
                    "overscroll-x": ["auto", "contain", "none"]
                }],
                "overscroll-y": [{
                    "overscroll-y": ["auto", "contain", "none"]
                }],
                position: ["static", "fixed", "absolute", "relative", "sticky"],
                inset: [{
                    inset: [m]
                }],
                "inset-x": [{
                    "inset-x": [m]
                }],
                "inset-y": [{
                    "inset-y": [m]
                }],
                start: [{
                    start: [m]
                }],
                end: [{
                    end: [m]
                }],
                top: [{
                    top: [m]
                }],
                right: [{
                    right: [m]
                }],
                bottom: [{
                    bottom: [m]
                }],
                left: [{
                    left: [m]
                }],
                visibility: ["visible", "invisible", "collapse"],
                z: [{
                    z: ["auto", bc, vc]
                }],
                basis: [{
                    basis: E()
                }],
                "flex-direction": [{
                    flex: ["row", "row-reverse", "col", "col-reverse"]
                }],
                "flex-wrap": [{
                    flex: ["wrap", "wrap-reverse", "nowrap"]
                }],
                flex: [{
                    flex: ["1", "auto", "initial", "none", vc]
                }],
                grow: [{
                    grow: C()
                }],
                shrink: [{
                    shrink: C()
                }],
                order: [{
                    order: ["first", "last", "none", bc, vc]
                }],
                "grid-cols": [{
                    "grid-cols": [Tc]
                }],
                "col-start-end": [{
                    col: ["auto", {
                        span: ["full", bc, vc]
                    }, vc]
                }],
                "col-start": [{
                    "col-start": A()
                }],
                "col-end": [{
                    "col-end": A()
                }],
                "grid-rows": [{
                    "grid-rows": [Tc]
                }],
                "row-start-end": [{
                    row: ["auto", {
                        span: [bc, vc]
                    }, vc]
                }],
                "row-start": [{
                    "row-start": A()
                }],
                "row-end": [{
                    "row-end": A()
                }],
                "grid-flow": [{
                    "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
                }],
                "auto-cols": [{
                    "auto-cols": ["auto", "min", "max", "fr", vc]
                }],
                "auto-rows": [{
                    "auto-rows": ["auto", "min", "max", "fr", vc]
                }],
                gap: [{
                    gap: [p]
                }],
                "gap-x": [{
                    "gap-x": [p]
                }],
                "gap-y": [{
                    "gap-y": [p]
                }],
                "justify-content": [{
                    justify: ["normal", "start", "end", "center", "between", "around", "evenly", "stretch"]
                }],
                "justify-items": [{
                    "justify-items": ["start", "end", "center", "stretch"]
                }],
                "justify-self": [{
                    "justify-self": ["auto", "start", "end", "center", "stretch"]
                }],
                "align-content": [{
                    content: ["normal", "start", "end", "center", "between", "around", "evenly", "stretch", "baseline"]
                }],
                "align-items": [{
                    items: ["start", "end", "center", "baseline", "stretch"]
                }],
                "align-self": [{
                    self: ["auto", "start", "end", "center", "stretch", "baseline"]
                }],
                "place-content": [{
                    "place-content": ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline"]
                }],
                "place-items": [{
                    "place-items": ["start", "end", "center", "baseline", "stretch"]
                }],
                "place-self": [{
                    "place-self": ["auto", "start", "end", "center", "stretch"]
                }],
                p: [{
                    p: [O]
                }],
                px: [{
                    px: [O]
                }],
                py: [{
                    py: [O]
                }],
                ps: [{
                    ps: [O]
                }],
                pe: [{
                    pe: [O]
                }],
                pt: [{
                    pt: [O]
                }],
                pr: [{
                    pr: [O]
                }],
                pb: [{
                    pb: [O]
                }],
                pl: [{
                    pl: [O]
                }],
                m: [{
                    m: [g]
                }],
                mx: [{
                    mx: [g]
                }],
                my: [{
                    my: [g]
                }],
                ms: [{
                    ms: [g]
                }],
                me: [{
                    me: [g]
                }],
                mt: [{
                    mt: [g]
                }],
                mr: [{
                    mr: [g]
                }],
                mb: [{
                    mb: [g]
                }],
                ml: [{
                    ml: [g]
                }],
                "space-x": [{
                    "space-x": [k]
                }],
                "space-x-reverse": ["space-x-reverse"],
                "space-y": [{
                    "space-y": [k]
                }],
                "space-y-reverse": ["space-y-reverse"],
                w: [{
                    w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", vc, t]
                }],
                "min-w": [{
                    "min-w": [vc, t, "min", "max", "fit"]
                }],
                "max-w": [{
                    "max-w": [vc, t, "none", "full", "min", "max", "fit", "prose", {
                        screen: [yc]
                    }, yc]
                }],
                h: [{
                    h: [vc, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
                }],
                "min-h": [{
                    "min-h": [vc, t, "min", "max", "fit", "svh", "lvh", "dvh"]
                }],
                "max-h": [{
                    "max-h": [vc, t, "min", "max", "fit", "svh", "lvh", "dvh"]
                }],
                size: [{
                    size: [vc, t, "auto", "min", "max", "fit"]
                }],
                "font-size": [{
                    text: ["base", yc, fc]
                }],
                "font-smoothing": ["antialiased", "subpixel-antialiased"],
                "font-style": ["italic", "not-italic"],
                "font-weight": [{
                    font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", gc]
                }],
                "font-family": [{
                    font: [Tc]
                }],
                "fvn-normal": ["normal-nums"],
                "fvn-ordinal": ["ordinal"],
                "fvn-slashed-zero": ["slashed-zero"],
                "fvn-figure": ["lining-nums", "oldstyle-nums"],
                "fvn-spacing": ["proportional-nums", "tabular-nums"],
                "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
                tracking: [{
                    tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", vc]
                }],
                "line-clamp": [{
                    "line-clamp": ["none", mc, gc]
                }],
                leading: [{
                    leading: ["none", "tight", "snug", "normal", "relaxed", "loose", hc, vc]
                }],
                "list-image": [{
                    "list-image": ["none", vc]
                }],
                "list-style-type": [{
                    list: ["none", "disc", "decimal", vc]
                }],
                "list-style-position": [{
                    list: ["inside", "outside"]
                }],
                "placeholder-color": [{
                    placeholder: [e]
                }],
                "placeholder-opacity": [{
                    "placeholder-opacity": [b]
                }],
                "text-alignment": [{
                    text: ["left", "center", "right", "justify", "start", "end"]
                }],
                "text-color": [{
                    text: [e]
                }],
                "text-opacity": [{
                    "text-opacity": [b]
                }],
                "text-decoration": ["underline", "overline", "line-through", "no-underline"],
                "text-decoration-style": [{
                    decoration: ["solid", "dashed", "dotted", "double", "none", "wavy"]
                }],
                "text-decoration-thickness": [{
                    decoration: ["auto", "from-font", hc, fc]
                }],
                "underline-offset": [{
                    "underline-offset": ["auto", hc, vc]
                }],
                "text-decoration-color": [{
                    decoration: [e]
                }],
                "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
                "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
                "text-wrap": [{
                    text: ["wrap", "nowrap", "balance", "pretty"]
                }],
                indent: [{
                    indent: x()
                }],
                "vertical-align": [{
                    align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", vc]
                }],
                whitespace: [{
                    whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
                }],
                break: [{
                    break: ["normal", "words", "all", "keep"]
                }],
                hyphens: [{
                    hyphens: ["none", "manual", "auto"]
                }],
                content: [{
                    content: ["none", vc]
                }],
                "bg-attachment": [{
                    bg: ["fixed", "local", "scroll"]
                }],
                "bg-clip": [{
                    "bg-clip": ["border", "padding", "content", "text"]
                }],
                "bg-opacity": [{
                    "bg-opacity": [b]
                }],
                "bg-origin": [{
                    "bg-origin": ["border", "padding", "content"]
                }],
                "bg-position": [{
                    bg: ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top", kc]
                }],
                "bg-repeat": [{
                    bg: ["no-repeat", {
                        repeat: ["", "x", "y", "round", "space"]
                    }]
                }],
                "bg-size": [{
                    bg: ["auto", "cover", "contain", _c]
                }],
                "bg-image": [{
                    bg: ["none", {
                        "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
                    }, Ec]
                }],
                "bg-color": [{
                    bg: [e]
                }],
                "gradient-from-pos": [{
                    from: [f]
                }],
                "gradient-via-pos": [{
                    via: [f]
                }],
                "gradient-to-pos": [{
                    to: [f]
                }],
                "gradient-from": [{
                    from: [h]
                }],
                "gradient-via": [{
                    via: [h]
                }],
                "gradient-to": [{
                    to: [h]
                }],
                rounded: [{
                    rounded: [i]
                }],
                "rounded-s": [{
                    "rounded-s": [i]
                }],
                "rounded-e": [{
                    "rounded-e": [i]
                }],
                "rounded-t": [{
                    "rounded-t": [i]
                }],
                "rounded-r": [{
                    "rounded-r": [i]
                }],
                "rounded-b": [{
                    "rounded-b": [i]
                }],
                "rounded-l": [{
                    "rounded-l": [i]
                }],
                "rounded-ss": [{
                    "rounded-ss": [i]
                }],
                "rounded-se": [{
                    "rounded-se": [i]
                }],
                "rounded-ee": [{
                    "rounded-ee": [i]
                }],
                "rounded-es": [{
                    "rounded-es": [i]
                }],
                "rounded-tl": [{
                    "rounded-tl": [i]
                }],
                "rounded-tr": [{
                    "rounded-tr": [i]
                }],
                "rounded-br": [{
                    "rounded-br": [i]
                }],
                "rounded-bl": [{
                    "rounded-bl": [i]
                }],
                "border-w": [{
                    border: [s]
                }],
                "border-w-x": [{
                    "border-x": [s]
                }],
                "border-w-y": [{
                    "border-y": [s]
                }],
                "border-w-s": [{
                    "border-s": [s]
                }],
                "border-w-e": [{
                    "border-e": [s]
                }],
                "border-w-t": [{
                    "border-t": [s]
                }],
                "border-w-r": [{
                    "border-r": [s]
                }],
                "border-w-b": [{
                    "border-b": [s]
                }],
                "border-w-l": [{
                    "border-l": [s]
                }],
                "border-opacity": [{
                    "border-opacity": [b]
                }],
                "border-style": [{
                    border: ["solid", "dashed", "dotted", "double", "none", "hidden"]
                }],
                "divide-x": [{
                    "divide-x": [s]
                }],
                "divide-x-reverse": ["divide-x-reverse"],
                "divide-y": [{
                    "divide-y": [s]
                }],
                "divide-y-reverse": ["divide-y-reverse"],
                "divide-opacity": [{
                    "divide-opacity": [b]
                }],
                "divide-style": [{
                    divide: ["solid", "dashed", "dotted", "double", "none"]
                }],
                "border-color": [{
                    border: [o]
                }],
                "border-color-x": [{
                    "border-x": [o]
                }],
                "border-color-y": [{
                    "border-y": [o]
                }],
                "border-color-t": [{
                    "border-t": [o]
                }],
                "border-color-r": [{
                    "border-r": [o]
                }],
                "border-color-b": [{
                    "border-b": [o]
                }],
                "border-color-l": [{
                    "border-l": [o]
                }],
                "divide-color": [{
                    divide: [o]
                }],
                "outline-style": [{
                    outline: ["", "solid", "dashed", "dotted", "double", "none"]
                }],
                "outline-offset": [{
                    "outline-offset": [hc, vc]
                }],
                "outline-w": [{
                    outline: [hc, fc]
                }],
                "outline-color": [{
                    outline: [e]
                }],
                "ring-w": [{
                    ring: T()
                }],
                "ring-w-inset": ["ring-inset"],
                "ring-color": [{
                    ring: [e]
                }],
                "ring-opacity": [{
                    "ring-opacity": [b]
                }],
                "ring-offset-w": [{
                    "ring-offset": [hc, fc]
                }],
                "ring-offset-color": [{
                    "ring-offset": [e]
                }],
                shadow: [{
                    shadow: ["", "inner", "none", yc, xc]
                }],
                "shadow-color": [{
                    shadow: [Tc]
                }],
                opacity: [{
                    opacity: [b]
                }],
                "mix-blend": [{
                    "mix-blend": ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter", "plus-darker"]
                }],
                "bg-blend": [{
                    "bg-blend": ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"]
                }],
                filter: [{
                    filter: ["", "none"]
                }],
                blur: [{
                    blur: [n]
                }],
                brightness: [{
                    brightness: [r]
                }],
                contrast: [{
                    contrast: [l]
                }],
                "drop-shadow": [{
                    "drop-shadow": ["", "none", yc, vc]
                }],
                grayscale: [{
                    grayscale: [c]
                }],
                "hue-rotate": [{
                    "hue-rotate": [u]
                }],
                invert: [{
                    invert: [d]
                }],
                saturate: [{
                    saturate: [v]
                }],
                sepia: [{
                    sepia: [w]
                }],
                "backdrop-filter": [{
                    "backdrop-filter": ["", "none"]
                }],
                "backdrop-blur": [{
                    "backdrop-blur": [n]
                }],
                "backdrop-brightness": [{
                    "backdrop-brightness": [r]
                }],
                "backdrop-contrast": [{
                    "backdrop-contrast": [l]
                }],
                "backdrop-grayscale": [{
                    "backdrop-grayscale": [c]
                }],
                "backdrop-hue-rotate": [{
                    "backdrop-hue-rotate": [u]
                }],
                "backdrop-invert": [{
                    "backdrop-invert": [d]
                }],
                "backdrop-opacity": [{
                    "backdrop-opacity": [b]
                }],
                "backdrop-saturate": [{
                    "backdrop-saturate": [v]
                }],
                "backdrop-sepia": [{
                    "backdrop-sepia": [w]
                }],
                "border-collapse": [{
                    border: ["collapse", "separate"]
                }],
                "border-spacing": [{
                    "border-spacing": [a]
                }],
                "border-spacing-x": [{
                    "border-spacing-x": [a]
                }],
                "border-spacing-y": [{
                    "border-spacing-y": [a]
                }],
                "table-layout": [{
                    table: ["auto", "fixed"]
                }],
                caption: [{
                    caption: ["top", "bottom"]
                }],
                transition: [{
                    transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", vc]
                }],
                duration: [{
                    duration: D()
                }],
                ease: [{
                    ease: ["linear", "in", "out", "in-out", vc]
                }],
                delay: [{
                    delay: D()
                }],
                animate: [{
                    animate: ["none", "spin", "ping", "pulse", "bounce", vc]
                }],
                transform: [{
                    transform: ["", "gpu", "none"]
                }],
                scale: [{
                    scale: [y]
                }],
                "scale-x": [{
                    "scale-x": [y]
                }],
                "scale-y": [{
                    "scale-y": [y]
                }],
                rotate: [{
                    rotate: [bc, vc]
                }],
                "translate-x": [{
                    "translate-x": [S]
                }],
                "translate-y": [{
                    "translate-y": [S]
                }],
                "skew-x": [{
                    "skew-x": [_]
                }],
                "skew-y": [{
                    "skew-y": [_]
                }],
                "transform-origin": [{
                    origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", vc]
                }],
                accent: [{
                    accent: ["auto", e]
                }],
                appearance: [{
                    appearance: ["none", "auto"]
                }],
                cursor: [{
                    cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", vc]
                }],
                "caret-color": [{
                    caret: [e]
                }],
                "pointer-events": [{
                    "pointer-events": ["none", "auto"]
                }],
                resize: [{
                    resize: ["none", "y", "x", ""]
                }],
                "scroll-behavior": [{
                    scroll: ["auto", "smooth"]
                }],
                "scroll-m": [{
                    "scroll-m": x()
                }],
                "scroll-mx": [{
                    "scroll-mx": x()
                }],
                "scroll-my": [{
                    "scroll-my": x()
                }],
                "scroll-ms": [{
                    "scroll-ms": x()
                }],
                "scroll-me": [{
                    "scroll-me": x()
                }],
                "scroll-mt": [{
                    "scroll-mt": x()
                }],
                "scroll-mr": [{
                    "scroll-mr": x()
                }],
                "scroll-mb": [{
                    "scroll-mb": x()
                }],
                "scroll-ml": [{
                    "scroll-ml": x()
                }],
                "scroll-p": [{
                    "scroll-p": x()
                }],
                "scroll-px": [{
                    "scroll-px": x()
                }],
                "scroll-py": [{
                    "scroll-py": x()
                }],
                "scroll-ps": [{
                    "scroll-ps": x()
                }],
                "scroll-pe": [{
                    "scroll-pe": x()
                }],
                "scroll-pt": [{
                    "scroll-pt": x()
                }],
                "scroll-pr": [{
                    "scroll-pr": x()
                }],
                "scroll-pb": [{
                    "scroll-pb": x()
                }],
                "scroll-pl": [{
                    "scroll-pl": x()
                }],
                "snap-align": [{
                    snap: ["start", "end", "center", "align-none"]
                }],
                "snap-stop": [{
                    snap: ["normal", "always"]
                }],
                "snap-type": [{
                    snap: ["none", "x", "y", "both"]
                }],
                "snap-strictness": [{
                    snap: ["mandatory", "proximity"]
                }],
                touch: [{
                    touch: ["auto", "none", "manipulation"]
                }],
                "touch-x": [{
                    "touch-pan": ["x", "left", "right"]
                }],
                "touch-y": [{
                    "touch-pan": ["y", "up", "down"]
                }],
                "touch-pz": ["touch-pinch-zoom"],
                select: [{
                    select: ["none", "text", "all", "auto"]
                }],
                "will-change": [{
                    "will-change": ["auto", "scroll", "contents", "transform", vc]
                }],
                fill: [{
                    fill: [e, "none"]
                }],
                "stroke-w": [{
                    stroke: [hc, fc, gc]
                }],
                stroke: [{
                    stroke: [e, "none"]
                }],
                sr: ["sr-only", "not-sr-only"],
                "forced-color-adjust": [{
                    "forced-color-adjust": ["auto", "none"]
                }]
            },
            conflictingClassGroups: {
                overflow: ["overflow-x", "overflow-y"],
                overscroll: ["overscroll-x", "overscroll-y"],
                inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
                "inset-x": ["right", "left"],
                "inset-y": ["top", "bottom"],
                flex: ["basis", "grow", "shrink"],
                gap: ["gap-x", "gap-y"],
                p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
                px: ["pr", "pl"],
                py: ["pt", "pb"],
                m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
                mx: ["mr", "ml"],
                my: ["mt", "mb"],
                size: ["w", "h"],
                "font-size": ["leading"],
                "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
                "fvn-ordinal": ["fvn-normal"],
                "fvn-slashed-zero": ["fvn-normal"],
                "fvn-figure": ["fvn-normal"],
                "fvn-spacing": ["fvn-normal"],
                "fvn-fraction": ["fvn-normal"],
                "line-clamp": ["display", "overflow"],
                rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
                "rounded-s": ["rounded-ss", "rounded-es"],
                "rounded-e": ["rounded-se", "rounded-ee"],
                "rounded-t": ["rounded-tl", "rounded-tr"],
                "rounded-r": ["rounded-tr", "rounded-br"],
                "rounded-b": ["rounded-br", "rounded-bl"],
                "rounded-l": ["rounded-tl", "rounded-bl"],
                "border-spacing": ["border-spacing-x", "border-spacing-y"],
                "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
                "border-w-x": ["border-w-r", "border-w-l"],
                "border-w-y": ["border-w-t", "border-w-b"],
                "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
                "border-color-x": ["border-color-r", "border-color-l"],
                "border-color-y": ["border-color-t", "border-color-b"],
                "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
                "scroll-mx": ["scroll-mr", "scroll-ml"],
                "scroll-my": ["scroll-mt", "scroll-mb"],
                "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
                "scroll-px": ["scroll-pr", "scroll-pl"],
                "scroll-py": ["scroll-pt", "scroll-pb"],
                touch: ["touch-x", "touch-y", "touch-pz"],
                "touch-x": ["touch"],
                "touch-y": ["touch"],
                "touch-pz": ["touch"]
            },
            conflictingClassGroupModifiers: {
                "font-size": ["leading"]
            }
        }
    }
    function $c(e, t, n) {
        void 0 !== n && (e[t] = n)
    }
    function Ic(e, t) {
        if (t)
            for (const n in t)
                $c(e, n, t[n])
    }
    function Mc(e, t) {
        if (t)
            for (const n in t) {
                const r = t[n];
                void 0 !== r && (e[n] = (e[n] || []).concat(r))
            }
    }
    const Lc = function(e, ...t) {
        return "function" == typeof e ? rc(Nc, e, ...t) : rc((()=>function(e, {cacheSize: t, prefix: n, separator: r, extend: o={}, override: i={}}) {
            $c(e, "cacheSize", t),
            $c(e, "prefix", n),
            $c(e, "separator", r);
            for (const a in i)
                Ic(e[a], i[a]);
            for (const a in o)
                Mc(e[a], o[a]);
            return e
        }(Nc(), e)), ...t)
    }({
        extend: {
            classGroups: {
                "font-size": ["text-xxs"]
            }
        }
    })
      , {cva: Qc, cx: Bc, compose: Uc} = (e=>{
        const t = function() {
            for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
                n[r] = arguments[r];
            var o, i;
            return void 0 !== (null == e || null === (o = e.hooks) || void 0 === o ? void 0 : o["cx:done"]) ? null == e ? void 0 : e.hooks["cx:done"](zl(n)) : void 0 !== (null == e || null === (i = e.hooks) || void 0 === i ? void 0 : i.onComplete) ? null == e ? void 0 : e.hooks.onComplete(zl(n)) : zl(n)
        };
        return {
            compose: function() {
                for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
                    n[r] = arguments[r];
                return e=>{
                    const r = Object.fromEntries(Object.entries(e || {}).filter((e=>{
                        let[t] = e;
                        return !["class", "className"].includes(t)
                    }
                    )));
                    return t(n.map((e=>e(r))), null == e ? void 0 : e.class, null == e ? void 0 : e.className)
                }
            },
            cva: e=>n=>{
                var r;
                if (null == (null == e ? void 0 : e.variants))
                    return t(null == e ? void 0 : e.base, null == n ? void 0 : n.class, null == n ? void 0 : n.className);
                const {variants: o, defaultVariants: i} = e
                  , a = Object.keys(o).map((e=>{
                    const t = null == n ? void 0 : n[e]
                      , r = null == i ? void 0 : i[e]
                      , a = ql(t) || ql(r);
                    return o[e][a]
                }
                ))
                  , s = {
                    ...i,
                    ...n && Object.entries(n).reduce(((e,t)=>{
                        let[n,r] = t;
                        return void 0 === r ? e : {
                            ...e,
                            [n]: r
                        }
                    }
                    ), {})
                }
                  , l = null == e || null === (r = e.compoundVariants) || void 0 === r ? void 0 : r.reduce(((e,t)=>{
                    let {class: n, className: r, ...o} = t;
                    return Object.entries(o).every((e=>{
                        let[t,n] = e;
                        const r = s[t];
                        return Array.isArray(n) ? n.includes(r) : r === n
                    }
                    )) ? [...e, n, r] : e
                }
                ), []);
                return t(null == e ? void 0 : e.base, a, l, null == n ? void 0 : n.class, null == n ? void 0 : n.className)
            }
            ,
            cx: t
        }
    }
    )({
        hooks: {
            onComplete: e=>Lc(e)
        }
    })
      , Fc = ()=>ut({
        open: !1,
        show() {
            this.open = !0
        },
        hide() {
            this.open = !1
        }
    })
      , jc = Ln({
        __name: "ScalarModal",
        props: {
            state: {},
            title: {},
            bodyClass: {},
            maxWidth: {},
            size: {
                default: "md"
            },
            variant: {}
        },
        setup(e) {
            const t = Qc({
                base: ["scalar-modal", "col relative mx-auto mb-0 mt-20 w-full rounded-lg bg-b-2 p-0 text-left leading-snug text-c-1 opacity-0"].join(" "),
                variants: {
                    size: {
                        xs: "max-w-screen-xs",
                        sm: "max-w-screen-sm",
                        md: "max-w-screen-md",
                        lg: "max-w-screen-lg",
                        full: "mt-0 overflow-hidden"
                    },
                    variant: {
                        history: "scalar-modal-history bg-b-1",
                        search: "scalar-modal-search"
                    }
                }
            })
              , n = Qc({
                base: ["scalar-modal-body", "relative max-h-[calc(100dvh-240px)] overflow-y-auto rounded-lg bg-b-1 px-6 pb-4 pt-6"].join(" "),
                variants: {
                    variant: {
                        history: "pt-3",
                        search: "col max-h-[440px] overflow-hidden p-0"
                    }
                }
            });
            return (e,r)=>(mo(),
            yo(Ct(As), {
                open: e.state.open,
                onClose: r[0] || (r[0] = t=>e.state.hide())
            }, {
                default: dn((()=>[Eo("div", {
                    class: Z(Ct(Bc)("scalar-modal-layout fixed left-0 top-0", "z-[1001] h-[100dvh] w-[100dvw]", "bg-backdrop opacity-0", "full" === e.size && "flex"))
                }, [xo(Ct(Cs), {
                    class: Z(Ct(t)({
                        size: e.size,
                        variant: e.variant
                    })),
                    style: F({
                        maxWidth: e.maxWidth
                    })
                }, {
                    default: dn((()=>[e.title ? (mo(),
                    yo(Ct(Ps), {
                        key: 0,
                        class: Z(["scalar-modal-header font-semiBold m-0 rounded-lg px-6 py-3 text-left text-xs text-c-1", {
                            "pb-0 pt-6": "history" === e.variant
                        }])
                    }, {
                        default: dn((()=>[Co(K(e.title), 1)])),
                        _: 1
                    }, 8, ["class"])) : Do("", !0), "full" === e.size ? (mo(),
                    vo("div", {
                        key: 1,
                        class: Z(e.bodyClass)
                    }, [Fn(e.$slots, "default", {}, void 0, !0)], 2)) : (mo(),
                    yo(Ct(Ds), {
                        key: 2,
                        class: Z(Ct(Bc)(e.bodyClass, Ct(n)({
                            variant: e.variant
                        })))
                    }, {
                        default: dn((()=>[Fn(e.$slots, "default", {}, void 0, !0)])),
                        _: 3
                    }, 8, ["class"]))])),
                    _: 3
                }, 8, ["class", "style"])], 2)])),
                _: 3
            }, 8, ["open"]))
        }
    })
      , zc = (e,t)=>{
        const n = e.__vccOpts || e;
        for (const [r,o] of t)
            n[r] = o;
        return n
    }
      , qc = zc(jc, [["__scopeId", "data-v-03b82fd9"]])
      , Hc = {
        solid: ["scalar-button-solid", "bg-b-btn text-c-btn shadow-sm active:bg-b-btn active:shadow-none hocus:bg-h-btn"],
        outlined: ["scalar-button-outlined", "active:bg-btn-1 border border-solid border-border bg-transparent text-c-1 hocus:bg-border"],
        ghost: ["scalar-button-ghost", "bg-transparent text-c-3 transition-colors active:text-c-1 hocus:text-c-1"],
        danger: ["scalar-button-danger", "bg-error text-white active:brightness-90 hocus:brightness-90"]
    }
      , Zc = Qc({
        base: "scalar-button row cursor-pointer items-center justify-center rounded font-medium",
        variants: {
            disabled: {
                true: "bg-background-2 text-color-3 cursor-not-allowed shadow-none"
            },
            fullWidth: {
                true: "w-full"
            },
            size: {
                sm: "px-2 py-1 text-xs",
                md: "h-10 px-6 text-sm"
            },
            variant: Hc
        },
        compoundVariants: [{
            disabled: !0,
            variant: "ghost",
            class: "text-ghost bg-transparent"
        }]
    })
      , Wc = Po('<path class="svg-path svg-check-mark" d="m 0 60 l 30 30 l 70 -80" data-v-47faceda></path><path class="svg-path svg-x-mark" d="m 50 50 l 40 -40" data-v-47faceda></path><path class="svg-path svg-x-mark" d="m 50 50 l 40 40" data-v-47faceda></path><path class="svg-path svg-x-mark" d="m 50 50 l -40 -40" data-v-47faceda></path><path class="svg-path svg-x-mark" d="m 50 50 l -40 40" data-v-47faceda></path>', 5)
      , Xc = {
        key: 0,
        class: "circular-loader"
    }
      , Vc = zc(Ln({
        __name: "ScalarLoading",
        props: {
            loadingState: {},
            size: {
                default: "24px"
            }
        },
        setup: e=>(pi((e=>({
            d6cae758: e.size
        }))),
        (e,t)=>e.loadingState ? (mo(),
        vo("div", {
            key: 0,
            class: Z(Ct(Bc)("loader-wrapper"))
        }, [(mo(),
        vo("svg", {
            class: Z(["svg-loader", {
                "icon-is-valid": e.loadingState.isValid,
                "icon-is-invalid": e.loadingState.isInvalid
            }]),
            viewBox: "0 0 100 100",
            xmlns: "http://www.w3.org/2000/svg",
            "xmlns:xlink": "http://www.w3.org/1999/xlink"
        }, [Wc, e.loadingState.isLoading ? (mo(),
        vo("g", Xc, [Eo("circle", {
            class: Z(["loader-path", {
                "loader-path-off": e.loadingState.isValid || e.loadingState.isInvalid
            }]),
            cx: "50",
            cy: "50",
            fill: "none",
            r: "20",
            "stroke-width": "2"
        }, null, 2)])) : Do("", !0)], 2))], 2)) : Do("", !0))
    }), [["__scopeId", "data-v-47faceda"]])
      , Gc = ["ariaDisabled", "type"]
      , Yc = {
        key: 0,
        class: "mr-2 h-4 w-4"
    }
      , Kc = {
        key: 1,
        class: "ml-2"
    }
      , Jc = Ln({
        inheritAttrs: !1,
        __name: "ScalarButton",
        props: {
            disabled: {
                type: Boolean
            },
            fullWidth: {
                type: Boolean,
                default: !1
            },
            loading: {},
            size: {
                default: "md"
            },
            variant: {
                default: "solid"
            },
            type: {
                default: "button"
            }
        },
        setup(e) {
            const t = ei((()=>{
                const {class: e, ...t} = Wn();
                return {
                    class: e || "",
                    rest: t
                }
            }
            ));
            return (e,n)=>(mo(),
            vo("button", Io(t.value.rest, {
                ariaDisabled: e.disabled || void 0,
                class: Ct(Bc)(Ct(Zc)({
                    fullWidth: e.fullWidth,
                    disabled: e.disabled,
                    size: e.size,
                    variant: e.variant
                }), {
                    "pl-9 pr-3": e.loading
                }, `${t.value.class}`),
                type: e.type
            }), [e.$slots.icon ? (mo(),
            vo("div", Yc, [Fn(e.$slots, "icon")])) : Do("", !0), Fn(e.$slots, "default"), e.loading ? (mo(),
            vo("div", Kc, [xo(Ct(Vc), {
                loadingState: e.loading,
                size: "20px"
            }, null, 8, ["loadingState"])])) : Do("", !0)], 16, Gc))
        }
    })
      , eu = {
        ts: "typescript",
        js: "javascript",
        py: "python",
        py3: "python",
        "c#": "csharp",
        "c++": "cpp",
        node: "javascript"
    }
      , tu = function(e) {
        if (null == e)
            return ru;
        if ("function" == typeof e)
            return nu(e);
        if ("object" == typeof e)
            return Array.isArray(e) ? function(e) {
                const t = [];
                let n = -1;
                for (; ++n < e.length; )
                    t[n] = tu(e[n]);
                return nu(r);
                function r(...e) {
                    let n = -1;
                    for (; ++n < t.length; )
                        if (t[n].apply(this, e))
                            return !0;
                    return !1
                }
            }(e) : function(e) {
                const t = e;
                return nu(n);
                function n(n) {
                    const r = n;
                    let o;
                    for (o in e)
                        if (r[o] !== t[o])
                            return !1;
                    return !0
                }
            }(e);
        if ("string" == typeof e)
            return function(e) {
                return nu(t);
                function t(t) {
                    return t && t.type === e
                }
            }(e);
        throw new Error("Expected function, string, or object as test")
    };
    function nu(e) {
        return function(t, n, r) {
            return Boolean(function(e) {
                return null !== e && "object" == typeof e && "type"in e
            }(t) && e.call(this, t, "number" == typeof n ? n : void 0, r || void 0))
        }
    }
    function ru() {
        return !0
    }
    const ou = function(e, t, n) {
        const r = tu(n);
        if (!e || !e.type || !e.children)
            throw new Error("Expected parent node");
        if ("number" == typeof t) {
            if (t < 0 || t === Number.POSITIVE_INFINITY)
                throw new Error("Expected positive finite number as index")
        } else if ((t = e.children.indexOf(t)) < 0)
            throw new Error("Expected child node or index");
        for (; ++t < e.children.length; )
            if (r(e.children[t], t, e))
                return e.children[t]
    }
      , iu = function(e, t, n, r, o) {
        const i = au(t);
        return !!cu(e) && i.call(o, e, n, r)
    }
      , au = function(e) {
        if (null == e)
            return lu;
        if ("string" == typeof e)
            return function(e) {
                return su(t);
                function t(t) {
                    return t.tagName === e
                }
            }(e);
        if ("object" == typeof e)
            return function(e) {
                const t = [];
                let n = -1;
                for (; ++n < e.length; )
                    t[n] = au(e[n]);
                return su(r);
                function r(...e) {
                    let n = -1;
                    for (; ++n < t.length; )
                        if (t[n].apply(this, e))
                            return !0;
                    return !1
                }
            }(e);
        if ("function" == typeof e)
            return su(e);
        throw new Error("Expected function, string, or array as `test`")
    };
    function su(e) {
        return function(t, n, r) {
            return Boolean(cu(t) && e.call(this, t, "number" == typeof n ? n : void 0, r || void 0))
        }
    }
    function lu(e) {
        return Boolean(e && "object" == typeof e && "type"in e && "element" === e.type && "tagName"in e && "string" == typeof e.tagName)
    }
    function cu(e) {
        return null !== e && "object" == typeof e && "type"in e && "tagName"in e
    }
    const uu = /\n/g
      , du = /[\t ]+/g
      , pu = au("br")
      , hu = au((function(e) {
        return "td" === e.tagName || "th" === e.tagName
    }
    ))
      , fu = au("p")
      , mu = au("tr")
      , gu = au(["datalist", "head", "noembed", "noframes", "noscript", "rp", "script", "style", "template", "title", function(e) {
        return Boolean((e.properties || {}).hidden)
    }
    , function(e) {
        return "dialog" === e.tagName && !(e.properties || {}).open
    }
    ])
      , bu = au(["address", "article", "aside", "blockquote", "body", "caption", "center", "dd", "dialog", "dir", "dl", "dt", "div", "figure", "figcaption", "footer", "form,", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "legend", "li", "listing", "main", "menu", "nav", "ol", "p", "plaintext", "pre", "section", "ul", "xmp"]);
    function Ou(e, t) {
        const n = "children"in e ? e.children : []
          , r = bu(e)
          , o = _u(e, {
            whitespace: {}.whitespace || "normal",
            breakBefore: !1,
            breakAfter: !1
        })
          , i = [];
        "text" !== e.type && "comment" !== e.type || i.push(...yu(e, {
            whitespace: o,
            breakBefore: !0,
            breakAfter: !0
        }));
        let a = -1;
        for (; ++a < n.length; )
            i.push(...vu(n[a], e, {
                whitespace: o,
                breakBefore: a ? void 0 : r,
                breakAfter: a < n.length - 1 ? pu(n[a + 1]) : r
            }));
        const s = [];
        let l;
        for (a = -1; ++a < i.length; ) {
            const e = i[a];
            "number" == typeof e ? void 0 !== l && e > l && (l = e) : e && (void 0 !== l && l > -1 && s.push("\n".repeat(l) || " "),
            l = -1,
            s.push(e))
        }
        return s.join("")
    }
    function vu(e, t, n) {
        return "element" === e.type ? function(e, t, n) {
            const r = _u(e, n)
              , o = e.children || [];
            let i, a, s = -1, l = [];
            if (gu(e))
                return l;
            pu(e) || mu(e) && ou(t, e, mu) ? a = "\n" : fu(e) ? (i = 2,
            a = 2) : bu(e) && (i = 1,
            a = 1);
            for (; ++s < o.length; )
                l = l.concat(vu(o[s], e, {
                    whitespace: r,
                    breakBefore: s ? void 0 : i,
                    breakAfter: s < o.length - 1 ? pu(o[s + 1]) : a
                }));
            hu(e) && ou(t, e, hu) && l.push("\t");
            i && l.unshift(i);
            a && l.push(a);
            return l
        }(e, t, n) : "text" === e.type ? "normal" === n.whitespace ? yu(e, n) : function(e) {
            return [String(e.value)]
        }(e) : []
    }
    function yu(e, t) {
        const n = String(e.value)
          , r = []
          , o = [];
        let i = 0;
        for (; i <= n.length; ) {
            uu.lastIndex = i;
            const e = uu.exec(n)
              , o = e && "index"in e ? e.index : n.length;
            r.push(wu(n.slice(i, o).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ""), 0 !== i || t.breakBefore, o !== n.length || t.breakAfter)),
            i = o + 1
        }
        let a, s = -1;
        for (; ++s < r.length; )
            8203 === r[s].charCodeAt(r[s].length - 1) || s < r.length - 1 && 8203 === r[s + 1].charCodeAt(0) ? (o.push(r[s]),
            a = void 0) : r[s] ? ("number" == typeof a && o.push(a),
            o.push(r[s]),
            a = 0) : 0 !== s && s !== r.length - 1 || o.push(0);
        return o
    }
    function wu(e, t, n) {
        const r = [];
        let o, i = 0;
        for (; i < e.length; ) {
            du.lastIndex = i;
            const n = du.exec(e);
            o = n ? n.index : e.length,
            i || o || !n || t || r.push(""),
            i !== o && r.push(e.slice(i, o)),
            i = n ? o + n[0].length : o
        }
        return i === o || n || r.push(""),
        r.join(" ")
    }
    function _u(e, t) {
        if ("element" === e.type) {
            const n = e.properties || {};
            switch (e.tagName) {
            case "listing":
            case "plaintext":
            case "xmp":
                return "pre";
            case "nobr":
                return "nowrap";
            case "pre":
                return n.wrap ? "pre-wrap" : "pre";
            case "td":
            case "th":
                return n.noWrap ? "nowrap" : t.whitespace;
            case "textarea":
                return "pre-wrap"
            }
        }
        return t.whitespace
    }
    const ku = ["a", "abbr", "address", "article", "aside", "audio", "b", "blockquote", "body", "button", "canvas", "caption", "cite", "code", "dd", "del", "details", "dfn", "div", "dl", "dt", "em", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "mark", "menu", "nav", "object", "ol", "p", "q", "quote", "samp", "section", "span", "strong", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "ul", "var", "video"]
      , Su = ["any-hover", "any-pointer", "aspect-ratio", "color", "color-gamut", "color-index", "device-aspect-ratio", "device-height", "device-width", "display-mode", "forced-colors", "grid", "height", "hover", "inverted-colors", "monochrome", "orientation", "overflow-block", "overflow-inline", "pointer", "prefers-color-scheme", "prefers-contrast", "prefers-reduced-motion", "prefers-reduced-transparency", "resolution", "scan", "scripting", "update", "width", "min-width", "max-width", "min-height", "max-height"]
      , Eu = ["active", "any-link", "blank", "checked", "current", "default", "defined", "dir", "disabled", "drop", "empty", "enabled", "first", "first-child", "first-of-type", "fullscreen", "future", "focus", "focus-visible", "focus-within", "has", "host", "host-context", "hover", "indeterminate", "in-range", "invalid", "is", "lang", "last-child", "last-of-type", "left", "link", "local-link", "not", "nth-child", "nth-col", "nth-last-child", "nth-last-col", "nth-last-of-type", "nth-of-type", "only-child", "only-of-type", "optional", "out-of-range", "past", "placeholder-shown", "read-only", "read-write", "required", "right", "root", "scope", "target", "target-within", "user-invalid", "valid", "visited", "where"]
      , xu = ["after", "backdrop", "before", "cue", "cue-region", "first-letter", "first-line", "grammar-error", "marker", "part", "placeholder", "selection", "slotted", "spelling-error"]
      , Tu = ["align-content", "align-items", "align-self", "all", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "backface-visibility", "background", "background-attachment", "background-blend-mode", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "block-size", "border", "border-block", "border-block-color", "border-block-end", "border-block-end-color", "border-block-end-style", "border-block-end-width", "border-block-start", "border-block-start-color", "border-block-start-style", "border-block-start-width", "border-block-style", "border-block-width", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-inline", "border-inline-color", "border-inline-end", "border-inline-end-color", "border-inline-end-style", "border-inline-end-width", "border-inline-start", "border-inline-start-color", "border-inline-start-style", "border-inline-start-width", "border-inline-style", "border-inline-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "caret-color", "clear", "clip", "clip-path", "clip-rule", "color", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "contain", "content", "content-visibility", "counter-increment", "counter-reset", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "empty-cells", "filter", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "flow", "font", "font-display", "font-family", "font-feature-settings", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-smoothing", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-variation-settings", "font-weight", "gap", "glyph-orientation-vertical", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "ime-mode", "inline-size", "isolation", "justify-content", "left", "letter-spacing", "line-break", "line-height", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-block", "margin-block-end", "margin-block-start", "margin-bottom", "margin-inline", "margin-inline-end", "margin-inline-start", "margin-left", "margin-right", "margin-top", "marks", "mask", "mask-border", "mask-border-mode", "mask-border-outset", "mask-border-repeat", "mask-border-slice", "mask-border-source", "mask-border-width", "mask-clip", "mask-composite", "mask-image", "mask-mode", "mask-origin", "mask-position", "mask-repeat", "mask-size", "mask-type", "max-block-size", "max-height", "max-inline-size", "max-width", "min-block-size", "min-height", "min-inline-size", "min-width", "mix-blend-mode", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "none", "normal", "object-fit", "object-position", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-block", "padding-block-end", "padding-block-start", "padding-bottom", "padding-inline", "padding-inline-end", "padding-inline-start", "padding-left", "padding-right", "padding-top", "page-break-after", "page-break-before", "page-break-inside", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pointer-events", "position", "quotes", "resize", "rest", "rest-after", "rest-before", "right", "row-gap", "scroll-margin", "scroll-margin-block", "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom", "scroll-margin-inline", "scroll-margin-inline-end", "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right", "scroll-margin-top", "scroll-padding", "scroll-padding-block", "scroll-padding-block-end", "scroll-padding-block-start", "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end", "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right", "scroll-padding-top", "scroll-snap-align", "scroll-snap-stop", "scroll-snap-type", "scrollbar-color", "scrollbar-gutter", "scrollbar-width", "shape-image-threshold", "shape-margin", "shape-outside", "speak", "speak-as", "src", "tab-size", "table-layout", "text-align", "text-align-all", "text-align-last", "text-combine-upright", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-indent", "text-justify", "text-orientation", "text-overflow", "text-rendering", "text-shadow", "text-transform", "text-underline-position", "top", "transform", "transform-box", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "white-space", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "writing-mode", "z-index"].reverse();
    var Au = "[0-9](_*[0-9])*"
      , Cu = `\\.(${Au})`
      , Pu = "[0-9a-fA-F](_*[0-9a-fA-F])*"
      , Du = {
        className: "number",
        variants: [{
            begin: `(\\b(${Au})((${Cu})|\\.)?|(${Cu}))[eE][+-]?(${Au})[fFdD]?\\b`
        }, {
            begin: `\\b(${Au})((${Cu})[fFdD]?\\b|\\.([fFdD]\\b)?)`
        }, {
            begin: `(${Cu})[fFdD]?\\b`
        }, {
            begin: `\\b(${Au})[fFdD]\\b`
        }, {
            begin: `\\b0[xX]((${Pu})\\.?|(${Pu})?\\.(${Pu}))[pP][+-]?(${Au})[fFdD]?\\b`
        }, {
            begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b"
        }, {
            begin: `\\b0[xX](${Pu})[lL]?\\b`
        }, {
            begin: "\\b0(_*[0-7])*[lL]?\\b"
        }, {
            begin: "\\b0[bB][01](_*[01])*[lL]?\\b"
        }],
        relevance: 0
    };
    function Ru(e, t, n) {
        return -1 === n ? "" : e.replace(t, (r=>Ru(e, t, n - 1)))
    }
    const Nu = "[A-Za-z$_][0-9A-Za-z$_]*"
      , $u = ["as", "in", "of", "if", "for", "while", "finally", "var", "new", "function", "do", "return", "void", "else", "break", "catch", "instanceof", "with", "throw", "case", "default", "try", "switch", "continue", "typeof", "delete", "let", "yield", "const", "class", "debugger", "async", "await", "static", "import", "from", "export", "extends"]
      , Iu = ["true", "false", "null", "undefined", "NaN", "Infinity"]
      , Mu = ["Object", "Function", "Boolean", "Symbol", "Math", "Date", "Number", "BigInt", "String", "RegExp", "Array", "Float32Array", "Float64Array", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Int32Array", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array", "Set", "Map", "WeakSet", "WeakMap", "ArrayBuffer", "SharedArrayBuffer", "Atomics", "DataView", "JSON", "Promise", "Generator", "GeneratorFunction", "AsyncFunction", "Reflect", "Proxy", "Intl", "WebAssembly"]
      , Lu = ["Error", "EvalError", "InternalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError"]
      , Qu = ["setInterval", "setTimeout", "clearInterval", "clearTimeout", "require", "exports", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "unescape"]
      , Bu = ["arguments", "this", "super", "console", "window", "document", "localStorage", "sessionStorage", "module", "global"]
      , Uu = [].concat(Qu, Mu, Lu);
    var Fu = "[0-9](_*[0-9])*"
      , ju = `\\.(${Fu})`
      , zu = "[0-9a-fA-F](_*[0-9a-fA-F])*"
      , qu = {
        className: "number",
        variants: [{
            begin: `(\\b(${Fu})((${ju})|\\.)?|(${ju}))[eE][+-]?(${Fu})[fFdD]?\\b`
        }, {
            begin: `\\b(${Fu})((${ju})[fFdD]?\\b|\\.([fFdD]\\b)?)`
        }, {
            begin: `(${ju})[fFdD]?\\b`
        }, {
            begin: `\\b(${Fu})[fFdD]\\b`
        }, {
            begin: `\\b0[xX]((${zu})\\.?|(${zu})?\\.(${zu}))[pP][+-]?(${Fu})[fFdD]?\\b`
        }, {
            begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b"
        }, {
            begin: `\\b0[xX](${zu})[lL]?\\b`
        }, {
            begin: "\\b0(_*[0-7])*[lL]?\\b"
        }, {
            begin: "\\b0[bB][01](_*[01])*[lL]?\\b"
        }],
        relevance: 0
    };
    const Hu = ["a", "abbr", "address", "article", "aside", "audio", "b", "blockquote", "body", "button", "canvas", "caption", "cite", "code", "dd", "del", "details", "dfn", "div", "dl", "dt", "em", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "mark", "menu", "nav", "object", "ol", "p", "q", "quote", "samp", "section", "span", "strong", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "ul", "var", "video"]
      , Zu = ["any-hover", "any-pointer", "aspect-ratio", "color", "color-gamut", "color-index", "device-aspect-ratio", "device-height", "device-width", "display-mode", "forced-colors", "grid", "height", "hover", "inverted-colors", "monochrome", "orientation", "overflow-block", "overflow-inline", "pointer", "prefers-color-scheme", "prefers-contrast", "prefers-reduced-motion", "prefers-reduced-transparency", "resolution", "scan", "scripting", "update", "width", "min-width", "max-width", "min-height", "max-height"]
      , Wu = ["active", "any-link", "blank", "checked", "current", "default", "defined", "dir", "disabled", "drop", "empty", "enabled", "first", "first-child", "first-of-type", "fullscreen", "future", "focus", "focus-visible", "focus-within", "has", "host", "host-context", "hover", "indeterminate", "in-range", "invalid", "is", "lang", "last-child", "last-of-type", "left", "link", "local-link", "not", "nth-child", "nth-col", "nth-last-child", "nth-last-col", "nth-last-of-type", "nth-of-type", "only-child", "only-of-type", "optional", "out-of-range", "past", "placeholder-shown", "read-only", "read-write", "required", "right", "root", "scope", "target", "target-within", "user-invalid", "valid", "visited", "where"]
      , Xu = ["after", "backdrop", "before", "cue", "cue-region", "first-letter", "first-line", "grammar-error", "marker", "part", "placeholder", "selection", "slotted", "spelling-error"]
      , Vu = ["align-content", "align-items", "align-self", "all", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "backface-visibility", "background", "background-attachment", "background-blend-mode", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "block-size", "border", "border-block", "border-block-color", "border-block-end", "border-block-end-color", "border-block-end-style", "border-block-end-width", "border-block-start", "border-block-start-color", "border-block-start-style", "border-block-start-width", "border-block-style", "border-block-width", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-inline", "border-inline-color", "border-inline-end", "border-inline-end-color", "border-inline-end-style", "border-inline-end-width", "border-inline-start", "border-inline-start-color", "border-inline-start-style", "border-inline-start-width", "border-inline-style", "border-inline-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "caret-color", "clear", "clip", "clip-path", "clip-rule", "color", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "contain", "content", "content-visibility", "counter-increment", "counter-reset", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "empty-cells", "filter", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "flow", "font", "font-display", "font-family", "font-feature-settings", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-smoothing", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-variation-settings", "font-weight", "gap", "glyph-orientation-vertical", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "ime-mode", "inline-size", "isolation", "justify-content", "left", "letter-spacing", "line-break", "line-height", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-block", "margin-block-end", "margin-block-start", "margin-bottom", "margin-inline", "margin-inline-end", "margin-inline-start", "margin-left", "margin-right", "margin-top", "marks", "mask", "mask-border", "mask-border-mode", "mask-border-outset", "mask-border-repeat", "mask-border-slice", "mask-border-source", "mask-border-width", "mask-clip", "mask-composite", "mask-image", "mask-mode", "mask-origin", "mask-position", "mask-repeat", "mask-size", "mask-type", "max-block-size", "max-height", "max-inline-size", "max-width", "min-block-size", "min-height", "min-inline-size", "min-width", "mix-blend-mode", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "none", "normal", "object-fit", "object-position", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-block", "padding-block-end", "padding-block-start", "padding-bottom", "padding-inline", "padding-inline-end", "padding-inline-start", "padding-left", "padding-right", "padding-top", "page-break-after", "page-break-before", "page-break-inside", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pointer-events", "position", "quotes", "resize", "rest", "rest-after", "rest-before", "right", "row-gap", "scroll-margin", "scroll-margin-block", "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom", "scroll-margin-inline", "scroll-margin-inline-end", "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right", "scroll-margin-top", "scroll-padding", "scroll-padding-block", "scroll-padding-block-end", "scroll-padding-block-start", "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end", "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right", "scroll-padding-top", "scroll-snap-align", "scroll-snap-stop", "scroll-snap-type", "scrollbar-color", "scrollbar-gutter", "scrollbar-width", "shape-image-threshold", "shape-margin", "shape-outside", "speak", "speak-as", "src", "tab-size", "table-layout", "text-align", "text-align-all", "text-align-last", "text-combine-upright", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-indent", "text-justify", "text-orientation", "text-overflow", "text-rendering", "text-shadow", "text-transform", "text-underline-position", "top", "transform", "transform-box", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "white-space", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "writing-mode", "z-index"].reverse()
      , Gu = Wu.concat(Xu);
    const Yu = ["a", "abbr", "address", "article", "aside", "audio", "b", "blockquote", "body", "button", "canvas", "caption", "cite", "code", "dd", "del", "details", "dfn", "div", "dl", "dt", "em", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "mark", "menu", "nav", "object", "ol", "p", "q", "quote", "samp", "section", "span", "strong", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "ul", "var", "video"]
      , Ku = ["any-hover", "any-pointer", "aspect-ratio", "color", "color-gamut", "color-index", "device-aspect-ratio", "device-height", "device-width", "display-mode", "forced-colors", "grid", "height", "hover", "inverted-colors", "monochrome", "orientation", "overflow-block", "overflow-inline", "pointer", "prefers-color-scheme", "prefers-contrast", "prefers-reduced-motion", "prefers-reduced-transparency", "resolution", "scan", "scripting", "update", "width", "min-width", "max-width", "min-height", "max-height"]
      , Ju = ["active", "any-link", "blank", "checked", "current", "default", "defined", "dir", "disabled", "drop", "empty", "enabled", "first", "first-child", "first-of-type", "fullscreen", "future", "focus", "focus-visible", "focus-within", "has", "host", "host-context", "hover", "indeterminate", "in-range", "invalid", "is", "lang", "last-child", "last-of-type", "left", "link", "local-link", "not", "nth-child", "nth-col", "nth-last-child", "nth-last-col", "nth-last-of-type", "nth-of-type", "only-child", "only-of-type", "optional", "out-of-range", "past", "placeholder-shown", "read-only", "read-write", "required", "right", "root", "scope", "target", "target-within", "user-invalid", "valid", "visited", "where"]
      , ed = ["after", "backdrop", "before", "cue", "cue-region", "first-letter", "first-line", "grammar-error", "marker", "part", "placeholder", "selection", "slotted", "spelling-error"]
      , td = ["align-content", "align-items", "align-self", "all", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "backface-visibility", "background", "background-attachment", "background-blend-mode", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "block-size", "border", "border-block", "border-block-color", "border-block-end", "border-block-end-color", "border-block-end-style", "border-block-end-width", "border-block-start", "border-block-start-color", "border-block-start-style", "border-block-start-width", "border-block-style", "border-block-width", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-inline", "border-inline-color", "border-inline-end", "border-inline-end-color", "border-inline-end-style", "border-inline-end-width", "border-inline-start", "border-inline-start-color", "border-inline-start-style", "border-inline-start-width", "border-inline-style", "border-inline-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "caret-color", "clear", "clip", "clip-path", "clip-rule", "color", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "contain", "content", "content-visibility", "counter-increment", "counter-reset", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "empty-cells", "filter", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "flow", "font", "font-display", "font-family", "font-feature-settings", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-smoothing", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-variation-settings", "font-weight", "gap", "glyph-orientation-vertical", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "ime-mode", "inline-size", "isolation", "justify-content", "left", "letter-spacing", "line-break", "line-height", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-block", "margin-block-end", "margin-block-start", "margin-bottom", "margin-inline", "margin-inline-end", "margin-inline-start", "margin-left", "margin-right", "margin-top", "marks", "mask", "mask-border", "mask-border-mode", "mask-border-outset", "mask-border-repeat", "mask-border-slice", "mask-border-source", "mask-border-width", "mask-clip", "mask-composite", "mask-image", "mask-mode", "mask-origin", "mask-position", "mask-repeat", "mask-size", "mask-type", "max-block-size", "max-height", "max-inline-size", "max-width", "min-block-size", "min-height", "min-inline-size", "min-width", "mix-blend-mode", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "none", "normal", "object-fit", "object-position", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-block", "padding-block-end", "padding-block-start", "padding-bottom", "padding-inline", "padding-inline-end", "padding-inline-start", "padding-left", "padding-right", "padding-top", "page-break-after", "page-break-before", "page-break-inside", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pointer-events", "position", "quotes", "resize", "rest", "rest-after", "rest-before", "right", "row-gap", "scroll-margin", "scroll-margin-block", "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom", "scroll-margin-inline", "scroll-margin-inline-end", "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right", "scroll-margin-top", "scroll-padding", "scroll-padding-block", "scroll-padding-block-end", "scroll-padding-block-start", "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end", "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right", "scroll-padding-top", "scroll-snap-align", "scroll-snap-stop", "scroll-snap-type", "scrollbar-color", "scrollbar-gutter", "scrollbar-width", "shape-image-threshold", "shape-margin", "shape-outside", "speak", "speak-as", "src", "tab-size", "table-layout", "text-align", "text-align-all", "text-align-last", "text-combine-upright", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-indent", "text-justify", "text-orientation", "text-overflow", "text-rendering", "text-shadow", "text-transform", "text-underline-position", "top", "transform", "transform-box", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "white-space", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "writing-mode", "z-index"].reverse();
    function nd(e) {
        return e ? "string" == typeof e ? e : e.source : null
    }
    function rd(e) {
        return od("(?=", e, ")")
    }
    function od(...e) {
        return e.map((e=>nd(e))).join("")
    }
    function id(...e) {
        const t = function(e) {
            const t = e[e.length - 1];
            return "object" == typeof t && t.constructor === Object ? (e.splice(e.length - 1, 1),
            t) : {}
        }(e);
        return "(" + (t.capture ? "" : "?:") + e.map((e=>nd(e))).join("|") + ")"
    }
    const ad = e=>od(/\b/, e, /\w$/.test(e) ? /\b/ : /\B/)
      , sd = ["Protocol", "Type"].map(ad)
      , ld = ["init", "self"].map(ad)
      , cd = ["Any", "Self"]
      , ud = ["actor", "any", "associatedtype", "async", "await", /as\?/, /as!/, "as", "borrowing", "break", "case", "catch", "class", "consume", "consuming", "continue", "convenience", "copy", "default", "defer", "deinit", "didSet", "distributed", "do", "dynamic", "each", "else", "enum", "extension", "fallthrough", /fileprivate\(set\)/, "fileprivate", "final", "for", "func", "get", "guard", "if", "import", "indirect", "infix", /init\?/, /init!/, "inout", /internal\(set\)/, "internal", "in", "is", "isolated", "nonisolated", "lazy", "let", "macro", "mutating", "nonmutating", /open\(set\)/, "open", "operator", "optional", "override", "postfix", "precedencegroup", "prefix", /private\(set\)/, "private", "protocol", /public\(set\)/, "public", "repeat", "required", "rethrows", "return", "set", "some", "static", "struct", "subscript", "super", "switch", "throws", "throw", /try\?/, /try!/, "try", "typealias", /unowned\(safe\)/, /unowned\(unsafe\)/, "unowned", "var", "weak", "where", "while", "willSet"]
      , dd = ["false", "nil", "true"]
      , pd = ["assignment", "associativity", "higherThan", "left", "lowerThan", "none", "right"]
      , hd = ["#colorLiteral", "#column", "#dsohandle", "#else", "#elseif", "#endif", "#error", "#file", "#fileID", "#fileLiteral", "#filePath", "#function", "#if", "#imageLiteral", "#keyPath", "#line", "#selector", "#sourceLocation", "#warning"]
      , fd = ["abs", "all", "any", "assert", "assertionFailure", "debugPrint", "dump", "fatalError", "getVaList", "isKnownUniquelyReferenced", "max", "min", "numericCast", "pointwiseMax", "pointwiseMin", "precondition", "preconditionFailure", "print", "readLine", "repeatElement", "sequence", "stride", "swap", "swift_unboxFromSwiftValueWithType", "transcode", "type", "unsafeBitCast", "unsafeDowncast", "withExtendedLifetime", "withUnsafeMutablePointer", "withUnsafePointer", "withVaList", "withoutActuallyEscaping", "zip"]
      , md = id(/[/=\-+!*%<>&|^~?]/, /[\u00A1-\u00A7]/, /[\u00A9\u00AB]/, /[\u00AC\u00AE]/, /[\u00B0\u00B1]/, /[\u00B6\u00BB\u00BF\u00D7\u00F7]/, /[\u2016-\u2017]/, /[\u2020-\u2027]/, /[\u2030-\u203E]/, /[\u2041-\u2053]/, /[\u2055-\u205E]/, /[\u2190-\u23FF]/, /[\u2500-\u2775]/, /[\u2794-\u2BFF]/, /[\u2E00-\u2E7F]/, /[\u3001-\u3003]/, /[\u3008-\u3020]/, /[\u3030]/)
      , gd = id(md, /[\u0300-\u036F]/, /[\u1DC0-\u1DFF]/, /[\u20D0-\u20FF]/, /[\uFE00-\uFE0F]/, /[\uFE20-\uFE2F]/)
      , bd = od(md, gd, "*")
      , Od = id(/[a-zA-Z_]/, /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/, /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/, /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/, /[\u1E00-\u1FFF]/, /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/, /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/, /[\u2C00-\u2DFF\u2E80-\u2FFF]/, /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/, /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/, /[\uFE47-\uFEFE\uFF00-\uFFFD]/)
      , vd = id(Od, /\d/, /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/)
      , yd = od(Od, vd, "*")
      , wd = od(/[A-Z]/, vd, "*")
      , _d = ["attached", "autoclosure", od(/convention\(/, id("swift", "block", "c"), /\)/), "discardableResult", "dynamicCallable", "dynamicMemberLookup", "escaping", "freestanding", "frozen", "GKInspectable", "IBAction", "IBDesignable", "IBInspectable", "IBOutlet", "IBSegueAction", "inlinable", "main", "nonobjc", "NSApplicationMain", "NSCopying", "NSManaged", od(/objc\(/, yd, /\)/), "objc", "objcMembers", "propertyWrapper", "requires_stored_property_inits", "resultBuilder", "Sendable", "testable", "UIApplicationMain", "unchecked", "unknown", "usableFromInline", "warn_unqualified_access"]
      , kd = ["iOS", "iOSApplicationExtension", "macOS", "macOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "watchOS", "watchOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "swift"];
    const Sd = "[A-Za-z$_][0-9A-Za-z$_]*"
      , Ed = ["as", "in", "of", "if", "for", "while", "finally", "var", "new", "function", "do", "return", "void", "else", "break", "catch", "instanceof", "with", "throw", "case", "default", "try", "switch", "continue", "typeof", "delete", "let", "yield", "const", "class", "debugger", "async", "await", "static", "import", "from", "export", "extends"]
      , xd = ["true", "false", "null", "undefined", "NaN", "Infinity"]
      , Td = ["Object", "Function", "Boolean", "Symbol", "Math", "Date", "Number", "BigInt", "String", "RegExp", "Array", "Float32Array", "Float64Array", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Int32Array", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array", "Set", "Map", "WeakSet", "WeakMap", "ArrayBuffer", "SharedArrayBuffer", "Atomics", "DataView", "JSON", "Promise", "Generator", "GeneratorFunction", "AsyncFunction", "Reflect", "Proxy", "Intl", "WebAssembly"]
      , Ad = ["Error", "EvalError", "InternalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError"]
      , Cd = ["setInterval", "setTimeout", "clearInterval", "clearTimeout", "require", "exports", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "unescape"]
      , Pd = ["arguments", "this", "super", "console", "window", "document", "localStorage", "sessionStorage", "module", "global"]
      , Dd = [].concat(Cd, Td, Ad);
    function Rd(e) {
        const t = e.regex
          , n = t.concat(/[\p{L}_]/u, t.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u)
          , r = {
            className: "symbol",
            begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
        }
          , o = {
            begin: /\s/,
            contains: [{
                className: "keyword",
                begin: /#?[a-z_][a-z1-9_-]+/,
                illegal: /\n/
            }]
        }
          , i = e.inherit(o, {
            begin: /\(/,
            end: /\)/
        })
          , a = e.inherit(e.APOS_STRING_MODE, {
            className: "string"
        })
          , s = e.inherit(e.QUOTE_STRING_MODE, {
            className: "string"
        })
          , l = {
            endsWithParent: !0,
            illegal: /</,
            relevance: 0,
            contains: [{
                className: "attr",
                begin: /[\p{L}0-9._:-]+/u,
                relevance: 0
            }, {
                begin: /=\s*/,
                relevance: 0,
                contains: [{
                    className: "string",
                    endsParent: !0,
                    variants: [{
                        begin: /"/,
                        end: /"/,
                        contains: [r]
                    }, {
                        begin: /'/,
                        end: /'/,
                        contains: [r]
                    }, {
                        begin: /[^\s"'=<>`]+/
                    }]
                }]
            }]
        };
        return {
            name: "HTML, XML",
            aliases: ["html", "xhtml", "rss", "atom", "xjb", "xsd", "xsl", "plist", "wsf", "svg"],
            case_insensitive: !0,
            unicodeRegex: !0,
            contains: [{
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                relevance: 10,
                contains: [o, s, a, i, {
                    begin: /\[/,
                    end: /\]/,
                    contains: [{
                        className: "meta",
                        begin: /<![a-z]/,
                        end: />/,
                        contains: [o, i, s, a]
                    }]
                }]
            }, e.COMMENT(/<!--/, /-->/, {
                relevance: 10
            }), {
                begin: /<!\[CDATA\[/,
                end: /\]\]>/,
                relevance: 10
            }, r, {
                className: "meta",
                end: /\?>/,
                variants: [{
                    begin: /<\?xml/,
                    relevance: 10,
                    contains: [s]
                }, {
                    begin: /<\?[a-z][a-z0-9]+/
                }]
            }, {
                className: "tag",
                begin: /<style(?=\s|>)/,
                end: />/,
                keywords: {
                    name: "style"
                },
                contains: [l],
                starts: {
                    end: /<\/style>/,
                    returnEnd: !0,
                    subLanguage: ["css", "xml"]
                }
            }, {
                className: "tag",
                begin: /<script(?=\s|>)/,
                end: />/,
                keywords: {
                    name: "script"
                },
                contains: [l],
                starts: {
                    end: /<\/script>/,
                    returnEnd: !0,
                    subLanguage: ["javascript", "handlebars", "xml"]
                }
            }, {
                className: "tag",
                begin: /<>|<\/>/
            }, {
                className: "tag",
                begin: t.concat(/</, t.lookahead(t.concat(n, t.either(/\/>/, />/, /\s/)))),
                end: /\/?>/,
                contains: [{
                    className: "name",
                    begin: n,
                    relevance: 0,
                    starts: l
                }]
            }, {
                className: "tag",
                begin: t.concat(/<\//, t.lookahead(t.concat(n, />/))),
                contains: [{
                    className: "name",
                    begin: n,
                    relevance: 0
                }, {
                    begin: />/,
                    relevance: 0,
                    endsParent: !0
                }]
            }]
        }
    }
    function Nd(e) {
        return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
    }
    function $d(e) {
        return e instanceof Map ? e.clear = e.delete = e.set = function() {
            throw new Error("map is read-only")
        }
        : e instanceof Set && (e.add = e.clear = e.delete = function() {
            throw new Error("set is read-only")
        }
        ),
        Object.freeze(e),
        Object.getOwnPropertyNames(e).forEach((t=>{
            const n = e[t]
              , r = typeof n;
            "object" !== r && "function" !== r || Object.isFrozen(n) || $d(n)
        }
        )),
        e
    }
    let Id = class {
        constructor(e) {
            void 0 === e.data && (e.data = {}),
            this.data = e.data,
            this.isMatchIgnored = !1
        }
        ignoreMatch() {
            this.isMatchIgnored = !0
        }
    }
    ;
    function Md(e) {
        return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;")
    }
    function Ld(e, ...t) {
        const n = Object.create(null);
        for (const r in e)
            n[r] = e[r];
        return t.forEach((function(e) {
            for (const t in e)
                n[t] = e[t]
        }
        )),
        n
    }
    const Qd = e=>!!e.scope;
    class Bd {
        constructor(e, t) {
            this.buffer = "",
            this.classPrefix = t.classPrefix,
            e.walk(this)
        }
        addText(e) {
            this.buffer += Md(e)
        }
        openNode(e) {
            if (!Qd(e))
                return;
            const t = ((e,{prefix: t})=>{
                if (e.startsWith("language:"))
                    return e.replace("language:", "language-");
                if (e.includes(".")) {
                    const n = e.split(".");
                    return [`${t}${n.shift()}`, ...n.map(((e,t)=>`${e}${"_".repeat(t + 1)}`))].join(" ")
                }
                return `${t}${e}`
            }
            )(e.scope, {
                prefix: this.classPrefix
            });
            this.span(t)
        }
        closeNode(e) {
            Qd(e) && (this.buffer += "</span>")
        }
        value() {
            return this.buffer
        }
        span(e) {
            this.buffer += `<span class="${e}">`
        }
    }
    const Ud = (e={})=>{
        const t = {
            children: []
        };
        return Object.assign(t, e),
        t
    }
    ;
    class Fd {
        constructor() {
            this.rootNode = Ud(),
            this.stack = [this.rootNode]
        }
        get top() {
            return this.stack[this.stack.length - 1]
        }
        get root() {
            return this.rootNode
        }
        add(e) {
            this.top.children.push(e)
        }
        openNode(e) {
            const t = Ud({
                scope: e
            });
            this.add(t),
            this.stack.push(t)
        }
        closeNode() {
            if (this.stack.length > 1)
                return this.stack.pop()
        }
        closeAllNodes() {
            for (; this.closeNode(); )
                ;
        }
        toJSON() {
            return JSON.stringify(this.rootNode, null, 4)
        }
        walk(e) {
            return this.constructor._walk(e, this.rootNode)
        }
        static _walk(e, t) {
            return "string" == typeof t ? e.addText(t) : t.children && (e.openNode(t),
            t.children.forEach((t=>this._walk(e, t))),
            e.closeNode(t)),
            e
        }
        static _collapse(e) {
            "string" != typeof e && e.children && (e.children.every((e=>"string" == typeof e)) ? e.children = [e.children.join("")] : e.children.forEach((e=>{
                Fd._collapse(e)
            }
            )))
        }
    }
    class jd extends Fd {
        constructor(e) {
            super(),
            this.options = e
        }
        addText(e) {
            "" !== e && this.add(e)
        }
        startScope(e) {
            this.openNode(e)
        }
        endScope() {
            this.closeNode()
        }
        __addSublanguage(e, t) {
            const n = e.root;
            t && (n.scope = `language:${t}`),
            this.add(n)
        }
        toHTML() {
            return new Bd(this,this.options).value()
        }
        finalize() {
            return this.closeAllNodes(),
            !0
        }
    }
    function zd(e) {
        return e ? "string" == typeof e ? e : e.source : null
    }
    function qd(e) {
        return Wd("(?=", e, ")")
    }
    function Hd(e) {
        return Wd("(?:", e, ")*")
    }
    function Zd(e) {
        return Wd("(?:", e, ")?")
    }
    function Wd(...e) {
        return e.map((e=>zd(e))).join("")
    }
    function Xd(...e) {
        const t = function(e) {
            const t = e[e.length - 1];
            return "object" == typeof t && t.constructor === Object ? (e.splice(e.length - 1, 1),
            t) : {}
        }(e);
        return "(" + (t.capture ? "" : "?:") + e.map((e=>zd(e))).join("|") + ")"
    }
    function Vd(e) {
        return new RegExp(e.toString() + "|").exec("").length - 1
    }
    const Gd = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
    function Yd(e, {joinWith: t}) {
        let n = 0;
        return e.map((e=>{
            n += 1;
            const t = n;
            let r = zd(e)
              , o = "";
            for (; r.length > 0; ) {
                const e = Gd.exec(r);
                if (!e) {
                    o += r;
                    break
                }
                o += r.substring(0, e.index),
                r = r.substring(e.index + e[0].length),
                "\\" === e[0][0] && e[1] ? o += "\\" + String(Number(e[1]) + t) : (o += e[0],
                "(" === e[0] && n++)
            }
            return o
        }
        )).map((e=>`(${e})`)).join(t)
    }
    const Kd = "[a-zA-Z]\\w*"
      , Jd = "[a-zA-Z_]\\w*"
      , ep = "\\b\\d+(\\.\\d+)?"
      , tp = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)"
      , np = "\\b(0b[01]+)"
      , rp = {
        begin: "\\\\[\\s\\S]",
        relevance: 0
    }
      , op = {
        scope: "string",
        begin: "'",
        end: "'",
        illegal: "\\n",
        contains: [rp]
    }
      , ip = {
        scope: "string",
        begin: '"',
        end: '"',
        illegal: "\\n",
        contains: [rp]
    }
      , ap = function(e, t, n={}) {
        const r = Ld({
            scope: "comment",
            begin: e,
            end: t,
            contains: []
        }, n);
        r.contains.push({
            scope: "doctag",
            begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
            end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
            excludeBegin: !0,
            relevance: 0
        });
        const o = Xd("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/);
        return r.contains.push({
            begin: Wd(/[ ]+/, "(", o, /[.]?[:]?([.][ ]|[ ])/, "){3}")
        }),
        r
    }
      , sp = ap("//", "$")
      , lp = ap("/\\*", "\\*/")
      , cp = ap("#", "$")
      , up = {
        scope: "number",
        begin: ep,
        relevance: 0
    }
      , dp = {
        scope: "number",
        begin: tp,
        relevance: 0
    }
      , pp = {
        scope: "number",
        begin: np,
        relevance: 0
    }
      , hp = {
        scope: "regexp",
        begin: /\/(?=[^/\n]*\/)/,
        end: /\/[gimuy]*/,
        contains: [rp, {
            begin: /\[/,
            end: /\]/,
            relevance: 0,
            contains: [rp]
        }]
    }
      , fp = {
        scope: "title",
        begin: Kd,
        relevance: 0
    }
      , mp = {
        scope: "title",
        begin: Jd,
        relevance: 0
    }
      , gp = {
        begin: "\\.\\s*" + Jd,
        relevance: 0
    };
    var bp = Object.freeze({
        __proto__: null,
        APOS_STRING_MODE: op,
        BACKSLASH_ESCAPE: rp,
        BINARY_NUMBER_MODE: pp,
        BINARY_NUMBER_RE: np,
        COMMENT: ap,
        C_BLOCK_COMMENT_MODE: lp,
        C_LINE_COMMENT_MODE: sp,
        C_NUMBER_MODE: dp,
        C_NUMBER_RE: tp,
        END_SAME_AS_BEGIN: function(e) {
            return Object.assign(e, {
                "on:begin": (e,t)=>{
                    t.data._beginMatch = e[1]
                }
                ,
                "on:end": (e,t)=>{
                    t.data._beginMatch !== e[1] && t.ignoreMatch()
                }
            })
        },
        HASH_COMMENT_MODE: cp,
        IDENT_RE: Kd,
        MATCH_NOTHING_RE: /\b\B/,
        METHOD_GUARD: gp,
        NUMBER_MODE: up,
        NUMBER_RE: ep,
        PHRASAL_WORDS_MODE: {
            begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
        },
        QUOTE_STRING_MODE: ip,
        REGEXP_MODE: hp,
        RE_STARTERS_RE: "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",
        SHEBANG: (e={})=>{
            const t = /^#![ ]*\//;
            return e.binary && (e.begin = Wd(t, /.*\b/, e.binary, /\b.*/)),
            Ld({
                scope: "meta",
                begin: t,
                end: /$/,
                relevance: 0,
                "on:begin": (e,t)=>{
                    0 !== e.index && t.ignoreMatch()
                }
            }, e)
        }
        ,
        TITLE_MODE: fp,
        UNDERSCORE_IDENT_RE: Jd,
        UNDERSCORE_TITLE_MODE: mp
    });
    function Op(e, t) {
        "." === e.input[e.index - 1] && t.ignoreMatch()
    }
    function vp(e, t) {
        void 0 !== e.className && (e.scope = e.className,
        delete e.className)
    }
    function yp(e, t) {
        t && e.beginKeywords && (e.begin = "\\b(" + e.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)",
        e.__beforeBegin = Op,
        e.keywords = e.keywords || e.beginKeywords,
        delete e.beginKeywords,
        void 0 === e.relevance && (e.relevance = 0))
    }
    function wp(e, t) {
        Array.isArray(e.illegal) && (e.illegal = Xd(...e.illegal))
    }
    function _p(e, t) {
        if (e.match) {
            if (e.begin || e.end)
                throw new Error("begin & end are not supported with match");
            e.begin = e.match,
            delete e.match
        }
    }
    function kp(e, t) {
        void 0 === e.relevance && (e.relevance = 1)
    }
    const Sp = (e,t)=>{
        if (!e.beforeMatch)
            return;
        if (e.starts)
            throw new Error("beforeMatch cannot be used with starts");
        const n = Object.assign({}, e);
        Object.keys(e).forEach((t=>{
            delete e[t]
        }
        )),
        e.keywords = n.keywords,
        e.begin = Wd(n.beforeMatch, qd(n.begin)),
        e.starts = {
            relevance: 0,
            contains: [Object.assign(n, {
                endsParent: !0
            })]
        },
        e.relevance = 0,
        delete n.beforeMatch
    }
      , Ep = ["of", "and", "for", "in", "not", "or", "if", "then", "parent", "list", "value"]
      , xp = "keyword";
    function Tp(e, t, n=xp) {
        const r = Object.create(null);
        return "string" == typeof e ? o(n, e.split(" ")) : Array.isArray(e) ? o(n, e) : Object.keys(e).forEach((function(n) {
            Object.assign(r, Tp(e[n], t, n))
        }
        )),
        r;
        function o(e, n) {
            t && (n = n.map((e=>e.toLowerCase()))),
            n.forEach((function(t) {
                const n = t.split("|");
                r[n[0]] = [e, Ap(n[0], n[1])]
            }
            ))
        }
    }
    function Ap(e, t) {
        return t ? Number(t) : function(e) {
            return Ep.includes(e.toLowerCase())
        }(e) ? 0 : 1
    }
    const Cp = {}
      , Pp = e=>{
        console.error(e)
    }
      , Dp = (e,...t)=>{
        console.log(`WARN: ${e}`, ...t)
    }
      , Rp = (e,t)=>{
        Cp[`${e}/${t}`] || (console.log(`Deprecated as of ${e}. ${t}`),
        Cp[`${e}/${t}`] = !0)
    }
      , Np = new Error;
    function $p(e, t, {key: n}) {
        let r = 0;
        const o = e[n]
          , i = {}
          , a = {};
        for (let s = 1; s <= t.length; s++)
            a[s + r] = o[s],
            i[s + r] = !0,
            r += Vd(t[s - 1]);
        e[n] = a,
        e[n]._emit = i,
        e[n]._multi = !0
    }
    function Ip(e) {
        !function(e) {
            e.scope && "object" == typeof e.scope && null !== e.scope && (e.beginScope = e.scope,
            delete e.scope)
        }(e),
        "string" == typeof e.beginScope && (e.beginScope = {
            _wrap: e.beginScope
        }),
        "string" == typeof e.endScope && (e.endScope = {
            _wrap: e.endScope
        }),
        function(e) {
            if (Array.isArray(e.begin)) {
                if (e.skip || e.excludeBegin || e.returnBegin)
                    throw Pp("skip, excludeBegin, returnBegin not compatible with beginScope: {}"),
                    Np;
                if ("object" != typeof e.beginScope || null === e.beginScope)
                    throw Pp("beginScope must be object"),
                    Np;
                $p(e, e.begin, {
                    key: "beginScope"
                }),
                e.begin = Yd(e.begin, {
                    joinWith: ""
                })
            }
        }(e),
        function(e) {
            if (Array.isArray(e.end)) {
                if (e.skip || e.excludeEnd || e.returnEnd)
                    throw Pp("skip, excludeEnd, returnEnd not compatible with endScope: {}"),
                    Np;
                if ("object" != typeof e.endScope || null === e.endScope)
                    throw Pp("endScope must be object"),
                    Np;
                $p(e, e.end, {
                    key: "endScope"
                }),
                e.end = Yd(e.end, {
                    joinWith: ""
                })
            }
        }(e)
    }
    function Mp(e) {
        function t(t, n) {
            return new RegExp(zd(t),"m" + (e.case_insensitive ? "i" : "") + (e.unicodeRegex ? "u" : "") + (n ? "g" : ""))
        }
        class n {
            constructor() {
                this.matchIndexes = {},
                this.regexes = [],
                this.matchAt = 1,
                this.position = 0
            }
            addRule(e, t) {
                t.position = this.position++,
                this.matchIndexes[this.matchAt] = t,
                this.regexes.push([t, e]),
                this.matchAt += Vd(e) + 1
            }
            compile() {
                0 === this.regexes.length && (this.exec = ()=>null);
                const e = this.regexes.map((e=>e[1]));
                this.matcherRe = t(Yd(e, {
                    joinWith: "|"
                }), !0),
                this.lastIndex = 0
            }
            exec(e) {
                this.matcherRe.lastIndex = this.lastIndex;
                const t = this.matcherRe.exec(e);
                if (!t)
                    return null;
                const n = t.findIndex(((e,t)=>t > 0 && void 0 !== e))
                  , r = this.matchIndexes[n];
                return t.splice(0, n),
                Object.assign(t, r)
            }
        }
        class r {
            constructor() {
                this.rules = [],
                this.multiRegexes = [],
                this.count = 0,
                this.lastIndex = 0,
                this.regexIndex = 0
            }
            getMatcher(e) {
                if (this.multiRegexes[e])
                    return this.multiRegexes[e];
                const t = new n;
                return this.rules.slice(e).forEach((([e,n])=>t.addRule(e, n))),
                t.compile(),
                this.multiRegexes[e] = t,
                t
            }
            resumingScanAtSamePosition() {
                return 0 !== this.regexIndex
            }
            considerAll() {
                this.regexIndex = 0
            }
            addRule(e, t) {
                this.rules.push([e, t]),
                "begin" === t.type && this.count++
            }
            exec(e) {
                const t = this.getMatcher(this.regexIndex);
                t.lastIndex = this.lastIndex;
                let n = t.exec(e);
                if (this.resumingScanAtSamePosition())
                    if (n && n.index === this.lastIndex)
                        ;
                    else {
                        const t = this.getMatcher(0);
                        t.lastIndex = this.lastIndex + 1,
                        n = t.exec(e)
                    }
                return n && (this.regexIndex += n.position + 1,
                this.regexIndex === this.count && this.considerAll()),
                n
            }
        }
        if (e.compilerExtensions || (e.compilerExtensions = []),
        e.contains && e.contains.includes("self"))
            throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
        return e.classNameAliases = Ld(e.classNameAliases || {}),
        function n(o, i) {
            const a = o;
            if (o.isCompiled)
                return a;
            [vp, _p, Ip, Sp].forEach((e=>e(o, i))),
            e.compilerExtensions.forEach((e=>e(o, i))),
            o.__beforeBegin = null,
            [yp, wp, kp].forEach((e=>e(o, i))),
            o.isCompiled = !0;
            let s = null;
            return "object" == typeof o.keywords && o.keywords.$pattern && (o.keywords = Object.assign({}, o.keywords),
            s = o.keywords.$pattern,
            delete o.keywords.$pattern),
            s = s || /\w+/,
            o.keywords && (o.keywords = Tp(o.keywords, e.case_insensitive)),
            a.keywordPatternRe = t(s, !0),
            i && (o.begin || (o.begin = /\B|\b/),
            a.beginRe = t(a.begin),
            o.end || o.endsWithParent || (o.end = /\B|\b/),
            o.end && (a.endRe = t(a.end)),
            a.terminatorEnd = zd(a.end) || "",
            o.endsWithParent && i.terminatorEnd && (a.terminatorEnd += (o.end ? "|" : "") + i.terminatorEnd)),
            o.illegal && (a.illegalRe = t(o.illegal)),
            o.contains || (o.contains = []),
            o.contains = [].concat(...o.contains.map((function(e) {
                return function(e) {
                    e.variants && !e.cachedVariants && (e.cachedVariants = e.variants.map((function(t) {
                        return Ld(e, {
                            variants: null
                        }, t)
                    }
                    )));
                    if (e.cachedVariants)
                        return e.cachedVariants;
                    if (Lp(e))
                        return Ld(e, {
                            starts: e.starts ? Ld(e.starts) : null
                        });
                    if (Object.isFrozen(e))
                        return Ld(e);
                    return e
                }("self" === e ? o : e)
            }
            ))),
            o.contains.forEach((function(e) {
                n(e, a)
            }
            )),
            o.starts && n(o.starts, i),
            a.matcher = function(e) {
                const t = new r;
                return e.contains.forEach((e=>t.addRule(e.begin, {
                    rule: e,
                    type: "begin"
                }))),
                e.terminatorEnd && t.addRule(e.terminatorEnd, {
                    type: "end"
                }),
                e.illegal && t.addRule(e.illegal, {
                    type: "illegal"
                }),
                t
            }(a),
            a
        }(e)
    }
    function Lp(e) {
        return !!e && (e.endsWithParent || Lp(e.starts))
    }
    class Qp extends Error {
        constructor(e, t) {
            super(e),
            this.name = "HTMLInjectionError",
            this.html = t
        }
    }
    const Bp = Md
      , Up = Ld
      , Fp = Symbol("nomatch")
      , jp = function(e) {
        const t = Object.create(null)
          , n = Object.create(null)
          , r = [];
        let o = !0;
        const i = "Could not find the language '{}', did you forget to load/include a language module?"
          , a = {
            disableAutodetect: !0,
            name: "Plain text",
            contains: []
        };
        let s = {
            ignoreUnescapedHTML: !1,
            throwUnescapedHTML: !1,
            noHighlightRe: /^(no-?highlight)$/i,
            languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
            classPrefix: "hljs-",
            cssSelector: "pre code",
            languages: null,
            __emitter: jd
        };
        function l(e) {
            return s.noHighlightRe.test(e)
        }
        function c(e, t, n) {
            let r = ""
              , o = "";
            "object" == typeof t ? (r = e,
            n = t.ignoreIllegals,
            o = t.language) : (Rp("10.7.0", "highlight(lang, code, ...args) has been deprecated."),
            Rp("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277"),
            o = e,
            r = t),
            void 0 === n && (n = !0);
            const i = {
                code: r,
                language: o
            };
            O("before:highlight", i);
            const a = i.result ? i.result : u(i.language, i.code, n);
            return a.code = i.code,
            O("after:highlight", a),
            a
        }
        function u(e, n, r, a) {
            const l = Object.create(null);
            function c() {
                if (!E.keywords)
                    return void T.addText(A);
                let e = 0;
                E.keywordPatternRe.lastIndex = 0;
                let t = E.keywordPatternRe.exec(A)
                  , n = "";
                for (; t; ) {
                    n += A.substring(e, t.index);
                    const o = _.case_insensitive ? t[0].toLowerCase() : t[0]
                      , i = (r = o,
                    E.keywords[r]);
                    if (i) {
                        const [e,r] = i;
                        if (T.addText(n),
                        n = "",
                        l[o] = (l[o] || 0) + 1,
                        l[o] <= 7 && (C += r),
                        e.startsWith("_"))
                            n += t[0];
                        else {
                            const n = _.classNameAliases[e] || e;
                            h(t[0], n)
                        }
                    } else
                        n += t[0];
                    e = E.keywordPatternRe.lastIndex,
                    t = E.keywordPatternRe.exec(A)
                }
                var r;
                n += A.substring(e),
                T.addText(n)
            }
            function p() {
                null != E.subLanguage ? function() {
                    if ("" === A)
                        return;
                    let e = null;
                    if ("string" == typeof E.subLanguage) {
                        if (!t[E.subLanguage])
                            return void T.addText(A);
                        e = u(E.subLanguage, A, !0, x[E.subLanguage]),
                        x[E.subLanguage] = e._top
                    } else
                        e = d(A, E.subLanguage.length ? E.subLanguage : null);
                    E.relevance > 0 && (C += e.relevance),
                    T.__addSublanguage(e._emitter, e.language)
                }() : c(),
                A = ""
            }
            function h(e, t) {
                "" !== e && (T.startScope(t),
                T.addText(e),
                T.endScope())
            }
            function f(e, t) {
                let n = 1;
                const r = t.length - 1;
                for (; n <= r; ) {
                    if (!e._emit[n]) {
                        n++;
                        continue
                    }
                    const r = _.classNameAliases[e[n]] || e[n]
                      , o = t[n];
                    r ? h(o, r) : (A = o,
                    c(),
                    A = ""),
                    n++
                }
            }
            function g(e, t) {
                return e.scope && "string" == typeof e.scope && T.openNode(_.classNameAliases[e.scope] || e.scope),
                e.beginScope && (e.beginScope._wrap ? (h(A, _.classNameAliases[e.beginScope._wrap] || e.beginScope._wrap),
                A = "") : e.beginScope._multi && (f(e.beginScope, t),
                A = "")),
                E = Object.create(e, {
                    parent: {
                        value: E
                    }
                }),
                E
            }
            function b(e, t, n) {
                let r = function(e, t) {
                    const n = e && e.exec(t);
                    return n && 0 === n.index
                }(e.endRe, n);
                if (r) {
                    if (e["on:end"]) {
                        const n = new Id(e);
                        e["on:end"](t, n),
                        n.isMatchIgnored && (r = !1)
                    }
                    if (r) {
                        for (; e.endsParent && e.parent; )
                            e = e.parent;
                        return e
                    }
                }
                if (e.endsWithParent)
                    return b(e.parent, t, n)
            }
            function O(e) {
                return 0 === E.matcher.regexIndex ? (A += e[0],
                1) : (R = !0,
                0)
            }
            function v(e) {
                const t = e[0]
                  , r = n.substring(e.index)
                  , o = b(E, e, r);
                if (!o)
                    return Fp;
                const i = E;
                E.endScope && E.endScope._wrap ? (p(),
                h(t, E.endScope._wrap)) : E.endScope && E.endScope._multi ? (p(),
                f(E.endScope, e)) : i.skip ? A += t : (i.returnEnd || i.excludeEnd || (A += t),
                p(),
                i.excludeEnd && (A = t));
                do {
                    E.scope && T.closeNode(),
                    E.skip || E.subLanguage || (C += E.relevance),
                    E = E.parent
                } while (E !== o.parent);
                return o.starts && g(o.starts, e),
                i.returnEnd ? 0 : t.length
            }
            let y = {};
            function w(t, i) {
                const a = i && i[0];
                if (A += t,
                null == a)
                    return p(),
                    0;
                if ("begin" === y.type && "end" === i.type && y.index === i.index && "" === a) {
                    if (A += n.slice(i.index, i.index + 1),
                    !o) {
                        const t = new Error(`0 width match regex (${e})`);
                        throw t.languageName = e,
                        t.badRule = y.rule,
                        t
                    }
                    return 1
                }
                if (y = i,
                "begin" === i.type)
                    return function(e) {
                        const t = e[0]
                          , n = e.rule
                          , r = new Id(n)
                          , o = [n.__beforeBegin, n["on:begin"]];
                        for (const i of o)
                            if (i && (i(e, r),
                            r.isMatchIgnored))
                                return O(t);
                        return n.skip ? A += t : (n.excludeBegin && (A += t),
                        p(),
                        n.returnBegin || n.excludeBegin || (A = t)),
                        g(n, e),
                        n.returnBegin ? 0 : t.length
                    }(i);
                if ("illegal" === i.type && !r) {
                    const e = new Error('Illegal lexeme "' + a + '" for mode "' + (E.scope || "<unnamed>") + '"');
                    throw e.mode = E,
                    e
                }
                if ("end" === i.type) {
                    const e = v(i);
                    if (e !== Fp)
                        return e
                }
                if ("illegal" === i.type && "" === a)
                    return 1;
                if (D > 1e5 && D > 3 * i.index) {
                    throw new Error("potential infinite loop, way more iterations than matches")
                }
                return A += a,
                a.length
            }
            const _ = m(e);
            if (!_)
                throw Pp(i.replace("{}", e)),
                new Error('Unknown language: "' + e + '"');
            const k = Mp(_);
            let S = ""
              , E = a || k;
            const x = {}
              , T = new s.__emitter(s);
            !function() {
                const e = [];
                for (let t = E; t !== _; t = t.parent)
                    t.scope && e.unshift(t.scope);
                e.forEach((e=>T.openNode(e)))
            }();
            let A = ""
              , C = 0
              , P = 0
              , D = 0
              , R = !1;
            try {
                if (_.__emitTokens)
                    _.__emitTokens(n, T);
                else {
                    for (E.matcher.considerAll(); ; ) {
                        D++,
                        R ? R = !1 : E.matcher.considerAll(),
                        E.matcher.lastIndex = P;
                        const e = E.matcher.exec(n);
                        if (!e)
                            break;
                        const t = w(n.substring(P, e.index), e);
                        P = e.index + t
                    }
                    w(n.substring(P))
                }
                return T.finalize(),
                S = T.toHTML(),
                {
                    language: e,
                    value: S,
                    relevance: C,
                    illegal: !1,
                    _emitter: T,
                    _top: E
                }
            } catch (N) {
                if (N.message && N.message.includes("Illegal"))
                    return {
                        language: e,
                        value: Bp(n),
                        illegal: !0,
                        relevance: 0,
                        _illegalBy: {
                            message: N.message,
                            index: P,
                            context: n.slice(P - 100, P + 100),
                            mode: N.mode,
                            resultSoFar: S
                        },
                        _emitter: T
                    };
                if (o)
                    return {
                        language: e,
                        value: Bp(n),
                        illegal: !1,
                        relevance: 0,
                        errorRaised: N,
                        _emitter: T,
                        _top: E
                    };
                throw N
            }
        }
        function d(e, n) {
            n = n || s.languages || Object.keys(t);
            const r = function(e) {
                const t = {
                    value: Bp(e),
                    illegal: !1,
                    relevance: 0,
                    _top: a,
                    _emitter: new s.__emitter(s)
                };
                return t._emitter.addText(e),
                t
            }(e)
              , o = n.filter(m).filter(b).map((t=>u(t, e, !1)));
            o.unshift(r);
            const i = o.sort(((e,t)=>{
                if (e.relevance !== t.relevance)
                    return t.relevance - e.relevance;
                if (e.language && t.language) {
                    if (m(e.language).supersetOf === t.language)
                        return 1;
                    if (m(t.language).supersetOf === e.language)
                        return -1
                }
                return 0
            }
            ))
              , [l,c] = i
              , d = l;
            return d.secondBest = c,
            d
        }
        function p(e) {
            let t = null;
            const r = function(e) {
                let t = e.className + " ";
                t += e.parentNode ? e.parentNode.className : "";
                const n = s.languageDetectRe.exec(t);
                if (n) {
                    const t = m(n[1]);
                    return t || (Dp(i.replace("{}", n[1])),
                    Dp("Falling back to no-highlight mode for this block.", e)),
                    t ? n[1] : "no-highlight"
                }
                return t.split(/\s+/).find((e=>l(e) || m(e)))
            }(e);
            if (l(r))
                return;
            if (O("before:highlightElement", {
                el: e,
                language: r
            }),
            e.dataset.highlighted)
                return void console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", e);
            if (e.children.length > 0 && (s.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."),
            console.warn("https://github.com/highlightjs/highlight.js/wiki/security"),
            console.warn("The element with unescaped HTML:"),
            console.warn(e)),
            s.throwUnescapedHTML)) {
                throw new Qp("One of your code blocks includes unescaped HTML.",e.innerHTML)
            }
            t = e;
            const o = t.textContent
              , a = r ? c(o, {
                language: r,
                ignoreIllegals: !0
            }) : d(o);
            e.innerHTML = a.value,
            e.dataset.highlighted = "yes",
            function(e, t, r) {
                const o = t && n[t] || r;
                e.classList.add("hljs"),
                e.classList.add(`language-${o}`)
            }(e, r, a.language),
            e.result = {
                language: a.language,
                re: a.relevance,
                relevance: a.relevance
            },
            a.secondBest && (e.secondBest = {
                language: a.secondBest.language,
                relevance: a.secondBest.relevance
            }),
            O("after:highlightElement", {
                el: e,
                result: a,
                text: o
            })
        }
        let h = !1;
        function f() {
            if ("loading" === document.readyState)
                return void (h = !0);
            document.querySelectorAll(s.cssSelector).forEach(p)
        }
        function m(e) {
            return e = (e || "").toLowerCase(),
            t[e] || t[n[e]]
        }
        function g(e, {languageName: t}) {
            "string" == typeof e && (e = [e]),
            e.forEach((e=>{
                n[e.toLowerCase()] = t
            }
            ))
        }
        function b(e) {
            const t = m(e);
            return t && !t.disableAutodetect
        }
        function O(e, t) {
            const n = e;
            r.forEach((function(e) {
                e[n] && e[n](t)
            }
            ))
        }
        "undefined" != typeof window && window.addEventListener && window.addEventListener("DOMContentLoaded", (function() {
            h && f()
        }
        ), !1),
        Object.assign(e, {
            highlight: c,
            highlightAuto: d,
            highlightAll: f,
            highlightElement: p,
            highlightBlock: function(e) {
                return Rp("10.7.0", "highlightBlock will be removed entirely in v12.0"),
                Rp("10.7.0", "Please use highlightElement now."),
                p(e)
            },
            configure: function(e) {
                s = Up(s, e)
            },
            initHighlighting: ()=>{
                f(),
                Rp("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.")
            }
            ,
            initHighlightingOnLoad: function() {
                f(),
                Rp("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.")
            },
            registerLanguage: function(n, r) {
                let i = null;
                try {
                    i = r(e)
                } catch (s) {
                    if (Pp("Language definition for '{}' could not be registered.".replace("{}", n)),
                    !o)
                        throw s;
                    Pp(s),
                    i = a
                }
                i.name || (i.name = n),
                t[n] = i,
                i.rawDefinition = r.bind(null, e),
                i.aliases && g(i.aliases, {
                    languageName: n
                })
            },
            unregisterLanguage: function(e) {
                delete t[e];
                for (const t of Object.keys(n))
                    n[t] === e && delete n[t]
            },
            listLanguages: function() {
                return Object.keys(t)
            },
            getLanguage: m,
            registerAliases: g,
            autoDetection: b,
            inherit: Up,
            addPlugin: function(e) {
                !function(e) {
                    e["before:highlightBlock"] && !e["before:highlightElement"] && (e["before:highlightElement"] = t=>{
                        e["before:highlightBlock"](Object.assign({
                            block: t.el
                        }, t))
                    }
                    ),
                    e["after:highlightBlock"] && !e["after:highlightElement"] && (e["after:highlightElement"] = t=>{
                        e["after:highlightBlock"](Object.assign({
                            block: t.el
                        }, t))
                    }
                    )
                }(e),
                r.push(e)
            },
            removePlugin: function(e) {
                const t = r.indexOf(e);
                -1 !== t && r.splice(t, 1)
            }
        }),
        e.debugMode = function() {
            o = !1
        }
        ,
        e.safeMode = function() {
            o = !0
        }
        ,
        e.versionString = "11.9.0",
        e.regex = {
            concat: Wd,
            lookahead: qd,
            either: Xd,
            optional: Zd,
            anyNumberOfTimes: Hd
        };
        for (const v in bp)
            "object" == typeof bp[v] && $d(bp[v]);
        return Object.assign(e, bp),
        e
    }
      , zp = jp({});
    zp.newInstance = ()=>jp({});
    var qp = zp;
    zp.HighlightJS = zp,
    zp.default = zp;
    const Hp = Nd(qp)
      , Zp = {}
      , Wp = "hljs-";
    class Xp {
        constructor(e) {
            this.options = e,
            this.root = {
                type: "root",
                children: [],
                data: {
                    language: void 0,
                    relevance: 0
                }
            },
            this.stack = [this.root]
        }
        addText(e) {
            if ("" === e)
                return;
            const t = this.stack[this.stack.length - 1]
              , n = t.children[t.children.length - 1];
            n && "text" === n.type ? n.value += e : t.children.push({
                type: "text",
                value: e
            })
        }
        startScope(e) {
            this.openNode(String(e))
        }
        endScope() {
            this.closeNode()
        }
        __addSublanguage(e, t) {
            const n = this.stack[this.stack.length - 1]
              , r = e.root.children;
            t ? n.children.push({
                type: "element",
                tagName: "span",
                properties: {
                    className: [t]
                },
                children: r
            }) : n.children.push(...r)
        }
        openNode(e) {
            const t = this
              , n = e.split(".").map((function(e, n) {
                return n ? e + "_".repeat(n) : t.options.classPrefix + e
            }
            ))
              , r = {
                type: "element",
                tagName: "span",
                properties: {
                    className: n
                },
                children: []
            };
            this.stack[this.stack.length - 1].children.push(r),
            this.stack.push(r)
        }
        closeNode() {
            this.stack.pop()
        }
        finalize() {}
        toHTML() {
            return ""
        }
    }
    const Vp = []
      , Gp = !0
      , Yp = !1
      , Kp = "skip";
    function Jp(e, t, n, r) {
        let o;
        "function" == typeof t && "function" != typeof n ? (r = n,
        n = t) : o = t;
        const i = tu(o)
          , a = r ? -1 : 1;
        !function e(o, s, l) {
            const c = o && "object" == typeof o ? o : {};
            if ("string" == typeof c.type) {
                const e = "string" == typeof c.tagName ? c.tagName : "string" == typeof c.name ? c.name : void 0;
                Object.defineProperty(u, "name", {
                    value: "node (" + o.type + (e ? "<" + e + ">" : "") + ")"
                })
            }
            return u;
            function u() {
                let c, u, d, p = Vp;
                if ((!t || i(o, s, l[l.length - 1] || void 0)) && (p = function(e) {
                    if (Array.isArray(e))
                        return e;
                    if ("number" == typeof e)
                        return [Gp, e];
                    return null == e ? Vp : [e]
                }(n(o, l)),
                p[0] === Yp))
                    return p;
                if ("children"in o && o.children) {
                    const t = o;
                    if (t.children && p[0] !== Kp)
                        for (u = (r ? t.children.length : -1) + a,
                        d = l.concat(t); u > -1 && u < t.children.length; ) {
                            const n = t.children[u];
                            if (c = e(n, u, d)(),
                            c[0] === Yp)
                                return c;
                            u = "number" == typeof c[1] ? c[1] : u + a
                        }
                }
                return p
            }
        }(e, void 0, [])()
    }
    function eh(e, t, n, r) {
        let o, i, a;
        "function" == typeof t && "function" != typeof n ? (i = void 0,
        a = t,
        o = n) : (i = t,
        a = n,
        o = r),
        Jp(e, i, (function(e, t) {
            const n = t[t.length - 1]
              , r = n ? n.children.indexOf(e) : void 0;
            return a(e, r, n)
        }
        ), o)
    }
    const th = {};
    function nh(e) {
        const t = e || th
          , n = t.aliases
          , r = (null == e ? void 0 : e.detect) ?? !1
          , o = t.languages
          , i = t.plainText
          , a = t.prefix
          , s = t.subset;
        let l = "hljs";
        const c = (null == e ? void 0 : e.lowlight) ?? function(e) {
            const t = Hp.newInstance();
            return e && o(e),
            {
                highlight: n,
                highlightAuto: function(e, o) {
                    const i = (o || Zp).subset || r();
                    let a, s = -1, l = 0;
                    for (; ++s < i.length; ) {
                        const r = i[s];
                        if (!t.getLanguage(r))
                            continue;
                        const c = n(r, e, o);
                        c.data && void 0 !== c.data.relevance && c.data.relevance > l && (l = c.data.relevance,
                        a = c)
                    }
                    return a || {
                        type: "root",
                        children: [],
                        data: {
                            language: void 0,
                            relevance: l
                        }
                    }
                },
                listLanguages: r,
                register: o,
                registerAlias: function(e, n) {
                    if ("string" == typeof e)
                        t.registerAliases("string" == typeof n ? n : [...n], {
                            languageName: e
                        });
                    else {
                        let n;
                        for (n in e)
                            if (Object.hasOwn(e, n)) {
                                const r = e[n];
                                t.registerAliases("string" == typeof r ? r : [...r], {
                                    languageName: n
                                })
                            }
                    }
                },
                registered: function(e) {
                    return Boolean(t.getLanguage(e))
                }
            };
            function n(e, n, r) {
                const o = r || Zp
                  , i = "string" == typeof o.prefix ? o.prefix : Wp;
                if (!t.getLanguage(e))
                    throw new Error("Unknown language: `" + e + "` is not registered");
                t.configure({
                    __emitter: Xp,
                    classPrefix: i
                });
                const a = t.highlight(n, {
                    ignoreIllegals: !0,
                    language: e
                });
                if (a.errorRaised)
                    throw new Error("Could not highlight with `Highlight.js`",{
                        cause: a.errorRaised
                    });
                const s = a._emitter.root
                  , l = s.data;
                return l.language = a.language,
                l.relevance = a.relevance,
                s
            }
            function r() {
                return t.listLanguages()
            }
            function o(e, n) {
                if ("string" == typeof e)
                    t.registerLanguage(e, n);
                else {
                    let n;
                    for (n in e)
                        Object.hasOwn(e, n) && t.registerLanguage(n, e[n])
                }
            }
        }(o);
        if (n && c.registerAlias(n),
        a) {
            const e = a.indexOf("-");
            l = e > -1 ? a.slice(0, e) : a
        }
        return function(e, t) {
            eh(e, "element", (function(e, n, o) {
                var u;
                if ("code" !== e.tagName || !o || "element" !== o.type || "pre" !== o.tagName)
                    return;
                const d = function(e) {
                    const t = e.properties.className;
                    if (!Array.isArray(t))
                        return "";
                    const n = t.reduce(((e,t)=>{
                        if (e)
                            return e;
                        const n = String(t);
                        return "no-highlight" === n || "nohighlight" === n ? "no-highlight" : "lang-" === n.slice(0, 5) ? n.slice(5) : "language-" === n.slice(0, 9) ? n.slice(9) : e
                    }
                    ), "");
                    return eu[n || ""] || n
                }(e);
                if ("no-highlight" === d || !d && !r || d && (null == i ? void 0 : i.includes(d)))
                    return;
                let p;
                Array.isArray(e.properties.className) || (e.properties.className = []),
                e.properties.className.includes(l) || e.properties.className.unshift(l);
                try {
                    p = d ? c.highlight(d, Ou(o), {
                        prefix: a
                    }) : c.highlightAuto(Ou(o), {
                        prefix: a,
                        subset: s
                    })
                } catch (h) {
                    const n = h;
                    if (d && /Unknown language/.test(n.message))
                        return void t.message("Cannot highlight as `" + d + "`, it’s not registered", {
                            ancestors: [o, e],
                            cause: n,
                            place: e.position,
                            ruleId: "missing-language",
                            source: "rehype-highlight"
                        });
                    throw n
                }
                !d && (null == (u = p.data) ? void 0 : u.language) && e.properties.className.push("language-" + p.data.language),
                p.children.length > 0 && (e.children = p.children)
            }
            ))
        }
    }
    const rh = "object" == typeof self ? self : globalThis
      , oh = e=>((e,t)=>{
        const n = (t,n)=>(e.set(n, t),
        t)
          , r = o=>{
            if (e.has(o))
                return e.get(o);
            const [i,a] = t[o];
            switch (i) {
            case 0:
            case -1:
                return n(a, o);
            case 1:
                {
                    const e = n([], o);
                    for (const t of a)
                        e.push(r(t));
                    return e
                }
            case 2:
                {
                    const e = n({}, o);
                    for (const [t,n] of a)
                        e[r(t)] = r(n);
                    return e
                }
            case 3:
                return n(new Date(a), o);
            case 4:
                {
                    const {source: e, flags: t} = a;
                    return n(new RegExp(e,t), o)
                }
            case 5:
                {
                    const e = n(new Map, o);
                    for (const [t,n] of a)
                        e.set(r(t), r(n));
                    return e
                }
            case 6:
                {
                    const e = n(new Set, o);
                    for (const t of a)
                        e.add(r(t));
                    return e
                }
            case 7:
                {
                    const {name: e, message: t} = a;
                    return n(new rh[e](t), o)
                }
            case 8:
                return n(BigInt(a), o);
            case "BigInt":
                return n(Object(BigInt(a)), o)
            }
            return n(new rh[i](a), o)
        }
        ;
        return r
    }
    )(new Map, e)(0)
      , ih = ""
      , {toString: ah} = {}
      , {keys: sh} = Object
      , lh = e=>{
        const t = typeof e;
        if ("object" !== t || !e)
            return [0, t];
        const n = ah.call(e).slice(8, -1);
        switch (n) {
        case "Array":
            return [1, ih];
        case "Object":
            return [2, ih];
        case "Date":
            return [3, ih];
        case "RegExp":
            return [4, ih];
        case "Map":
            return [5, ih];
        case "Set":
            return [6, ih]
        }
        return n.includes("Array") ? [1, n] : n.includes("Error") ? [7, n] : [2, n]
    }
      , ch = ([e,t])=>0 === e && ("function" === t || "symbol" === t)
      , uh = (e,{json: t, lossy: n}={})=>{
        const r = [];
        return ((e,t,n,r)=>{
            const o = (e,t)=>{
                const o = r.push(e) - 1;
                return n.set(t, o),
                o
            }
              , i = r=>{
                if (n.has(r))
                    return n.get(r);
                let[a,s] = lh(r);
                switch (a) {
                case 0:
                    {
                        let t = r;
                        switch (s) {
                        case "bigint":
                            a = 8,
                            t = r.toString();
                            break;
                        case "function":
                        case "symbol":
                            if (e)
                                throw new TypeError("unable to serialize " + s);
                            t = null;
                            break;
                        case "undefined":
                            return o([-1], r)
                        }
                        return o([a, t], r)
                    }
                case 1:
                    {
                        if (s)
                            return o([s, [...r]], r);
                        const e = []
                          , t = o([a, e], r);
                        for (const n of r)
                            e.push(i(n));
                        return t
                    }
                case 2:
                    {
                        if (s)
                            switch (s) {
                            case "BigInt":
                                return o([s, r.toString()], r);
                            case "Boolean":
                            case "Number":
                            case "String":
                                return o([s, r.valueOf()], r)
                            }
                        if (t && "toJSON"in r)
                            return i(r.toJSON());
                        const n = []
                          , l = o([a, n], r);
                        for (const t of sh(r))
                            !e && ch(lh(r[t])) || n.push([i(t), i(r[t])]);
                        return l
                    }
                case 3:
                    return o([a, r.toISOString()], r);
                case 4:
                    {
                        const {source: e, flags: t} = r;
                        return o([a, {
                            source: e,
                            flags: t
                        }], r)
                    }
                case 5:
                    {
                        const t = []
                          , n = o([a, t], r);
                        for (const [o,a] of r)
                            (e || !ch(lh(o)) && !ch(lh(a))) && t.push([i(o), i(a)]);
                        return n
                    }
                case 6:
                    {
                        const t = []
                          , n = o([a, t], r);
                        for (const o of r)
                            !e && ch(lh(o)) || t.push(i(o));
                        return n
                    }
                }
                const {message: l} = r;
                return o([a, {
                    name: s,
                    message: l
                }], r)
            }
            ;
            return i
        }
        )(!(t || n), !!t, new Map, r)(e),
        r
    }
      , dh = "function" == typeof structuredClone ? (e,t)=>t && ("json"in t || "lossy"in t) ? oh(uh(e, t)) : structuredClone(e) : (e,t)=>oh(uh(e, t))
      , ph = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/
      , hh = /^[a-zA-Z]:\\/;
    function fh(e) {
        const t = String(e || "").trim();
        return t ? t.split(/[ \t\n\r\f]+/g) : []
    }
    function mh(e) {
        return e.join(" ").trim()
    }
    const gh = ["http", "https"]
      , bh = ["nofollow"]
      , Oh = {};
    function vh(e) {
        const t = e || Oh
          , n = t.protocols || gh
          , r = au(t.test);
        return function(e) {
            eh(e, "element", (function(e, o, i) {
                if ("a" === e.tagName && "string" == typeof e.properties.href && r(e, o, i)) {
                    const r = e.properties.href;
                    if (function(e) {
                        if ("string" != typeof e)
                            throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
                        return !hh.test(e) && ph.test(e)
                    }(r) ? n.includes(r.slice(0, r.indexOf(":"))) : r.startsWith("//")) {
                        const n = yh(t.content, e)
                          , r = n && !Array.isArray(n) ? [n] : n
                          , o = yh(t.rel, e) || bh
                          , i = "string" == typeof o ? fh(o) : o
                          , a = yh(t.target, e)
                          , s = yh(t.properties, e);
                        if (s && Object.assign(e.properties, dh(s)),
                        i.length > 0 && (e.properties.rel = [...i]),
                        a && (e.properties.target = a),
                        r) {
                            const n = yh(t.contentProperties, e) || {};
                            e.children.push({
                                type: "element",
                                tagName: "span",
                                properties: dh(n),
                                children: dh(r)
                            })
                        }
                    }
                }
            }
            ))
        }
    }
    function yh(e, t) {
        return "function" == typeof e ? e(t) : e
    }
    const wh = au((function(e) {
        return "audio" === e.tagName || "canvas" === e.tagName || "embed" === e.tagName || "iframe" === e.tagName || "img" === e.tagName || "math" === e.tagName || "object" === e.tagName || "picture" === e.tagName || "svg" === e.tagName || "video" === e.tagName
    }
    ))
      , _h = {}.hasOwnProperty;
    const kh = new Set(["pingback", "prefetch", "stylesheet"]);
    const Sh = au(["a", "abbr", "area", "b", "bdi", "bdo", "br", "button", "cite", "code", "data", "datalist", "del", "dfn", "em", "i", "input", "ins", "kbd", "keygen", "label", "map", "mark", "meter", "noscript", "output", "progress", "q", "ruby", "s", "samp", "script", "select", "small", "span", "strong", "sub", "sup", "template", "textarea", "time", "u", "var", "wbr"])
      , Eh = au("meta");
    function xh(e) {
        return Boolean("text" === e.type || Sh(e) || wh(e) || function(e) {
            if ("element" !== e.type || "link" !== e.tagName)
                return !1;
            if (e.properties.itemProp)
                return !0;
            const t = e.properties.rel;
            let n = -1;
            if (!Array.isArray(t) || 0 === t.length)
                return !1;
            for (; ++n < t.length; )
                if (!kh.has(String(t[n])))
                    return !1;
            return !0
        }(e) || Eh(e) && function(e, t) {
            const n = "element" === e.type && _h.call(e.properties, t) && e.properties[t];
            return null != n && !1 !== n
        }(e, "itemProp"))
    }
    const Th = /[ \t\n\f\r]/g;
    function Ah(e) {
        return "object" == typeof e ? "text" === e.type && Ch(e.value) : Ch(e)
    }
    function Ch(e) {
        return "" === e.replace(Th, "")
    }
    const Ph = ["pre", "script", "style", "textarea"]
      , Dh = ["address", "article", "aside", "blockquote", "body", "br", "caption", "center", "col", "colgroup", "dd", "dialog", "dir", "div", "dl", "dt", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "legend", "li", "li", "listing", "main", "menu", "nav", "ol", "optgroup", "option", "p", "plaintext", "pre", "section", "summary", "table", "tbody", "td", "td", "tfoot", "th", "th", "thead", "tr", "ul", "wbr", "xmp"]
      , Rh = ["button", "input", "select", "textarea"]
      , Nh = ["area", "base", "basefont", "dialog", "datalist", "head", "link", "meta", "noembed", "noframes", "param", "rp", "script", "source", "style", "template", "track", "title"]
      , $h = {}
      , Ih = tu(["doctype", "comment"]);
    function Mh(e, t) {
        if ("children"in e) {
            const n = {
                ...t
            };
            return ("root" === e.type || Uh(e)) && (n.before = !0,
            n.after = !0),
            n.whitespace = function(e, t) {
                if ("tagName"in e && e.properties)
                    switch (e.tagName) {
                    case "listing":
                    case "plaintext":
                    case "script":
                    case "style":
                    case "xmp":
                        return "pre";
                    case "nobr":
                        return "nowrap";
                    case "pre":
                        return e.properties.wrap ? "pre-wrap" : "pre";
                    case "td":
                    case "th":
                        return e.properties.noWrap ? "nowrap" : t.whitespace;
                    case "textarea":
                        return "pre-wrap"
                    }
                return t.whitespace
            }(e, t),
            function(e, t) {
                let n = t.before;
                const r = t.after
                  , o = e.children;
                let i = o.length
                  , a = -1;
                for (; ++a < i; ) {
                    const e = Mh(o[a], {
                        ...t,
                        after: Lh(o, a, r),
                        before: n
                    });
                    e.remove ? (o.splice(a, 1),
                    a--,
                    i--) : e.ignore || (n = e.stripAtStart),
                    Bh(o[a]) && (n = !1)
                }
                return {
                    ignore: !1,
                    stripAtStart: Boolean(n || r),
                    remove: !1
                }
            }(e, n)
        }
        if ("text" === e.type) {
            if ("normal" === t.whitespace)
                return function(e, t) {
                    const n = t.collapse(e.value)
                      , r = {
                        ignore: !1,
                        stripAtStart: !1,
                        remove: !1
                    };
                    let o = 0
                      , i = n.length;
                    t.before && jh(n.charAt(0)) && o++;
                    o !== i && jh(n.charAt(i - 1)) && (t.after ? i-- : r.stripAtStart = !0);
                    o === i ? r.remove = !0 : e.value = n.slice(o, i);
                    return r
                }(e, t);
            "nowrap" === t.whitespace && (e.value = t.collapse(e.value))
        }
        return {
            ignore: Ih(e),
            stripAtStart: !1,
            remove: !1
        }
    }
    function Lh(e, t, n) {
        for (; ++t < e.length; ) {
            const n = e[t];
            let r = Qh(n);
            if (void 0 === r && "children"in n && !Fh(n) && (r = Lh(n.children, -1)),
            "boolean" == typeof r)
                return r
        }
        return n
    }
    function Qh(e) {
        if ("element" === e.type) {
            if (Bh(e))
                return !1;
            if (Uh(e))
                return !0
        } else if ("text" === e.type) {
            if (!Ah(e))
                return !1
        } else if (!Ih(e))
            return !1
    }
    function Bh(e) {
        return wh(e) || iu(e, Rh)
    }
    function Uh(e) {
        return iu(e, Dh)
    }
    function Fh(e) {
        return Boolean("element" === e.type && e.properties.hidden) || Ih(e) || iu(e, Nh)
    }
    function jh(e) {
        return " " === e || "\n" === e
    }
    function zh(e) {
        const t = /\r?\n|\r/.exec(e);
        return t ? t[0] : " "
    }
    function qh() {
        return " "
    }
    const Hh = {}
      , Zh = function(e) {
        const t = function(e) {
            return t;
            function t(t) {
                return String(t).replace(/[\t\n\v\f\r ]+/g, e)
            }
        }((e || $h).newlines ? zh : qh);
        return function(e) {
            Mh(e, {
                collapse: t,
                whitespace: "normal"
            })
        }
    }({
        newlines: !0
    });
    function Wh(e) {
        const t = e || Hh;
        let n = t.indent || 2
          , r = t.indentInitial;
        return "number" == typeof n && (n = " ".repeat(n)),
        null == r && (r = !0),
        function(e) {
            let t;
            Zh(e),
            Jp(e, (function(e, i) {
                let a = -1;
                if (!("children"in e))
                    return;
                if (iu(e, "head") && (t = !0),
                t && iu(e, "body") && (t = void 0),
                iu(e, Ph))
                    return Kp;
                const s = e.children;
                let l, c = i.length;
                if (0 === s.length || !Xh(e, t))
                    return;
                for (r || c--; ++a < s.length; ) {
                    const e = s[a];
                    "text" !== e.type && "comment" !== e.type || (e.value.includes("\n") && (l = !0),
                    e.value = e.value.replace(/ *\n/g, "$&" + String(n).repeat(c)))
                }
                const u = [];
                let d;
                for (a = -1; ++a < s.length; ) {
                    const e = s[a];
                    (Xh(e, t) || l && !a) && (o(u, c, e),
                    l = !0),
                    d = e,
                    u.push(e)
                }
                d && (l || Xh(d, t)) && (Ah(d) && (u.pop(),
                d = u[u.length - 1]),
                o(u, c - 1)),
                e.children = u
            }
            ))
        }
        ;
        function o(e, t, r) {
            const o = e[e.length - 1]
              , a = (i(o && Ah(o) ? e[e.length - 2] : o) && i(r) ? "\n\n" : "\n") + String(n).repeat(Math.max(t, 0));
            o && "text" === o.type ? o.value = Ah(o) ? a : o.value + a : e.push({
                type: "text",
                value: a
            })
        }
        function i(e) {
            return Boolean(e && "element" === e.type && t.blanks && t.blanks.length > 0 && t.blanks.includes(e.tagName))
        }
    }
    function Xh(e, t) {
        return "root" === e.type || "element" === e.type && (t || iu(e, "script") || wh(e) || !xh(e))
    }
    let Vh = class {
        constructor(e, t, n) {
            this.property = e,
            this.normal = t,
            n && (this.space = n)
        }
    }
    ;
    function Gh(e, t) {
        const n = {}
          , r = {};
        let o = -1;
        for (; ++o < e.length; )
            Object.assign(n, e[o].property),
            Object.assign(r, e[o].normal);
        return new Vh(n,r,t)
    }
    function Yh(e) {
        return e.toLowerCase()
    }
    Vh.prototype.property = {},
    Vh.prototype.normal = {},
    Vh.prototype.space = null;
    class Kh {
        constructor(e, t) {
            this.property = e,
            this.attribute = t
        }
    }
    Kh.prototype.space = null,
    Kh.prototype.boolean = !1,
    Kh.prototype.booleanish = !1,
    Kh.prototype.overloadedBoolean = !1,
    Kh.prototype.number = !1,
    Kh.prototype.commaSeparated = !1,
    Kh.prototype.spaceSeparated = !1,
    Kh.prototype.commaOrSpaceSeparated = !1,
    Kh.prototype.mustUseProperty = !1,
    Kh.prototype.defined = !1;
    let Jh = 0;
    const ef = lf()
      , tf = lf()
      , nf = lf()
      , rf = lf()
      , of = lf()
      , af = lf()
      , sf = lf();
    function lf() {
        return 2 ** ++Jh
    }
    const cf = Object.freeze(Object.defineProperty({
        __proto__: null,
        boolean: ef,
        booleanish: tf,
        commaOrSpaceSeparated: sf,
        commaSeparated: af,
        number: rf,
        overloadedBoolean: nf,
        spaceSeparated: of
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , uf = Object.keys(cf);
    class df extends Kh {
        constructor(e, t, n, r) {
            let o = -1;
            if (super(e, t),
            pf(this, "space", r),
            "number" == typeof n)
                for (; ++o < uf.length; ) {
                    const e = uf[o];
                    pf(this, uf[o], (n & cf[e]) === cf[e])
                }
        }
    }
    function pf(e, t, n) {
        n && (e[t] = n)
    }
    df.prototype.defined = !0;
    const hf = {}.hasOwnProperty;
    function ff(e) {
        const t = {}
          , n = {};
        let r;
        for (r in e.properties)
            if (hf.call(e.properties, r)) {
                const o = e.properties[r]
                  , i = new df(r,e.transform(e.attributes || {}, r),o,e.space);
                e.mustUseProperty && e.mustUseProperty.includes(r) && (i.mustUseProperty = !0),
                t[r] = i,
                n[Yh(r)] = r,
                n[Yh(i.attribute)] = r
            }
        return new Vh(t,n,e.space)
    }
    const mf = ff({
        space: "xlink",
        transform: (e,t)=>"xlink:" + t.slice(5).toLowerCase(),
        properties: {
            xLinkActuate: null,
            xLinkArcRole: null,
            xLinkHref: null,
            xLinkRole: null,
            xLinkShow: null,
            xLinkTitle: null,
            xLinkType: null
        }
    })
      , gf = ff({
        space: "xml",
        transform: (e,t)=>"xml:" + t.slice(3).toLowerCase(),
        properties: {
            xmlLang: null,
            xmlBase: null,
            xmlSpace: null
        }
    });
    function bf(e, t) {
        return t in e ? e[t] : t
    }
    function Of(e, t) {
        return bf(e, t.toLowerCase())
    }
    const vf = ff({
        space: "xmlns",
        attributes: {
            xmlnsxlink: "xmlns:xlink"
        },
        transform: Of,
        properties: {
            xmlns: null,
            xmlnsXLink: null
        }
    })
      , yf = ff({
        transform: (e,t)=>"role" === t ? t : "aria-" + t.slice(4).toLowerCase(),
        properties: {
            ariaActiveDescendant: null,
            ariaAtomic: tf,
            ariaAutoComplete: null,
            ariaBusy: tf,
            ariaChecked: tf,
            ariaColCount: rf,
            ariaColIndex: rf,
            ariaColSpan: rf,
            ariaControls: of,
            ariaCurrent: null,
            ariaDescribedBy: of,
            ariaDetails: null,
            ariaDisabled: tf,
            ariaDropEffect: of,
            ariaErrorMessage: null,
            ariaExpanded: tf,
            ariaFlowTo: of,
            ariaGrabbed: tf,
            ariaHasPopup: null,
            ariaHidden: tf,
            ariaInvalid: null,
            ariaKeyShortcuts: null,
            ariaLabel: null,
            ariaLabelledBy: of,
            ariaLevel: rf,
            ariaLive: null,
            ariaModal: tf,
            ariaMultiLine: tf,
            ariaMultiSelectable: tf,
            ariaOrientation: null,
            ariaOwns: of,
            ariaPlaceholder: null,
            ariaPosInSet: rf,
            ariaPressed: tf,
            ariaReadOnly: tf,
            ariaRelevant: null,
            ariaRequired: tf,
            ariaRoleDescription: of,
            ariaRowCount: rf,
            ariaRowIndex: rf,
            ariaRowSpan: rf,
            ariaSelected: tf,
            ariaSetSize: rf,
            ariaSort: null,
            ariaValueMax: rf,
            ariaValueMin: rf,
            ariaValueNow: rf,
            ariaValueText: null,
            role: null
        }
    })
      , wf = ff({
        space: "html",
        attributes: {
            acceptcharset: "accept-charset",
            classname: "class",
            htmlfor: "for",
            httpequiv: "http-equiv"
        },
        transform: Of,
        mustUseProperty: ["checked", "multiple", "muted", "selected"],
        properties: {
            abbr: null,
            accept: af,
            acceptCharset: of,
            accessKey: of,
            action: null,
            allow: null,
            allowFullScreen: ef,
            allowPaymentRequest: ef,
            allowUserMedia: ef,
            alt: null,
            as: null,
            async: ef,
            autoCapitalize: null,
            autoComplete: of,
            autoFocus: ef,
            autoPlay: ef,
            blocking: of,
            capture: null,
            charSet: null,
            checked: ef,
            cite: null,
            className: of,
            cols: rf,
            colSpan: null,
            content: null,
            contentEditable: tf,
            controls: ef,
            controlsList: of,
            coords: rf | af,
            crossOrigin: null,
            data: null,
            dateTime: null,
            decoding: null,
            default: ef,
            defer: ef,
            dir: null,
            dirName: null,
            disabled: ef,
            download: nf,
            draggable: tf,
            encType: null,
            enterKeyHint: null,
            fetchPriority: null,
            form: null,
            formAction: null,
            formEncType: null,
            formMethod: null,
            formNoValidate: ef,
            formTarget: null,
            headers: of,
            height: rf,
            hidden: ef,
            high: rf,
            href: null,
            hrefLang: null,
            htmlFor: of,
            httpEquiv: of,
            id: null,
            imageSizes: null,
            imageSrcSet: null,
            inert: ef,
            inputMode: null,
            integrity: null,
            is: null,
            isMap: ef,
            itemId: null,
            itemProp: of,
            itemRef: of,
            itemScope: ef,
            itemType: of,
            kind: null,
            label: null,
            lang: null,
            language: null,
            list: null,
            loading: null,
            loop: ef,
            low: rf,
            manifest: null,
            max: null,
            maxLength: rf,
            media: null,
            method: null,
            min: null,
            minLength: rf,
            multiple: ef,
            muted: ef,
            name: null,
            nonce: null,
            noModule: ef,
            noValidate: ef,
            onAbort: null,
            onAfterPrint: null,
            onAuxClick: null,
            onBeforeMatch: null,
            onBeforePrint: null,
            onBeforeToggle: null,
            onBeforeUnload: null,
            onBlur: null,
            onCancel: null,
            onCanPlay: null,
            onCanPlayThrough: null,
            onChange: null,
            onClick: null,
            onClose: null,
            onContextLost: null,
            onContextMenu: null,
            onContextRestored: null,
            onCopy: null,
            onCueChange: null,
            onCut: null,
            onDblClick: null,
            onDrag: null,
            onDragEnd: null,
            onDragEnter: null,
            onDragExit: null,
            onDragLeave: null,
            onDragOver: null,
            onDragStart: null,
            onDrop: null,
            onDurationChange: null,
            onEmptied: null,
            onEnded: null,
            onError: null,
            onFocus: null,
            onFormData: null,
            onHashChange: null,
            onInput: null,
            onInvalid: null,
            onKeyDown: null,
            onKeyPress: null,
            onKeyUp: null,
            onLanguageChange: null,
            onLoad: null,
            onLoadedData: null,
            onLoadedMetadata: null,
            onLoadEnd: null,
            onLoadStart: null,
            onMessage: null,
            onMessageError: null,
            onMouseDown: null,
            onMouseEnter: null,
            onMouseLeave: null,
            onMouseMove: null,
            onMouseOut: null,
            onMouseOver: null,
            onMouseUp: null,
            onOffline: null,
            onOnline: null,
            onPageHide: null,
            onPageShow: null,
            onPaste: null,
            onPause: null,
            onPlay: null,
            onPlaying: null,
            onPopState: null,
            onProgress: null,
            onRateChange: null,
            onRejectionHandled: null,
            onReset: null,
            onResize: null,
            onScroll: null,
            onScrollEnd: null,
            onSecurityPolicyViolation: null,
            onSeeked: null,
            onSeeking: null,
            onSelect: null,
            onSlotChange: null,
            onStalled: null,
            onStorage: null,
            onSubmit: null,
            onSuspend: null,
            onTimeUpdate: null,
            onToggle: null,
            onUnhandledRejection: null,
            onUnload: null,
            onVolumeChange: null,
            onWaiting: null,
            onWheel: null,
            open: ef,
            optimum: rf,
            pattern: null,
            ping: of,
            placeholder: null,
            playsInline: ef,
            popover: null,
            popoverTarget: null,
            popoverTargetAction: null,
            poster: null,
            preload: null,
            readOnly: ef,
            referrerPolicy: null,
            rel: of,
            required: ef,
            reversed: ef,
            rows: rf,
            rowSpan: rf,
            sandbox: of,
            scope: null,
            scoped: ef,
            seamless: ef,
            selected: ef,
            shadowRootClonable: ef,
            shadowRootDelegatesFocus: ef,
            shadowRootMode: null,
            shape: null,
            size: rf,
            sizes: null,
            slot: null,
            span: rf,
            spellCheck: tf,
            src: null,
            srcDoc: null,
            srcLang: null,
            srcSet: null,
            start: rf,
            step: null,
            style: null,
            tabIndex: rf,
            target: null,
            title: null,
            translate: null,
            type: null,
            typeMustMatch: ef,
            useMap: null,
            value: tf,
            width: rf,
            wrap: null,
            writingSuggestions: null,
            align: null,
            aLink: null,
            archive: of,
            axis: null,
            background: null,
            bgColor: null,
            border: rf,
            borderColor: null,
            bottomMargin: rf,
            cellPadding: null,
            cellSpacing: null,
            char: null,
            charOff: null,
            classId: null,
            clear: null,
            code: null,
            codeBase: null,
            codeType: null,
            color: null,
            compact: ef,
            declare: ef,
            event: null,
            face: null,
            frame: null,
            frameBorder: null,
            hSpace: rf,
            leftMargin: rf,
            link: null,
            longDesc: null,
            lowSrc: null,
            marginHeight: rf,
            marginWidth: rf,
            noResize: ef,
            noHref: ef,
            noShade: ef,
            noWrap: ef,
            object: null,
            profile: null,
            prompt: null,
            rev: null,
            rightMargin: rf,
            rules: null,
            scheme: null,
            scrolling: tf,
            standby: null,
            summary: null,
            text: null,
            topMargin: rf,
            valueType: null,
            version: null,
            vAlign: null,
            vLink: null,
            vSpace: rf,
            allowTransparency: null,
            autoCorrect: null,
            autoSave: null,
            disablePictureInPicture: ef,
            disableRemotePlayback: ef,
            prefix: null,
            property: null,
            results: rf,
            security: null,
            unselectable: null
        }
    })
      , _f = ff({
        space: "svg",
        attributes: {
            accentHeight: "accent-height",
            alignmentBaseline: "alignment-baseline",
            arabicForm: "arabic-form",
            baselineShift: "baseline-shift",
            capHeight: "cap-height",
            className: "class",
            clipPath: "clip-path",
            clipRule: "clip-rule",
            colorInterpolation: "color-interpolation",
            colorInterpolationFilters: "color-interpolation-filters",
            colorProfile: "color-profile",
            colorRendering: "color-rendering",
            crossOrigin: "crossorigin",
            dataType: "datatype",
            dominantBaseline: "dominant-baseline",
            enableBackground: "enable-background",
            fillOpacity: "fill-opacity",
            fillRule: "fill-rule",
            floodColor: "flood-color",
            floodOpacity: "flood-opacity",
            fontFamily: "font-family",
            fontSize: "font-size",
            fontSizeAdjust: "font-size-adjust",
            fontStretch: "font-stretch",
            fontStyle: "font-style",
            fontVariant: "font-variant",
            fontWeight: "font-weight",
            glyphName: "glyph-name",
            glyphOrientationHorizontal: "glyph-orientation-horizontal",
            glyphOrientationVertical: "glyph-orientation-vertical",
            hrefLang: "hreflang",
            horizAdvX: "horiz-adv-x",
            horizOriginX: "horiz-origin-x",
            horizOriginY: "horiz-origin-y",
            imageRendering: "image-rendering",
            letterSpacing: "letter-spacing",
            lightingColor: "lighting-color",
            markerEnd: "marker-end",
            markerMid: "marker-mid",
            markerStart: "marker-start",
            navDown: "nav-down",
            navDownLeft: "nav-down-left",
            navDownRight: "nav-down-right",
            navLeft: "nav-left",
            navNext: "nav-next",
            navPrev: "nav-prev",
            navRight: "nav-right",
            navUp: "nav-up",
            navUpLeft: "nav-up-left",
            navUpRight: "nav-up-right",
            onAbort: "onabort",
            onActivate: "onactivate",
            onAfterPrint: "onafterprint",
            onBeforePrint: "onbeforeprint",
            onBegin: "onbegin",
            onCancel: "oncancel",
            onCanPlay: "oncanplay",
            onCanPlayThrough: "oncanplaythrough",
            onChange: "onchange",
            onClick: "onclick",
            onClose: "onclose",
            onCopy: "oncopy",
            onCueChange: "oncuechange",
            onCut: "oncut",
            onDblClick: "ondblclick",
            onDrag: "ondrag",
            onDragEnd: "ondragend",
            onDragEnter: "ondragenter",
            onDragExit: "ondragexit",
            onDragLeave: "ondragleave",
            onDragOver: "ondragover",
            onDragStart: "ondragstart",
            onDrop: "ondrop",
            onDurationChange: "ondurationchange",
            onEmptied: "onemptied",
            onEnd: "onend",
            onEnded: "onended",
            onError: "onerror",
            onFocus: "onfocus",
            onFocusIn: "onfocusin",
            onFocusOut: "onfocusout",
            onHashChange: "onhashchange",
            onInput: "oninput",
            onInvalid: "oninvalid",
            onKeyDown: "onkeydown",
            onKeyPress: "onkeypress",
            onKeyUp: "onkeyup",
            onLoad: "onload",
            onLoadedData: "onloadeddata",
            onLoadedMetadata: "onloadedmetadata",
            onLoadStart: "onloadstart",
            onMessage: "onmessage",
            onMouseDown: "onmousedown",
            onMouseEnter: "onmouseenter",
            onMouseLeave: "onmouseleave",
            onMouseMove: "onmousemove",
            onMouseOut: "onmouseout",
            onMouseOver: "onmouseover",
            onMouseUp: "onmouseup",
            onMouseWheel: "onmousewheel",
            onOffline: "onoffline",
            onOnline: "ononline",
            onPageHide: "onpagehide",
            onPageShow: "onpageshow",
            onPaste: "onpaste",
            onPause: "onpause",
            onPlay: "onplay",
            onPlaying: "onplaying",
            onPopState: "onpopstate",
            onProgress: "onprogress",
            onRateChange: "onratechange",
            onRepeat: "onrepeat",
            onReset: "onreset",
            onResize: "onresize",
            onScroll: "onscroll",
            onSeeked: "onseeked",
            onSeeking: "onseeking",
            onSelect: "onselect",
            onShow: "onshow",
            onStalled: "onstalled",
            onStorage: "onstorage",
            onSubmit: "onsubmit",
            onSuspend: "onsuspend",
            onTimeUpdate: "ontimeupdate",
            onToggle: "ontoggle",
            onUnload: "onunload",
            onVolumeChange: "onvolumechange",
            onWaiting: "onwaiting",
            onZoom: "onzoom",
            overlinePosition: "overline-position",
            overlineThickness: "overline-thickness",
            paintOrder: "paint-order",
            panose1: "panose-1",
            pointerEvents: "pointer-events",
            referrerPolicy: "referrerpolicy",
            renderingIntent: "rendering-intent",
            shapeRendering: "shape-rendering",
            stopColor: "stop-color",
            stopOpacity: "stop-opacity",
            strikethroughPosition: "strikethrough-position",
            strikethroughThickness: "strikethrough-thickness",
            strokeDashArray: "stroke-dasharray",
            strokeDashOffset: "stroke-dashoffset",
            strokeLineCap: "stroke-linecap",
            strokeLineJoin: "stroke-linejoin",
            strokeMiterLimit: "stroke-miterlimit",
            strokeOpacity: "stroke-opacity",
            strokeWidth: "stroke-width",
            tabIndex: "tabindex",
            textAnchor: "text-anchor",
            textDecoration: "text-decoration",
            textRendering: "text-rendering",
            transformOrigin: "transform-origin",
            typeOf: "typeof",
            underlinePosition: "underline-position",
            underlineThickness: "underline-thickness",
            unicodeBidi: "unicode-bidi",
            unicodeRange: "unicode-range",
            unitsPerEm: "units-per-em",
            vAlphabetic: "v-alphabetic",
            vHanging: "v-hanging",
            vIdeographic: "v-ideographic",
            vMathematical: "v-mathematical",
            vectorEffect: "vector-effect",
            vertAdvY: "vert-adv-y",
            vertOriginX: "vert-origin-x",
            vertOriginY: "vert-origin-y",
            wordSpacing: "word-spacing",
            writingMode: "writing-mode",
            xHeight: "x-height",
            playbackOrder: "playbackorder",
            timelineBegin: "timelinebegin"
        },
        transform: bf,
        properties: {
            about: sf,
            accentHeight: rf,
            accumulate: null,
            additive: null,
            alignmentBaseline: null,
            alphabetic: rf,
            amplitude: rf,
            arabicForm: null,
            ascent: rf,
            attributeName: null,
            attributeType: null,
            azimuth: rf,
            bandwidth: null,
            baselineShift: null,
            baseFrequency: null,
            baseProfile: null,
            bbox: null,
            begin: null,
            bias: rf,
            by: null,
            calcMode: null,
            capHeight: rf,
            className: of,
            clip: null,
            clipPath: null,
            clipPathUnits: null,
            clipRule: null,
            color: null,
            colorInterpolation: null,
            colorInterpolationFilters: null,
            colorProfile: null,
            colorRendering: null,
            content: null,
            contentScriptType: null,
            contentStyleType: null,
            crossOrigin: null,
            cursor: null,
            cx: null,
            cy: null,
            d: null,
            dataType: null,
            defaultAction: null,
            descent: rf,
            diffuseConstant: rf,
            direction: null,
            display: null,
            dur: null,
            divisor: rf,
            dominantBaseline: null,
            download: ef,
            dx: null,
            dy: null,
            edgeMode: null,
            editable: null,
            elevation: rf,
            enableBackground: null,
            end: null,
            event: null,
            exponent: rf,
            externalResourcesRequired: null,
            fill: null,
            fillOpacity: rf,
            fillRule: null,
            filter: null,
            filterRes: null,
            filterUnits: null,
            floodColor: null,
            floodOpacity: null,
            focusable: null,
            focusHighlight: null,
            fontFamily: null,
            fontSize: null,
            fontSizeAdjust: null,
            fontStretch: null,
            fontStyle: null,
            fontVariant: null,
            fontWeight: null,
            format: null,
            fr: null,
            from: null,
            fx: null,
            fy: null,
            g1: af,
            g2: af,
            glyphName: af,
            glyphOrientationHorizontal: null,
            glyphOrientationVertical: null,
            glyphRef: null,
            gradientTransform: null,
            gradientUnits: null,
            handler: null,
            hanging: rf,
            hatchContentUnits: null,
            hatchUnits: null,
            height: null,
            href: null,
            hrefLang: null,
            horizAdvX: rf,
            horizOriginX: rf,
            horizOriginY: rf,
            id: null,
            ideographic: rf,
            imageRendering: null,
            initialVisibility: null,
            in: null,
            in2: null,
            intercept: rf,
            k: rf,
            k1: rf,
            k2: rf,
            k3: rf,
            k4: rf,
            kernelMatrix: sf,
            kernelUnitLength: null,
            keyPoints: null,
            keySplines: null,
            keyTimes: null,
            kerning: null,
            lang: null,
            lengthAdjust: null,
            letterSpacing: null,
            lightingColor: null,
            limitingConeAngle: rf,
            local: null,
            markerEnd: null,
            markerMid: null,
            markerStart: null,
            markerHeight: null,
            markerUnits: null,
            markerWidth: null,
            mask: null,
            maskContentUnits: null,
            maskUnits: null,
            mathematical: null,
            max: null,
            media: null,
            mediaCharacterEncoding: null,
            mediaContentEncodings: null,
            mediaSize: rf,
            mediaTime: null,
            method: null,
            min: null,
            mode: null,
            name: null,
            navDown: null,
            navDownLeft: null,
            navDownRight: null,
            navLeft: null,
            navNext: null,
            navPrev: null,
            navRight: null,
            navUp: null,
            navUpLeft: null,
            navUpRight: null,
            numOctaves: null,
            observer: null,
            offset: null,
            onAbort: null,
            onActivate: null,
            onAfterPrint: null,
            onBeforePrint: null,
            onBegin: null,
            onCancel: null,
            onCanPlay: null,
            onCanPlayThrough: null,
            onChange: null,
            onClick: null,
            onClose: null,
            onCopy: null,
            onCueChange: null,
            onCut: null,
            onDblClick: null,
            onDrag: null,
            onDragEnd: null,
            onDragEnter: null,
            onDragExit: null,
            onDragLeave: null,
            onDragOver: null,
            onDragStart: null,
            onDrop: null,
            onDurationChange: null,
            onEmptied: null,
            onEnd: null,
            onEnded: null,
            onError: null,
            onFocus: null,
            onFocusIn: null,
            onFocusOut: null,
            onHashChange: null,
            onInput: null,
            onInvalid: null,
            onKeyDown: null,
            onKeyPress: null,
            onKeyUp: null,
            onLoad: null,
            onLoadedData: null,
            onLoadedMetadata: null,
            onLoadStart: null,
            onMessage: null,
            onMouseDown: null,
            onMouseEnter: null,
            onMouseLeave: null,
            onMouseMove: null,
            onMouseOut: null,
            onMouseOver: null,
            onMouseUp: null,
            onMouseWheel: null,
            onOffline: null,
            onOnline: null,
            onPageHide: null,
            onPageShow: null,
            onPaste: null,
            onPause: null,
            onPlay: null,
            onPlaying: null,
            onPopState: null,
            onProgress: null,
            onRateChange: null,
            onRepeat: null,
            onReset: null,
            onResize: null,
            onScroll: null,
            onSeeked: null,
            onSeeking: null,
            onSelect: null,
            onShow: null,
            onStalled: null,
            onStorage: null,
            onSubmit: null,
            onSuspend: null,
            onTimeUpdate: null,
            onToggle: null,
            onUnload: null,
            onVolumeChange: null,
            onWaiting: null,
            onZoom: null,
            opacity: null,
            operator: null,
            order: null,
            orient: null,
            orientation: null,
            origin: null,
            overflow: null,
            overlay: null,
            overlinePosition: rf,
            overlineThickness: rf,
            paintOrder: null,
            panose1: null,
            path: null,
            pathLength: rf,
            patternContentUnits: null,
            patternTransform: null,
            patternUnits: null,
            phase: null,
            ping: of,
            pitch: null,
            playbackOrder: null,
            pointerEvents: null,
            points: null,
            pointsAtX: rf,
            pointsAtY: rf,
            pointsAtZ: rf,
            preserveAlpha: null,
            preserveAspectRatio: null,
            primitiveUnits: null,
            propagate: null,
            property: sf,
            r: null,
            radius: null,
            referrerPolicy: null,
            refX: null,
            refY: null,
            rel: sf,
            rev: sf,
            renderingIntent: null,
            repeatCount: null,
            repeatDur: null,
            requiredExtensions: sf,
            requiredFeatures: sf,
            requiredFonts: sf,
            requiredFormats: sf,
            resource: null,
            restart: null,
            result: null,
            rotate: null,
            rx: null,
            ry: null,
            scale: null,
            seed: null,
            shapeRendering: null,
            side: null,
            slope: null,
            snapshotTime: null,
            specularConstant: rf,
            specularExponent: rf,
            spreadMethod: null,
            spacing: null,
            startOffset: null,
            stdDeviation: null,
            stemh: null,
            stemv: null,
            stitchTiles: null,
            stopColor: null,
            stopOpacity: null,
            strikethroughPosition: rf,
            strikethroughThickness: rf,
            string: null,
            stroke: null,
            strokeDashArray: sf,
            strokeDashOffset: null,
            strokeLineCap: null,
            strokeLineJoin: null,
            strokeMiterLimit: rf,
            strokeOpacity: rf,
            strokeWidth: null,
            style: null,
            surfaceScale: rf,
            syncBehavior: null,
            syncBehaviorDefault: null,
            syncMaster: null,
            syncTolerance: null,
            syncToleranceDefault: null,
            systemLanguage: sf,
            tabIndex: rf,
            tableValues: null,
            target: null,
            targetX: rf,
            targetY: rf,
            textAnchor: null,
            textDecoration: null,
            textRendering: null,
            textLength: null,
            timelineBegin: null,
            title: null,
            transformBehavior: null,
            type: null,
            typeOf: sf,
            to: null,
            transform: null,
            transformOrigin: null,
            u1: null,
            u2: null,
            underlinePosition: rf,
            underlineThickness: rf,
            unicode: null,
            unicodeBidi: null,
            unicodeRange: null,
            unitsPerEm: rf,
            values: null,
            vAlphabetic: rf,
            vMathematical: rf,
            vectorEffect: null,
            vHanging: rf,
            vIdeographic: rf,
            version: null,
            vertAdvY: rf,
            vertOriginX: rf,
            vertOriginY: rf,
            viewBox: null,
            viewTarget: null,
            visibility: null,
            width: null,
            widths: null,
            wordSpacing: null,
            writingMode: null,
            x: null,
            x1: null,
            x2: null,
            xChannelSelector: null,
            xHeight: rf,
            y: null,
            y1: null,
            y2: null,
            yChannelSelector: null,
            z: null,
            zoomAndPan: null
        }
    })
      , kf = /^data[-\w.:]+$/i
      , Sf = /-[a-z]/g
      , Ef = /[A-Z]/g;
    function xf(e, t) {
        const n = Yh(t);
        let r = t
          , o = Kh;
        if (n in e.normal)
            return e.property[e.normal[n]];
        if (n.length > 4 && "data" === n.slice(0, 4) && kf.test(t)) {
            if ("-" === t.charAt(4)) {
                const e = t.slice(5).replace(Sf, Af);
                r = "data" + e.charAt(0).toUpperCase() + e.slice(1)
            } else {
                const e = t.slice(4);
                if (!Sf.test(e)) {
                    let n = e.replace(Ef, Tf);
                    "-" !== n.charAt(0) && (n = "-" + n),
                    t = "data" + n
                }
            }
            o = df
        }
        return new o(r,t)
    }
    function Tf(e) {
        return "-" + e.toLowerCase()
    }
    function Af(e) {
        return e.charAt(1).toUpperCase()
    }
    const Cf = Gh([gf, mf, vf, yf, wf], "html")
      , Pf = Gh([gf, mf, vf, yf, _f], "svg");
    function Df(e) {
        const t = []
          , n = String(e || "");
        let r = n.indexOf(",")
          , o = 0
          , i = !1;
        for (; !i; ) {
            -1 === r && (r = n.length,
            i = !0);
            const e = n.slice(o, r).trim();
            !e && i || t.push(e),
            o = r + 1,
            r = n.indexOf(",", o)
        }
        return t
    }
    function Rf(e, t) {
        const n = t || {};
        return ("" === e[e.length - 1] ? [...e, ""] : e).join((n.padRight ? " " : "") + "," + (!1 === n.padLeft ? "" : " ")).trim()
    }
    const Nf = /[#.]/g;
    const $f = new Set(["button", "menu", "reset", "submit"])
      , If = {}.hasOwnProperty;
    function Mf(e, t, n) {
        const r = n && function(e) {
            const t = {};
            let n = -1;
            for (; ++n < e.length; )
                t[e[n].toLowerCase()] = e[n];
            return t
        }(n);
        return function(n, o, ...i) {
            let a, s = -1;
            if (null == n) {
                a = {
                    type: "root",
                    children: []
                };
                const e = o;
                i.unshift(e)
            } else if (a = function(e, t) {
                const n = e || ""
                  , r = {};
                let o, i, a = 0;
                for (; a < n.length; ) {
                    Nf.lastIndex = a;
                    const e = Nf.exec(n)
                      , t = n.slice(a, e ? e.index : n.length);
                    t && (o ? "#" === o ? r.id = t : Array.isArray(r.className) ? r.className.push(t) : r.className = [t] : i = t,
                    a += t.length),
                    e && (o = e[0],
                    a++)
                }
                return {
                    type: "element",
                    tagName: i || t || "div",
                    properties: r,
                    children: []
                }
            }(n, t),
            a.tagName = a.tagName.toLowerCase(),
            r && If.call(r, a.tagName) && (a.tagName = r[a.tagName]),
            function(e, t) {
                if (null == e || "object" != typeof e || Array.isArray(e))
                    return !1;
                if ("input" === t || !e.type || "string" != typeof e.type)
                    return !0;
                if ("children"in e && Array.isArray(e.children))
                    return !1;
                if ("button" === t)
                    return $f.has(e.type.toLowerCase());
                return !("value"in e)
            }(o, a.tagName)) {
                let t;
                for (t in o)
                    If.call(o, t) && Lf(e, a.properties, t, o[t])
            } else
                i.unshift(o);
            for (; ++s < i.length; )
                Qf(a.children, i[s]);
            return "element" === a.type && "template" === a.tagName && (a.content = {
                type: "root",
                children: a.children
            },
            a.children = []),
            a
        }
    }
    function Lf(e, t, n, r) {
        const o = xf(e, n);
        let i, a = -1;
        if (null != r) {
            if ("number" == typeof r) {
                if (Number.isNaN(r))
                    return;
                i = r
            } else
                i = "boolean" == typeof r ? r : "string" == typeof r ? o.spaceSeparated ? fh(r) : o.commaSeparated ? Df(r) : o.commaOrSpaceSeparated ? fh(Df(r).join(" ")) : Bf(o, o.property, r) : Array.isArray(r) ? r.concat() : "style" === o.property ? function(e) {
                    const t = [];
                    let n;
                    for (n in e)
                        If.call(e, n) && t.push([n, e[n]].join(": "));
                    return t.join("; ")
                }(r) : String(r);
            if (Array.isArray(i)) {
                const e = [];
                for (; ++a < i.length; ) {
                    const t = Bf(o, o.property, i[a]);
                    e[a] = t
                }
                i = e
            }
            if ("className" === o.property && Array.isArray(t.className)) {
                const e = i;
                i = t.className.concat(e)
            }
            t[o.property] = i
        }
    }
    function Qf(e, t) {
        let n = -1;
        if (null == t)
            ;
        else if ("string" == typeof t || "number" == typeof t)
            e.push({
                type: "text",
                value: String(t)
            });
        else if (Array.isArray(t))
            for (; ++n < t.length; )
                Qf(e, t[n]);
        else {
            if ("object" != typeof t || !("type"in t))
                throw new Error("Expected node, nodes, or string, got `" + t + "`");
            "root" === t.type ? Qf(e, t.children) : e.push(t)
        }
    }
    function Bf(e, t, n) {
        if ("string" == typeof n) {
            if (e.number && n && !Number.isNaN(Number(n)))
                return Number(n);
            if ((e.boolean || e.overloadedBoolean) && ("" === n || Yh(n) === Yh(t)))
                return !0
        }
        return n
    }
    const Uf = Mf(Cf, "div")
      , Ff = Mf(Pf, "g", ["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "solidColor", "textArea", "textPath"])
      , jf = /\r?\n|\r/g;
    const zf = {
        html: "http://www.w3.org/1999/xhtml",
        mathml: "http://www.w3.org/1998/Math/MathML",
        svg: "http://www.w3.org/2000/svg",
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    }
      , qf = {}.hasOwnProperty
      , Hf = Object.prototype;
    function Zf(e, t) {
        const n = t || {};
        return Wf({
            file: n.file || void 0,
            location: !1,
            schema: "svg" === n.space ? Pf : Cf,
            verbose: n.verbose || !1
        }, e)
    }
    function Wf(e, t) {
        let n;
        switch (t.nodeName) {
        case "#comment":
            {
                const r = t;
                return n = {
                    type: "comment",
                    value: r.data
                },
                Vf(e, r, n),
                n
            }
        case "#document":
        case "#document-fragment":
            {
                const r = t
                  , o = "mode"in r && ("quirks" === r.mode || "limited-quirks" === r.mode);
                if (n = {
                    type: "root",
                    children: Xf(e, t.childNodes),
                    data: {
                        quirksMode: o
                    }
                },
                e.file && e.location) {
                    const t = String(e.file)
                      , r = function(e) {
                        const t = String(e)
                          , n = [];
                        for (jf.lastIndex = 0; jf.test(t); )
                            n.push(jf.lastIndex);
                        return n.push(t.length + 1),
                        {
                            toPoint: function(e) {
                                let t = -1;
                                if ("number" == typeof e && e > -1 && e < n[n.length - 1])
                                    for (; ++t < n.length; )
                                        if (n[t] > e)
                                            return {
                                                line: t + 1,
                                                column: e - (t > 0 ? n[t - 1] : 0) + 1,
                                                offset: e
                                            }
                            },
                            toOffset: function(e) {
                                const t = e && e.line
                                  , r = e && e.column;
                                if ("number" == typeof t && "number" == typeof r && !Number.isNaN(t) && !Number.isNaN(r) && t - 1 in n) {
                                    const e = (n[t - 2] || 0) + r - 1 || 0;
                                    if (e > -1 && e < n[n.length - 1])
                                        return e
                                }
                            }
                        }
                    }(t)
                      , o = r.toPoint(0)
                      , i = r.toPoint(t.length);
                    n.position = {
                        start: o,
                        end: i
                    }
                }
                return n
            }
        case "#documentType":
            return n = {
                type: "doctype"
            },
            Vf(e, t, n),
            n;
        case "#text":
            {
                const r = t;
                return n = {
                    type: "text",
                    value: r.value
                },
                Vf(e, r, n),
                n
            }
        default:
            return n = function(e, t) {
                const n = e.schema;
                e.schema = t.namespaceURI === zf.svg ? Pf : Cf;
                let r = -1;
                const o = {};
                for (; ++r < t.attrs.length; ) {
                    const e = t.attrs[r]
                      , n = (e.prefix ? e.prefix + ":" : "") + e.name;
                    qf.call(Hf, n) || (o[n] = e.value)
                }
                const i = "svg" === e.schema.space ? Ff : Uf
                  , a = i(t.tagName, o, Xf(e, t.childNodes));
                if (Vf(e, t, a),
                "template" === a.tagName) {
                    const n = t
                      , r = n.sourceCodeLocation
                      , o = r && r.startTag && Gf(r.startTag)
                      , i = r && r.endTag && Gf(r.endTag)
                      , s = Wf(e, n.content);
                    o && i && e.file && (s.position = {
                        start: o.end,
                        end: i.start
                    }),
                    a.content = s
                }
                return e.schema = n,
                a
            }(e, t),
            n
        }
    }
    function Xf(e, t) {
        let n = -1;
        const r = [];
        for (; ++n < t.length; ) {
            const o = Wf(e, t[n]);
            r.push(o)
        }
        return r
    }
    function Vf(e, t, n) {
        if ("sourceCodeLocation"in t && t.sourceCodeLocation && e.file) {
            const r = function(e, t, n) {
                const r = Gf(n);
                if ("element" === t.type) {
                    const o = t.children[t.children.length - 1];
                    if (r && !n.endTag && o && o.position && o.position.end && (r.end = Object.assign({}, o.position.end)),
                    e.verbose) {
                        const r = {};
                        let o;
                        if (n.attrs)
                            for (o in n.attrs)
                                qf.call(n.attrs, o) && (r[xf(e.schema, o).property] = Gf(n.attrs[o]));
                        n.startTag;
                        const i = Gf(n.startTag)
                          , a = n.endTag ? Gf(n.endTag) : void 0
                          , s = {
                            opening: i
                        };
                        a && (s.closing = a),
                        s.properties = r,
                        t.data = {
                            position: s
                        }
                    }
                }
                return r
            }(e, n, t.sourceCodeLocation);
            r && (e.location = !0,
            n.position = r)
        }
    }
    function Gf(e) {
        const t = Yf({
            line: e.startLine,
            column: e.startCol,
            offset: e.startOffset
        })
          , n = Yf({
            line: e.endLine,
            column: e.endCol,
            offset: e.endOffset
        });
        return t || n ? {
            start: t,
            end: n
        } : void 0
    }
    function Yf(e) {
        return e.line && e.column ? e : void 0
    }
    const Kf = {}.hasOwnProperty;
    function Jf(e, t) {
        const n = t || {};
        function r(t, ...n) {
            let o = r.invalid;
            const i = r.handlers;
            if (t && Kf.call(t, e)) {
                const n = String(t[e]);
                o = Kf.call(i, n) ? i[n] : r.unknown
            }
            if (o)
                return o.call(this, t, ...n)
        }
        return r.handlers = n.handlers || {},
        r.invalid = n.invalid,
        r.unknown = n.unknown,
        r
    }
    const em = {}
      , tm = {}.hasOwnProperty
      , nm = Jf("type", {
        handlers: {
            root: function(e, t) {
                const n = {
                    nodeName: "#document",
                    mode: (e.data || {}).quirksMode ? "quirks" : "no-quirks",
                    childNodes: []
                };
                return n.childNodes = om(e.children, n, t),
                im(e, n),
                n
            },
            element: function(e, t) {
                const n = t;
                let r = n;
                "element" === e.type && "svg" === e.tagName.toLowerCase() && "html" === n.space && (r = Pf);
                const o = [];
                let i;
                if (e.properties)
                    for (i in e.properties)
                        if ("children" !== i && tm.call(e.properties, i)) {
                            const t = rm(r, i, e.properties[i]);
                            t && o.push(t)
                        }
                const a = r.space
                  , s = {
                    nodeName: e.tagName,
                    tagName: e.tagName,
                    attrs: o,
                    namespaceURI: zf[a],
                    childNodes: [],
                    parentNode: null
                };
                s.childNodes = om(e.children, s, r),
                im(e, s),
                "template" === e.tagName && e.content && (s.content = function(e, t) {
                    const n = {
                        nodeName: "#document-fragment",
                        childNodes: []
                    };
                    return n.childNodes = om(e.children, n, t),
                    im(e, n),
                    n
                }(e.content, r));
                return s
            },
            text: function(e) {
                const t = {
                    nodeName: "#text",
                    value: e.value,
                    parentNode: null
                };
                return im(e, t),
                t
            },
            comment: function(e) {
                const t = {
                    nodeName: "#comment",
                    data: e.value,
                    parentNode: null
                };
                return im(e, t),
                t
            },
            doctype: function(e) {
                const t = {
                    nodeName: "#documentType",
                    name: "html",
                    publicId: "",
                    systemId: "",
                    parentNode: null
                };
                return im(e, t),
                t
            }
        }
    });
    function rm(e, t, n) {
        const r = xf(e, t);
        if (!1 === n || null == n || "number" == typeof n && Number.isNaN(n) || !n && r.boolean)
            return;
        Array.isArray(n) && (n = r.commaSeparated ? Rf(n) : mh(n));
        const o = {
            name: r.attribute,
            value: !0 === n ? "" : String(n)
        };
        if (r.space && "html" !== r.space && "svg" !== r.space) {
            const e = o.name.indexOf(":");
            e < 0 ? o.prefix = "" : (o.name = o.name.slice(e + 1),
            o.prefix = r.attribute.slice(0, e)),
            o.namespace = zf[r.space]
        }
        return o
    }
    function om(e, t, n) {
        let r = -1;
        const o = [];
        if (e)
            for (; ++r < e.length; ) {
                const i = nm(e[r], n);
                i.parentNode = t,
                o.push(i)
            }
        return o
    }
    function im(e, t) {
        const n = e.position;
        n && n.start && n.end && (n.start.offset,
        n.end.offset,
        t.sourceCodeLocation = {
            startLine: n.start.line,
            startCol: n.start.column,
            startOffset: n.start.offset,
            endLine: n.end.line,
            endCol: n.end.column,
            endOffset: n.end.offset
        })
    }
    const am = ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"]
      , sm = new Set([65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111])
      , lm = "�";
    var cm, um;
    (um = cm = cm || (cm = {}))[um.EOF = -1] = "EOF",
    um[um.NULL = 0] = "NULL",
    um[um.TABULATION = 9] = "TABULATION",
    um[um.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN",
    um[um.LINE_FEED = 10] = "LINE_FEED",
    um[um.FORM_FEED = 12] = "FORM_FEED",
    um[um.SPACE = 32] = "SPACE",
    um[um.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK",
    um[um.QUOTATION_MARK = 34] = "QUOTATION_MARK",
    um[um.NUMBER_SIGN = 35] = "NUMBER_SIGN",
    um[um.AMPERSAND = 38] = "AMPERSAND",
    um[um.APOSTROPHE = 39] = "APOSTROPHE",
    um[um.HYPHEN_MINUS = 45] = "HYPHEN_MINUS",
    um[um.SOLIDUS = 47] = "SOLIDUS",
    um[um.DIGIT_0 = 48] = "DIGIT_0",
    um[um.DIGIT_9 = 57] = "DIGIT_9",
    um[um.SEMICOLON = 59] = "SEMICOLON",
    um[um.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN",
    um[um.EQUALS_SIGN = 61] = "EQUALS_SIGN",
    um[um.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN",
    um[um.QUESTION_MARK = 63] = "QUESTION_MARK",
    um[um.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A",
    um[um.LATIN_CAPITAL_F = 70] = "LATIN_CAPITAL_F",
    um[um.LATIN_CAPITAL_X = 88] = "LATIN_CAPITAL_X",
    um[um.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z",
    um[um.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET",
    um[um.GRAVE_ACCENT = 96] = "GRAVE_ACCENT",
    um[um.LATIN_SMALL_A = 97] = "LATIN_SMALL_A",
    um[um.LATIN_SMALL_F = 102] = "LATIN_SMALL_F",
    um[um.LATIN_SMALL_X = 120] = "LATIN_SMALL_X",
    um[um.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z",
    um[um.REPLACEMENT_CHARACTER = 65533] = "REPLACEMENT_CHARACTER";
    const dm = "--"
      , pm = "[CDATA["
      , hm = "doctype"
      , fm = "script"
      , mm = "public"
      , gm = "system";
    function bm(e) {
        return e >= 55296 && e <= 57343
    }
    function Om(e) {
        return 32 !== e && 10 !== e && 13 !== e && 9 !== e && 12 !== e && e >= 1 && e <= 31 || e >= 127 && e <= 159
    }
    function vm(e) {
        return e >= 64976 && e <= 65007 || sm.has(e)
    }
    var ym, wm;
    (wm = ym = ym || (ym = {})).controlCharacterInInputStream = "control-character-in-input-stream",
    wm.noncharacterInInputStream = "noncharacter-in-input-stream",
    wm.surrogateInInputStream = "surrogate-in-input-stream",
    wm.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus",
    wm.endTagWithAttributes = "end-tag-with-attributes",
    wm.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus",
    wm.unexpectedSolidusInTag = "unexpected-solidus-in-tag",
    wm.unexpectedNullCharacter = "unexpected-null-character",
    wm.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name",
    wm.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name",
    wm.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name",
    wm.missingEndTagName = "missing-end-tag-name",
    wm.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name",
    wm.unknownNamedCharacterReference = "unknown-named-character-reference",
    wm.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference",
    wm.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier",
    wm.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value",
    wm.eofBeforeTagName = "eof-before-tag-name",
    wm.eofInTag = "eof-in-tag",
    wm.missingAttributeValue = "missing-attribute-value",
    wm.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes",
    wm.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword",
    wm.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers",
    wm.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword",
    wm.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier",
    wm.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier",
    wm.missingDoctypePublicIdentifier = "missing-doctype-public-identifier",
    wm.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier",
    wm.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier",
    wm.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier",
    wm.cdataInHtmlContent = "cdata-in-html-content",
    wm.incorrectlyOpenedComment = "incorrectly-opened-comment",
    wm.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text",
    wm.eofInDoctype = "eof-in-doctype",
    wm.nestedComment = "nested-comment",
    wm.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment",
    wm.eofInComment = "eof-in-comment",
    wm.incorrectlyClosedComment = "incorrectly-closed-comment",
    wm.eofInCdata = "eof-in-cdata",
    wm.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference",
    wm.nullCharacterReference = "null-character-reference",
    wm.surrogateCharacterReference = "surrogate-character-reference",
    wm.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range",
    wm.controlCharacterReference = "control-character-reference",
    wm.noncharacterCharacterReference = "noncharacter-character-reference",
    wm.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name",
    wm.missingDoctypeName = "missing-doctype-name",
    wm.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name",
    wm.duplicateAttribute = "duplicate-attribute",
    wm.nonConformingDoctype = "non-conforming-doctype",
    wm.missingDoctype = "missing-doctype",
    wm.misplacedDoctype = "misplaced-doctype",
    wm.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element",
    wm.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements",
    wm.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head",
    wm.openElementsLeftAfterEof = "open-elements-left-after-eof",
    wm.abandonedHeadElementChild = "abandoned-head-element-child",
    wm.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element",
    wm.nestedNoscriptInHead = "nested-noscript-in-head",
    wm.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
    class _m {
        constructor(e) {
            this.handler = e,
            this.html = "",
            this.pos = -1,
            this.lastGapPos = -2,
            this.gapStack = [],
            this.skipNextNewLine = !1,
            this.lastChunkWritten = !1,
            this.endOfChunkHit = !1,
            this.bufferWaterline = 65536,
            this.isEol = !1,
            this.lineStartPos = 0,
            this.droppedBufferSize = 0,
            this.line = 1,
            this.lastErrOffset = -1
        }
        get col() {
            return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos)
        }
        get offset() {
            return this.droppedBufferSize + this.pos
        }
        getError(e) {
            const {line: t, col: n, offset: r} = this;
            return {
                code: e,
                startLine: t,
                endLine: t,
                startCol: n,
                endCol: n,
                startOffset: r,
                endOffset: r
            }
        }
        _err(e) {
            this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset,
            this.handler.onParseError(this.getError(e)))
        }
        _addGap() {
            this.gapStack.push(this.lastGapPos),
            this.lastGapPos = this.pos
        }
        _processSurrogate(e) {
            if (this.pos !== this.html.length - 1) {
                const t = this.html.charCodeAt(this.pos + 1);
                if (function(e) {
                    return e >= 56320 && e <= 57343
                }(t))
                    return this.pos++,
                    this._addGap(),
                    1024 * (e - 55296) + 9216 + t
            } else if (!this.lastChunkWritten)
                return this.endOfChunkHit = !0,
                cm.EOF;
            return this._err(ym.surrogateInInputStream),
            e
        }
        willDropParsedChunk() {
            return this.pos > this.bufferWaterline
        }
        dropParsedChunk() {
            this.willDropParsedChunk() && (this.html = this.html.substring(this.pos),
            this.lineStartPos -= this.pos,
            this.droppedBufferSize += this.pos,
            this.pos = 0,
            this.lastGapPos = -2,
            this.gapStack.length = 0)
        }
        write(e, t) {
            this.html.length > 0 ? this.html += e : this.html = e,
            this.endOfChunkHit = !1,
            this.lastChunkWritten = t
        }
        insertHtmlAtCurrentPos(e) {
            this.html = this.html.substring(0, this.pos + 1) + e + this.html.substring(this.pos + 1),
            this.endOfChunkHit = !1
        }
        startsWith(e, t) {
            if (this.pos + e.length > this.html.length)
                return this.endOfChunkHit = !this.lastChunkWritten,
                !1;
            if (t)
                return this.html.startsWith(e, this.pos);
            for (let n = 0; n < e.length; n++) {
                if ((32 | this.html.charCodeAt(this.pos + n)) !== e.charCodeAt(n))
                    return !1
            }
            return !0
        }
        peek(e) {
            const t = this.pos + e;
            if (t >= this.html.length)
                return this.endOfChunkHit = !this.lastChunkWritten,
                cm.EOF;
            const n = this.html.charCodeAt(t);
            return n === cm.CARRIAGE_RETURN ? cm.LINE_FEED : n
        }
        advance() {
            if (this.pos++,
            this.isEol && (this.isEol = !1,
            this.line++,
            this.lineStartPos = this.pos),
            this.pos >= this.html.length)
                return this.endOfChunkHit = !this.lastChunkWritten,
                cm.EOF;
            let e = this.html.charCodeAt(this.pos);
            if (e === cm.CARRIAGE_RETURN)
                return this.isEol = !0,
                this.skipNextNewLine = !0,
                cm.LINE_FEED;
            if (e === cm.LINE_FEED && (this.isEol = !0,
            this.skipNextNewLine))
                return this.line--,
                this.skipNextNewLine = !1,
                this._addGap(),
                this.advance();
            this.skipNextNewLine = !1,
            bm(e) && (e = this._processSurrogate(e));
            return null === this.handler.onParseError || e > 31 && e < 127 || e === cm.LINE_FEED || e === cm.CARRIAGE_RETURN || e > 159 && e < 64976 || this._checkForProblematicCharacters(e),
            e
        }
        _checkForProblematicCharacters(e) {
            Om(e) ? this._err(ym.controlCharacterInInputStream) : vm(e) && this._err(ym.noncharacterInInputStream)
        }
        retreat(e) {
            for (this.pos -= e; this.pos < this.lastGapPos; )
                this.lastGapPos = this.gapStack.pop(),
                this.pos--;
            this.isEol = !1
        }
    }
    var km, Sm;
    function Em(e, t) {
        for (let n = e.attrs.length - 1; n >= 0; n--)
            if (e.attrs[n].name === t)
                return e.attrs[n].value;
        return null
    }
    (Sm = km = km || (km = {}))[Sm.CHARACTER = 0] = "CHARACTER",
    Sm[Sm.NULL_CHARACTER = 1] = "NULL_CHARACTER",
    Sm[Sm.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER",
    Sm[Sm.START_TAG = 3] = "START_TAG",
    Sm[Sm.END_TAG = 4] = "END_TAG",
    Sm[Sm.COMMENT = 5] = "COMMENT",
    Sm[Sm.DOCTYPE = 6] = "DOCTYPE",
    Sm[Sm.EOF = 7] = "EOF",
    Sm[Sm.HIBERNATION = 8] = "HIBERNATION";
    const xm = new Uint16Array('ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((e=>e.charCodeAt(0))))
      , Tm = new Uint16Array("Ȁaglq\tɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((e=>e.charCodeAt(0))));
    var Am;
    const Cm = new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]])
      , Pm = null !== (Am = String.fromCodePoint) && void 0 !== Am ? Am : function(e) {
        let t = "";
        return e > 65535 && (e -= 65536,
        t += String.fromCharCode(e >>> 10 & 1023 | 55296),
        e = 56320 | 1023 & e),
        t += String.fromCharCode(e),
        t
    }
    ;
    var Dm, Rm;
    (Rm = Dm || (Dm = {}))[Rm.NUM = 35] = "NUM",
    Rm[Rm.SEMI = 59] = "SEMI",
    Rm[Rm.EQUALS = 61] = "EQUALS",
    Rm[Rm.ZERO = 48] = "ZERO",
    Rm[Rm.NINE = 57] = "NINE",
    Rm[Rm.LOWER_A = 97] = "LOWER_A",
    Rm[Rm.LOWER_F = 102] = "LOWER_F",
    Rm[Rm.LOWER_X = 120] = "LOWER_X",
    Rm[Rm.LOWER_Z = 122] = "LOWER_Z",
    Rm[Rm.UPPER_A = 65] = "UPPER_A",
    Rm[Rm.UPPER_F = 70] = "UPPER_F",
    Rm[Rm.UPPER_Z = 90] = "UPPER_Z";
    var Nm, $m, Im, Mm, Lm, Qm, Bm, Um, Fm, jm, zm, qm, Hm, Zm, Wm, Xm;
    function Vm(e) {
        return e >= Dm.ZERO && e <= Dm.NINE
    }
    function Gm(e) {
        return e === Dm.EQUALS || function(e) {
            return e >= Dm.UPPER_A && e <= Dm.UPPER_Z || e >= Dm.LOWER_A && e <= Dm.LOWER_Z || Vm(e)
        }(e)
    }
    ($m = Nm || (Nm = {}))[$m.VALUE_LENGTH = 49152] = "VALUE_LENGTH",
    $m[$m.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH",
    $m[$m.JUMP_TABLE = 127] = "JUMP_TABLE",
    (Mm = Im || (Im = {}))[Mm.EntityStart = 0] = "EntityStart",
    Mm[Mm.NumericStart = 1] = "NumericStart",
    Mm[Mm.NumericDecimal = 2] = "NumericDecimal",
    Mm[Mm.NumericHex = 3] = "NumericHex",
    Mm[Mm.NamedEntity = 4] = "NamedEntity",
    (Qm = Lm || (Lm = {}))[Qm.Legacy = 0] = "Legacy",
    Qm[Qm.Strict = 1] = "Strict",
    Qm[Qm.Attribute = 2] = "Attribute";
    class Ym {
        constructor(e, t, n) {
            this.decodeTree = e,
            this.emitCodePoint = t,
            this.errors = n,
            this.state = Im.EntityStart,
            this.consumed = 1,
            this.result = 0,
            this.treeIndex = 0,
            this.excess = 1,
            this.decodeMode = Lm.Strict
        }
        startEntity(e) {
            this.decodeMode = e,
            this.state = Im.EntityStart,
            this.result = 0,
            this.treeIndex = 0,
            this.excess = 1,
            this.consumed = 1
        }
        write(e, t) {
            switch (this.state) {
            case Im.EntityStart:
                return e.charCodeAt(t) === Dm.NUM ? (this.state = Im.NumericStart,
                this.consumed += 1,
                this.stateNumericStart(e, t + 1)) : (this.state = Im.NamedEntity,
                this.stateNamedEntity(e, t));
            case Im.NumericStart:
                return this.stateNumericStart(e, t);
            case Im.NumericDecimal:
                return this.stateNumericDecimal(e, t);
            case Im.NumericHex:
                return this.stateNumericHex(e, t);
            case Im.NamedEntity:
                return this.stateNamedEntity(e, t)
            }
        }
        stateNumericStart(e, t) {
            return t >= e.length ? -1 : (32 | e.charCodeAt(t)) === Dm.LOWER_X ? (this.state = Im.NumericHex,
            this.consumed += 1,
            this.stateNumericHex(e, t + 1)) : (this.state = Im.NumericDecimal,
            this.stateNumericDecimal(e, t))
        }
        addToNumericResult(e, t, n, r) {
            if (t !== n) {
                const o = n - t;
                this.result = this.result * Math.pow(r, o) + parseInt(e.substr(t, o), r),
                this.consumed += o
            }
        }
        stateNumericHex(e, t) {
            const n = t;
            for (; t < e.length; ) {
                const o = e.charCodeAt(t);
                if (!(Vm(o) || (r = o,
                r >= Dm.UPPER_A && r <= Dm.UPPER_F || r >= Dm.LOWER_A && r <= Dm.LOWER_F)))
                    return this.addToNumericResult(e, n, t, 16),
                    this.emitNumericEntity(o, 3);
                t += 1
            }
            var r;
            return this.addToNumericResult(e, n, t, 16),
            -1
        }
        stateNumericDecimal(e, t) {
            const n = t;
            for (; t < e.length; ) {
                const r = e.charCodeAt(t);
                if (!Vm(r))
                    return this.addToNumericResult(e, n, t, 10),
                    this.emitNumericEntity(r, 2);
                t += 1
            }
            return this.addToNumericResult(e, n, t, 10),
            -1
        }
        emitNumericEntity(e, t) {
            var n;
            if (this.consumed <= t)
                return null === (n = this.errors) || void 0 === n || n.absenceOfDigitsInNumericCharacterReference(this.consumed),
                0;
            if (e === Dm.SEMI)
                this.consumed += 1;
            else if (this.decodeMode === Lm.Strict)
                return 0;
            return this.emitCodePoint(function(e) {
                var t;
                return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : null !== (t = Cm.get(e)) && void 0 !== t ? t : e
            }(this.result), this.consumed),
            this.errors && (e !== Dm.SEMI && this.errors.missingSemicolonAfterCharacterReference(),
            this.errors.validateNumericCharacterReference(this.result)),
            this.consumed
        }
        stateNamedEntity(e, t) {
            const {decodeTree: n} = this;
            let r = n[this.treeIndex]
              , o = (r & Nm.VALUE_LENGTH) >> 14;
            for (; t < e.length; t++,
            this.excess++) {
                const i = e.charCodeAt(t);
                if (this.treeIndex = Jm(n, r, this.treeIndex + Math.max(1, o), i),
                this.treeIndex < 0)
                    return 0 === this.result || this.decodeMode === Lm.Attribute && (0 === o || Gm(i)) ? 0 : this.emitNotTerminatedNamedEntity();
                if (r = n[this.treeIndex],
                o = (r & Nm.VALUE_LENGTH) >> 14,
                0 !== o) {
                    if (i === Dm.SEMI)
                        return this.emitNamedEntityData(this.treeIndex, o, this.consumed + this.excess);
                    this.decodeMode !== Lm.Strict && (this.result = this.treeIndex,
                    this.consumed += this.excess,
                    this.excess = 0)
                }
            }
            return -1
        }
        emitNotTerminatedNamedEntity() {
            var e;
            const {result: t, decodeTree: n} = this
              , r = (n[t] & Nm.VALUE_LENGTH) >> 14;
            return this.emitNamedEntityData(t, r, this.consumed),
            null === (e = this.errors) || void 0 === e || e.missingSemicolonAfterCharacterReference(),
            this.consumed
        }
        emitNamedEntityData(e, t, n) {
            const {decodeTree: r} = this;
            return this.emitCodePoint(1 === t ? r[e] & ~Nm.VALUE_LENGTH : r[e + 1], n),
            3 === t && this.emitCodePoint(r[e + 2], n),
            n
        }
        end() {
            var e;
            switch (this.state) {
            case Im.NamedEntity:
                return 0 === this.result || this.decodeMode === Lm.Attribute && this.result !== this.treeIndex ? 0 : this.emitNotTerminatedNamedEntity();
            case Im.NumericDecimal:
                return this.emitNumericEntity(0, 2);
            case Im.NumericHex:
                return this.emitNumericEntity(0, 3);
            case Im.NumericStart:
                return null === (e = this.errors) || void 0 === e || e.absenceOfDigitsInNumericCharacterReference(this.consumed),
                0;
            case Im.EntityStart:
                return 0
            }
        }
    }
    function Km(e) {
        let t = "";
        const n = new Ym(e,(e=>t += Pm(e)));
        return function(e, r) {
            let o = 0
              , i = 0;
            for (; (i = e.indexOf("&", i)) >= 0; ) {
                t += e.slice(o, i),
                n.startEntity(r);
                const a = n.write(e, i + 1);
                if (a < 0) {
                    o = i + n.end();
                    break
                }
                o = i + a,
                i = 0 === a ? o + 1 : o
            }
            const a = t + e.slice(o);
            return t = "",
            a
        }
    }
    function Jm(e, t, n, r) {
        const o = (t & Nm.BRANCH_LENGTH) >> 7
          , i = t & Nm.JUMP_TABLE;
        if (0 === o)
            return 0 !== i && r === i ? n : -1;
        if (i) {
            const t = r - i;
            return t < 0 || t >= o ? -1 : e[n + t] - 1
        }
        let a = n
          , s = a + o - 1;
        for (; a <= s; ) {
            const t = a + s >>> 1
              , n = e[t];
            if (n < r)
                a = t + 1;
            else {
                if (!(n > r))
                    return e[t + o];
                s = t - 1
            }
        }
        return -1
    }
    Km(xm),
    Km(Tm),
    (Um = Bm = Bm || (Bm = {})).HTML = "http://www.w3.org/1999/xhtml",
    Um.MATHML = "http://www.w3.org/1998/Math/MathML",
    Um.SVG = "http://www.w3.org/2000/svg",
    Um.XLINK = "http://www.w3.org/1999/xlink",
    Um.XML = "http://www.w3.org/XML/1998/namespace",
    Um.XMLNS = "http://www.w3.org/2000/xmlns/",
    (jm = Fm = Fm || (Fm = {})).TYPE = "type",
    jm.ACTION = "action",
    jm.ENCODING = "encoding",
    jm.PROMPT = "prompt",
    jm.NAME = "name",
    jm.COLOR = "color",
    jm.FACE = "face",
    jm.SIZE = "size",
    (qm = zm = zm || (zm = {})).NO_QUIRKS = "no-quirks",
    qm.QUIRKS = "quirks",
    qm.LIMITED_QUIRKS = "limited-quirks",
    (Zm = Hm = Hm || (Hm = {})).A = "a",
    Zm.ADDRESS = "address",
    Zm.ANNOTATION_XML = "annotation-xml",
    Zm.APPLET = "applet",
    Zm.AREA = "area",
    Zm.ARTICLE = "article",
    Zm.ASIDE = "aside",
    Zm.B = "b",
    Zm.BASE = "base",
    Zm.BASEFONT = "basefont",
    Zm.BGSOUND = "bgsound",
    Zm.BIG = "big",
    Zm.BLOCKQUOTE = "blockquote",
    Zm.BODY = "body",
    Zm.BR = "br",
    Zm.BUTTON = "button",
    Zm.CAPTION = "caption",
    Zm.CENTER = "center",
    Zm.CODE = "code",
    Zm.COL = "col",
    Zm.COLGROUP = "colgroup",
    Zm.DD = "dd",
    Zm.DESC = "desc",
    Zm.DETAILS = "details",
    Zm.DIALOG = "dialog",
    Zm.DIR = "dir",
    Zm.DIV = "div",
    Zm.DL = "dl",
    Zm.DT = "dt",
    Zm.EM = "em",
    Zm.EMBED = "embed",
    Zm.FIELDSET = "fieldset",
    Zm.FIGCAPTION = "figcaption",
    Zm.FIGURE = "figure",
    Zm.FONT = "font",
    Zm.FOOTER = "footer",
    Zm.FOREIGN_OBJECT = "foreignObject",
    Zm.FORM = "form",
    Zm.FRAME = "frame",
    Zm.FRAMESET = "frameset",
    Zm.H1 = "h1",
    Zm.H2 = "h2",
    Zm.H3 = "h3",
    Zm.H4 = "h4",
    Zm.H5 = "h5",
    Zm.H6 = "h6",
    Zm.HEAD = "head",
    Zm.HEADER = "header",
    Zm.HGROUP = "hgroup",
    Zm.HR = "hr",
    Zm.HTML = "html",
    Zm.I = "i",
    Zm.IMG = "img",
    Zm.IMAGE = "image",
    Zm.INPUT = "input",
    Zm.IFRAME = "iframe",
    Zm.KEYGEN = "keygen",
    Zm.LABEL = "label",
    Zm.LI = "li",
    Zm.LINK = "link",
    Zm.LISTING = "listing",
    Zm.MAIN = "main",
    Zm.MALIGNMARK = "malignmark",
    Zm.MARQUEE = "marquee",
    Zm.MATH = "math",
    Zm.MENU = "menu",
    Zm.META = "meta",
    Zm.MGLYPH = "mglyph",
    Zm.MI = "mi",
    Zm.MO = "mo",
    Zm.MN = "mn",
    Zm.MS = "ms",
    Zm.MTEXT = "mtext",
    Zm.NAV = "nav",
    Zm.NOBR = "nobr",
    Zm.NOFRAMES = "noframes",
    Zm.NOEMBED = "noembed",
    Zm.NOSCRIPT = "noscript",
    Zm.OBJECT = "object",
    Zm.OL = "ol",
    Zm.OPTGROUP = "optgroup",
    Zm.OPTION = "option",
    Zm.P = "p",
    Zm.PARAM = "param",
    Zm.PLAINTEXT = "plaintext",
    Zm.PRE = "pre",
    Zm.RB = "rb",
    Zm.RP = "rp",
    Zm.RT = "rt",
    Zm.RTC = "rtc",
    Zm.RUBY = "ruby",
    Zm.S = "s",
    Zm.SCRIPT = "script",
    Zm.SECTION = "section",
    Zm.SELECT = "select",
    Zm.SOURCE = "source",
    Zm.SMALL = "small",
    Zm.SPAN = "span",
    Zm.STRIKE = "strike",
    Zm.STRONG = "strong",
    Zm.STYLE = "style",
    Zm.SUB = "sub",
    Zm.SUMMARY = "summary",
    Zm.SUP = "sup",
    Zm.TABLE = "table",
    Zm.TBODY = "tbody",
    Zm.TEMPLATE = "template",
    Zm.TEXTAREA = "textarea",
    Zm.TFOOT = "tfoot",
    Zm.TD = "td",
    Zm.TH = "th",
    Zm.THEAD = "thead",
    Zm.TITLE = "title",
    Zm.TR = "tr",
    Zm.TRACK = "track",
    Zm.TT = "tt",
    Zm.U = "u",
    Zm.UL = "ul",
    Zm.SVG = "svg",
    Zm.VAR = "var",
    Zm.WBR = "wbr",
    Zm.XMP = "xmp",
    (Xm = Wm = Wm || (Wm = {}))[Xm.UNKNOWN = 0] = "UNKNOWN",
    Xm[Xm.A = 1] = "A",
    Xm[Xm.ADDRESS = 2] = "ADDRESS",
    Xm[Xm.ANNOTATION_XML = 3] = "ANNOTATION_XML",
    Xm[Xm.APPLET = 4] = "APPLET",
    Xm[Xm.AREA = 5] = "AREA",
    Xm[Xm.ARTICLE = 6] = "ARTICLE",
    Xm[Xm.ASIDE = 7] = "ASIDE",
    Xm[Xm.B = 8] = "B",
    Xm[Xm.BASE = 9] = "BASE",
    Xm[Xm.BASEFONT = 10] = "BASEFONT",
    Xm[Xm.BGSOUND = 11] = "BGSOUND",
    Xm[Xm.BIG = 12] = "BIG",
    Xm[Xm.BLOCKQUOTE = 13] = "BLOCKQUOTE",
    Xm[Xm.BODY = 14] = "BODY",
    Xm[Xm.BR = 15] = "BR",
    Xm[Xm.BUTTON = 16] = "BUTTON",
    Xm[Xm.CAPTION = 17] = "CAPTION",
    Xm[Xm.CENTER = 18] = "CENTER",
    Xm[Xm.CODE = 19] = "CODE",
    Xm[Xm.COL = 20] = "COL",
    Xm[Xm.COLGROUP = 21] = "COLGROUP",
    Xm[Xm.DD = 22] = "DD",
    Xm[Xm.DESC = 23] = "DESC",
    Xm[Xm.DETAILS = 24] = "DETAILS",
    Xm[Xm.DIALOG = 25] = "DIALOG",
    Xm[Xm.DIR = 26] = "DIR",
    Xm[Xm.DIV = 27] = "DIV",
    Xm[Xm.DL = 28] = "DL",
    Xm[Xm.DT = 29] = "DT",
    Xm[Xm.EM = 30] = "EM",
    Xm[Xm.EMBED = 31] = "EMBED",
    Xm[Xm.FIELDSET = 32] = "FIELDSET",
    Xm[Xm.FIGCAPTION = 33] = "FIGCAPTION",
    Xm[Xm.FIGURE = 34] = "FIGURE",
    Xm[Xm.FONT = 35] = "FONT",
    Xm[Xm.FOOTER = 36] = "FOOTER",
    Xm[Xm.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT",
    Xm[Xm.FORM = 38] = "FORM",
    Xm[Xm.FRAME = 39] = "FRAME",
    Xm[Xm.FRAMESET = 40] = "FRAMESET",
    Xm[Xm.H1 = 41] = "H1",
    Xm[Xm.H2 = 42] = "H2",
    Xm[Xm.H3 = 43] = "H3",
    Xm[Xm.H4 = 44] = "H4",
    Xm[Xm.H5 = 45] = "H5",
    Xm[Xm.H6 = 46] = "H6",
    Xm[Xm.HEAD = 47] = "HEAD",
    Xm[Xm.HEADER = 48] = "HEADER",
    Xm[Xm.HGROUP = 49] = "HGROUP",
    Xm[Xm.HR = 50] = "HR",
    Xm[Xm.HTML = 51] = "HTML",
    Xm[Xm.I = 52] = "I",
    Xm[Xm.IMG = 53] = "IMG",
    Xm[Xm.IMAGE = 54] = "IMAGE",
    Xm[Xm.INPUT = 55] = "INPUT",
    Xm[Xm.IFRAME = 56] = "IFRAME",
    Xm[Xm.KEYGEN = 57] = "KEYGEN",
    Xm[Xm.LABEL = 58] = "LABEL",
    Xm[Xm.LI = 59] = "LI",
    Xm[Xm.LINK = 60] = "LINK",
    Xm[Xm.LISTING = 61] = "LISTING",
    Xm[Xm.MAIN = 62] = "MAIN",
    Xm[Xm.MALIGNMARK = 63] = "MALIGNMARK",
    Xm[Xm.MARQUEE = 64] = "MARQUEE",
    Xm[Xm.MATH = 65] = "MATH",
    Xm[Xm.MENU = 66] = "MENU",
    Xm[Xm.META = 67] = "META",
    Xm[Xm.MGLYPH = 68] = "MGLYPH",
    Xm[Xm.MI = 69] = "MI",
    Xm[Xm.MO = 70] = "MO",
    Xm[Xm.MN = 71] = "MN",
    Xm[Xm.MS = 72] = "MS",
    Xm[Xm.MTEXT = 73] = "MTEXT",
    Xm[Xm.NAV = 74] = "NAV",
    Xm[Xm.NOBR = 75] = "NOBR",
    Xm[Xm.NOFRAMES = 76] = "NOFRAMES",
    Xm[Xm.NOEMBED = 77] = "NOEMBED",
    Xm[Xm.NOSCRIPT = 78] = "NOSCRIPT",
    Xm[Xm.OBJECT = 79] = "OBJECT",
    Xm[Xm.OL = 80] = "OL",
    Xm[Xm.OPTGROUP = 81] = "OPTGROUP",
    Xm[Xm.OPTION = 82] = "OPTION",
    Xm[Xm.P = 83] = "P",
    Xm[Xm.PARAM = 84] = "PARAM",
    Xm[Xm.PLAINTEXT = 85] = "PLAINTEXT",
    Xm[Xm.PRE = 86] = "PRE",
    Xm[Xm.RB = 87] = "RB",
    Xm[Xm.RP = 88] = "RP",
    Xm[Xm.RT = 89] = "RT",
    Xm[Xm.RTC = 90] = "RTC",
    Xm[Xm.RUBY = 91] = "RUBY",
    Xm[Xm.S = 92] = "S",
    Xm[Xm.SCRIPT = 93] = "SCRIPT",
    Xm[Xm.SECTION = 94] = "SECTION",
    Xm[Xm.SELECT = 95] = "SELECT",
    Xm[Xm.SOURCE = 96] = "SOURCE",
    Xm[Xm.SMALL = 97] = "SMALL",
    Xm[Xm.SPAN = 98] = "SPAN",
    Xm[Xm.STRIKE = 99] = "STRIKE",
    Xm[Xm.STRONG = 100] = "STRONG",
    Xm[Xm.STYLE = 101] = "STYLE",
    Xm[Xm.SUB = 102] = "SUB",
    Xm[Xm.SUMMARY = 103] = "SUMMARY",
    Xm[Xm.SUP = 104] = "SUP",
    Xm[Xm.TABLE = 105] = "TABLE",
    Xm[Xm.TBODY = 106] = "TBODY",
    Xm[Xm.TEMPLATE = 107] = "TEMPLATE",
    Xm[Xm.TEXTAREA = 108] = "TEXTAREA",
    Xm[Xm.TFOOT = 109] = "TFOOT",
    Xm[Xm.TD = 110] = "TD",
    Xm[Xm.TH = 111] = "TH",
    Xm[Xm.THEAD = 112] = "THEAD",
    Xm[Xm.TITLE = 113] = "TITLE",
    Xm[Xm.TR = 114] = "TR",
    Xm[Xm.TRACK = 115] = "TRACK",
    Xm[Xm.TT = 116] = "TT",
    Xm[Xm.U = 117] = "U",
    Xm[Xm.UL = 118] = "UL",
    Xm[Xm.SVG = 119] = "SVG",
    Xm[Xm.VAR = 120] = "VAR",
    Xm[Xm.WBR = 121] = "WBR",
    Xm[Xm.XMP = 122] = "XMP";
    const eg = new Map([[Hm.A, Wm.A], [Hm.ADDRESS, Wm.ADDRESS], [Hm.ANNOTATION_XML, Wm.ANNOTATION_XML], [Hm.APPLET, Wm.APPLET], [Hm.AREA, Wm.AREA], [Hm.ARTICLE, Wm.ARTICLE], [Hm.ASIDE, Wm.ASIDE], [Hm.B, Wm.B], [Hm.BASE, Wm.BASE], [Hm.BASEFONT, Wm.BASEFONT], [Hm.BGSOUND, Wm.BGSOUND], [Hm.BIG, Wm.BIG], [Hm.BLOCKQUOTE, Wm.BLOCKQUOTE], [Hm.BODY, Wm.BODY], [Hm.BR, Wm.BR], [Hm.BUTTON, Wm.BUTTON], [Hm.CAPTION, Wm.CAPTION], [Hm.CENTER, Wm.CENTER], [Hm.CODE, Wm.CODE], [Hm.COL, Wm.COL], [Hm.COLGROUP, Wm.COLGROUP], [Hm.DD, Wm.DD], [Hm.DESC, Wm.DESC], [Hm.DETAILS, Wm.DETAILS], [Hm.DIALOG, Wm.DIALOG], [Hm.DIR, Wm.DIR], [Hm.DIV, Wm.DIV], [Hm.DL, Wm.DL], [Hm.DT, Wm.DT], [Hm.EM, Wm.EM], [Hm.EMBED, Wm.EMBED], [Hm.FIELDSET, Wm.FIELDSET], [Hm.FIGCAPTION, Wm.FIGCAPTION], [Hm.FIGURE, Wm.FIGURE], [Hm.FONT, Wm.FONT], [Hm.FOOTER, Wm.FOOTER], [Hm.FOREIGN_OBJECT, Wm.FOREIGN_OBJECT], [Hm.FORM, Wm.FORM], [Hm.FRAME, Wm.FRAME], [Hm.FRAMESET, Wm.FRAMESET], [Hm.H1, Wm.H1], [Hm.H2, Wm.H2], [Hm.H3, Wm.H3], [Hm.H4, Wm.H4], [Hm.H5, Wm.H5], [Hm.H6, Wm.H6], [Hm.HEAD, Wm.HEAD], [Hm.HEADER, Wm.HEADER], [Hm.HGROUP, Wm.HGROUP], [Hm.HR, Wm.HR], [Hm.HTML, Wm.HTML], [Hm.I, Wm.I], [Hm.IMG, Wm.IMG], [Hm.IMAGE, Wm.IMAGE], [Hm.INPUT, Wm.INPUT], [Hm.IFRAME, Wm.IFRAME], [Hm.KEYGEN, Wm.KEYGEN], [Hm.LABEL, Wm.LABEL], [Hm.LI, Wm.LI], [Hm.LINK, Wm.LINK], [Hm.LISTING, Wm.LISTING], [Hm.MAIN, Wm.MAIN], [Hm.MALIGNMARK, Wm.MALIGNMARK], [Hm.MARQUEE, Wm.MARQUEE], [Hm.MATH, Wm.MATH], [Hm.MENU, Wm.MENU], [Hm.META, Wm.META], [Hm.MGLYPH, Wm.MGLYPH], [Hm.MI, Wm.MI], [Hm.MO, Wm.MO], [Hm.MN, Wm.MN], [Hm.MS, Wm.MS], [Hm.MTEXT, Wm.MTEXT], [Hm.NAV, Wm.NAV], [Hm.NOBR, Wm.NOBR], [Hm.NOFRAMES, Wm.NOFRAMES], [Hm.NOEMBED, Wm.NOEMBED], [Hm.NOSCRIPT, Wm.NOSCRIPT], [Hm.OBJECT, Wm.OBJECT], [Hm.OL, Wm.OL], [Hm.OPTGROUP, Wm.OPTGROUP], [Hm.OPTION, Wm.OPTION], [Hm.P, Wm.P], [Hm.PARAM, Wm.PARAM], [Hm.PLAINTEXT, Wm.PLAINTEXT], [Hm.PRE, Wm.PRE], [Hm.RB, Wm.RB], [Hm.RP, Wm.RP], [Hm.RT, Wm.RT], [Hm.RTC, Wm.RTC], [Hm.RUBY, Wm.RUBY], [Hm.S, Wm.S], [Hm.SCRIPT, Wm.SCRIPT], [Hm.SECTION, Wm.SECTION], [Hm.SELECT, Wm.SELECT], [Hm.SOURCE, Wm.SOURCE], [Hm.SMALL, Wm.SMALL], [Hm.SPAN, Wm.SPAN], [Hm.STRIKE, Wm.STRIKE], [Hm.STRONG, Wm.STRONG], [Hm.STYLE, Wm.STYLE], [Hm.SUB, Wm.SUB], [Hm.SUMMARY, Wm.SUMMARY], [Hm.SUP, Wm.SUP], [Hm.TABLE, Wm.TABLE], [Hm.TBODY, Wm.TBODY], [Hm.TEMPLATE, Wm.TEMPLATE], [Hm.TEXTAREA, Wm.TEXTAREA], [Hm.TFOOT, Wm.TFOOT], [Hm.TD, Wm.TD], [Hm.TH, Wm.TH], [Hm.THEAD, Wm.THEAD], [Hm.TITLE, Wm.TITLE], [Hm.TR, Wm.TR], [Hm.TRACK, Wm.TRACK], [Hm.TT, Wm.TT], [Hm.U, Wm.U], [Hm.UL, Wm.UL], [Hm.SVG, Wm.SVG], [Hm.VAR, Wm.VAR], [Hm.WBR, Wm.WBR], [Hm.XMP, Wm.XMP]]);
    function tg(e) {
        var t;
        return null !== (t = eg.get(e)) && void 0 !== t ? t : Wm.UNKNOWN
    }
    const ng = Wm
      , rg = {
        [Bm.HTML]: new Set([ng.ADDRESS, ng.APPLET, ng.AREA, ng.ARTICLE, ng.ASIDE, ng.BASE, ng.BASEFONT, ng.BGSOUND, ng.BLOCKQUOTE, ng.BODY, ng.BR, ng.BUTTON, ng.CAPTION, ng.CENTER, ng.COL, ng.COLGROUP, ng.DD, ng.DETAILS, ng.DIR, ng.DIV, ng.DL, ng.DT, ng.EMBED, ng.FIELDSET, ng.FIGCAPTION, ng.FIGURE, ng.FOOTER, ng.FORM, ng.FRAME, ng.FRAMESET, ng.H1, ng.H2, ng.H3, ng.H4, ng.H5, ng.H6, ng.HEAD, ng.HEADER, ng.HGROUP, ng.HR, ng.HTML, ng.IFRAME, ng.IMG, ng.INPUT, ng.LI, ng.LINK, ng.LISTING, ng.MAIN, ng.MARQUEE, ng.MENU, ng.META, ng.NAV, ng.NOEMBED, ng.NOFRAMES, ng.NOSCRIPT, ng.OBJECT, ng.OL, ng.P, ng.PARAM, ng.PLAINTEXT, ng.PRE, ng.SCRIPT, ng.SECTION, ng.SELECT, ng.SOURCE, ng.STYLE, ng.SUMMARY, ng.TABLE, ng.TBODY, ng.TD, ng.TEMPLATE, ng.TEXTAREA, ng.TFOOT, ng.TH, ng.THEAD, ng.TITLE, ng.TR, ng.TRACK, ng.UL, ng.WBR, ng.XMP]),
        [Bm.MATHML]: new Set([ng.MI, ng.MO, ng.MN, ng.MS, ng.MTEXT, ng.ANNOTATION_XML]),
        [Bm.SVG]: new Set([ng.TITLE, ng.FOREIGN_OBJECT, ng.DESC]),
        [Bm.XLINK]: new Set,
        [Bm.XML]: new Set,
        [Bm.XMLNS]: new Set
    };
    function og(e) {
        return e === ng.H1 || e === ng.H2 || e === ng.H3 || e === ng.H4 || e === ng.H5 || e === ng.H6
    }
    Hm.STYLE,
    Hm.SCRIPT,
    Hm.XMP,
    Hm.IFRAME,
    Hm.NOEMBED,
    Hm.NOFRAMES,
    Hm.PLAINTEXT;
    const ig = new Map([[128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]);
    var ag, sg;
    (sg = ag || (ag = {}))[sg.DATA = 0] = "DATA",
    sg[sg.RCDATA = 1] = "RCDATA",
    sg[sg.RAWTEXT = 2] = "RAWTEXT",
    sg[sg.SCRIPT_DATA = 3] = "SCRIPT_DATA",
    sg[sg.PLAINTEXT = 4] = "PLAINTEXT",
    sg[sg.TAG_OPEN = 5] = "TAG_OPEN",
    sg[sg.END_TAG_OPEN = 6] = "END_TAG_OPEN",
    sg[sg.TAG_NAME = 7] = "TAG_NAME",
    sg[sg.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN",
    sg[sg.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN",
    sg[sg.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME",
    sg[sg.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN",
    sg[sg.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN",
    sg[sg.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME",
    sg[sg.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN",
    sg[sg.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN",
    sg[sg.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME",
    sg[sg.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START",
    sg[sg.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH",
    sg[sg.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED",
    sg[sg.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH",
    sg[sg.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH",
    sg[sg.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN",
    sg[sg.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN",
    sg[sg.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME",
    sg[sg.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START",
    sg[sg.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED",
    sg[sg.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH",
    sg[sg.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH",
    sg[sg.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN",
    sg[sg.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END",
    sg[sg.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME",
    sg[sg.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME",
    sg[sg.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME",
    sg[sg.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE",
    sg[sg.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED",
    sg[sg.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED",
    sg[sg.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED",
    sg[sg.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED",
    sg[sg.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG",
    sg[sg.BOGUS_COMMENT = 40] = "BOGUS_COMMENT",
    sg[sg.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN",
    sg[sg.COMMENT_START = 42] = "COMMENT_START",
    sg[sg.COMMENT_START_DASH = 43] = "COMMENT_START_DASH",
    sg[sg.COMMENT = 44] = "COMMENT",
    sg[sg.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN",
    sg[sg.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG",
    sg[sg.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH",
    sg[sg.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH",
    sg[sg.COMMENT_END_DASH = 49] = "COMMENT_END_DASH",
    sg[sg.COMMENT_END = 50] = "COMMENT_END",
    sg[sg.COMMENT_END_BANG = 51] = "COMMENT_END_BANG",
    sg[sg.DOCTYPE = 52] = "DOCTYPE",
    sg[sg.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME",
    sg[sg.DOCTYPE_NAME = 54] = "DOCTYPE_NAME",
    sg[sg.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME",
    sg[sg.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD",
    sg[sg.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER",
    sg[sg.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED",
    sg[sg.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED",
    sg[sg.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER",
    sg[sg.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS",
    sg[sg.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD",
    sg[sg.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER",
    sg[sg.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED",
    sg[sg.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED",
    sg[sg.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER",
    sg[sg.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE",
    sg[sg.CDATA_SECTION = 68] = "CDATA_SECTION",
    sg[sg.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET",
    sg[sg.CDATA_SECTION_END = 70] = "CDATA_SECTION_END",
    sg[sg.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE",
    sg[sg.NAMED_CHARACTER_REFERENCE = 72] = "NAMED_CHARACTER_REFERENCE",
    sg[sg.AMBIGUOUS_AMPERSAND = 73] = "AMBIGUOUS_AMPERSAND",
    sg[sg.NUMERIC_CHARACTER_REFERENCE = 74] = "NUMERIC_CHARACTER_REFERENCE",
    sg[sg.HEXADEMICAL_CHARACTER_REFERENCE_START = 75] = "HEXADEMICAL_CHARACTER_REFERENCE_START",
    sg[sg.HEXADEMICAL_CHARACTER_REFERENCE = 76] = "HEXADEMICAL_CHARACTER_REFERENCE",
    sg[sg.DECIMAL_CHARACTER_REFERENCE = 77] = "DECIMAL_CHARACTER_REFERENCE",
    sg[sg.NUMERIC_CHARACTER_REFERENCE_END = 78] = "NUMERIC_CHARACTER_REFERENCE_END";
    const lg = {
        DATA: ag.DATA,
        RCDATA: ag.RCDATA,
        RAWTEXT: ag.RAWTEXT,
        SCRIPT_DATA: ag.SCRIPT_DATA,
        PLAINTEXT: ag.PLAINTEXT,
        CDATA_SECTION: ag.CDATA_SECTION
    };
    function cg(e) {
        return e >= cm.DIGIT_0 && e <= cm.DIGIT_9
    }
    function ug(e) {
        return e >= cm.LATIN_CAPITAL_A && e <= cm.LATIN_CAPITAL_Z
    }
    function dg(e) {
        return function(e) {
            return e >= cm.LATIN_SMALL_A && e <= cm.LATIN_SMALL_Z
        }(e) || ug(e)
    }
    function pg(e) {
        return dg(e) || cg(e)
    }
    function hg(e) {
        return e >= cm.LATIN_CAPITAL_A && e <= cm.LATIN_CAPITAL_F
    }
    function fg(e) {
        return e >= cm.LATIN_SMALL_A && e <= cm.LATIN_SMALL_F
    }
    function mg(e) {
        return e + 32
    }
    function gg(e) {
        return e === cm.SPACE || e === cm.LINE_FEED || e === cm.TABULATION || e === cm.FORM_FEED
    }
    function bg(e) {
        return gg(e) || e === cm.SOLIDUS || e === cm.GREATER_THAN_SIGN
    }
    class Og {
        constructor(e, t) {
            this.options = e,
            this.handler = t,
            this.paused = !1,
            this.inLoop = !1,
            this.inForeignNode = !1,
            this.lastStartTagName = "",
            this.active = !1,
            this.state = ag.DATA,
            this.returnState = ag.DATA,
            this.charRefCode = -1,
            this.consumedAfterSnapshot = -1,
            this.currentCharacterToken = null,
            this.currentToken = null,
            this.currentAttr = {
                name: "",
                value: ""
            },
            this.preprocessor = new _m(t),
            this.currentLocation = this.getCurrentLocation(-1)
        }
        _err(e) {
            var t, n;
            null === (n = (t = this.handler).onParseError) || void 0 === n || n.call(t, this.preprocessor.getError(e))
        }
        getCurrentLocation(e) {
            return this.options.sourceCodeLocationInfo ? {
                startLine: this.preprocessor.line,
                startCol: this.preprocessor.col - e,
                startOffset: this.preprocessor.offset - e,
                endLine: -1,
                endCol: -1,
                endOffset: -1
            } : null
        }
        _runParsingLoop() {
            if (!this.inLoop) {
                for (this.inLoop = !0; this.active && !this.paused; ) {
                    this.consumedAfterSnapshot = 0;
                    const e = this._consume();
                    this._ensureHibernation() || this._callState(e)
                }
                this.inLoop = !1
            }
        }
        pause() {
            this.paused = !0
        }
        resume(e) {
            if (!this.paused)
                throw new Error("Parser was already resumed");
            this.paused = !1,
            this.inLoop || (this._runParsingLoop(),
            this.paused || null == e || e())
        }
        write(e, t, n) {
            this.active = !0,
            this.preprocessor.write(e, t),
            this._runParsingLoop(),
            this.paused || null == n || n()
        }
        insertHtmlAtCurrentPos(e) {
            this.active = !0,
            this.preprocessor.insertHtmlAtCurrentPos(e),
            this._runParsingLoop()
        }
        _ensureHibernation() {
            return !!this.preprocessor.endOfChunkHit && (this._unconsume(this.consumedAfterSnapshot),
            this.active = !1,
            !0)
        }
        _consume() {
            return this.consumedAfterSnapshot++,
            this.preprocessor.advance()
        }
        _unconsume(e) {
            this.consumedAfterSnapshot -= e,
            this.preprocessor.retreat(e)
        }
        _reconsumeInState(e, t) {
            this.state = e,
            this._callState(t)
        }
        _advanceBy(e) {
            this.consumedAfterSnapshot += e;
            for (let t = 0; t < e; t++)
                this.preprocessor.advance()
        }
        _consumeSequenceIfMatch(e, t) {
            return !!this.preprocessor.startsWith(e, t) && (this._advanceBy(e.length - 1),
            !0)
        }
        _createStartTagToken() {
            this.currentToken = {
                type: km.START_TAG,
                tagName: "",
                tagID: Wm.UNKNOWN,
                selfClosing: !1,
                ackSelfClosing: !1,
                attrs: [],
                location: this.getCurrentLocation(1)
            }
        }
        _createEndTagToken() {
            this.currentToken = {
                type: km.END_TAG,
                tagName: "",
                tagID: Wm.UNKNOWN,
                selfClosing: !1,
                ackSelfClosing: !1,
                attrs: [],
                location: this.getCurrentLocation(2)
            }
        }
        _createCommentToken(e) {
            this.currentToken = {
                type: km.COMMENT,
                data: "",
                location: this.getCurrentLocation(e)
            }
        }
        _createDoctypeToken(e) {
            this.currentToken = {
                type: km.DOCTYPE,
                name: e,
                forceQuirks: !1,
                publicId: null,
                systemId: null,
                location: this.currentLocation
            }
        }
        _createCharacterToken(e, t) {
            this.currentCharacterToken = {
                type: e,
                chars: t,
                location: this.currentLocation
            }
        }
        _createAttr(e) {
            this.currentAttr = {
                name: e,
                value: ""
            },
            this.currentLocation = this.getCurrentLocation(0)
        }
        _leaveAttrName() {
            var e, t;
            const n = this.currentToken;
            if (null === Em(n, this.currentAttr.name)) {
                if (n.attrs.push(this.currentAttr),
                n.location && this.currentLocation) {
                    (null !== (e = (t = n.location).attrs) && void 0 !== e ? e : t.attrs = Object.create(null))[this.currentAttr.name] = this.currentLocation,
                    this._leaveAttrValue()
                }
            } else
                this._err(ym.duplicateAttribute)
        }
        _leaveAttrValue() {
            this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line,
            this.currentLocation.endCol = this.preprocessor.col,
            this.currentLocation.endOffset = this.preprocessor.offset)
        }
        prepareToken(e) {
            this._emitCurrentCharacterToken(e.location),
            this.currentToken = null,
            e.location && (e.location.endLine = this.preprocessor.line,
            e.location.endCol = this.preprocessor.col + 1,
            e.location.endOffset = this.preprocessor.offset + 1),
            this.currentLocation = this.getCurrentLocation(-1)
        }
        emitCurrentTagToken() {
            const e = this.currentToken;
            this.prepareToken(e),
            e.tagID = tg(e.tagName),
            e.type === km.START_TAG ? (this.lastStartTagName = e.tagName,
            this.handler.onStartTag(e)) : (e.attrs.length > 0 && this._err(ym.endTagWithAttributes),
            e.selfClosing && this._err(ym.endTagWithTrailingSolidus),
            this.handler.onEndTag(e)),
            this.preprocessor.dropParsedChunk()
        }
        emitCurrentComment(e) {
            this.prepareToken(e),
            this.handler.onComment(e),
            this.preprocessor.dropParsedChunk()
        }
        emitCurrentDoctype(e) {
            this.prepareToken(e),
            this.handler.onDoctype(e),
            this.preprocessor.dropParsedChunk()
        }
        _emitCurrentCharacterToken(e) {
            if (this.currentCharacterToken) {
                switch (e && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = e.startLine,
                this.currentCharacterToken.location.endCol = e.startCol,
                this.currentCharacterToken.location.endOffset = e.startOffset),
                this.currentCharacterToken.type) {
                case km.CHARACTER:
                    this.handler.onCharacter(this.currentCharacterToken);
                    break;
                case km.NULL_CHARACTER:
                    this.handler.onNullCharacter(this.currentCharacterToken);
                    break;
                case km.WHITESPACE_CHARACTER:
                    this.handler.onWhitespaceCharacter(this.currentCharacterToken)
                }
                this.currentCharacterToken = null
            }
        }
        _emitEOFToken() {
            const e = this.getCurrentLocation(0);
            e && (e.endLine = e.startLine,
            e.endCol = e.startCol,
            e.endOffset = e.startOffset),
            this._emitCurrentCharacterToken(e),
            this.handler.onEof({
                type: km.EOF,
                location: e
            }),
            this.active = !1
        }
        _appendCharToCurrentCharacterToken(e, t) {
            if (this.currentCharacterToken) {
                if (this.currentCharacterToken.type === e)
                    return void (this.currentCharacterToken.chars += t);
                this.currentLocation = this.getCurrentLocation(0),
                this._emitCurrentCharacterToken(this.currentLocation),
                this.preprocessor.dropParsedChunk()
            }
            this._createCharacterToken(e, t)
        }
        _emitCodePoint(e) {
            const t = gg(e) ? km.WHITESPACE_CHARACTER : e === cm.NULL ? km.NULL_CHARACTER : km.CHARACTER;
            this._appendCharToCurrentCharacterToken(t, String.fromCodePoint(e))
        }
        _emitChars(e) {
            this._appendCharToCurrentCharacterToken(km.CHARACTER, e)
        }
        _matchNamedCharacterReference(e) {
            let t = null
              , n = 0
              , r = !1;
            for (let i = 0, a = xm[0]; i >= 0 && (i = Jm(xm, a, i + 1, e),
            !(i < 0)); e = this._consume()) {
                n += 1,
                a = xm[i];
                const s = a & Nm.VALUE_LENGTH;
                if (s) {
                    const a = (s >> 14) - 1;
                    if (e !== cm.SEMICOLON && this._isCharacterReferenceInAttribute() && ((o = this.preprocessor.peek(1)) === cm.EQUALS_SIGN || pg(o)) ? (t = [cm.AMPERSAND],
                    i += a) : (t = 0 === a ? [xm[i] & ~Nm.VALUE_LENGTH] : 1 === a ? [xm[++i]] : [xm[++i], xm[++i]],
                    n = 0,
                    r = e !== cm.SEMICOLON),
                    0 === a) {
                        this._consume();
                        break
                    }
                }
            }
            var o;
            return this._unconsume(n),
            r && !this.preprocessor.endOfChunkHit && this._err(ym.missingSemicolonAfterCharacterReference),
            this._unconsume(1),
            t
        }
        _isCharacterReferenceInAttribute() {
            return this.returnState === ag.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === ag.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === ag.ATTRIBUTE_VALUE_UNQUOTED
        }
        _flushCodePointConsumedAsCharacterReference(e) {
            this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(e) : this._emitCodePoint(e)
        }
        _callState(e) {
            switch (this.state) {
            case ag.DATA:
                this._stateData(e);
                break;
            case ag.RCDATA:
                this._stateRcdata(e);
                break;
            case ag.RAWTEXT:
                this._stateRawtext(e);
                break;
            case ag.SCRIPT_DATA:
                this._stateScriptData(e);
                break;
            case ag.PLAINTEXT:
                this._statePlaintext(e);
                break;
            case ag.TAG_OPEN:
                this._stateTagOpen(e);
                break;
            case ag.END_TAG_OPEN:
                this._stateEndTagOpen(e);
                break;
            case ag.TAG_NAME:
                this._stateTagName(e);
                break;
            case ag.RCDATA_LESS_THAN_SIGN:
                this._stateRcdataLessThanSign(e);
                break;
            case ag.RCDATA_END_TAG_OPEN:
                this._stateRcdataEndTagOpen(e);
                break;
            case ag.RCDATA_END_TAG_NAME:
                this._stateRcdataEndTagName(e);
                break;
            case ag.RAWTEXT_LESS_THAN_SIGN:
                this._stateRawtextLessThanSign(e);
                break;
            case ag.RAWTEXT_END_TAG_OPEN:
                this._stateRawtextEndTagOpen(e);
                break;
            case ag.RAWTEXT_END_TAG_NAME:
                this._stateRawtextEndTagName(e);
                break;
            case ag.SCRIPT_DATA_LESS_THAN_SIGN:
                this._stateScriptDataLessThanSign(e);
                break;
            case ag.SCRIPT_DATA_END_TAG_OPEN:
                this._stateScriptDataEndTagOpen(e);
                break;
            case ag.SCRIPT_DATA_END_TAG_NAME:
                this._stateScriptDataEndTagName(e);
                break;
            case ag.SCRIPT_DATA_ESCAPE_START:
                this._stateScriptDataEscapeStart(e);
                break;
            case ag.SCRIPT_DATA_ESCAPE_START_DASH:
                this._stateScriptDataEscapeStartDash(e);
                break;
            case ag.SCRIPT_DATA_ESCAPED:
                this._stateScriptDataEscaped(e);
                break;
            case ag.SCRIPT_DATA_ESCAPED_DASH:
                this._stateScriptDataEscapedDash(e);
                break;
            case ag.SCRIPT_DATA_ESCAPED_DASH_DASH:
                this._stateScriptDataEscapedDashDash(e);
                break;
            case ag.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN:
                this._stateScriptDataEscapedLessThanSign(e);
                break;
            case ag.SCRIPT_DATA_ESCAPED_END_TAG_OPEN:
                this._stateScriptDataEscapedEndTagOpen(e);
                break;
            case ag.SCRIPT_DATA_ESCAPED_END_TAG_NAME:
                this._stateScriptDataEscapedEndTagName(e);
                break;
            case ag.SCRIPT_DATA_DOUBLE_ESCAPE_START:
                this._stateScriptDataDoubleEscapeStart(e);
                break;
            case ag.SCRIPT_DATA_DOUBLE_ESCAPED:
                this._stateScriptDataDoubleEscaped(e);
                break;
            case ag.SCRIPT_DATA_DOUBLE_ESCAPED_DASH:
                this._stateScriptDataDoubleEscapedDash(e);
                break;
            case ag.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH:
                this._stateScriptDataDoubleEscapedDashDash(e);
                break;
            case ag.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN:
                this._stateScriptDataDoubleEscapedLessThanSign(e);
                break;
            case ag.SCRIPT_DATA_DOUBLE_ESCAPE_END:
                this._stateScriptDataDoubleEscapeEnd(e);
                break;
            case ag.BEFORE_ATTRIBUTE_NAME:
                this._stateBeforeAttributeName(e);
                break;
            case ag.ATTRIBUTE_NAME:
                this._stateAttributeName(e);
                break;
            case ag.AFTER_ATTRIBUTE_NAME:
                this._stateAfterAttributeName(e);
                break;
            case ag.BEFORE_ATTRIBUTE_VALUE:
                this._stateBeforeAttributeValue(e);
                break;
            case ag.ATTRIBUTE_VALUE_DOUBLE_QUOTED:
                this._stateAttributeValueDoubleQuoted(e);
                break;
            case ag.ATTRIBUTE_VALUE_SINGLE_QUOTED:
                this._stateAttributeValueSingleQuoted(e);
                break;
            case ag.ATTRIBUTE_VALUE_UNQUOTED:
                this._stateAttributeValueUnquoted(e);
                break;
            case ag.AFTER_ATTRIBUTE_VALUE_QUOTED:
                this._stateAfterAttributeValueQuoted(e);
                break;
            case ag.SELF_CLOSING_START_TAG:
                this._stateSelfClosingStartTag(e);
                break;
            case ag.BOGUS_COMMENT:
                this._stateBogusComment(e);
                break;
            case ag.MARKUP_DECLARATION_OPEN:
                this._stateMarkupDeclarationOpen(e);
                break;
            case ag.COMMENT_START:
                this._stateCommentStart(e);
                break;
            case ag.COMMENT_START_DASH:
                this._stateCommentStartDash(e);
                break;
            case ag.COMMENT:
                this._stateComment(e);
                break;
            case ag.COMMENT_LESS_THAN_SIGN:
                this._stateCommentLessThanSign(e);
                break;
            case ag.COMMENT_LESS_THAN_SIGN_BANG:
                this._stateCommentLessThanSignBang(e);
                break;
            case ag.COMMENT_LESS_THAN_SIGN_BANG_DASH:
                this._stateCommentLessThanSignBangDash(e);
                break;
            case ag.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH:
                this._stateCommentLessThanSignBangDashDash(e);
                break;
            case ag.COMMENT_END_DASH:
                this._stateCommentEndDash(e);
                break;
            case ag.COMMENT_END:
                this._stateCommentEnd(e);
                break;
            case ag.COMMENT_END_BANG:
                this._stateCommentEndBang(e);
                break;
            case ag.DOCTYPE:
                this._stateDoctype(e);
                break;
            case ag.BEFORE_DOCTYPE_NAME:
                this._stateBeforeDoctypeName(e);
                break;
            case ag.DOCTYPE_NAME:
                this._stateDoctypeName(e);
                break;
            case ag.AFTER_DOCTYPE_NAME:
                this._stateAfterDoctypeName(e);
                break;
            case ag.AFTER_DOCTYPE_PUBLIC_KEYWORD:
                this._stateAfterDoctypePublicKeyword(e);
                break;
            case ag.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER:
                this._stateBeforeDoctypePublicIdentifier(e);
                break;
            case ag.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED:
                this._stateDoctypePublicIdentifierDoubleQuoted(e);
                break;
            case ag.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED:
                this._stateDoctypePublicIdentifierSingleQuoted(e);
                break;
            case ag.AFTER_DOCTYPE_PUBLIC_IDENTIFIER:
                this._stateAfterDoctypePublicIdentifier(e);
                break;
            case ag.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS:
                this._stateBetweenDoctypePublicAndSystemIdentifiers(e);
                break;
            case ag.AFTER_DOCTYPE_SYSTEM_KEYWORD:
                this._stateAfterDoctypeSystemKeyword(e);
                break;
            case ag.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER:
                this._stateBeforeDoctypeSystemIdentifier(e);
                break;
            case ag.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED:
                this._stateDoctypeSystemIdentifierDoubleQuoted(e);
                break;
            case ag.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED:
                this._stateDoctypeSystemIdentifierSingleQuoted(e);
                break;
            case ag.AFTER_DOCTYPE_SYSTEM_IDENTIFIER:
                this._stateAfterDoctypeSystemIdentifier(e);
                break;
            case ag.BOGUS_DOCTYPE:
                this._stateBogusDoctype(e);
                break;
            case ag.CDATA_SECTION:
                this._stateCdataSection(e);
                break;
            case ag.CDATA_SECTION_BRACKET:
                this._stateCdataSectionBracket(e);
                break;
            case ag.CDATA_SECTION_END:
                this._stateCdataSectionEnd(e);
                break;
            case ag.CHARACTER_REFERENCE:
                this._stateCharacterReference(e);
                break;
            case ag.NAMED_CHARACTER_REFERENCE:
                this._stateNamedCharacterReference(e);
                break;
            case ag.AMBIGUOUS_AMPERSAND:
                this._stateAmbiguousAmpersand(e);
                break;
            case ag.NUMERIC_CHARACTER_REFERENCE:
                this._stateNumericCharacterReference(e);
                break;
            case ag.HEXADEMICAL_CHARACTER_REFERENCE_START:
                this._stateHexademicalCharacterReferenceStart(e);
                break;
            case ag.HEXADEMICAL_CHARACTER_REFERENCE:
                this._stateHexademicalCharacterReference(e);
                break;
            case ag.DECIMAL_CHARACTER_REFERENCE:
                this._stateDecimalCharacterReference(e);
                break;
            case ag.NUMERIC_CHARACTER_REFERENCE_END:
                this._stateNumericCharacterReferenceEnd(e);
                break;
            default:
                throw new Error("Unknown state")
            }
        }
        _stateData(e) {
            switch (e) {
            case cm.LESS_THAN_SIGN:
                this.state = ag.TAG_OPEN;
                break;
            case cm.AMPERSAND:
                this.returnState = ag.DATA,
                this.state = ag.CHARACTER_REFERENCE;
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                this._emitCodePoint(e);
                break;
            case cm.EOF:
                this._emitEOFToken();
                break;
            default:
                this._emitCodePoint(e)
            }
        }
        _stateRcdata(e) {
            switch (e) {
            case cm.AMPERSAND:
                this.returnState = ag.RCDATA,
                this.state = ag.CHARACTER_REFERENCE;
                break;
            case cm.LESS_THAN_SIGN:
                this.state = ag.RCDATA_LESS_THAN_SIGN;
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                this._emitChars(lm);
                break;
            case cm.EOF:
                this._emitEOFToken();
                break;
            default:
                this._emitCodePoint(e)
            }
        }
        _stateRawtext(e) {
            switch (e) {
            case cm.LESS_THAN_SIGN:
                this.state = ag.RAWTEXT_LESS_THAN_SIGN;
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                this._emitChars(lm);
                break;
            case cm.EOF:
                this._emitEOFToken();
                break;
            default:
                this._emitCodePoint(e)
            }
        }
        _stateScriptData(e) {
            switch (e) {
            case cm.LESS_THAN_SIGN:
                this.state = ag.SCRIPT_DATA_LESS_THAN_SIGN;
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                this._emitChars(lm);
                break;
            case cm.EOF:
                this._emitEOFToken();
                break;
            default:
                this._emitCodePoint(e)
            }
        }
        _statePlaintext(e) {
            switch (e) {
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                this._emitChars(lm);
                break;
            case cm.EOF:
                this._emitEOFToken();
                break;
            default:
                this._emitCodePoint(e)
            }
        }
        _stateTagOpen(e) {
            if (dg(e))
                this._createStartTagToken(),
                this.state = ag.TAG_NAME,
                this._stateTagName(e);
            else
                switch (e) {
                case cm.EXCLAMATION_MARK:
                    this.state = ag.MARKUP_DECLARATION_OPEN;
                    break;
                case cm.SOLIDUS:
                    this.state = ag.END_TAG_OPEN;
                    break;
                case cm.QUESTION_MARK:
                    this._err(ym.unexpectedQuestionMarkInsteadOfTagName),
                    this._createCommentToken(1),
                    this.state = ag.BOGUS_COMMENT,
                    this._stateBogusComment(e);
                    break;
                case cm.EOF:
                    this._err(ym.eofBeforeTagName),
                    this._emitChars("<"),
                    this._emitEOFToken();
                    break;
                default:
                    this._err(ym.invalidFirstCharacterOfTagName),
                    this._emitChars("<"),
                    this.state = ag.DATA,
                    this._stateData(e)
                }
        }
        _stateEndTagOpen(e) {
            if (dg(e))
                this._createEndTagToken(),
                this.state = ag.TAG_NAME,
                this._stateTagName(e);
            else
                switch (e) {
                case cm.GREATER_THAN_SIGN:
                    this._err(ym.missingEndTagName),
                    this.state = ag.DATA;
                    break;
                case cm.EOF:
                    this._err(ym.eofBeforeTagName),
                    this._emitChars("</"),
                    this._emitEOFToken();
                    break;
                default:
                    this._err(ym.invalidFirstCharacterOfTagName),
                    this._createCommentToken(2),
                    this.state = ag.BOGUS_COMMENT,
                    this._stateBogusComment(e)
                }
        }
        _stateTagName(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.SPACE:
            case cm.LINE_FEED:
            case cm.TABULATION:
            case cm.FORM_FEED:
                this.state = ag.BEFORE_ATTRIBUTE_NAME;
                break;
            case cm.SOLIDUS:
                this.state = ag.SELF_CLOSING_START_TAG;
                break;
            case cm.GREATER_THAN_SIGN:
                this.state = ag.DATA,
                this.emitCurrentTagToken();
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                t.tagName += lm;
                break;
            case cm.EOF:
                this._err(ym.eofInTag),
                this._emitEOFToken();
                break;
            default:
                t.tagName += String.fromCodePoint(ug(e) ? mg(e) : e)
            }
        }
        _stateRcdataLessThanSign(e) {
            e === cm.SOLIDUS ? this.state = ag.RCDATA_END_TAG_OPEN : (this._emitChars("<"),
            this.state = ag.RCDATA,
            this._stateRcdata(e))
        }
        _stateRcdataEndTagOpen(e) {
            dg(e) ? (this.state = ag.RCDATA_END_TAG_NAME,
            this._stateRcdataEndTagName(e)) : (this._emitChars("</"),
            this.state = ag.RCDATA,
            this._stateRcdata(e))
        }
        handleSpecialEndTag(e) {
            if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
                return !this._ensureHibernation();
            this._createEndTagToken();
            this.currentToken.tagName = this.lastStartTagName;
            switch (this.preprocessor.peek(this.lastStartTagName.length)) {
            case cm.SPACE:
            case cm.LINE_FEED:
            case cm.TABULATION:
            case cm.FORM_FEED:
                return this._advanceBy(this.lastStartTagName.length),
                this.state = ag.BEFORE_ATTRIBUTE_NAME,
                !1;
            case cm.SOLIDUS:
                return this._advanceBy(this.lastStartTagName.length),
                this.state = ag.SELF_CLOSING_START_TAG,
                !1;
            case cm.GREATER_THAN_SIGN:
                return this._advanceBy(this.lastStartTagName.length),
                this.emitCurrentTagToken(),
                this.state = ag.DATA,
                !1;
            default:
                return !this._ensureHibernation()
            }
        }
        _stateRcdataEndTagName(e) {
            this.handleSpecialEndTag(e) && (this._emitChars("</"),
            this.state = ag.RCDATA,
            this._stateRcdata(e))
        }
        _stateRawtextLessThanSign(e) {
            e === cm.SOLIDUS ? this.state = ag.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"),
            this.state = ag.RAWTEXT,
            this._stateRawtext(e))
        }
        _stateRawtextEndTagOpen(e) {
            dg(e) ? (this.state = ag.RAWTEXT_END_TAG_NAME,
            this._stateRawtextEndTagName(e)) : (this._emitChars("</"),
            this.state = ag.RAWTEXT,
            this._stateRawtext(e))
        }
        _stateRawtextEndTagName(e) {
            this.handleSpecialEndTag(e) && (this._emitChars("</"),
            this.state = ag.RAWTEXT,
            this._stateRawtext(e))
        }
        _stateScriptDataLessThanSign(e) {
            switch (e) {
            case cm.SOLIDUS:
                this.state = ag.SCRIPT_DATA_END_TAG_OPEN;
                break;
            case cm.EXCLAMATION_MARK:
                this.state = ag.SCRIPT_DATA_ESCAPE_START,
                this._emitChars("<!");
                break;
            default:
                this._emitChars("<"),
                this.state = ag.SCRIPT_DATA,
                this._stateScriptData(e)
            }
        }
        _stateScriptDataEndTagOpen(e) {
            dg(e) ? (this.state = ag.SCRIPT_DATA_END_TAG_NAME,
            this._stateScriptDataEndTagName(e)) : (this._emitChars("</"),
            this.state = ag.SCRIPT_DATA,
            this._stateScriptData(e))
        }
        _stateScriptDataEndTagName(e) {
            this.handleSpecialEndTag(e) && (this._emitChars("</"),
            this.state = ag.SCRIPT_DATA,
            this._stateScriptData(e))
        }
        _stateScriptDataEscapeStart(e) {
            e === cm.HYPHEN_MINUS ? (this.state = ag.SCRIPT_DATA_ESCAPE_START_DASH,
            this._emitChars("-")) : (this.state = ag.SCRIPT_DATA,
            this._stateScriptData(e))
        }
        _stateScriptDataEscapeStartDash(e) {
            e === cm.HYPHEN_MINUS ? (this.state = ag.SCRIPT_DATA_ESCAPED_DASH_DASH,
            this._emitChars("-")) : (this.state = ag.SCRIPT_DATA,
            this._stateScriptData(e))
        }
        _stateScriptDataEscaped(e) {
            switch (e) {
            case cm.HYPHEN_MINUS:
                this.state = ag.SCRIPT_DATA_ESCAPED_DASH,
                this._emitChars("-");
                break;
            case cm.LESS_THAN_SIGN:
                this.state = ag.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                this._emitChars(lm);
                break;
            case cm.EOF:
                this._err(ym.eofInScriptHtmlCommentLikeText),
                this._emitEOFToken();
                break;
            default:
                this._emitCodePoint(e)
            }
        }
        _stateScriptDataEscapedDash(e) {
            switch (e) {
            case cm.HYPHEN_MINUS:
                this.state = ag.SCRIPT_DATA_ESCAPED_DASH_DASH,
                this._emitChars("-");
                break;
            case cm.LESS_THAN_SIGN:
                this.state = ag.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                this.state = ag.SCRIPT_DATA_ESCAPED,
                this._emitChars(lm);
                break;
            case cm.EOF:
                this._err(ym.eofInScriptHtmlCommentLikeText),
                this._emitEOFToken();
                break;
            default:
                this.state = ag.SCRIPT_DATA_ESCAPED,
                this._emitCodePoint(e)
            }
        }
        _stateScriptDataEscapedDashDash(e) {
            switch (e) {
            case cm.HYPHEN_MINUS:
                this._emitChars("-");
                break;
            case cm.LESS_THAN_SIGN:
                this.state = ag.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
                break;
            case cm.GREATER_THAN_SIGN:
                this.state = ag.SCRIPT_DATA,
                this._emitChars(">");
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                this.state = ag.SCRIPT_DATA_ESCAPED,
                this._emitChars(lm);
                break;
            case cm.EOF:
                this._err(ym.eofInScriptHtmlCommentLikeText),
                this._emitEOFToken();
                break;
            default:
                this.state = ag.SCRIPT_DATA_ESCAPED,
                this._emitCodePoint(e)
            }
        }
        _stateScriptDataEscapedLessThanSign(e) {
            e === cm.SOLIDUS ? this.state = ag.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : dg(e) ? (this._emitChars("<"),
            this.state = ag.SCRIPT_DATA_DOUBLE_ESCAPE_START,
            this._stateScriptDataDoubleEscapeStart(e)) : (this._emitChars("<"),
            this.state = ag.SCRIPT_DATA_ESCAPED,
            this._stateScriptDataEscaped(e))
        }
        _stateScriptDataEscapedEndTagOpen(e) {
            dg(e) ? (this.state = ag.SCRIPT_DATA_ESCAPED_END_TAG_NAME,
            this._stateScriptDataEscapedEndTagName(e)) : (this._emitChars("</"),
            this.state = ag.SCRIPT_DATA_ESCAPED,
            this._stateScriptDataEscaped(e))
        }
        _stateScriptDataEscapedEndTagName(e) {
            this.handleSpecialEndTag(e) && (this._emitChars("</"),
            this.state = ag.SCRIPT_DATA_ESCAPED,
            this._stateScriptDataEscaped(e))
        }
        _stateScriptDataDoubleEscapeStart(e) {
            if (this.preprocessor.startsWith(fm, !1) && bg(this.preprocessor.peek(fm.length))) {
                this._emitCodePoint(e);
                for (let e = 0; e < fm.length; e++)
                    this._emitCodePoint(this._consume());
                this.state = ag.SCRIPT_DATA_DOUBLE_ESCAPED
            } else
                this._ensureHibernation() || (this.state = ag.SCRIPT_DATA_ESCAPED,
                this._stateScriptDataEscaped(e))
        }
        _stateScriptDataDoubleEscaped(e) {
            switch (e) {
            case cm.HYPHEN_MINUS:
                this.state = ag.SCRIPT_DATA_DOUBLE_ESCAPED_DASH,
                this._emitChars("-");
                break;
            case cm.LESS_THAN_SIGN:
                this.state = ag.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN,
                this._emitChars("<");
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                this._emitChars(lm);
                break;
            case cm.EOF:
                this._err(ym.eofInScriptHtmlCommentLikeText),
                this._emitEOFToken();
                break;
            default:
                this._emitCodePoint(e)
            }
        }
        _stateScriptDataDoubleEscapedDash(e) {
            switch (e) {
            case cm.HYPHEN_MINUS:
                this.state = ag.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH,
                this._emitChars("-");
                break;
            case cm.LESS_THAN_SIGN:
                this.state = ag.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN,
                this._emitChars("<");
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                this.state = ag.SCRIPT_DATA_DOUBLE_ESCAPED,
                this._emitChars(lm);
                break;
            case cm.EOF:
                this._err(ym.eofInScriptHtmlCommentLikeText),
                this._emitEOFToken();
                break;
            default:
                this.state = ag.SCRIPT_DATA_DOUBLE_ESCAPED,
                this._emitCodePoint(e)
            }
        }
        _stateScriptDataDoubleEscapedDashDash(e) {
            switch (e) {
            case cm.HYPHEN_MINUS:
                this._emitChars("-");
                break;
            case cm.LESS_THAN_SIGN:
                this.state = ag.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN,
                this._emitChars("<");
                break;
            case cm.GREATER_THAN_SIGN:
                this.state = ag.SCRIPT_DATA,
                this._emitChars(">");
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                this.state = ag.SCRIPT_DATA_DOUBLE_ESCAPED,
                this._emitChars(lm);
                break;
            case cm.EOF:
                this._err(ym.eofInScriptHtmlCommentLikeText),
                this._emitEOFToken();
                break;
            default:
                this.state = ag.SCRIPT_DATA_DOUBLE_ESCAPED,
                this._emitCodePoint(e)
            }
        }
        _stateScriptDataDoubleEscapedLessThanSign(e) {
            e === cm.SOLIDUS ? (this.state = ag.SCRIPT_DATA_DOUBLE_ESCAPE_END,
            this._emitChars("/")) : (this.state = ag.SCRIPT_DATA_DOUBLE_ESCAPED,
            this._stateScriptDataDoubleEscaped(e))
        }
        _stateScriptDataDoubleEscapeEnd(e) {
            if (this.preprocessor.startsWith(fm, !1) && bg(this.preprocessor.peek(fm.length))) {
                this._emitCodePoint(e);
                for (let e = 0; e < fm.length; e++)
                    this._emitCodePoint(this._consume());
                this.state = ag.SCRIPT_DATA_ESCAPED
            } else
                this._ensureHibernation() || (this.state = ag.SCRIPT_DATA_DOUBLE_ESCAPED,
                this._stateScriptDataDoubleEscaped(e))
        }
        _stateBeforeAttributeName(e) {
            switch (e) {
            case cm.SPACE:
            case cm.LINE_FEED:
            case cm.TABULATION:
            case cm.FORM_FEED:
                break;
            case cm.SOLIDUS:
            case cm.GREATER_THAN_SIGN:
            case cm.EOF:
                this.state = ag.AFTER_ATTRIBUTE_NAME,
                this._stateAfterAttributeName(e);
                break;
            case cm.EQUALS_SIGN:
                this._err(ym.unexpectedEqualsSignBeforeAttributeName),
                this._createAttr("="),
                this.state = ag.ATTRIBUTE_NAME;
                break;
            default:
                this._createAttr(""),
                this.state = ag.ATTRIBUTE_NAME,
                this._stateAttributeName(e)
            }
        }
        _stateAttributeName(e) {
            switch (e) {
            case cm.SPACE:
            case cm.LINE_FEED:
            case cm.TABULATION:
            case cm.FORM_FEED:
            case cm.SOLIDUS:
            case cm.GREATER_THAN_SIGN:
            case cm.EOF:
                this._leaveAttrName(),
                this.state = ag.AFTER_ATTRIBUTE_NAME,
                this._stateAfterAttributeName(e);
                break;
            case cm.EQUALS_SIGN:
                this._leaveAttrName(),
                this.state = ag.BEFORE_ATTRIBUTE_VALUE;
                break;
            case cm.QUOTATION_MARK:
            case cm.APOSTROPHE:
            case cm.LESS_THAN_SIGN:
                this._err(ym.unexpectedCharacterInAttributeName),
                this.currentAttr.name += String.fromCodePoint(e);
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                this.currentAttr.name += lm;
                break;
            default:
                this.currentAttr.name += String.fromCodePoint(ug(e) ? mg(e) : e)
            }
        }
        _stateAfterAttributeName(e) {
            switch (e) {
            case cm.SPACE:
            case cm.LINE_FEED:
            case cm.TABULATION:
            case cm.FORM_FEED:
                break;
            case cm.SOLIDUS:
                this.state = ag.SELF_CLOSING_START_TAG;
                break;
            case cm.EQUALS_SIGN:
                this.state = ag.BEFORE_ATTRIBUTE_VALUE;
                break;
            case cm.GREATER_THAN_SIGN:
                this.state = ag.DATA,
                this.emitCurrentTagToken();
                break;
            case cm.EOF:
                this._err(ym.eofInTag),
                this._emitEOFToken();
                break;
            default:
                this._createAttr(""),
                this.state = ag.ATTRIBUTE_NAME,
                this._stateAttributeName(e)
            }
        }
        _stateBeforeAttributeValue(e) {
            switch (e) {
            case cm.SPACE:
            case cm.LINE_FEED:
            case cm.TABULATION:
            case cm.FORM_FEED:
                break;
            case cm.QUOTATION_MARK:
                this.state = ag.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
                break;
            case cm.APOSTROPHE:
                this.state = ag.ATTRIBUTE_VALUE_SINGLE_QUOTED;
                break;
            case cm.GREATER_THAN_SIGN:
                this._err(ym.missingAttributeValue),
                this.state = ag.DATA,
                this.emitCurrentTagToken();
                break;
            default:
                this.state = ag.ATTRIBUTE_VALUE_UNQUOTED,
                this._stateAttributeValueUnquoted(e)
            }
        }
        _stateAttributeValueDoubleQuoted(e) {
            switch (e) {
            case cm.QUOTATION_MARK:
                this.state = ag.AFTER_ATTRIBUTE_VALUE_QUOTED;
                break;
            case cm.AMPERSAND:
                this.returnState = ag.ATTRIBUTE_VALUE_DOUBLE_QUOTED,
                this.state = ag.CHARACTER_REFERENCE;
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                this.currentAttr.value += lm;
                break;
            case cm.EOF:
                this._err(ym.eofInTag),
                this._emitEOFToken();
                break;
            default:
                this.currentAttr.value += String.fromCodePoint(e)
            }
        }
        _stateAttributeValueSingleQuoted(e) {
            switch (e) {
            case cm.APOSTROPHE:
                this.state = ag.AFTER_ATTRIBUTE_VALUE_QUOTED;
                break;
            case cm.AMPERSAND:
                this.returnState = ag.ATTRIBUTE_VALUE_SINGLE_QUOTED,
                this.state = ag.CHARACTER_REFERENCE;
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                this.currentAttr.value += lm;
                break;
            case cm.EOF:
                this._err(ym.eofInTag),
                this._emitEOFToken();
                break;
            default:
                this.currentAttr.value += String.fromCodePoint(e)
            }
        }
        _stateAttributeValueUnquoted(e) {
            switch (e) {
            case cm.SPACE:
            case cm.LINE_FEED:
            case cm.TABULATION:
            case cm.FORM_FEED:
                this._leaveAttrValue(),
                this.state = ag.BEFORE_ATTRIBUTE_NAME;
                break;
            case cm.AMPERSAND:
                this.returnState = ag.ATTRIBUTE_VALUE_UNQUOTED,
                this.state = ag.CHARACTER_REFERENCE;
                break;
            case cm.GREATER_THAN_SIGN:
                this._leaveAttrValue(),
                this.state = ag.DATA,
                this.emitCurrentTagToken();
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                this.currentAttr.value += lm;
                break;
            case cm.QUOTATION_MARK:
            case cm.APOSTROPHE:
            case cm.LESS_THAN_SIGN:
            case cm.EQUALS_SIGN:
            case cm.GRAVE_ACCENT:
                this._err(ym.unexpectedCharacterInUnquotedAttributeValue),
                this.currentAttr.value += String.fromCodePoint(e);
                break;
            case cm.EOF:
                this._err(ym.eofInTag),
                this._emitEOFToken();
                break;
            default:
                this.currentAttr.value += String.fromCodePoint(e)
            }
        }
        _stateAfterAttributeValueQuoted(e) {
            switch (e) {
            case cm.SPACE:
            case cm.LINE_FEED:
            case cm.TABULATION:
            case cm.FORM_FEED:
                this._leaveAttrValue(),
                this.state = ag.BEFORE_ATTRIBUTE_NAME;
                break;
            case cm.SOLIDUS:
                this._leaveAttrValue(),
                this.state = ag.SELF_CLOSING_START_TAG;
                break;
            case cm.GREATER_THAN_SIGN:
                this._leaveAttrValue(),
                this.state = ag.DATA,
                this.emitCurrentTagToken();
                break;
            case cm.EOF:
                this._err(ym.eofInTag),
                this._emitEOFToken();
                break;
            default:
                this._err(ym.missingWhitespaceBetweenAttributes),
                this.state = ag.BEFORE_ATTRIBUTE_NAME,
                this._stateBeforeAttributeName(e)
            }
        }
        _stateSelfClosingStartTag(e) {
            switch (e) {
            case cm.GREATER_THAN_SIGN:
                this.currentToken.selfClosing = !0,
                this.state = ag.DATA,
                this.emitCurrentTagToken();
                break;
            case cm.EOF:
                this._err(ym.eofInTag),
                this._emitEOFToken();
                break;
            default:
                this._err(ym.unexpectedSolidusInTag),
                this.state = ag.BEFORE_ATTRIBUTE_NAME,
                this._stateBeforeAttributeName(e)
            }
        }
        _stateBogusComment(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.GREATER_THAN_SIGN:
                this.state = ag.DATA,
                this.emitCurrentComment(t);
                break;
            case cm.EOF:
                this.emitCurrentComment(t),
                this._emitEOFToken();
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                t.data += lm;
                break;
            default:
                t.data += String.fromCodePoint(e)
            }
        }
        _stateMarkupDeclarationOpen(e) {
            this._consumeSequenceIfMatch(dm, !0) ? (this._createCommentToken(dm.length + 1),
            this.state = ag.COMMENT_START) : this._consumeSequenceIfMatch(hm, !1) ? (this.currentLocation = this.getCurrentLocation(hm.length + 1),
            this.state = ag.DOCTYPE) : this._consumeSequenceIfMatch(pm, !0) ? this.inForeignNode ? this.state = ag.CDATA_SECTION : (this._err(ym.cdataInHtmlContent),
            this._createCommentToken(pm.length + 1),
            this.currentToken.data = "[CDATA[",
            this.state = ag.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(ym.incorrectlyOpenedComment),
            this._createCommentToken(2),
            this.state = ag.BOGUS_COMMENT,
            this._stateBogusComment(e))
        }
        _stateCommentStart(e) {
            switch (e) {
            case cm.HYPHEN_MINUS:
                this.state = ag.COMMENT_START_DASH;
                break;
            case cm.GREATER_THAN_SIGN:
                {
                    this._err(ym.abruptClosingOfEmptyComment),
                    this.state = ag.DATA;
                    const e = this.currentToken;
                    this.emitCurrentComment(e);
                    break
                }
            default:
                this.state = ag.COMMENT,
                this._stateComment(e)
            }
        }
        _stateCommentStartDash(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.HYPHEN_MINUS:
                this.state = ag.COMMENT_END;
                break;
            case cm.GREATER_THAN_SIGN:
                this._err(ym.abruptClosingOfEmptyComment),
                this.state = ag.DATA,
                this.emitCurrentComment(t);
                break;
            case cm.EOF:
                this._err(ym.eofInComment),
                this.emitCurrentComment(t),
                this._emitEOFToken();
                break;
            default:
                t.data += "-",
                this.state = ag.COMMENT,
                this._stateComment(e)
            }
        }
        _stateComment(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.HYPHEN_MINUS:
                this.state = ag.COMMENT_END_DASH;
                break;
            case cm.LESS_THAN_SIGN:
                t.data += "<",
                this.state = ag.COMMENT_LESS_THAN_SIGN;
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                t.data += lm;
                break;
            case cm.EOF:
                this._err(ym.eofInComment),
                this.emitCurrentComment(t),
                this._emitEOFToken();
                break;
            default:
                t.data += String.fromCodePoint(e)
            }
        }
        _stateCommentLessThanSign(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.EXCLAMATION_MARK:
                t.data += "!",
                this.state = ag.COMMENT_LESS_THAN_SIGN_BANG;
                break;
            case cm.LESS_THAN_SIGN:
                t.data += "<";
                break;
            default:
                this.state = ag.COMMENT,
                this._stateComment(e)
            }
        }
        _stateCommentLessThanSignBang(e) {
            e === cm.HYPHEN_MINUS ? this.state = ag.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = ag.COMMENT,
            this._stateComment(e))
        }
        _stateCommentLessThanSignBangDash(e) {
            e === cm.HYPHEN_MINUS ? this.state = ag.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = ag.COMMENT_END_DASH,
            this._stateCommentEndDash(e))
        }
        _stateCommentLessThanSignBangDashDash(e) {
            e !== cm.GREATER_THAN_SIGN && e !== cm.EOF && this._err(ym.nestedComment),
            this.state = ag.COMMENT_END,
            this._stateCommentEnd(e)
        }
        _stateCommentEndDash(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.HYPHEN_MINUS:
                this.state = ag.COMMENT_END;
                break;
            case cm.EOF:
                this._err(ym.eofInComment),
                this.emitCurrentComment(t),
                this._emitEOFToken();
                break;
            default:
                t.data += "-",
                this.state = ag.COMMENT,
                this._stateComment(e)
            }
        }
        _stateCommentEnd(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.GREATER_THAN_SIGN:
                this.state = ag.DATA,
                this.emitCurrentComment(t);
                break;
            case cm.EXCLAMATION_MARK:
                this.state = ag.COMMENT_END_BANG;
                break;
            case cm.HYPHEN_MINUS:
                t.data += "-";
                break;
            case cm.EOF:
                this._err(ym.eofInComment),
                this.emitCurrentComment(t),
                this._emitEOFToken();
                break;
            default:
                t.data += "--",
                this.state = ag.COMMENT,
                this._stateComment(e)
            }
        }
        _stateCommentEndBang(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.HYPHEN_MINUS:
                t.data += "--!",
                this.state = ag.COMMENT_END_DASH;
                break;
            case cm.GREATER_THAN_SIGN:
                this._err(ym.incorrectlyClosedComment),
                this.state = ag.DATA,
                this.emitCurrentComment(t);
                break;
            case cm.EOF:
                this._err(ym.eofInComment),
                this.emitCurrentComment(t),
                this._emitEOFToken();
                break;
            default:
                t.data += "--!",
                this.state = ag.COMMENT,
                this._stateComment(e)
            }
        }
        _stateDoctype(e) {
            switch (e) {
            case cm.SPACE:
            case cm.LINE_FEED:
            case cm.TABULATION:
            case cm.FORM_FEED:
                this.state = ag.BEFORE_DOCTYPE_NAME;
                break;
            case cm.GREATER_THAN_SIGN:
                this.state = ag.BEFORE_DOCTYPE_NAME,
                this._stateBeforeDoctypeName(e);
                break;
            case cm.EOF:
                {
                    this._err(ym.eofInDoctype),
                    this._createDoctypeToken(null);
                    const e = this.currentToken;
                    e.forceQuirks = !0,
                    this.emitCurrentDoctype(e),
                    this._emitEOFToken();
                    break
                }
            default:
                this._err(ym.missingWhitespaceBeforeDoctypeName),
                this.state = ag.BEFORE_DOCTYPE_NAME,
                this._stateBeforeDoctypeName(e)
            }
        }
        _stateBeforeDoctypeName(e) {
            if (ug(e))
                this._createDoctypeToken(String.fromCharCode(mg(e))),
                this.state = ag.DOCTYPE_NAME;
            else
                switch (e) {
                case cm.SPACE:
                case cm.LINE_FEED:
                case cm.TABULATION:
                case cm.FORM_FEED:
                    break;
                case cm.NULL:
                    this._err(ym.unexpectedNullCharacter),
                    this._createDoctypeToken(lm),
                    this.state = ag.DOCTYPE_NAME;
                    break;
                case cm.GREATER_THAN_SIGN:
                    {
                        this._err(ym.missingDoctypeName),
                        this._createDoctypeToken(null);
                        const e = this.currentToken;
                        e.forceQuirks = !0,
                        this.emitCurrentDoctype(e),
                        this.state = ag.DATA;
                        break
                    }
                case cm.EOF:
                    {
                        this._err(ym.eofInDoctype),
                        this._createDoctypeToken(null);
                        const e = this.currentToken;
                        e.forceQuirks = !0,
                        this.emitCurrentDoctype(e),
                        this._emitEOFToken();
                        break
                    }
                default:
                    this._createDoctypeToken(String.fromCodePoint(e)),
                    this.state = ag.DOCTYPE_NAME
                }
        }
        _stateDoctypeName(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.SPACE:
            case cm.LINE_FEED:
            case cm.TABULATION:
            case cm.FORM_FEED:
                this.state = ag.AFTER_DOCTYPE_NAME;
                break;
            case cm.GREATER_THAN_SIGN:
                this.state = ag.DATA,
                this.emitCurrentDoctype(t);
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                t.name += lm;
                break;
            case cm.EOF:
                this._err(ym.eofInDoctype),
                t.forceQuirks = !0,
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
                break;
            default:
                t.name += String.fromCodePoint(ug(e) ? mg(e) : e)
            }
        }
        _stateAfterDoctypeName(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.SPACE:
            case cm.LINE_FEED:
            case cm.TABULATION:
            case cm.FORM_FEED:
                break;
            case cm.GREATER_THAN_SIGN:
                this.state = ag.DATA,
                this.emitCurrentDoctype(t);
                break;
            case cm.EOF:
                this._err(ym.eofInDoctype),
                t.forceQuirks = !0,
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
                break;
            default:
                this._consumeSequenceIfMatch(mm, !1) ? this.state = ag.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(gm, !1) ? this.state = ag.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(ym.invalidCharacterSequenceAfterDoctypeName),
                t.forceQuirks = !0,
                this.state = ag.BOGUS_DOCTYPE,
                this._stateBogusDoctype(e))
            }
        }
        _stateAfterDoctypePublicKeyword(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.SPACE:
            case cm.LINE_FEED:
            case cm.TABULATION:
            case cm.FORM_FEED:
                this.state = ag.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
                break;
            case cm.QUOTATION_MARK:
                this._err(ym.missingWhitespaceAfterDoctypePublicKeyword),
                t.publicId = "",
                this.state = ag.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
                break;
            case cm.APOSTROPHE:
                this._err(ym.missingWhitespaceAfterDoctypePublicKeyword),
                t.publicId = "",
                this.state = ag.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
                break;
            case cm.GREATER_THAN_SIGN:
                this._err(ym.missingDoctypePublicIdentifier),
                t.forceQuirks = !0,
                this.state = ag.DATA,
                this.emitCurrentDoctype(t);
                break;
            case cm.EOF:
                this._err(ym.eofInDoctype),
                t.forceQuirks = !0,
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
                break;
            default:
                this._err(ym.missingQuoteBeforeDoctypePublicIdentifier),
                t.forceQuirks = !0,
                this.state = ag.BOGUS_DOCTYPE,
                this._stateBogusDoctype(e)
            }
        }
        _stateBeforeDoctypePublicIdentifier(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.SPACE:
            case cm.LINE_FEED:
            case cm.TABULATION:
            case cm.FORM_FEED:
                break;
            case cm.QUOTATION_MARK:
                t.publicId = "",
                this.state = ag.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
                break;
            case cm.APOSTROPHE:
                t.publicId = "",
                this.state = ag.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
                break;
            case cm.GREATER_THAN_SIGN:
                this._err(ym.missingDoctypePublicIdentifier),
                t.forceQuirks = !0,
                this.state = ag.DATA,
                this.emitCurrentDoctype(t);
                break;
            case cm.EOF:
                this._err(ym.eofInDoctype),
                t.forceQuirks = !0,
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
                break;
            default:
                this._err(ym.missingQuoteBeforeDoctypePublicIdentifier),
                t.forceQuirks = !0,
                this.state = ag.BOGUS_DOCTYPE,
                this._stateBogusDoctype(e)
            }
        }
        _stateDoctypePublicIdentifierDoubleQuoted(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.QUOTATION_MARK:
                this.state = ag.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                t.publicId += lm;
                break;
            case cm.GREATER_THAN_SIGN:
                this._err(ym.abruptDoctypePublicIdentifier),
                t.forceQuirks = !0,
                this.emitCurrentDoctype(t),
                this.state = ag.DATA;
                break;
            case cm.EOF:
                this._err(ym.eofInDoctype),
                t.forceQuirks = !0,
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
                break;
            default:
                t.publicId += String.fromCodePoint(e)
            }
        }
        _stateDoctypePublicIdentifierSingleQuoted(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.APOSTROPHE:
                this.state = ag.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                t.publicId += lm;
                break;
            case cm.GREATER_THAN_SIGN:
                this._err(ym.abruptDoctypePublicIdentifier),
                t.forceQuirks = !0,
                this.emitCurrentDoctype(t),
                this.state = ag.DATA;
                break;
            case cm.EOF:
                this._err(ym.eofInDoctype),
                t.forceQuirks = !0,
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
                break;
            default:
                t.publicId += String.fromCodePoint(e)
            }
        }
        _stateAfterDoctypePublicIdentifier(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.SPACE:
            case cm.LINE_FEED:
            case cm.TABULATION:
            case cm.FORM_FEED:
                this.state = ag.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
                break;
            case cm.GREATER_THAN_SIGN:
                this.state = ag.DATA,
                this.emitCurrentDoctype(t);
                break;
            case cm.QUOTATION_MARK:
                this._err(ym.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers),
                t.systemId = "",
                this.state = ag.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
                break;
            case cm.APOSTROPHE:
                this._err(ym.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers),
                t.systemId = "",
                this.state = ag.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
                break;
            case cm.EOF:
                this._err(ym.eofInDoctype),
                t.forceQuirks = !0,
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
                break;
            default:
                this._err(ym.missingQuoteBeforeDoctypeSystemIdentifier),
                t.forceQuirks = !0,
                this.state = ag.BOGUS_DOCTYPE,
                this._stateBogusDoctype(e)
            }
        }
        _stateBetweenDoctypePublicAndSystemIdentifiers(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.SPACE:
            case cm.LINE_FEED:
            case cm.TABULATION:
            case cm.FORM_FEED:
                break;
            case cm.GREATER_THAN_SIGN:
                this.emitCurrentDoctype(t),
                this.state = ag.DATA;
                break;
            case cm.QUOTATION_MARK:
                t.systemId = "",
                this.state = ag.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
                break;
            case cm.APOSTROPHE:
                t.systemId = "",
                this.state = ag.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
                break;
            case cm.EOF:
                this._err(ym.eofInDoctype),
                t.forceQuirks = !0,
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
                break;
            default:
                this._err(ym.missingQuoteBeforeDoctypeSystemIdentifier),
                t.forceQuirks = !0,
                this.state = ag.BOGUS_DOCTYPE,
                this._stateBogusDoctype(e)
            }
        }
        _stateAfterDoctypeSystemKeyword(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.SPACE:
            case cm.LINE_FEED:
            case cm.TABULATION:
            case cm.FORM_FEED:
                this.state = ag.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
                break;
            case cm.QUOTATION_MARK:
                this._err(ym.missingWhitespaceAfterDoctypeSystemKeyword),
                t.systemId = "",
                this.state = ag.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
                break;
            case cm.APOSTROPHE:
                this._err(ym.missingWhitespaceAfterDoctypeSystemKeyword),
                t.systemId = "",
                this.state = ag.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
                break;
            case cm.GREATER_THAN_SIGN:
                this._err(ym.missingDoctypeSystemIdentifier),
                t.forceQuirks = !0,
                this.state = ag.DATA,
                this.emitCurrentDoctype(t);
                break;
            case cm.EOF:
                this._err(ym.eofInDoctype),
                t.forceQuirks = !0,
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
                break;
            default:
                this._err(ym.missingQuoteBeforeDoctypeSystemIdentifier),
                t.forceQuirks = !0,
                this.state = ag.BOGUS_DOCTYPE,
                this._stateBogusDoctype(e)
            }
        }
        _stateBeforeDoctypeSystemIdentifier(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.SPACE:
            case cm.LINE_FEED:
            case cm.TABULATION:
            case cm.FORM_FEED:
                break;
            case cm.QUOTATION_MARK:
                t.systemId = "",
                this.state = ag.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
                break;
            case cm.APOSTROPHE:
                t.systemId = "",
                this.state = ag.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
                break;
            case cm.GREATER_THAN_SIGN:
                this._err(ym.missingDoctypeSystemIdentifier),
                t.forceQuirks = !0,
                this.state = ag.DATA,
                this.emitCurrentDoctype(t);
                break;
            case cm.EOF:
                this._err(ym.eofInDoctype),
                t.forceQuirks = !0,
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
                break;
            default:
                this._err(ym.missingQuoteBeforeDoctypeSystemIdentifier),
                t.forceQuirks = !0,
                this.state = ag.BOGUS_DOCTYPE,
                this._stateBogusDoctype(e)
            }
        }
        _stateDoctypeSystemIdentifierDoubleQuoted(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.QUOTATION_MARK:
                this.state = ag.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                t.systemId += lm;
                break;
            case cm.GREATER_THAN_SIGN:
                this._err(ym.abruptDoctypeSystemIdentifier),
                t.forceQuirks = !0,
                this.emitCurrentDoctype(t),
                this.state = ag.DATA;
                break;
            case cm.EOF:
                this._err(ym.eofInDoctype),
                t.forceQuirks = !0,
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
                break;
            default:
                t.systemId += String.fromCodePoint(e)
            }
        }
        _stateDoctypeSystemIdentifierSingleQuoted(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.APOSTROPHE:
                this.state = ag.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter),
                t.systemId += lm;
                break;
            case cm.GREATER_THAN_SIGN:
                this._err(ym.abruptDoctypeSystemIdentifier),
                t.forceQuirks = !0,
                this.emitCurrentDoctype(t),
                this.state = ag.DATA;
                break;
            case cm.EOF:
                this._err(ym.eofInDoctype),
                t.forceQuirks = !0,
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
                break;
            default:
                t.systemId += String.fromCodePoint(e)
            }
        }
        _stateAfterDoctypeSystemIdentifier(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.SPACE:
            case cm.LINE_FEED:
            case cm.TABULATION:
            case cm.FORM_FEED:
                break;
            case cm.GREATER_THAN_SIGN:
                this.emitCurrentDoctype(t),
                this.state = ag.DATA;
                break;
            case cm.EOF:
                this._err(ym.eofInDoctype),
                t.forceQuirks = !0,
                this.emitCurrentDoctype(t),
                this._emitEOFToken();
                break;
            default:
                this._err(ym.unexpectedCharacterAfterDoctypeSystemIdentifier),
                this.state = ag.BOGUS_DOCTYPE,
                this._stateBogusDoctype(e)
            }
        }
        _stateBogusDoctype(e) {
            const t = this.currentToken;
            switch (e) {
            case cm.GREATER_THAN_SIGN:
                this.emitCurrentDoctype(t),
                this.state = ag.DATA;
                break;
            case cm.NULL:
                this._err(ym.unexpectedNullCharacter);
                break;
            case cm.EOF:
                this.emitCurrentDoctype(t),
                this._emitEOFToken()
            }
        }
        _stateCdataSection(e) {
            switch (e) {
            case cm.RIGHT_SQUARE_BRACKET:
                this.state = ag.CDATA_SECTION_BRACKET;
                break;
            case cm.EOF:
                this._err(ym.eofInCdata),
                this._emitEOFToken();
                break;
            default:
                this._emitCodePoint(e)
            }
        }
        _stateCdataSectionBracket(e) {
            e === cm.RIGHT_SQUARE_BRACKET ? this.state = ag.CDATA_SECTION_END : (this._emitChars("]"),
            this.state = ag.CDATA_SECTION,
            this._stateCdataSection(e))
        }
        _stateCdataSectionEnd(e) {
            switch (e) {
            case cm.GREATER_THAN_SIGN:
                this.state = ag.DATA;
                break;
            case cm.RIGHT_SQUARE_BRACKET:
                this._emitChars("]");
                break;
            default:
                this._emitChars("]]"),
                this.state = ag.CDATA_SECTION,
                this._stateCdataSection(e)
            }
        }
        _stateCharacterReference(e) {
            e === cm.NUMBER_SIGN ? this.state = ag.NUMERIC_CHARACTER_REFERENCE : pg(e) ? (this.state = ag.NAMED_CHARACTER_REFERENCE,
            this._stateNamedCharacterReference(e)) : (this._flushCodePointConsumedAsCharacterReference(cm.AMPERSAND),
            this._reconsumeInState(this.returnState, e))
        }
        _stateNamedCharacterReference(e) {
            const t = this._matchNamedCharacterReference(e);
            if (this._ensureHibernation())
                ;
            else if (t) {
                for (let e = 0; e < t.length; e++)
                    this._flushCodePointConsumedAsCharacterReference(t[e]);
                this.state = this.returnState
            } else
                this._flushCodePointConsumedAsCharacterReference(cm.AMPERSAND),
                this.state = ag.AMBIGUOUS_AMPERSAND
        }
        _stateAmbiguousAmpersand(e) {
            pg(e) ? this._flushCodePointConsumedAsCharacterReference(e) : (e === cm.SEMICOLON && this._err(ym.unknownNamedCharacterReference),
            this._reconsumeInState(this.returnState, e))
        }
        _stateNumericCharacterReference(e) {
            this.charRefCode = 0,
            e === cm.LATIN_SMALL_X || e === cm.LATIN_CAPITAL_X ? this.state = ag.HEXADEMICAL_CHARACTER_REFERENCE_START : cg(e) ? (this.state = ag.DECIMAL_CHARACTER_REFERENCE,
            this._stateDecimalCharacterReference(e)) : (this._err(ym.absenceOfDigitsInNumericCharacterReference),
            this._flushCodePointConsumedAsCharacterReference(cm.AMPERSAND),
            this._flushCodePointConsumedAsCharacterReference(cm.NUMBER_SIGN),
            this._reconsumeInState(this.returnState, e))
        }
        _stateHexademicalCharacterReferenceStart(e) {
            !function(e) {
                return cg(e) || hg(e) || fg(e)
            }(e) ? (this._err(ym.absenceOfDigitsInNumericCharacterReference),
            this._flushCodePointConsumedAsCharacterReference(cm.AMPERSAND),
            this._flushCodePointConsumedAsCharacterReference(cm.NUMBER_SIGN),
            this._unconsume(2),
            this.state = this.returnState) : (this.state = ag.HEXADEMICAL_CHARACTER_REFERENCE,
            this._stateHexademicalCharacterReference(e))
        }
        _stateHexademicalCharacterReference(e) {
            hg(e) ? this.charRefCode = 16 * this.charRefCode + e - 55 : fg(e) ? this.charRefCode = 16 * this.charRefCode + e - 87 : cg(e) ? this.charRefCode = 16 * this.charRefCode + e - 48 : e === cm.SEMICOLON ? this.state = ag.NUMERIC_CHARACTER_REFERENCE_END : (this._err(ym.missingSemicolonAfterCharacterReference),
            this.state = ag.NUMERIC_CHARACTER_REFERENCE_END,
            this._stateNumericCharacterReferenceEnd(e))
        }
        _stateDecimalCharacterReference(e) {
            cg(e) ? this.charRefCode = 10 * this.charRefCode + e - 48 : e === cm.SEMICOLON ? this.state = ag.NUMERIC_CHARACTER_REFERENCE_END : (this._err(ym.missingSemicolonAfterCharacterReference),
            this.state = ag.NUMERIC_CHARACTER_REFERENCE_END,
            this._stateNumericCharacterReferenceEnd(e))
        }
        _stateNumericCharacterReferenceEnd(e) {
            if (this.charRefCode === cm.NULL)
                this._err(ym.nullCharacterReference),
                this.charRefCode = cm.REPLACEMENT_CHARACTER;
            else if (this.charRefCode > 1114111)
                this._err(ym.characterReferenceOutsideUnicodeRange),
                this.charRefCode = cm.REPLACEMENT_CHARACTER;
            else if (bm(this.charRefCode))
                this._err(ym.surrogateCharacterReference),
                this.charRefCode = cm.REPLACEMENT_CHARACTER;
            else if (vm(this.charRefCode))
                this._err(ym.noncharacterCharacterReference);
            else if (Om(this.charRefCode) || this.charRefCode === cm.CARRIAGE_RETURN) {
                this._err(ym.controlCharacterReference);
                const e = ig.get(this.charRefCode);
                void 0 !== e && (this.charRefCode = e)
            }
            this._flushCodePointConsumedAsCharacterReference(this.charRefCode),
            this._reconsumeInState(this.returnState, e)
        }
    }
    const vg = new Set([Wm.DD, Wm.DT, Wm.LI, Wm.OPTGROUP, Wm.OPTION, Wm.P, Wm.RB, Wm.RP, Wm.RT, Wm.RTC])
      , yg = new Set([...vg, Wm.CAPTION, Wm.COLGROUP, Wm.TBODY, Wm.TD, Wm.TFOOT, Wm.TH, Wm.THEAD, Wm.TR])
      , wg = new Map([[Wm.APPLET, Bm.HTML], [Wm.CAPTION, Bm.HTML], [Wm.HTML, Bm.HTML], [Wm.MARQUEE, Bm.HTML], [Wm.OBJECT, Bm.HTML], [Wm.TABLE, Bm.HTML], [Wm.TD, Bm.HTML], [Wm.TEMPLATE, Bm.HTML], [Wm.TH, Bm.HTML], [Wm.ANNOTATION_XML, Bm.MATHML], [Wm.MI, Bm.MATHML], [Wm.MN, Bm.MATHML], [Wm.MO, Bm.MATHML], [Wm.MS, Bm.MATHML], [Wm.MTEXT, Bm.MATHML], [Wm.DESC, Bm.SVG], [Wm.FOREIGN_OBJECT, Bm.SVG], [Wm.TITLE, Bm.SVG]])
      , _g = [Wm.H1, Wm.H2, Wm.H3, Wm.H4, Wm.H5, Wm.H6]
      , kg = [Wm.TR, Wm.TEMPLATE, Wm.HTML]
      , Sg = [Wm.TBODY, Wm.TFOOT, Wm.THEAD, Wm.TEMPLATE, Wm.HTML]
      , Eg = [Wm.TABLE, Wm.TEMPLATE, Wm.HTML]
      , xg = [Wm.TD, Wm.TH];
    class Tg {
        get currentTmplContentOrNode() {
            return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current
        }
        constructor(e, t, n) {
            this.treeAdapter = t,
            this.handler = n,
            this.items = [],
            this.tagIDs = [],
            this.stackTop = -1,
            this.tmplCount = 0,
            this.currentTagId = Wm.UNKNOWN,
            this.current = e
        }
        _indexOf(e) {
            return this.items.lastIndexOf(e, this.stackTop)
        }
        _isInTemplate() {
            return this.currentTagId === Wm.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === Bm.HTML
        }
        _updateCurrentElement() {
            this.current = this.items[this.stackTop],
            this.currentTagId = this.tagIDs[this.stackTop]
        }
        push(e, t) {
            this.stackTop++,
            this.items[this.stackTop] = e,
            this.current = e,
            this.tagIDs[this.stackTop] = t,
            this.currentTagId = t,
            this._isInTemplate() && this.tmplCount++,
            this.handler.onItemPush(e, t, !0)
        }
        pop() {
            const e = this.current;
            this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--,
            this.stackTop--,
            this._updateCurrentElement(),
            this.handler.onItemPop(e, !0)
        }
        replace(e, t) {
            const n = this._indexOf(e);
            this.items[n] = t,
            n === this.stackTop && (this.current = t)
        }
        insertAfter(e, t, n) {
            const r = this._indexOf(e) + 1;
            this.items.splice(r, 0, t),
            this.tagIDs.splice(r, 0, n),
            this.stackTop++,
            r === this.stackTop && this._updateCurrentElement(),
            this.handler.onItemPush(this.current, this.currentTagId, r === this.stackTop)
        }
        popUntilTagNamePopped(e) {
            let t = this.stackTop + 1;
            do {
                t = this.tagIDs.lastIndexOf(e, t - 1)
            } while (t > 0 && this.treeAdapter.getNamespaceURI(this.items[t]) !== Bm.HTML);
            this.shortenToLength(t < 0 ? 0 : t)
        }
        shortenToLength(e) {
            for (; this.stackTop >= e; ) {
                const t = this.current;
                this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1),
                this.stackTop--,
                this._updateCurrentElement(),
                this.handler.onItemPop(t, this.stackTop < e)
            }
        }
        popUntilElementPopped(e) {
            const t = this._indexOf(e);
            this.shortenToLength(t < 0 ? 0 : t)
        }
        popUntilPopped(e, t) {
            const n = this._indexOfTagNames(e, t);
            this.shortenToLength(n < 0 ? 0 : n)
        }
        popUntilNumberedHeaderPopped() {
            this.popUntilPopped(_g, Bm.HTML)
        }
        popUntilTableCellPopped() {
            this.popUntilPopped(xg, Bm.HTML)
        }
        popAllUpToHtmlElement() {
            this.tmplCount = 0,
            this.shortenToLength(1)
        }
        _indexOfTagNames(e, t) {
            for (let n = this.stackTop; n >= 0; n--)
                if (e.includes(this.tagIDs[n]) && this.treeAdapter.getNamespaceURI(this.items[n]) === t)
                    return n;
            return -1
        }
        clearBackTo(e, t) {
            const n = this._indexOfTagNames(e, t);
            this.shortenToLength(n + 1)
        }
        clearBackToTableContext() {
            this.clearBackTo(Eg, Bm.HTML)
        }
        clearBackToTableBodyContext() {
            this.clearBackTo(Sg, Bm.HTML)
        }
        clearBackToTableRowContext() {
            this.clearBackTo(kg, Bm.HTML)
        }
        remove(e) {
            const t = this._indexOf(e);
            t >= 0 && (t === this.stackTop ? this.pop() : (this.items.splice(t, 1),
            this.tagIDs.splice(t, 1),
            this.stackTop--,
            this._updateCurrentElement(),
            this.handler.onItemPop(e, !1)))
        }
        tryPeekProperlyNestedBodyElement() {
            return this.stackTop >= 1 && this.tagIDs[1] === Wm.BODY ? this.items[1] : null
        }
        contains(e) {
            return this._indexOf(e) > -1
        }
        getCommonAncestor(e) {
            const t = this._indexOf(e) - 1;
            return t >= 0 ? this.items[t] : null
        }
        isRootHtmlElementCurrent() {
            return 0 === this.stackTop && this.tagIDs[0] === Wm.HTML
        }
        hasInScope(e) {
            for (let t = this.stackTop; t >= 0; t--) {
                const n = this.tagIDs[t]
                  , r = this.treeAdapter.getNamespaceURI(this.items[t]);
                if (n === e && r === Bm.HTML)
                    return !0;
                if (wg.get(n) === r)
                    return !1
            }
            return !0
        }
        hasNumberedHeaderInScope() {
            for (let e = this.stackTop; e >= 0; e--) {
                const t = this.tagIDs[e]
                  , n = this.treeAdapter.getNamespaceURI(this.items[e]);
                if (og(t) && n === Bm.HTML)
                    return !0;
                if (wg.get(t) === n)
                    return !1
            }
            return !0
        }
        hasInListItemScope(e) {
            for (let t = this.stackTop; t >= 0; t--) {
                const n = this.tagIDs[t]
                  , r = this.treeAdapter.getNamespaceURI(this.items[t]);
                if (n === e && r === Bm.HTML)
                    return !0;
                if ((n === Wm.UL || n === Wm.OL) && r === Bm.HTML || wg.get(n) === r)
                    return !1
            }
            return !0
        }
        hasInButtonScope(e) {
            for (let t = this.stackTop; t >= 0; t--) {
                const n = this.tagIDs[t]
                  , r = this.treeAdapter.getNamespaceURI(this.items[t]);
                if (n === e && r === Bm.HTML)
                    return !0;
                if (n === Wm.BUTTON && r === Bm.HTML || wg.get(n) === r)
                    return !1
            }
            return !0
        }
        hasInTableScope(e) {
            for (let t = this.stackTop; t >= 0; t--) {
                const n = this.tagIDs[t];
                if (this.treeAdapter.getNamespaceURI(this.items[t]) === Bm.HTML) {
                    if (n === e)
                        return !0;
                    if (n === Wm.TABLE || n === Wm.TEMPLATE || n === Wm.HTML)
                        return !1
                }
            }
            return !0
        }
        hasTableBodyContextInTableScope() {
            for (let e = this.stackTop; e >= 0; e--) {
                const t = this.tagIDs[e];
                if (this.treeAdapter.getNamespaceURI(this.items[e]) === Bm.HTML) {
                    if (t === Wm.TBODY || t === Wm.THEAD || t === Wm.TFOOT)
                        return !0;
                    if (t === Wm.TABLE || t === Wm.HTML)
                        return !1
                }
            }
            return !0
        }
        hasInSelectScope(e) {
            for (let t = this.stackTop; t >= 0; t--) {
                const n = this.tagIDs[t];
                if (this.treeAdapter.getNamespaceURI(this.items[t]) === Bm.HTML) {
                    if (n === e)
                        return !0;
                    if (n !== Wm.OPTION && n !== Wm.OPTGROUP)
                        return !1
                }
            }
            return !0
        }
        generateImpliedEndTags() {
            for (; vg.has(this.currentTagId); )
                this.pop()
        }
        generateImpliedEndTagsThoroughly() {
            for (; yg.has(this.currentTagId); )
                this.pop()
        }
        generateImpliedEndTagsWithExclusion(e) {
            for (; this.currentTagId !== e && yg.has(this.currentTagId); )
                this.pop()
        }
    }
    var Ag, Cg;
    (Cg = Ag = Ag || (Ag = {}))[Cg.Marker = 0] = "Marker",
    Cg[Cg.Element = 1] = "Element";
    const Pg = {
        type: Ag.Marker
    };
    class Dg {
        constructor(e) {
            this.treeAdapter = e,
            this.entries = [],
            this.bookmark = null
        }
        _getNoahArkConditionCandidates(e, t) {
            const n = []
              , r = t.length
              , o = this.treeAdapter.getTagName(e)
              , i = this.treeAdapter.getNamespaceURI(e);
            for (let a = 0; a < this.entries.length; a++) {
                const e = this.entries[a];
                if (e.type === Ag.Marker)
                    break;
                const {element: t} = e;
                if (this.treeAdapter.getTagName(t) === o && this.treeAdapter.getNamespaceURI(t) === i) {
                    const e = this.treeAdapter.getAttrList(t);
                    e.length === r && n.push({
                        idx: a,
                        attrs: e
                    })
                }
            }
            return n
        }
        _ensureNoahArkCondition(e) {
            if (this.entries.length < 3)
                return;
            const t = this.treeAdapter.getAttrList(e)
              , n = this._getNoahArkConditionCandidates(e, t);
            if (n.length < 3)
                return;
            const r = new Map(t.map((e=>[e.name, e.value])));
            let o = 0;
            for (let i = 0; i < n.length; i++) {
                const e = n[i];
                e.attrs.every((e=>r.get(e.name) === e.value)) && (o += 1,
                o >= 3 && this.entries.splice(e.idx, 1))
            }
        }
        insertMarker() {
            this.entries.unshift(Pg)
        }
        pushElement(e, t) {
            this._ensureNoahArkCondition(e),
            this.entries.unshift({
                type: Ag.Element,
                element: e,
                token: t
            })
        }
        insertElementAfterBookmark(e, t) {
            const n = this.entries.indexOf(this.bookmark);
            this.entries.splice(n, 0, {
                type: Ag.Element,
                element: e,
                token: t
            })
        }
        removeEntry(e) {
            const t = this.entries.indexOf(e);
            t >= 0 && this.entries.splice(t, 1)
        }
        clearToLastMarker() {
            const e = this.entries.indexOf(Pg);
            e >= 0 ? this.entries.splice(0, e + 1) : this.entries.length = 0
        }
        getElementEntryInScopeWithTagName(e) {
            const t = this.entries.find((t=>t.type === Ag.Marker || this.treeAdapter.getTagName(t.element) === e));
            return t && t.type === Ag.Element ? t : null
        }
        getElementEntry(e) {
            return this.entries.find((t=>t.type === Ag.Element && t.element === e))
        }
    }
    function Rg(e) {
        return {
            nodeName: "#text",
            value: e,
            parentNode: null
        }
    }
    const Ng = {
        createDocument: ()=>({
            nodeName: "#document",
            mode: zm.NO_QUIRKS,
            childNodes: []
        }),
        createDocumentFragment: ()=>({
            nodeName: "#document-fragment",
            childNodes: []
        }),
        createElement: (e,t,n)=>({
            nodeName: e,
            tagName: e,
            attrs: n,
            namespaceURI: t,
            childNodes: [],
            parentNode: null
        }),
        createCommentNode: e=>({
            nodeName: "#comment",
            data: e,
            parentNode: null
        }),
        appendChild(e, t) {
            e.childNodes.push(t),
            t.parentNode = e
        },
        insertBefore(e, t, n) {
            const r = e.childNodes.indexOf(n);
            e.childNodes.splice(r, 0, t),
            t.parentNode = e
        },
        setTemplateContent(e, t) {
            e.content = t
        },
        getTemplateContent: e=>e.content,
        setDocumentType(e, t, n, r) {
            const o = e.childNodes.find((e=>"#documentType" === e.nodeName));
            if (o)
                o.name = t,
                o.publicId = n,
                o.systemId = r;
            else {
                const o = {
                    nodeName: "#documentType",
                    name: t,
                    publicId: n,
                    systemId: r,
                    parentNode: null
                };
                Ng.appendChild(e, o)
            }
        },
        setDocumentMode(e, t) {
            e.mode = t
        },
        getDocumentMode: e=>e.mode,
        detachNode(e) {
            if (e.parentNode) {
                const t = e.parentNode.childNodes.indexOf(e);
                e.parentNode.childNodes.splice(t, 1),
                e.parentNode = null
            }
        },
        insertText(e, t) {
            if (e.childNodes.length > 0) {
                const n = e.childNodes[e.childNodes.length - 1];
                if (Ng.isTextNode(n))
                    return void (n.value += t)
            }
            Ng.appendChild(e, Rg(t))
        },
        insertTextBefore(e, t, n) {
            const r = e.childNodes[e.childNodes.indexOf(n) - 1];
            r && Ng.isTextNode(r) ? r.value += t : Ng.insertBefore(e, Rg(t), n)
        },
        adoptAttributes(e, t) {
            const n = new Set(e.attrs.map((e=>e.name)));
            for (let r = 0; r < t.length; r++)
                n.has(t[r].name) || e.attrs.push(t[r])
        },
        getFirstChild: e=>e.childNodes[0],
        getChildNodes: e=>e.childNodes,
        getParentNode: e=>e.parentNode,
        getAttrList: e=>e.attrs,
        getTagName: e=>e.tagName,
        getNamespaceURI: e=>e.namespaceURI,
        getTextNodeContent: e=>e.value,
        getCommentNodeContent: e=>e.data,
        getDocumentTypeNodeName: e=>e.name,
        getDocumentTypeNodePublicId: e=>e.publicId,
        getDocumentTypeNodeSystemId: e=>e.systemId,
        isTextNode: e=>"#text" === e.nodeName,
        isCommentNode: e=>"#comment" === e.nodeName,
        isDocumentTypeNode: e=>"#documentType" === e.nodeName,
        isElementNode: e=>Object.prototype.hasOwnProperty.call(e, "tagName"),
        setNodeSourceCodeLocation(e, t) {
            e.sourceCodeLocation = t
        },
        getNodeSourceCodeLocation: e=>e.sourceCodeLocation,
        updateNodeSourceCodeLocation(e, t) {
            e.sourceCodeLocation = {
                ...e.sourceCodeLocation,
                ...t
            }
        }
    }
      , $g = "html"
      , Ig = "about:legacy-compat"
      , Mg = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd"
      , Lg = ["+//silmaril//dtd html pro v0r11 19970101//", "-//as//dtd html 3.0 aswedit + extensions//", "-//advasoft ltd//dtd html 3.0 aswedit + extensions//", "-//ietf//dtd html 2.0 level 1//", "-//ietf//dtd html 2.0 level 2//", "-//ietf//dtd html 2.0 strict level 1//", "-//ietf//dtd html 2.0 strict level 2//", "-//ietf//dtd html 2.0 strict//", "-//ietf//dtd html 2.0//", "-//ietf//dtd html 2.1e//", "-//ietf//dtd html 3.0//", "-//ietf//dtd html 3.2 final//", "-//ietf//dtd html 3.2//", "-//ietf//dtd html 3//", "-//ietf//dtd html level 0//", "-//ietf//dtd html level 1//", "-//ietf//dtd html level 2//", "-//ietf//dtd html level 3//", "-//ietf//dtd html strict level 0//", "-//ietf//dtd html strict level 1//", "-//ietf//dtd html strict level 2//", "-//ietf//dtd html strict level 3//", "-//ietf//dtd html strict//", "-//ietf//dtd html//", "-//metrius//dtd metrius presentational//", "-//microsoft//dtd internet explorer 2.0 html strict//", "-//microsoft//dtd internet explorer 2.0 html//", "-//microsoft//dtd internet explorer 2.0 tables//", "-//microsoft//dtd internet explorer 3.0 html strict//", "-//microsoft//dtd internet explorer 3.0 html//", "-//microsoft//dtd internet explorer 3.0 tables//", "-//netscape comm. corp.//dtd html//", "-//netscape comm. corp.//dtd strict html//", "-//o'reilly and associates//dtd html 2.0//", "-//o'reilly and associates//dtd html extended 1.0//", "-//o'reilly and associates//dtd html extended relaxed 1.0//", "-//sq//dtd html 2.0 hotmetal + extensions//", "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//", "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//", "-//spyglass//dtd html 2.0 extended//", "-//sun microsystems corp.//dtd hotjava html//", "-//sun microsystems corp.//dtd hotjava strict html//", "-//w3c//dtd html 3 1995-03-24//", "-//w3c//dtd html 3.2 draft//", "-//w3c//dtd html 3.2 final//", "-//w3c//dtd html 3.2//", "-//w3c//dtd html 3.2s draft//", "-//w3c//dtd html 4.0 frameset//", "-//w3c//dtd html 4.0 transitional//", "-//w3c//dtd html experimental 19960712//", "-//w3c//dtd html experimental 970421//", "-//w3c//dtd w3 html//", "-//w3o//dtd w3 html 3.0//", "-//webtechs//dtd mozilla html 2.0//", "-//webtechs//dtd mozilla html//"]
      , Qg = [...Lg, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"]
      , Bg = new Set(["-//w3o//dtd w3 html strict 3.0//en//", "-/w3c/dtd html 4.0 transitional/en", "html"])
      , Ug = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"]
      , Fg = [...Ug, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"];
    function jg(e, t) {
        return t.some((t=>e.startsWith(t)))
    }
    const zg = {
        TEXT_HTML: "text/html",
        APPLICATION_XML: "application/xhtml+xml"
    }
      , qg = "definitionurl"
      , Hg = "definitionURL"
      , Zg = new Map(["attributeName", "attributeType", "baseFrequency", "baseProfile", "calcMode", "clipPathUnits", "diffuseConstant", "edgeMode", "filterUnits", "glyphRef", "gradientTransform", "gradientUnits", "kernelMatrix", "kernelUnitLength", "keyPoints", "keySplines", "keyTimes", "lengthAdjust", "limitingConeAngle", "markerHeight", "markerUnits", "markerWidth", "maskContentUnits", "maskUnits", "numOctaves", "pathLength", "patternContentUnits", "patternTransform", "patternUnits", "pointsAtX", "pointsAtY", "pointsAtZ", "preserveAlpha", "preserveAspectRatio", "primitiveUnits", "refX", "refY", "repeatCount", "repeatDur", "requiredExtensions", "requiredFeatures", "specularConstant", "specularExponent", "spreadMethod", "startOffset", "stdDeviation", "stitchTiles", "surfaceScale", "systemLanguage", "tableValues", "targetX", "targetY", "textLength", "viewBox", "viewTarget", "xChannelSelector", "yChannelSelector", "zoomAndPan"].map((e=>[e.toLowerCase(), e])))
      , Wg = new Map([["xlink:actuate", {
        prefix: "xlink",
        name: "actuate",
        namespace: Bm.XLINK
    }], ["xlink:arcrole", {
        prefix: "xlink",
        name: "arcrole",
        namespace: Bm.XLINK
    }], ["xlink:href", {
        prefix: "xlink",
        name: "href",
        namespace: Bm.XLINK
    }], ["xlink:role", {
        prefix: "xlink",
        name: "role",
        namespace: Bm.XLINK
    }], ["xlink:show", {
        prefix: "xlink",
        name: "show",
        namespace: Bm.XLINK
    }], ["xlink:title", {
        prefix: "xlink",
        name: "title",
        namespace: Bm.XLINK
    }], ["xlink:type", {
        prefix: "xlink",
        name: "type",
        namespace: Bm.XLINK
    }], ["xml:base", {
        prefix: "xml",
        name: "base",
        namespace: Bm.XML
    }], ["xml:lang", {
        prefix: "xml",
        name: "lang",
        namespace: Bm.XML
    }], ["xml:space", {
        prefix: "xml",
        name: "space",
        namespace: Bm.XML
    }], ["xmlns", {
        prefix: "",
        name: "xmlns",
        namespace: Bm.XMLNS
    }], ["xmlns:xlink", {
        prefix: "xmlns",
        name: "xlink",
        namespace: Bm.XMLNS
    }]])
      , Xg = new Map(["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "textPath"].map((e=>[e.toLowerCase(), e])))
      , Vg = new Set([Wm.B, Wm.BIG, Wm.BLOCKQUOTE, Wm.BODY, Wm.BR, Wm.CENTER, Wm.CODE, Wm.DD, Wm.DIV, Wm.DL, Wm.DT, Wm.EM, Wm.EMBED, Wm.H1, Wm.H2, Wm.H3, Wm.H4, Wm.H5, Wm.H6, Wm.HEAD, Wm.HR, Wm.I, Wm.IMG, Wm.LI, Wm.LISTING, Wm.MENU, Wm.META, Wm.NOBR, Wm.OL, Wm.P, Wm.PRE, Wm.RUBY, Wm.S, Wm.SMALL, Wm.SPAN, Wm.STRONG, Wm.STRIKE, Wm.SUB, Wm.SUP, Wm.TABLE, Wm.TT, Wm.U, Wm.UL, Wm.VAR]);
    function Gg(e) {
        for (let t = 0; t < e.attrs.length; t++)
            if (e.attrs[t].name === qg) {
                e.attrs[t].name = Hg;
                break
            }
    }
    function Yg(e) {
        for (let t = 0; t < e.attrs.length; t++) {
            const n = Zg.get(e.attrs[t].name);
            null != n && (e.attrs[t].name = n)
        }
    }
    function Kg(e) {
        for (let t = 0; t < e.attrs.length; t++) {
            const n = Wg.get(e.attrs[t].name);
            n && (e.attrs[t].prefix = n.prefix,
            e.attrs[t].name = n.name,
            e.attrs[t].namespace = n.namespace)
        }
    }
    function Jg(e, t, n, r) {
        return (!r || r === Bm.HTML) && function(e, t, n) {
            if (t === Bm.MATHML && e === Wm.ANNOTATION_XML)
                for (let r = 0; r < n.length; r++)
                    if (n[r].name === Fm.ENCODING) {
                        const e = n[r].value.toLowerCase();
                        return e === zg.TEXT_HTML || e === zg.APPLICATION_XML
                    }
            return t === Bm.SVG && (e === Wm.FOREIGN_OBJECT || e === Wm.DESC || e === Wm.TITLE)
        }(e, t, n) || (!r || r === Bm.MATHML) && function(e, t) {
            return t === Bm.MATHML && (e === Wm.MI || e === Wm.MO || e === Wm.MN || e === Wm.MS || e === Wm.MTEXT)
        }(e, t)
    }
    const eb = "hidden"
      , tb = 8
      , nb = 3;
    var rb, ob;
    (ob = rb || (rb = {}))[ob.INITIAL = 0] = "INITIAL",
    ob[ob.BEFORE_HTML = 1] = "BEFORE_HTML",
    ob[ob.BEFORE_HEAD = 2] = "BEFORE_HEAD",
    ob[ob.IN_HEAD = 3] = "IN_HEAD",
    ob[ob.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT",
    ob[ob.AFTER_HEAD = 5] = "AFTER_HEAD",
    ob[ob.IN_BODY = 6] = "IN_BODY",
    ob[ob.TEXT = 7] = "TEXT",
    ob[ob.IN_TABLE = 8] = "IN_TABLE",
    ob[ob.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT",
    ob[ob.IN_CAPTION = 10] = "IN_CAPTION",
    ob[ob.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP",
    ob[ob.IN_TABLE_BODY = 12] = "IN_TABLE_BODY",
    ob[ob.IN_ROW = 13] = "IN_ROW",
    ob[ob.IN_CELL = 14] = "IN_CELL",
    ob[ob.IN_SELECT = 15] = "IN_SELECT",
    ob[ob.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE",
    ob[ob.IN_TEMPLATE = 17] = "IN_TEMPLATE",
    ob[ob.AFTER_BODY = 18] = "AFTER_BODY",
    ob[ob.IN_FRAMESET = 19] = "IN_FRAMESET",
    ob[ob.AFTER_FRAMESET = 20] = "AFTER_FRAMESET",
    ob[ob.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY",
    ob[ob.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
    const ib = {
        startLine: -1,
        startCol: -1,
        startOffset: -1,
        endLine: -1,
        endCol: -1,
        endOffset: -1
    }
      , ab = new Set([Wm.TABLE, Wm.TBODY, Wm.TFOOT, Wm.THEAD, Wm.TR])
      , sb = {
        scriptingEnabled: !0,
        sourceCodeLocationInfo: !1,
        treeAdapter: Ng,
        onParseError: null
    };
    let lb = class {
        constructor(e, t, n=null, r=null) {
            this.fragmentContext = n,
            this.scriptHandler = r,
            this.currentToken = null,
            this.stopped = !1,
            this.insertionMode = rb.INITIAL,
            this.originalInsertionMode = rb.INITIAL,
            this.headElement = null,
            this.formElement = null,
            this.currentNotInHTML = !1,
            this.tmplInsertionModeStack = [],
            this.pendingCharacterTokens = [],
            this.hasNonWhitespacePendingCharacterToken = !1,
            this.framesetOk = !0,
            this.skipNextNewLine = !1,
            this.fosterParentingEnabled = !1,
            this.options = {
                ...sb,
                ...e
            },
            this.treeAdapter = this.options.treeAdapter,
            this.onParseError = this.options.onParseError,
            this.onParseError && (this.options.sourceCodeLocationInfo = !0),
            this.document = null != t ? t : this.treeAdapter.createDocument(),
            this.tokenizer = new Og(this.options,this),
            this.activeFormattingElements = new Dg(this.treeAdapter),
            this.fragmentContextID = n ? tg(this.treeAdapter.getTagName(n)) : Wm.UNKNOWN,
            this._setContextModes(null != n ? n : this.document, this.fragmentContextID),
            this.openElements = new Tg(this.document,this.treeAdapter,this)
        }
        static parse(e, t) {
            const n = new this(t);
            return n.tokenizer.write(e, !0),
            n.document
        }
        static getFragmentParser(e, t) {
            const n = {
                ...sb,
                ...t
            };
            null != e || (e = n.treeAdapter.createElement(Hm.TEMPLATE, Bm.HTML, []));
            const r = n.treeAdapter.createElement("documentmock", Bm.HTML, [])
              , o = new this(n,r,e);
            return o.fragmentContextID === Wm.TEMPLATE && o.tmplInsertionModeStack.unshift(rb.IN_TEMPLATE),
            o._initTokenizerForFragmentParsing(),
            o._insertFakeRootElement(),
            o._resetInsertionMode(),
            o._findFormInFragmentContext(),
            o
        }
        getFragment() {
            const e = this.treeAdapter.getFirstChild(this.document)
              , t = this.treeAdapter.createDocumentFragment();
            return this._adoptNodes(e, t),
            t
        }
        _err(e, t, n) {
            var r;
            if (!this.onParseError)
                return;
            const o = null !== (r = e.location) && void 0 !== r ? r : ib
              , i = {
                code: t,
                startLine: o.startLine,
                startCol: o.startCol,
                startOffset: o.startOffset,
                endLine: n ? o.startLine : o.endLine,
                endCol: n ? o.startCol : o.endCol,
                endOffset: n ? o.startOffset : o.endOffset
            };
            this.onParseError(i)
        }
        onItemPush(e, t, n) {
            var r, o;
            null === (o = (r = this.treeAdapter).onItemPush) || void 0 === o || o.call(r, e),
            n && this.openElements.stackTop > 0 && this._setContextModes(e, t)
        }
        onItemPop(e, t) {
            var n, r;
            if (this.options.sourceCodeLocationInfo && this._setEndLocation(e, this.currentToken),
            null === (r = (n = this.treeAdapter).onItemPop) || void 0 === r || r.call(n, e, this.openElements.current),
            t) {
                let e, t;
                0 === this.openElements.stackTop && this.fragmentContext ? (e = this.fragmentContext,
                t = this.fragmentContextID) : ({current: e, currentTagId: t} = this.openElements),
                this._setContextModes(e, t)
            }
        }
        _setContextModes(e, t) {
            const n = e === this.document || this.treeAdapter.getNamespaceURI(e) === Bm.HTML;
            this.currentNotInHTML = !n,
            this.tokenizer.inForeignNode = !n && !this._isIntegrationPoint(t, e)
        }
        _switchToTextParsing(e, t) {
            this._insertElement(e, Bm.HTML),
            this.tokenizer.state = t,
            this.originalInsertionMode = this.insertionMode,
            this.insertionMode = rb.TEXT
        }
        switchToPlaintextParsing() {
            this.insertionMode = rb.TEXT,
            this.originalInsertionMode = rb.IN_BODY,
            this.tokenizer.state = lg.PLAINTEXT
        }
        _getAdjustedCurrentElement() {
            return 0 === this.openElements.stackTop && this.fragmentContext ? this.fragmentContext : this.openElements.current
        }
        _findFormInFragmentContext() {
            let e = this.fragmentContext;
            for (; e; ) {
                if (this.treeAdapter.getTagName(e) === Hm.FORM) {
                    this.formElement = e;
                    break
                }
                e = this.treeAdapter.getParentNode(e)
            }
        }
        _initTokenizerForFragmentParsing() {
            if (this.fragmentContext && this.treeAdapter.getNamespaceURI(this.fragmentContext) === Bm.HTML)
                switch (this.fragmentContextID) {
                case Wm.TITLE:
                case Wm.TEXTAREA:
                    this.tokenizer.state = lg.RCDATA;
                    break;
                case Wm.STYLE:
                case Wm.XMP:
                case Wm.IFRAME:
                case Wm.NOEMBED:
                case Wm.NOFRAMES:
                case Wm.NOSCRIPT:
                    this.tokenizer.state = lg.RAWTEXT;
                    break;
                case Wm.SCRIPT:
                    this.tokenizer.state = lg.SCRIPT_DATA;
                    break;
                case Wm.PLAINTEXT:
                    this.tokenizer.state = lg.PLAINTEXT
                }
        }
        _setDocumentType(e) {
            const t = e.name || ""
              , n = e.publicId || ""
              , r = e.systemId || "";
            if (this.treeAdapter.setDocumentType(this.document, t, n, r),
            e.location) {
                const t = this.treeAdapter.getChildNodes(this.document).find((e=>this.treeAdapter.isDocumentTypeNode(e)));
                t && this.treeAdapter.setNodeSourceCodeLocation(t, e.location)
            }
        }
        _attachElementToTree(e, t) {
            if (this.options.sourceCodeLocationInfo) {
                const n = t && {
                    ...t,
                    startTag: t
                };
                this.treeAdapter.setNodeSourceCodeLocation(e, n)
            }
            if (this._shouldFosterParentOnInsertion())
                this._fosterParentElement(e);
            else {
                const t = this.openElements.currentTmplContentOrNode;
                this.treeAdapter.appendChild(t, e)
            }
        }
        _appendElement(e, t) {
            const n = this.treeAdapter.createElement(e.tagName, t, e.attrs);
            this._attachElementToTree(n, e.location)
        }
        _insertElement(e, t) {
            const n = this.treeAdapter.createElement(e.tagName, t, e.attrs);
            this._attachElementToTree(n, e.location),
            this.openElements.push(n, e.tagID)
        }
        _insertFakeElement(e, t) {
            const n = this.treeAdapter.createElement(e, Bm.HTML, []);
            this._attachElementToTree(n, null),
            this.openElements.push(n, t)
        }
        _insertTemplate(e) {
            const t = this.treeAdapter.createElement(e.tagName, Bm.HTML, e.attrs)
              , n = this.treeAdapter.createDocumentFragment();
            this.treeAdapter.setTemplateContent(t, n),
            this._attachElementToTree(t, e.location),
            this.openElements.push(t, e.tagID),
            this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(n, null)
        }
        _insertFakeRootElement() {
            const e = this.treeAdapter.createElement(Hm.HTML, Bm.HTML, []);
            this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(e, null),
            this.treeAdapter.appendChild(this.openElements.current, e),
            this.openElements.push(e, Wm.HTML)
        }
        _appendCommentNode(e, t) {
            const n = this.treeAdapter.createCommentNode(e.data);
            this.treeAdapter.appendChild(t, n),
            this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(n, e.location)
        }
        _insertCharacters(e) {
            let t, n;
            if (this._shouldFosterParentOnInsertion() ? (({parent: t, beforeElement: n} = this._findFosterParentingLocation()),
            n ? this.treeAdapter.insertTextBefore(t, e.chars, n) : this.treeAdapter.insertText(t, e.chars)) : (t = this.openElements.currentTmplContentOrNode,
            this.treeAdapter.insertText(t, e.chars)),
            !e.location)
                return;
            const r = this.treeAdapter.getChildNodes(t)
              , o = n ? r.lastIndexOf(n) : r.length
              , i = r[o - 1];
            if (this.treeAdapter.getNodeSourceCodeLocation(i)) {
                const {endLine: t, endCol: n, endOffset: r} = e.location;
                this.treeAdapter.updateNodeSourceCodeLocation(i, {
                    endLine: t,
                    endCol: n,
                    endOffset: r
                })
            } else
                this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(i, e.location)
        }
        _adoptNodes(e, t) {
            for (let n = this.treeAdapter.getFirstChild(e); n; n = this.treeAdapter.getFirstChild(e))
                this.treeAdapter.detachNode(n),
                this.treeAdapter.appendChild(t, n)
        }
        _setEndLocation(e, t) {
            if (this.treeAdapter.getNodeSourceCodeLocation(e) && t.location) {
                const n = t.location
                  , r = this.treeAdapter.getTagName(e)
                  , o = t.type === km.END_TAG && r === t.tagName ? {
                    endTag: {
                        ...n
                    },
                    endLine: n.endLine,
                    endCol: n.endCol,
                    endOffset: n.endOffset
                } : {
                    endLine: n.startLine,
                    endCol: n.startCol,
                    endOffset: n.startOffset
                };
                this.treeAdapter.updateNodeSourceCodeLocation(e, o)
            }
        }
        shouldProcessStartTagTokenInForeignContent(e) {
            if (!this.currentNotInHTML)
                return !1;
            let t, n;
            return 0 === this.openElements.stackTop && this.fragmentContext ? (t = this.fragmentContext,
            n = this.fragmentContextID) : ({current: t, currentTagId: n} = this.openElements),
            (e.tagID !== Wm.SVG || this.treeAdapter.getTagName(t) !== Hm.ANNOTATION_XML || this.treeAdapter.getNamespaceURI(t) !== Bm.MATHML) && (this.tokenizer.inForeignNode || (e.tagID === Wm.MGLYPH || e.tagID === Wm.MALIGNMARK) && !this._isIntegrationPoint(n, t, Bm.HTML))
        }
        _processToken(e) {
            switch (e.type) {
            case km.CHARACTER:
                this.onCharacter(e);
                break;
            case km.NULL_CHARACTER:
                this.onNullCharacter(e);
                break;
            case km.COMMENT:
                this.onComment(e);
                break;
            case km.DOCTYPE:
                this.onDoctype(e);
                break;
            case km.START_TAG:
                this._processStartTag(e);
                break;
            case km.END_TAG:
                this.onEndTag(e);
                break;
            case km.EOF:
                this.onEof(e);
                break;
            case km.WHITESPACE_CHARACTER:
                this.onWhitespaceCharacter(e)
            }
        }
        _isIntegrationPoint(e, t, n) {
            return Jg(e, this.treeAdapter.getNamespaceURI(t), this.treeAdapter.getAttrList(t), n)
        }
        _reconstructActiveFormattingElements() {
            const e = this.activeFormattingElements.entries.length;
            if (e) {
                const t = this.activeFormattingElements.entries.findIndex((e=>e.type === Ag.Marker || this.openElements.contains(e.element)));
                for (let n = t < 0 ? e - 1 : t - 1; n >= 0; n--) {
                    const e = this.activeFormattingElements.entries[n];
                    this._insertElement(e.token, this.treeAdapter.getNamespaceURI(e.element)),
                    e.element = this.openElements.current
                }
            }
        }
        _closeTableCell() {
            this.openElements.generateImpliedEndTags(),
            this.openElements.popUntilTableCellPopped(),
            this.activeFormattingElements.clearToLastMarker(),
            this.insertionMode = rb.IN_ROW
        }
        _closePElement() {
            this.openElements.generateImpliedEndTagsWithExclusion(Wm.P),
            this.openElements.popUntilTagNamePopped(Wm.P)
        }
        _resetInsertionMode() {
            for (let e = this.openElements.stackTop; e >= 0; e--)
                switch (0 === e && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[e]) {
                case Wm.TR:
                    return void (this.insertionMode = rb.IN_ROW);
                case Wm.TBODY:
                case Wm.THEAD:
                case Wm.TFOOT:
                    return void (this.insertionMode = rb.IN_TABLE_BODY);
                case Wm.CAPTION:
                    return void (this.insertionMode = rb.IN_CAPTION);
                case Wm.COLGROUP:
                    return void (this.insertionMode = rb.IN_COLUMN_GROUP);
                case Wm.TABLE:
                    return void (this.insertionMode = rb.IN_TABLE);
                case Wm.BODY:
                    return void (this.insertionMode = rb.IN_BODY);
                case Wm.FRAMESET:
                    return void (this.insertionMode = rb.IN_FRAMESET);
                case Wm.SELECT:
                    return void this._resetInsertionModeForSelect(e);
                case Wm.TEMPLATE:
                    return void (this.insertionMode = this.tmplInsertionModeStack[0]);
                case Wm.HTML:
                    return void (this.insertionMode = this.headElement ? rb.AFTER_HEAD : rb.BEFORE_HEAD);
                case Wm.TD:
                case Wm.TH:
                    if (e > 0)
                        return void (this.insertionMode = rb.IN_CELL);
                    break;
                case Wm.HEAD:
                    if (e > 0)
                        return void (this.insertionMode = rb.IN_HEAD)
                }
            this.insertionMode = rb.IN_BODY
        }
        _resetInsertionModeForSelect(e) {
            if (e > 0)
                for (let t = e - 1; t > 0; t--) {
                    const e = this.openElements.tagIDs[t];
                    if (e === Wm.TEMPLATE)
                        break;
                    if (e === Wm.TABLE)
                        return void (this.insertionMode = rb.IN_SELECT_IN_TABLE)
                }
            this.insertionMode = rb.IN_SELECT
        }
        _isElementCausesFosterParenting(e) {
            return ab.has(e)
        }
        _shouldFosterParentOnInsertion() {
            return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId)
        }
        _findFosterParentingLocation() {
            for (let e = this.openElements.stackTop; e >= 0; e--) {
                const t = this.openElements.items[e];
                switch (this.openElements.tagIDs[e]) {
                case Wm.TEMPLATE:
                    if (this.treeAdapter.getNamespaceURI(t) === Bm.HTML)
                        return {
                            parent: this.treeAdapter.getTemplateContent(t),
                            beforeElement: null
                        };
                    break;
                case Wm.TABLE:
                    {
                        const n = this.treeAdapter.getParentNode(t);
                        return n ? {
                            parent: n,
                            beforeElement: t
                        } : {
                            parent: this.openElements.items[e - 1],
                            beforeElement: null
                        }
                    }
                }
            }
            return {
                parent: this.openElements.items[0],
                beforeElement: null
            }
        }
        _fosterParentElement(e) {
            const t = this._findFosterParentingLocation();
            t.beforeElement ? this.treeAdapter.insertBefore(t.parent, e, t.beforeElement) : this.treeAdapter.appendChild(t.parent, e)
        }
        _isSpecialElement(e, t) {
            const n = this.treeAdapter.getNamespaceURI(e);
            return rg[n].has(t)
        }
        onCharacter(e) {
            if (this.skipNextNewLine = !1,
            this.tokenizer.inForeignNode)
                !function(e, t) {
                    e._insertCharacters(t),
                    e.framesetOk = !1
                }(this, e);
            else
                switch (this.insertionMode) {
                case rb.INITIAL:
                    Ob(this, e);
                    break;
                case rb.BEFORE_HTML:
                    vb(this, e);
                    break;
                case rb.BEFORE_HEAD:
                    yb(this, e);
                    break;
                case rb.IN_HEAD:
                    kb(this, e);
                    break;
                case rb.IN_HEAD_NO_SCRIPT:
                    Sb(this, e);
                    break;
                case rb.AFTER_HEAD:
                    Eb(this, e);
                    break;
                case rb.IN_BODY:
                case rb.IN_CAPTION:
                case rb.IN_CELL:
                case rb.IN_TEMPLATE:
                    Ab(this, e);
                    break;
                case rb.TEXT:
                case rb.IN_SELECT:
                case rb.IN_SELECT_IN_TABLE:
                    this._insertCharacters(e);
                    break;
                case rb.IN_TABLE:
                case rb.IN_TABLE_BODY:
                case rb.IN_ROW:
                    Lb(this, e);
                    break;
                case rb.IN_TABLE_TEXT:
                    jb(this, e);
                    break;
                case rb.IN_COLUMN_GROUP:
                    Zb(this, e);
                    break;
                case rb.AFTER_BODY:
                    tO(this, e);
                    break;
                case rb.AFTER_AFTER_BODY:
                    nO(this, e)
                }
        }
        onNullCharacter(e) {
            if (this.skipNextNewLine = !1,
            this.tokenizer.inForeignNode)
                !function(e, t) {
                    t.chars = lm,
                    e._insertCharacters(t)
                }(this, e);
            else
                switch (this.insertionMode) {
                case rb.INITIAL:
                    Ob(this, e);
                    break;
                case rb.BEFORE_HTML:
                    vb(this, e);
                    break;
                case rb.BEFORE_HEAD:
                    yb(this, e);
                    break;
                case rb.IN_HEAD:
                    kb(this, e);
                    break;
                case rb.IN_HEAD_NO_SCRIPT:
                    Sb(this, e);
                    break;
                case rb.AFTER_HEAD:
                    Eb(this, e);
                    break;
                case rb.TEXT:
                    this._insertCharacters(e);
                    break;
                case rb.IN_TABLE:
                case rb.IN_TABLE_BODY:
                case rb.IN_ROW:
                    Lb(this, e);
                    break;
                case rb.IN_COLUMN_GROUP:
                    Zb(this, e);
                    break;
                case rb.AFTER_BODY:
                    tO(this, e);
                    break;
                case rb.AFTER_AFTER_BODY:
                    nO(this, e)
                }
        }
        onComment(e) {
            if (this.skipNextNewLine = !1,
            this.currentNotInHTML)
                gb(this, e);
            else
                switch (this.insertionMode) {
                case rb.INITIAL:
                case rb.BEFORE_HTML:
                case rb.BEFORE_HEAD:
                case rb.IN_HEAD:
                case rb.IN_HEAD_NO_SCRIPT:
                case rb.AFTER_HEAD:
                case rb.IN_BODY:
                case rb.IN_TABLE:
                case rb.IN_CAPTION:
                case rb.IN_COLUMN_GROUP:
                case rb.IN_TABLE_BODY:
                case rb.IN_ROW:
                case rb.IN_CELL:
                case rb.IN_SELECT:
                case rb.IN_SELECT_IN_TABLE:
                case rb.IN_TEMPLATE:
                case rb.IN_FRAMESET:
                case rb.AFTER_FRAMESET:
                    gb(this, e);
                    break;
                case rb.IN_TABLE_TEXT:
                    zb(this, e);
                    break;
                case rb.AFTER_BODY:
                    !function(e, t) {
                        e._appendCommentNode(t, e.openElements.items[0])
                    }(this, e);
                    break;
                case rb.AFTER_AFTER_BODY:
                case rb.AFTER_AFTER_FRAMESET:
                    !function(e, t) {
                        e._appendCommentNode(t, e.document)
                    }(this, e)
                }
        }
        onDoctype(e) {
            switch (this.skipNextNewLine = !1,
            this.insertionMode) {
            case rb.INITIAL:
                !function(e, t) {
                    e._setDocumentType(t);
                    const n = t.forceQuirks ? zm.QUIRKS : function(e) {
                        if (e.name !== $g)
                            return zm.QUIRKS;
                        const {systemId: t} = e;
                        if (t && t.toLowerCase() === Mg)
                            return zm.QUIRKS;
                        let {publicId: n} = e;
                        if (null !== n) {
                            if (n = n.toLowerCase(),
                            Bg.has(n))
                                return zm.QUIRKS;
                            let e = null === t ? Qg : Lg;
                            if (jg(n, e))
                                return zm.QUIRKS;
                            if (e = null === t ? Ug : Fg,
                            jg(n, e))
                                return zm.LIMITED_QUIRKS
                        }
                        return zm.NO_QUIRKS
                    }(t);
                    (function(e) {
                        return e.name === $g && null === e.publicId && (null === e.systemId || e.systemId === Ig)
                    }
                    )(t) || e._err(t, ym.nonConformingDoctype);
                    e.treeAdapter.setDocumentMode(e.document, n),
                    e.insertionMode = rb.BEFORE_HTML
                }(this, e);
                break;
            case rb.BEFORE_HEAD:
            case rb.IN_HEAD:
            case rb.IN_HEAD_NO_SCRIPT:
            case rb.AFTER_HEAD:
                this._err(e, ym.misplacedDoctype);
                break;
            case rb.IN_TABLE_TEXT:
                zb(this, e)
            }
        }
        onStartTag(e) {
            this.skipNextNewLine = !1,
            this.currentToken = e,
            this._processStartTag(e),
            e.selfClosing && !e.ackSelfClosing && this._err(e, ym.nonVoidHtmlElementStartTagWithTrailingSolidus)
        }
        _processStartTag(e) {
            this.shouldProcessStartTagTokenInForeignContent(e) ? function(e, t) {
                if (function(e) {
                    const t = e.tagID;
                    return t === Wm.FONT && e.attrs.some((({name: e})=>e === Fm.COLOR || e === Fm.SIZE || e === Fm.FACE)) || Vg.has(t)
                }(t))
                    rO(e),
                    e._startTagOutsideForeignContent(t);
                else {
                    const n = e._getAdjustedCurrentElement()
                      , r = e.treeAdapter.getNamespaceURI(n);
                    r === Bm.MATHML ? Gg(t) : r === Bm.SVG && (!function(e) {
                        const t = Xg.get(e.tagName);
                        null != t && (e.tagName = t,
                        e.tagID = tg(e.tagName))
                    }(t),
                    Yg(t)),
                    Kg(t),
                    t.selfClosing ? e._appendElement(t, r) : e._insertElement(t, r),
                    t.ackSelfClosing = !0
                }
            }(this, e) : this._startTagOutsideForeignContent(e)
        }
        _startTagOutsideForeignContent(e) {
            switch (this.insertionMode) {
            case rb.INITIAL:
                Ob(this, e);
                break;
            case rb.BEFORE_HTML:
                !function(e, t) {
                    t.tagID === Wm.HTML ? (e._insertElement(t, Bm.HTML),
                    e.insertionMode = rb.BEFORE_HEAD) : vb(e, t)
                }(this, e);
                break;
            case rb.BEFORE_HEAD:
                !function(e, t) {
                    switch (t.tagID) {
                    case Wm.HTML:
                        Nb(e, t);
                        break;
                    case Wm.HEAD:
                        e._insertElement(t, Bm.HTML),
                        e.headElement = e.openElements.current,
                        e.insertionMode = rb.IN_HEAD;
                        break;
                    default:
                        yb(e, t)
                    }
                }(this, e);
                break;
            case rb.IN_HEAD:
                wb(this, e);
                break;
            case rb.IN_HEAD_NO_SCRIPT:
                !function(e, t) {
                    switch (t.tagID) {
                    case Wm.HTML:
                        Nb(e, t);
                        break;
                    case Wm.BASEFONT:
                    case Wm.BGSOUND:
                    case Wm.HEAD:
                    case Wm.LINK:
                    case Wm.META:
                    case Wm.NOFRAMES:
                    case Wm.STYLE:
                        wb(e, t);
                        break;
                    case Wm.NOSCRIPT:
                        e._err(t, ym.nestedNoscriptInHead);
                        break;
                    default:
                        Sb(e, t)
                    }
                }(this, e);
                break;
            case rb.AFTER_HEAD:
                !function(e, t) {
                    switch (t.tagID) {
                    case Wm.HTML:
                        Nb(e, t);
                        break;
                    case Wm.BODY:
                        e._insertElement(t, Bm.HTML),
                        e.framesetOk = !1,
                        e.insertionMode = rb.IN_BODY;
                        break;
                    case Wm.FRAMESET:
                        e._insertElement(t, Bm.HTML),
                        e.insertionMode = rb.IN_FRAMESET;
                        break;
                    case Wm.BASE:
                    case Wm.BASEFONT:
                    case Wm.BGSOUND:
                    case Wm.LINK:
                    case Wm.META:
                    case Wm.NOFRAMES:
                    case Wm.SCRIPT:
                    case Wm.STYLE:
                    case Wm.TEMPLATE:
                    case Wm.TITLE:
                        e._err(t, ym.abandonedHeadElementChild),
                        e.openElements.push(e.headElement, Wm.HEAD),
                        wb(e, t),
                        e.openElements.remove(e.headElement);
                        break;
                    case Wm.HEAD:
                        e._err(t, ym.misplacedStartTagForHeadElement);
                        break;
                    default:
                        Eb(e, t)
                    }
                }(this, e);
                break;
            case rb.IN_BODY:
                Nb(this, e);
                break;
            case rb.IN_TABLE:
                Qb(this, e);
                break;
            case rb.IN_TABLE_TEXT:
                zb(this, e);
                break;
            case rb.IN_CAPTION:
                !function(e, t) {
                    const n = t.tagID;
                    qb.has(n) ? e.openElements.hasInTableScope(Wm.CAPTION) && (e.openElements.generateImpliedEndTags(),
                    e.openElements.popUntilTagNamePopped(Wm.CAPTION),
                    e.activeFormattingElements.clearToLastMarker(),
                    e.insertionMode = rb.IN_TABLE,
                    Qb(e, t)) : Nb(e, t)
                }(this, e);
                break;
            case rb.IN_COLUMN_GROUP:
                Hb(this, e);
                break;
            case rb.IN_TABLE_BODY:
                Wb(this, e);
                break;
            case rb.IN_ROW:
                Vb(this, e);
                break;
            case rb.IN_CELL:
                !function(e, t) {
                    const n = t.tagID;
                    qb.has(n) ? (e.openElements.hasInTableScope(Wm.TD) || e.openElements.hasInTableScope(Wm.TH)) && (e._closeTableCell(),
                    Vb(e, t)) : Nb(e, t)
                }(this, e);
                break;
            case rb.IN_SELECT:
                Yb(this, e);
                break;
            case rb.IN_SELECT_IN_TABLE:
                !function(e, t) {
                    const n = t.tagID;
                    n === Wm.CAPTION || n === Wm.TABLE || n === Wm.TBODY || n === Wm.TFOOT || n === Wm.THEAD || n === Wm.TR || n === Wm.TD || n === Wm.TH ? (e.openElements.popUntilTagNamePopped(Wm.SELECT),
                    e._resetInsertionMode(),
                    e._processStartTag(t)) : Yb(e, t)
                }(this, e);
                break;
            case rb.IN_TEMPLATE:
                !function(e, t) {
                    switch (t.tagID) {
                    case Wm.BASE:
                    case Wm.BASEFONT:
                    case Wm.BGSOUND:
                    case Wm.LINK:
                    case Wm.META:
                    case Wm.NOFRAMES:
                    case Wm.SCRIPT:
                    case Wm.STYLE:
                    case Wm.TEMPLATE:
                    case Wm.TITLE:
                        wb(e, t);
                        break;
                    case Wm.CAPTION:
                    case Wm.COLGROUP:
                    case Wm.TBODY:
                    case Wm.TFOOT:
                    case Wm.THEAD:
                        e.tmplInsertionModeStack[0] = rb.IN_TABLE,
                        e.insertionMode = rb.IN_TABLE,
                        Qb(e, t);
                        break;
                    case Wm.COL:
                        e.tmplInsertionModeStack[0] = rb.IN_COLUMN_GROUP,
                        e.insertionMode = rb.IN_COLUMN_GROUP,
                        Hb(e, t);
                        break;
                    case Wm.TR:
                        e.tmplInsertionModeStack[0] = rb.IN_TABLE_BODY,
                        e.insertionMode = rb.IN_TABLE_BODY,
                        Wb(e, t);
                        break;
                    case Wm.TD:
                    case Wm.TH:
                        e.tmplInsertionModeStack[0] = rb.IN_ROW,
                        e.insertionMode = rb.IN_ROW,
                        Vb(e, t);
                        break;
                    default:
                        e.tmplInsertionModeStack[0] = rb.IN_BODY,
                        e.insertionMode = rb.IN_BODY,
                        Nb(e, t)
                    }
                }(this, e);
                break;
            case rb.AFTER_BODY:
                !function(e, t) {
                    t.tagID === Wm.HTML ? Nb(e, t) : tO(e, t)
                }(this, e);
                break;
            case rb.IN_FRAMESET:
                !function(e, t) {
                    switch (t.tagID) {
                    case Wm.HTML:
                        Nb(e, t);
                        break;
                    case Wm.FRAMESET:
                        e._insertElement(t, Bm.HTML);
                        break;
                    case Wm.FRAME:
                        e._appendElement(t, Bm.HTML),
                        t.ackSelfClosing = !0;
                        break;
                    case Wm.NOFRAMES:
                        wb(e, t)
                    }
                }(this, e);
                break;
            case rb.AFTER_FRAMESET:
                !function(e, t) {
                    switch (t.tagID) {
                    case Wm.HTML:
                        Nb(e, t);
                        break;
                    case Wm.NOFRAMES:
                        wb(e, t)
                    }
                }(this, e);
                break;
            case rb.AFTER_AFTER_BODY:
                !function(e, t) {
                    t.tagID === Wm.HTML ? Nb(e, t) : nO(e, t)
                }(this, e);
                break;
            case rb.AFTER_AFTER_FRAMESET:
                !function(e, t) {
                    switch (t.tagID) {
                    case Wm.HTML:
                        Nb(e, t);
                        break;
                    case Wm.NOFRAMES:
                        wb(e, t)
                    }
                }(this, e)
            }
        }
        onEndTag(e) {
            this.skipNextNewLine = !1,
            this.currentToken = e,
            this.currentNotInHTML ? function(e, t) {
                if (t.tagID === Wm.P || t.tagID === Wm.BR)
                    return rO(e),
                    void e._endTagOutsideForeignContent(t);
                for (let n = e.openElements.stackTop; n > 0; n--) {
                    const r = e.openElements.items[n];
                    if (e.treeAdapter.getNamespaceURI(r) === Bm.HTML) {
                        e._endTagOutsideForeignContent(t);
                        break
                    }
                    const o = e.treeAdapter.getTagName(r);
                    if (o.toLowerCase() === t.tagName) {
                        t.tagName = o,
                        e.openElements.shortenToLength(n);
                        break
                    }
                }
            }(this, e) : this._endTagOutsideForeignContent(e)
        }
        _endTagOutsideForeignContent(e) {
            switch (this.insertionMode) {
            case rb.INITIAL:
                Ob(this, e);
                break;
            case rb.BEFORE_HTML:
                !function(e, t) {
                    const n = t.tagID;
                    n !== Wm.HTML && n !== Wm.HEAD && n !== Wm.BODY && n !== Wm.BR || vb(e, t)
                }(this, e);
                break;
            case rb.BEFORE_HEAD:
                !function(e, t) {
                    const n = t.tagID;
                    n === Wm.HEAD || n === Wm.BODY || n === Wm.HTML || n === Wm.BR ? yb(e, t) : e._err(t, ym.endTagWithoutMatchingOpenElement)
                }(this, e);
                break;
            case rb.IN_HEAD:
                !function(e, t) {
                    switch (t.tagID) {
                    case Wm.HEAD:
                        e.openElements.pop(),
                        e.insertionMode = rb.AFTER_HEAD;
                        break;
                    case Wm.BODY:
                    case Wm.BR:
                    case Wm.HTML:
                        kb(e, t);
                        break;
                    case Wm.TEMPLATE:
                        _b(e, t);
                        break;
                    default:
                        e._err(t, ym.endTagWithoutMatchingOpenElement)
                    }
                }(this, e);
                break;
            case rb.IN_HEAD_NO_SCRIPT:
                !function(e, t) {
                    switch (t.tagID) {
                    case Wm.NOSCRIPT:
                        e.openElements.pop(),
                        e.insertionMode = rb.IN_HEAD;
                        break;
                    case Wm.BR:
                        Sb(e, t);
                        break;
                    default:
                        e._err(t, ym.endTagWithoutMatchingOpenElement)
                    }
                }(this, e);
                break;
            case rb.AFTER_HEAD:
                !function(e, t) {
                    switch (t.tagID) {
                    case Wm.BODY:
                    case Wm.HTML:
                    case Wm.BR:
                        Eb(e, t);
                        break;
                    case Wm.TEMPLATE:
                        _b(e, t);
                        break;
                    default:
                        e._err(t, ym.endTagWithoutMatchingOpenElement)
                    }
                }(this, e);
                break;
            case rb.IN_BODY:
                Ib(this, e);
                break;
            case rb.TEXT:
                !function(e, t) {
                    var n;
                    t.tagID === Wm.SCRIPT && (null === (n = e.scriptHandler) || void 0 === n || n.call(e, e.openElements.current));
                    e.openElements.pop(),
                    e.insertionMode = e.originalInsertionMode
                }(this, e);
                break;
            case rb.IN_TABLE:
                Bb(this, e);
                break;
            case rb.IN_TABLE_TEXT:
                zb(this, e);
                break;
            case rb.IN_CAPTION:
                !function(e, t) {
                    const n = t.tagID;
                    switch (n) {
                    case Wm.CAPTION:
                    case Wm.TABLE:
                        e.openElements.hasInTableScope(Wm.CAPTION) && (e.openElements.generateImpliedEndTags(),
                        e.openElements.popUntilTagNamePopped(Wm.CAPTION),
                        e.activeFormattingElements.clearToLastMarker(),
                        e.insertionMode = rb.IN_TABLE,
                        n === Wm.TABLE && Bb(e, t));
                        break;
                    case Wm.BODY:
                    case Wm.COL:
                    case Wm.COLGROUP:
                    case Wm.HTML:
                    case Wm.TBODY:
                    case Wm.TD:
                    case Wm.TFOOT:
                    case Wm.TH:
                    case Wm.THEAD:
                    case Wm.TR:
                        break;
                    default:
                        Ib(e, t)
                    }
                }(this, e);
                break;
            case rb.IN_COLUMN_GROUP:
                !function(e, t) {
                    switch (t.tagID) {
                    case Wm.COLGROUP:
                        e.openElements.currentTagId === Wm.COLGROUP && (e.openElements.pop(),
                        e.insertionMode = rb.IN_TABLE);
                        break;
                    case Wm.TEMPLATE:
                        _b(e, t);
                        break;
                    case Wm.COL:
                        break;
                    default:
                        Zb(e, t)
                    }
                }(this, e);
                break;
            case rb.IN_TABLE_BODY:
                Xb(this, e);
                break;
            case rb.IN_ROW:
                Gb(this, e);
                break;
            case rb.IN_CELL:
                !function(e, t) {
                    const n = t.tagID;
                    switch (n) {
                    case Wm.TD:
                    case Wm.TH:
                        e.openElements.hasInTableScope(n) && (e.openElements.generateImpliedEndTags(),
                        e.openElements.popUntilTagNamePopped(n),
                        e.activeFormattingElements.clearToLastMarker(),
                        e.insertionMode = rb.IN_ROW);
                        break;
                    case Wm.TABLE:
                    case Wm.TBODY:
                    case Wm.TFOOT:
                    case Wm.THEAD:
                    case Wm.TR:
                        e.openElements.hasInTableScope(n) && (e._closeTableCell(),
                        Gb(e, t));
                        break;
                    case Wm.BODY:
                    case Wm.CAPTION:
                    case Wm.COL:
                    case Wm.COLGROUP:
                    case Wm.HTML:
                        break;
                    default:
                        Ib(e, t)
                    }
                }(this, e);
                break;
            case rb.IN_SELECT:
                Kb(this, e);
                break;
            case rb.IN_SELECT_IN_TABLE:
                !function(e, t) {
                    const n = t.tagID;
                    n === Wm.CAPTION || n === Wm.TABLE || n === Wm.TBODY || n === Wm.TFOOT || n === Wm.THEAD || n === Wm.TR || n === Wm.TD || n === Wm.TH ? e.openElements.hasInTableScope(n) && (e.openElements.popUntilTagNamePopped(Wm.SELECT),
                    e._resetInsertionMode(),
                    e.onEndTag(t)) : Kb(e, t)
                }(this, e);
                break;
            case rb.IN_TEMPLATE:
                !function(e, t) {
                    t.tagID === Wm.TEMPLATE && _b(e, t)
                }(this, e);
                break;
            case rb.AFTER_BODY:
                eO(this, e);
                break;
            case rb.IN_FRAMESET:
                !function(e, t) {
                    t.tagID !== Wm.FRAMESET || e.openElements.isRootHtmlElementCurrent() || (e.openElements.pop(),
                    e.fragmentContext || e.openElements.currentTagId === Wm.FRAMESET || (e.insertionMode = rb.AFTER_FRAMESET))
                }(this, e);
                break;
            case rb.AFTER_FRAMESET:
                !function(e, t) {
                    t.tagID === Wm.HTML && (e.insertionMode = rb.AFTER_AFTER_FRAMESET)
                }(this, e);
                break;
            case rb.AFTER_AFTER_BODY:
                nO(this, e)
            }
        }
        onEof(e) {
            switch (this.insertionMode) {
            case rb.INITIAL:
                Ob(this, e);
                break;
            case rb.BEFORE_HTML:
                vb(this, e);
                break;
            case rb.BEFORE_HEAD:
                yb(this, e);
                break;
            case rb.IN_HEAD:
                kb(this, e);
                break;
            case rb.IN_HEAD_NO_SCRIPT:
                Sb(this, e);
                break;
            case rb.AFTER_HEAD:
                Eb(this, e);
                break;
            case rb.IN_BODY:
            case rb.IN_TABLE:
            case rb.IN_CAPTION:
            case rb.IN_COLUMN_GROUP:
            case rb.IN_TABLE_BODY:
            case rb.IN_ROW:
            case rb.IN_CELL:
            case rb.IN_SELECT:
            case rb.IN_SELECT_IN_TABLE:
                Mb(this, e);
                break;
            case rb.TEXT:
                !function(e, t) {
                    e._err(t, ym.eofInElementThatCanContainOnlyText),
                    e.openElements.pop(),
                    e.insertionMode = e.originalInsertionMode,
                    e.onEof(t)
                }(this, e);
                break;
            case rb.IN_TABLE_TEXT:
                zb(this, e);
                break;
            case rb.IN_TEMPLATE:
                Jb(this, e);
                break;
            case rb.AFTER_BODY:
            case rb.IN_FRAMESET:
            case rb.AFTER_FRAMESET:
            case rb.AFTER_AFTER_BODY:
            case rb.AFTER_AFTER_FRAMESET:
                bb(this, e)
            }
        }
        onWhitespaceCharacter(e) {
            if (this.skipNextNewLine && (this.skipNextNewLine = !1,
            e.chars.charCodeAt(0) === cm.LINE_FEED)) {
                if (1 === e.chars.length)
                    return;
                e.chars = e.chars.substr(1)
            }
            if (this.tokenizer.inForeignNode)
                this._insertCharacters(e);
            else
                switch (this.insertionMode) {
                case rb.IN_HEAD:
                case rb.IN_HEAD_NO_SCRIPT:
                case rb.AFTER_HEAD:
                case rb.TEXT:
                case rb.IN_COLUMN_GROUP:
                case rb.IN_SELECT:
                case rb.IN_SELECT_IN_TABLE:
                case rb.IN_FRAMESET:
                case rb.AFTER_FRAMESET:
                    this._insertCharacters(e);
                    break;
                case rb.IN_BODY:
                case rb.IN_CAPTION:
                case rb.IN_CELL:
                case rb.IN_TEMPLATE:
                case rb.AFTER_BODY:
                case rb.AFTER_AFTER_BODY:
                case rb.AFTER_AFTER_FRAMESET:
                    Tb(this, e);
                    break;
                case rb.IN_TABLE:
                case rb.IN_TABLE_BODY:
                case rb.IN_ROW:
                    Lb(this, e);
                    break;
                case rb.IN_TABLE_TEXT:
                    Fb(this, e)
                }
        }
    }
    ;
    function cb(e, t) {
        let n = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);
        return n ? e.openElements.contains(n.element) ? e.openElements.hasInScope(t.tagID) || (n = null) : (e.activeFormattingElements.removeEntry(n),
        n = null) : $b(e, t),
        n
    }
    function ub(e, t) {
        let n = null
          , r = e.openElements.stackTop;
        for (; r >= 0; r--) {
            const o = e.openElements.items[r];
            if (o === t.element)
                break;
            e._isSpecialElement(o, e.openElements.tagIDs[r]) && (n = o)
        }
        return n || (e.openElements.shortenToLength(r < 0 ? 0 : r),
        e.activeFormattingElements.removeEntry(t)),
        n
    }
    function db(e, t, n) {
        let r = t
          , o = e.openElements.getCommonAncestor(t);
        for (let i = 0, a = o; a !== n; i++,
        a = o) {
            o = e.openElements.getCommonAncestor(a);
            const n = e.activeFormattingElements.getElementEntry(a)
              , s = n && i >= nb;
            !n || s ? (s && e.activeFormattingElements.removeEntry(n),
            e.openElements.remove(a)) : (a = pb(e, n),
            r === t && (e.activeFormattingElements.bookmark = n),
            e.treeAdapter.detachNode(r),
            e.treeAdapter.appendChild(a, r),
            r = a)
        }
        return r
    }
    function pb(e, t) {
        const n = e.treeAdapter.getNamespaceURI(t.element)
          , r = e.treeAdapter.createElement(t.token.tagName, n, t.token.attrs);
        return e.openElements.replace(t.element, r),
        t.element = r,
        r
    }
    function hb(e, t, n) {
        const r = tg(e.treeAdapter.getTagName(t));
        if (e._isElementCausesFosterParenting(r))
            e._fosterParentElement(n);
        else {
            const o = e.treeAdapter.getNamespaceURI(t);
            r === Wm.TEMPLATE && o === Bm.HTML && (t = e.treeAdapter.getTemplateContent(t)),
            e.treeAdapter.appendChild(t, n)
        }
    }
    function fb(e, t, n) {
        const r = e.treeAdapter.getNamespaceURI(n.element)
          , {token: o} = n
          , i = e.treeAdapter.createElement(o.tagName, r, o.attrs);
        e._adoptNodes(t, i),
        e.treeAdapter.appendChild(t, i),
        e.activeFormattingElements.insertElementAfterBookmark(i, o),
        e.activeFormattingElements.removeEntry(n),
        e.openElements.remove(n.element),
        e.openElements.insertAfter(t, i, o.tagID)
    }
    function mb(e, t) {
        for (let n = 0; n < tb; n++) {
            const n = cb(e, t);
            if (!n)
                break;
            const r = ub(e, n);
            if (!r)
                break;
            e.activeFormattingElements.bookmark = n;
            const o = db(e, r, n.element)
              , i = e.openElements.getCommonAncestor(n.element);
            e.treeAdapter.detachNode(o),
            i && hb(e, i, o),
            fb(e, r, n)
        }
    }
    function gb(e, t) {
        e._appendCommentNode(t, e.openElements.currentTmplContentOrNode)
    }
    function bb(e, t) {
        if (e.stopped = !0,
        t.location) {
            const n = e.fragmentContext ? 0 : 2;
            for (let r = e.openElements.stackTop; r >= n; r--)
                e._setEndLocation(e.openElements.items[r], t);
            if (!e.fragmentContext && e.openElements.stackTop >= 0) {
                const n = e.openElements.items[0]
                  , r = e.treeAdapter.getNodeSourceCodeLocation(n);
                if (r && !r.endTag && (e._setEndLocation(n, t),
                e.openElements.stackTop >= 1)) {
                    const n = e.openElements.items[1]
                      , r = e.treeAdapter.getNodeSourceCodeLocation(n);
                    r && !r.endTag && e._setEndLocation(n, t)
                }
            }
        }
    }
    function Ob(e, t) {
        e._err(t, ym.missingDoctype, !0),
        e.treeAdapter.setDocumentMode(e.document, zm.QUIRKS),
        e.insertionMode = rb.BEFORE_HTML,
        e._processToken(t)
    }
    function vb(e, t) {
        e._insertFakeRootElement(),
        e.insertionMode = rb.BEFORE_HEAD,
        e._processToken(t)
    }
    function yb(e, t) {
        e._insertFakeElement(Hm.HEAD, Wm.HEAD),
        e.headElement = e.openElements.current,
        e.insertionMode = rb.IN_HEAD,
        e._processToken(t)
    }
    function wb(e, t) {
        switch (t.tagID) {
        case Wm.HTML:
            Nb(e, t);
            break;
        case Wm.BASE:
        case Wm.BASEFONT:
        case Wm.BGSOUND:
        case Wm.LINK:
        case Wm.META:
            e._appendElement(t, Bm.HTML),
            t.ackSelfClosing = !0;
            break;
        case Wm.TITLE:
            e._switchToTextParsing(t, lg.RCDATA);
            break;
        case Wm.NOSCRIPT:
            e.options.scriptingEnabled ? e._switchToTextParsing(t, lg.RAWTEXT) : (e._insertElement(t, Bm.HTML),
            e.insertionMode = rb.IN_HEAD_NO_SCRIPT);
            break;
        case Wm.NOFRAMES:
        case Wm.STYLE:
            e._switchToTextParsing(t, lg.RAWTEXT);
            break;
        case Wm.SCRIPT:
            e._switchToTextParsing(t, lg.SCRIPT_DATA);
            break;
        case Wm.TEMPLATE:
            e._insertTemplate(t),
            e.activeFormattingElements.insertMarker(),
            e.framesetOk = !1,
            e.insertionMode = rb.IN_TEMPLATE,
            e.tmplInsertionModeStack.unshift(rb.IN_TEMPLATE);
            break;
        case Wm.HEAD:
            e._err(t, ym.misplacedStartTagForHeadElement);
            break;
        default:
            kb(e, t)
        }
    }
    function _b(e, t) {
        e.openElements.tmplCount > 0 ? (e.openElements.generateImpliedEndTagsThoroughly(),
        e.openElements.currentTagId !== Wm.TEMPLATE && e._err(t, ym.closingOfElementWithOpenChildElements),
        e.openElements.popUntilTagNamePopped(Wm.TEMPLATE),
        e.activeFormattingElements.clearToLastMarker(),
        e.tmplInsertionModeStack.shift(),
        e._resetInsertionMode()) : e._err(t, ym.endTagWithoutMatchingOpenElement)
    }
    function kb(e, t) {
        e.openElements.pop(),
        e.insertionMode = rb.AFTER_HEAD,
        e._processToken(t)
    }
    function Sb(e, t) {
        const n = t.type === km.EOF ? ym.openElementsLeftAfterEof : ym.disallowedContentInNoscriptInHead;
        e._err(t, n),
        e.openElements.pop(),
        e.insertionMode = rb.IN_HEAD,
        e._processToken(t)
    }
    function Eb(e, t) {
        e._insertFakeElement(Hm.BODY, Wm.BODY),
        e.insertionMode = rb.IN_BODY,
        xb(e, t)
    }
    function xb(e, t) {
        switch (t.type) {
        case km.CHARACTER:
            Ab(e, t);
            break;
        case km.WHITESPACE_CHARACTER:
            Tb(e, t);
            break;
        case km.COMMENT:
            gb(e, t);
            break;
        case km.START_TAG:
            Nb(e, t);
            break;
        case km.END_TAG:
            Ib(e, t);
            break;
        case km.EOF:
            Mb(e, t)
        }
    }
    function Tb(e, t) {
        e._reconstructActiveFormattingElements(),
        e._insertCharacters(t)
    }
    function Ab(e, t) {
        e._reconstructActiveFormattingElements(),
        e._insertCharacters(t),
        e.framesetOk = !1
    }
    function Cb(e, t) {
        e._reconstructActiveFormattingElements(),
        e._appendElement(t, Bm.HTML),
        e.framesetOk = !1,
        t.ackSelfClosing = !0
    }
    function Pb(e) {
        const t = Em(e, Fm.TYPE);
        return null != t && t.toLowerCase() === eb
    }
    function Db(e, t) {
        e._switchToTextParsing(t, lg.RAWTEXT)
    }
    function Rb(e, t) {
        e._reconstructActiveFormattingElements(),
        e._insertElement(t, Bm.HTML)
    }
    function Nb(e, t) {
        switch (t.tagID) {
        case Wm.I:
        case Wm.S:
        case Wm.B:
        case Wm.U:
        case Wm.EM:
        case Wm.TT:
        case Wm.BIG:
        case Wm.CODE:
        case Wm.FONT:
        case Wm.SMALL:
        case Wm.STRIKE:
        case Wm.STRONG:
            !function(e, t) {
                e._reconstructActiveFormattingElements(),
                e._insertElement(t, Bm.HTML),
                e.activeFormattingElements.pushElement(e.openElements.current, t)
            }(e, t);
            break;
        case Wm.A:
            !function(e, t) {
                const n = e.activeFormattingElements.getElementEntryInScopeWithTagName(Hm.A);
                n && (mb(e, t),
                e.openElements.remove(n.element),
                e.activeFormattingElements.removeEntry(n)),
                e._reconstructActiveFormattingElements(),
                e._insertElement(t, Bm.HTML),
                e.activeFormattingElements.pushElement(e.openElements.current, t)
            }(e, t);
            break;
        case Wm.H1:
        case Wm.H2:
        case Wm.H3:
        case Wm.H4:
        case Wm.H5:
        case Wm.H6:
            !function(e, t) {
                e.openElements.hasInButtonScope(Wm.P) && e._closePElement(),
                og(e.openElements.currentTagId) && e.openElements.pop(),
                e._insertElement(t, Bm.HTML)
            }(e, t);
            break;
        case Wm.P:
        case Wm.DL:
        case Wm.OL:
        case Wm.UL:
        case Wm.DIV:
        case Wm.DIR:
        case Wm.NAV:
        case Wm.MAIN:
        case Wm.MENU:
        case Wm.ASIDE:
        case Wm.CENTER:
        case Wm.FIGURE:
        case Wm.FOOTER:
        case Wm.HEADER:
        case Wm.HGROUP:
        case Wm.DIALOG:
        case Wm.DETAILS:
        case Wm.ADDRESS:
        case Wm.ARTICLE:
        case Wm.SECTION:
        case Wm.SUMMARY:
        case Wm.FIELDSET:
        case Wm.BLOCKQUOTE:
        case Wm.FIGCAPTION:
            !function(e, t) {
                e.openElements.hasInButtonScope(Wm.P) && e._closePElement(),
                e._insertElement(t, Bm.HTML)
            }(e, t);
            break;
        case Wm.LI:
        case Wm.DD:
        case Wm.DT:
            !function(e, t) {
                e.framesetOk = !1;
                const n = t.tagID;
                for (let r = e.openElements.stackTop; r >= 0; r--) {
                    const t = e.openElements.tagIDs[r];
                    if (n === Wm.LI && t === Wm.LI || (n === Wm.DD || n === Wm.DT) && (t === Wm.DD || t === Wm.DT)) {
                        e.openElements.generateImpliedEndTagsWithExclusion(t),
                        e.openElements.popUntilTagNamePopped(t);
                        break
                    }
                    if (t !== Wm.ADDRESS && t !== Wm.DIV && t !== Wm.P && e._isSpecialElement(e.openElements.items[r], t))
                        break
                }
                e.openElements.hasInButtonScope(Wm.P) && e._closePElement(),
                e._insertElement(t, Bm.HTML)
            }(e, t);
            break;
        case Wm.BR:
        case Wm.IMG:
        case Wm.WBR:
        case Wm.AREA:
        case Wm.EMBED:
        case Wm.KEYGEN:
            Cb(e, t);
            break;
        case Wm.HR:
            !function(e, t) {
                e.openElements.hasInButtonScope(Wm.P) && e._closePElement(),
                e._appendElement(t, Bm.HTML),
                e.framesetOk = !1,
                t.ackSelfClosing = !0
            }(e, t);
            break;
        case Wm.RB:
        case Wm.RTC:
            !function(e, t) {
                e.openElements.hasInScope(Wm.RUBY) && e.openElements.generateImpliedEndTags(),
                e._insertElement(t, Bm.HTML)
            }(e, t);
            break;
        case Wm.RT:
        case Wm.RP:
            !function(e, t) {
                e.openElements.hasInScope(Wm.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(Wm.RTC),
                e._insertElement(t, Bm.HTML)
            }(e, t);
            break;
        case Wm.PRE:
        case Wm.LISTING:
            !function(e, t) {
                e.openElements.hasInButtonScope(Wm.P) && e._closePElement(),
                e._insertElement(t, Bm.HTML),
                e.skipNextNewLine = !0,
                e.framesetOk = !1
            }(e, t);
            break;
        case Wm.XMP:
            !function(e, t) {
                e.openElements.hasInButtonScope(Wm.P) && e._closePElement(),
                e._reconstructActiveFormattingElements(),
                e.framesetOk = !1,
                e._switchToTextParsing(t, lg.RAWTEXT)
            }(e, t);
            break;
        case Wm.SVG:
            !function(e, t) {
                e._reconstructActiveFormattingElements(),
                Yg(t),
                Kg(t),
                t.selfClosing ? e._appendElement(t, Bm.SVG) : e._insertElement(t, Bm.SVG),
                t.ackSelfClosing = !0
            }(e, t);
            break;
        case Wm.HTML:
            !function(e, t) {
                0 === e.openElements.tmplCount && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs)
            }(e, t);
            break;
        case Wm.BASE:
        case Wm.LINK:
        case Wm.META:
        case Wm.STYLE:
        case Wm.TITLE:
        case Wm.SCRIPT:
        case Wm.BGSOUND:
        case Wm.BASEFONT:
        case Wm.TEMPLATE:
            wb(e, t);
            break;
        case Wm.BODY:
            !function(e, t) {
                const n = e.openElements.tryPeekProperlyNestedBodyElement();
                n && 0 === e.openElements.tmplCount && (e.framesetOk = !1,
                e.treeAdapter.adoptAttributes(n, t.attrs))
            }(e, t);
            break;
        case Wm.FORM:
            !function(e, t) {
                const n = e.openElements.tmplCount > 0;
                e.formElement && !n || (e.openElements.hasInButtonScope(Wm.P) && e._closePElement(),
                e._insertElement(t, Bm.HTML),
                n || (e.formElement = e.openElements.current))
            }(e, t);
            break;
        case Wm.NOBR:
            !function(e, t) {
                e._reconstructActiveFormattingElements(),
                e.openElements.hasInScope(Wm.NOBR) && (mb(e, t),
                e._reconstructActiveFormattingElements()),
                e._insertElement(t, Bm.HTML),
                e.activeFormattingElements.pushElement(e.openElements.current, t)
            }(e, t);
            break;
        case Wm.MATH:
            !function(e, t) {
                e._reconstructActiveFormattingElements(),
                Gg(t),
                Kg(t),
                t.selfClosing ? e._appendElement(t, Bm.MATHML) : e._insertElement(t, Bm.MATHML),
                t.ackSelfClosing = !0
            }(e, t);
            break;
        case Wm.TABLE:
            !function(e, t) {
                e.treeAdapter.getDocumentMode(e.document) !== zm.QUIRKS && e.openElements.hasInButtonScope(Wm.P) && e._closePElement(),
                e._insertElement(t, Bm.HTML),
                e.framesetOk = !1,
                e.insertionMode = rb.IN_TABLE
            }(e, t);
            break;
        case Wm.INPUT:
            !function(e, t) {
                e._reconstructActiveFormattingElements(),
                e._appendElement(t, Bm.HTML),
                Pb(t) || (e.framesetOk = !1),
                t.ackSelfClosing = !0
            }(e, t);
            break;
        case Wm.PARAM:
        case Wm.TRACK:
        case Wm.SOURCE:
            !function(e, t) {
                e._appendElement(t, Bm.HTML),
                t.ackSelfClosing = !0
            }(e, t);
            break;
        case Wm.IMAGE:
            !function(e, t) {
                t.tagName = Hm.IMG,
                t.tagID = Wm.IMG,
                Cb(e, t)
            }(e, t);
            break;
        case Wm.BUTTON:
            !function(e, t) {
                e.openElements.hasInScope(Wm.BUTTON) && (e.openElements.generateImpliedEndTags(),
                e.openElements.popUntilTagNamePopped(Wm.BUTTON)),
                e._reconstructActiveFormattingElements(),
                e._insertElement(t, Bm.HTML),
                e.framesetOk = !1
            }(e, t);
            break;
        case Wm.APPLET:
        case Wm.OBJECT:
        case Wm.MARQUEE:
            !function(e, t) {
                e._reconstructActiveFormattingElements(),
                e._insertElement(t, Bm.HTML),
                e.activeFormattingElements.insertMarker(),
                e.framesetOk = !1
            }(e, t);
            break;
        case Wm.IFRAME:
            !function(e, t) {
                e.framesetOk = !1,
                e._switchToTextParsing(t, lg.RAWTEXT)
            }(e, t);
            break;
        case Wm.SELECT:
            !function(e, t) {
                e._reconstructActiveFormattingElements(),
                e._insertElement(t, Bm.HTML),
                e.framesetOk = !1,
                e.insertionMode = e.insertionMode === rb.IN_TABLE || e.insertionMode === rb.IN_CAPTION || e.insertionMode === rb.IN_TABLE_BODY || e.insertionMode === rb.IN_ROW || e.insertionMode === rb.IN_CELL ? rb.IN_SELECT_IN_TABLE : rb.IN_SELECT
            }(e, t);
            break;
        case Wm.OPTION:
        case Wm.OPTGROUP:
            !function(e, t) {
                e.openElements.currentTagId === Wm.OPTION && e.openElements.pop(),
                e._reconstructActiveFormattingElements(),
                e._insertElement(t, Bm.HTML)
            }(e, t);
            break;
        case Wm.NOEMBED:
            Db(e, t);
            break;
        case Wm.FRAMESET:
            !function(e, t) {
                const n = e.openElements.tryPeekProperlyNestedBodyElement();
                e.framesetOk && n && (e.treeAdapter.detachNode(n),
                e.openElements.popAllUpToHtmlElement(),
                e._insertElement(t, Bm.HTML),
                e.insertionMode = rb.IN_FRAMESET)
            }(e, t);
            break;
        case Wm.TEXTAREA:
            !function(e, t) {
                e._insertElement(t, Bm.HTML),
                e.skipNextNewLine = !0,
                e.tokenizer.state = lg.RCDATA,
                e.originalInsertionMode = e.insertionMode,
                e.framesetOk = !1,
                e.insertionMode = rb.TEXT
            }(e, t);
            break;
        case Wm.NOSCRIPT:
            e.options.scriptingEnabled ? Db(e, t) : Rb(e, t);
            break;
        case Wm.PLAINTEXT:
            !function(e, t) {
                e.openElements.hasInButtonScope(Wm.P) && e._closePElement(),
                e._insertElement(t, Bm.HTML),
                e.tokenizer.state = lg.PLAINTEXT
            }(e, t);
            break;
        case Wm.COL:
        case Wm.TH:
        case Wm.TD:
        case Wm.TR:
        case Wm.HEAD:
        case Wm.FRAME:
        case Wm.TBODY:
        case Wm.TFOOT:
        case Wm.THEAD:
        case Wm.CAPTION:
        case Wm.COLGROUP:
            break;
        default:
            Rb(e, t)
        }
    }
    function $b(e, t) {
        const n = t.tagName
          , r = t.tagID;
        for (let o = e.openElements.stackTop; o > 0; o--) {
            const t = e.openElements.items[o]
              , i = e.openElements.tagIDs[o];
            if (r === i && (r !== Wm.UNKNOWN || e.treeAdapter.getTagName(t) === n)) {
                e.openElements.generateImpliedEndTagsWithExclusion(r),
                e.openElements.stackTop >= o && e.openElements.shortenToLength(o);
                break
            }
            if (e._isSpecialElement(t, i))
                break
        }
    }
    function Ib(e, t) {
        switch (t.tagID) {
        case Wm.A:
        case Wm.B:
        case Wm.I:
        case Wm.S:
        case Wm.U:
        case Wm.EM:
        case Wm.TT:
        case Wm.BIG:
        case Wm.CODE:
        case Wm.FONT:
        case Wm.NOBR:
        case Wm.SMALL:
        case Wm.STRIKE:
        case Wm.STRONG:
            mb(e, t);
            break;
        case Wm.P:
            !function(e) {
                e.openElements.hasInButtonScope(Wm.P) || e._insertFakeElement(Hm.P, Wm.P),
                e._closePElement()
            }(e);
            break;
        case Wm.DL:
        case Wm.UL:
        case Wm.OL:
        case Wm.DIR:
        case Wm.DIV:
        case Wm.NAV:
        case Wm.PRE:
        case Wm.MAIN:
        case Wm.MENU:
        case Wm.ASIDE:
        case Wm.BUTTON:
        case Wm.CENTER:
        case Wm.FIGURE:
        case Wm.FOOTER:
        case Wm.HEADER:
        case Wm.HGROUP:
        case Wm.DIALOG:
        case Wm.ADDRESS:
        case Wm.ARTICLE:
        case Wm.DETAILS:
        case Wm.SECTION:
        case Wm.SUMMARY:
        case Wm.LISTING:
        case Wm.FIELDSET:
        case Wm.BLOCKQUOTE:
        case Wm.FIGCAPTION:
            !function(e, t) {
                const n = t.tagID;
                e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(),
                e.openElements.popUntilTagNamePopped(n))
            }(e, t);
            break;
        case Wm.LI:
            !function(e) {
                e.openElements.hasInListItemScope(Wm.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(Wm.LI),
                e.openElements.popUntilTagNamePopped(Wm.LI))
            }(e);
            break;
        case Wm.DD:
        case Wm.DT:
            !function(e, t) {
                const n = t.tagID;
                e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTagsWithExclusion(n),
                e.openElements.popUntilTagNamePopped(n))
            }(e, t);
            break;
        case Wm.H1:
        case Wm.H2:
        case Wm.H3:
        case Wm.H4:
        case Wm.H5:
        case Wm.H6:
            !function(e) {
                e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(),
                e.openElements.popUntilNumberedHeaderPopped())
            }(e);
            break;
        case Wm.BR:
            !function(e) {
                e._reconstructActiveFormattingElements(),
                e._insertFakeElement(Hm.BR, Wm.BR),
                e.openElements.pop(),
                e.framesetOk = !1
            }(e);
            break;
        case Wm.BODY:
            !function(e, t) {
                if (e.openElements.hasInScope(Wm.BODY) && (e.insertionMode = rb.AFTER_BODY,
                e.options.sourceCodeLocationInfo)) {
                    const n = e.openElements.tryPeekProperlyNestedBodyElement();
                    n && e._setEndLocation(n, t)
                }
            }(e, t);
            break;
        case Wm.HTML:
            !function(e, t) {
                e.openElements.hasInScope(Wm.BODY) && (e.insertionMode = rb.AFTER_BODY,
                eO(e, t))
            }(e, t);
            break;
        case Wm.FORM:
            !function(e) {
                const t = e.openElements.tmplCount > 0
                  , {formElement: n} = e;
                t || (e.formElement = null),
                (n || t) && e.openElements.hasInScope(Wm.FORM) && (e.openElements.generateImpliedEndTags(),
                t ? e.openElements.popUntilTagNamePopped(Wm.FORM) : n && e.openElements.remove(n))
            }(e);
            break;
        case Wm.APPLET:
        case Wm.OBJECT:
        case Wm.MARQUEE:
            !function(e, t) {
                const n = t.tagID;
                e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(),
                e.openElements.popUntilTagNamePopped(n),
                e.activeFormattingElements.clearToLastMarker())
            }(e, t);
            break;
        case Wm.TEMPLATE:
            _b(e, t);
            break;
        default:
            $b(e, t)
        }
    }
    function Mb(e, t) {
        e.tmplInsertionModeStack.length > 0 ? Jb(e, t) : bb(e, t)
    }
    function Lb(e, t) {
        if (ab.has(e.openElements.currentTagId))
            switch (e.pendingCharacterTokens.length = 0,
            e.hasNonWhitespacePendingCharacterToken = !1,
            e.originalInsertionMode = e.insertionMode,
            e.insertionMode = rb.IN_TABLE_TEXT,
            t.type) {
            case km.CHARACTER:
                jb(e, t);
                break;
            case km.WHITESPACE_CHARACTER:
                Fb(e, t)
            }
        else
            Ub(e, t)
    }
    function Qb(e, t) {
        switch (t.tagID) {
        case Wm.TD:
        case Wm.TH:
        case Wm.TR:
            !function(e, t) {
                e.openElements.clearBackToTableContext(),
                e._insertFakeElement(Hm.TBODY, Wm.TBODY),
                e.insertionMode = rb.IN_TABLE_BODY,
                Wb(e, t)
            }(e, t);
            break;
        case Wm.STYLE:
        case Wm.SCRIPT:
        case Wm.TEMPLATE:
            wb(e, t);
            break;
        case Wm.COL:
            !function(e, t) {
                e.openElements.clearBackToTableContext(),
                e._insertFakeElement(Hm.COLGROUP, Wm.COLGROUP),
                e.insertionMode = rb.IN_COLUMN_GROUP,
                Hb(e, t)
            }(e, t);
            break;
        case Wm.FORM:
            !function(e, t) {
                e.formElement || 0 !== e.openElements.tmplCount || (e._insertElement(t, Bm.HTML),
                e.formElement = e.openElements.current,
                e.openElements.pop())
            }(e, t);
            break;
        case Wm.TABLE:
            !function(e, t) {
                e.openElements.hasInTableScope(Wm.TABLE) && (e.openElements.popUntilTagNamePopped(Wm.TABLE),
                e._resetInsertionMode(),
                e._processStartTag(t))
            }(e, t);
            break;
        case Wm.TBODY:
        case Wm.TFOOT:
        case Wm.THEAD:
            !function(e, t) {
                e.openElements.clearBackToTableContext(),
                e._insertElement(t, Bm.HTML),
                e.insertionMode = rb.IN_TABLE_BODY
            }(e, t);
            break;
        case Wm.INPUT:
            !function(e, t) {
                Pb(t) ? e._appendElement(t, Bm.HTML) : Ub(e, t),
                t.ackSelfClosing = !0
            }(e, t);
            break;
        case Wm.CAPTION:
            !function(e, t) {
                e.openElements.clearBackToTableContext(),
                e.activeFormattingElements.insertMarker(),
                e._insertElement(t, Bm.HTML),
                e.insertionMode = rb.IN_CAPTION
            }(e, t);
            break;
        case Wm.COLGROUP:
            !function(e, t) {
                e.openElements.clearBackToTableContext(),
                e._insertElement(t, Bm.HTML),
                e.insertionMode = rb.IN_COLUMN_GROUP
            }(e, t);
            break;
        default:
            Ub(e, t)
        }
    }
    function Bb(e, t) {
        switch (t.tagID) {
        case Wm.TABLE:
            e.openElements.hasInTableScope(Wm.TABLE) && (e.openElements.popUntilTagNamePopped(Wm.TABLE),
            e._resetInsertionMode());
            break;
        case Wm.TEMPLATE:
            _b(e, t);
            break;
        case Wm.BODY:
        case Wm.CAPTION:
        case Wm.COL:
        case Wm.COLGROUP:
        case Wm.HTML:
        case Wm.TBODY:
        case Wm.TD:
        case Wm.TFOOT:
        case Wm.TH:
        case Wm.THEAD:
        case Wm.TR:
            break;
        default:
            Ub(e, t)
        }
    }
    function Ub(e, t) {
        const n = e.fosterParentingEnabled;
        e.fosterParentingEnabled = !0,
        xb(e, t),
        e.fosterParentingEnabled = n
    }
    function Fb(e, t) {
        e.pendingCharacterTokens.push(t)
    }
    function jb(e, t) {
        e.pendingCharacterTokens.push(t),
        e.hasNonWhitespacePendingCharacterToken = !0
    }
    function zb(e, t) {
        let n = 0;
        if (e.hasNonWhitespacePendingCharacterToken)
            for (; n < e.pendingCharacterTokens.length; n++)
                Ub(e, e.pendingCharacterTokens[n]);
        else
            for (; n < e.pendingCharacterTokens.length; n++)
                e._insertCharacters(e.pendingCharacterTokens[n]);
        e.insertionMode = e.originalInsertionMode,
        e._processToken(t)
    }
    const qb = new Set([Wm.CAPTION, Wm.COL, Wm.COLGROUP, Wm.TBODY, Wm.TD, Wm.TFOOT, Wm.TH, Wm.THEAD, Wm.TR]);
    function Hb(e, t) {
        switch (t.tagID) {
        case Wm.HTML:
            Nb(e, t);
            break;
        case Wm.COL:
            e._appendElement(t, Bm.HTML),
            t.ackSelfClosing = !0;
            break;
        case Wm.TEMPLATE:
            wb(e, t);
            break;
        default:
            Zb(e, t)
        }
    }
    function Zb(e, t) {
        e.openElements.currentTagId === Wm.COLGROUP && (e.openElements.pop(),
        e.insertionMode = rb.IN_TABLE,
        e._processToken(t))
    }
    function Wb(e, t) {
        switch (t.tagID) {
        case Wm.TR:
            e.openElements.clearBackToTableBodyContext(),
            e._insertElement(t, Bm.HTML),
            e.insertionMode = rb.IN_ROW;
            break;
        case Wm.TH:
        case Wm.TD:
            e.openElements.clearBackToTableBodyContext(),
            e._insertFakeElement(Hm.TR, Wm.TR),
            e.insertionMode = rb.IN_ROW,
            Vb(e, t);
            break;
        case Wm.CAPTION:
        case Wm.COL:
        case Wm.COLGROUP:
        case Wm.TBODY:
        case Wm.TFOOT:
        case Wm.THEAD:
            e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(),
            e.openElements.pop(),
            e.insertionMode = rb.IN_TABLE,
            Qb(e, t));
            break;
        default:
            Qb(e, t)
        }
    }
    function Xb(e, t) {
        const n = t.tagID;
        switch (t.tagID) {
        case Wm.TBODY:
        case Wm.TFOOT:
        case Wm.THEAD:
            e.openElements.hasInTableScope(n) && (e.openElements.clearBackToTableBodyContext(),
            e.openElements.pop(),
            e.insertionMode = rb.IN_TABLE);
            break;
        case Wm.TABLE:
            e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(),
            e.openElements.pop(),
            e.insertionMode = rb.IN_TABLE,
            Bb(e, t));
            break;
        case Wm.BODY:
        case Wm.CAPTION:
        case Wm.COL:
        case Wm.COLGROUP:
        case Wm.HTML:
        case Wm.TD:
        case Wm.TH:
        case Wm.TR:
            break;
        default:
            Bb(e, t)
        }
    }
    function Vb(e, t) {
        switch (t.tagID) {
        case Wm.TH:
        case Wm.TD:
            e.openElements.clearBackToTableRowContext(),
            e._insertElement(t, Bm.HTML),
            e.insertionMode = rb.IN_CELL,
            e.activeFormattingElements.insertMarker();
            break;
        case Wm.CAPTION:
        case Wm.COL:
        case Wm.COLGROUP:
        case Wm.TBODY:
        case Wm.TFOOT:
        case Wm.THEAD:
        case Wm.TR:
            e.openElements.hasInTableScope(Wm.TR) && (e.openElements.clearBackToTableRowContext(),
            e.openElements.pop(),
            e.insertionMode = rb.IN_TABLE_BODY,
            Wb(e, t));
            break;
        default:
            Qb(e, t)
        }
    }
    function Gb(e, t) {
        switch (t.tagID) {
        case Wm.TR:
            e.openElements.hasInTableScope(Wm.TR) && (e.openElements.clearBackToTableRowContext(),
            e.openElements.pop(),
            e.insertionMode = rb.IN_TABLE_BODY);
            break;
        case Wm.TABLE:
            e.openElements.hasInTableScope(Wm.TR) && (e.openElements.clearBackToTableRowContext(),
            e.openElements.pop(),
            e.insertionMode = rb.IN_TABLE_BODY,
            Xb(e, t));
            break;
        case Wm.TBODY:
        case Wm.TFOOT:
        case Wm.THEAD:
            (e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(Wm.TR)) && (e.openElements.clearBackToTableRowContext(),
            e.openElements.pop(),
            e.insertionMode = rb.IN_TABLE_BODY,
            Xb(e, t));
            break;
        case Wm.BODY:
        case Wm.CAPTION:
        case Wm.COL:
        case Wm.COLGROUP:
        case Wm.HTML:
        case Wm.TD:
        case Wm.TH:
            break;
        default:
            Bb(e, t)
        }
    }
    function Yb(e, t) {
        switch (t.tagID) {
        case Wm.HTML:
            Nb(e, t);
            break;
        case Wm.OPTION:
            e.openElements.currentTagId === Wm.OPTION && e.openElements.pop(),
            e._insertElement(t, Bm.HTML);
            break;
        case Wm.OPTGROUP:
            e.openElements.currentTagId === Wm.OPTION && e.openElements.pop(),
            e.openElements.currentTagId === Wm.OPTGROUP && e.openElements.pop(),
            e._insertElement(t, Bm.HTML);
            break;
        case Wm.INPUT:
        case Wm.KEYGEN:
        case Wm.TEXTAREA:
        case Wm.SELECT:
            e.openElements.hasInSelectScope(Wm.SELECT) && (e.openElements.popUntilTagNamePopped(Wm.SELECT),
            e._resetInsertionMode(),
            t.tagID !== Wm.SELECT && e._processStartTag(t));
            break;
        case Wm.SCRIPT:
        case Wm.TEMPLATE:
            wb(e, t)
        }
    }
    function Kb(e, t) {
        switch (t.tagID) {
        case Wm.OPTGROUP:
            e.openElements.stackTop > 0 && e.openElements.currentTagId === Wm.OPTION && e.openElements.tagIDs[e.openElements.stackTop - 1] === Wm.OPTGROUP && e.openElements.pop(),
            e.openElements.currentTagId === Wm.OPTGROUP && e.openElements.pop();
            break;
        case Wm.OPTION:
            e.openElements.currentTagId === Wm.OPTION && e.openElements.pop();
            break;
        case Wm.SELECT:
            e.openElements.hasInSelectScope(Wm.SELECT) && (e.openElements.popUntilTagNamePopped(Wm.SELECT),
            e._resetInsertionMode());
            break;
        case Wm.TEMPLATE:
            _b(e, t)
        }
    }
    function Jb(e, t) {
        e.openElements.tmplCount > 0 ? (e.openElements.popUntilTagNamePopped(Wm.TEMPLATE),
        e.activeFormattingElements.clearToLastMarker(),
        e.tmplInsertionModeStack.shift(),
        e._resetInsertionMode(),
        e.onEof(t)) : bb(e, t)
    }
    function eO(e, t) {
        var n;
        if (t.tagID === Wm.HTML) {
            if (e.fragmentContext || (e.insertionMode = rb.AFTER_AFTER_BODY),
            e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === Wm.HTML) {
                e._setEndLocation(e.openElements.items[0], t);
                const r = e.openElements.items[1];
                r && !(null === (n = e.treeAdapter.getNodeSourceCodeLocation(r)) || void 0 === n ? void 0 : n.endTag) && e._setEndLocation(r, t)
            }
        } else
            tO(e, t)
    }
    function tO(e, t) {
        e.insertionMode = rb.IN_BODY,
        xb(e, t)
    }
    function nO(e, t) {
        e.insertionMode = rb.IN_BODY,
        xb(e, t)
    }
    function rO(e) {
        for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== Bm.HTML && !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current); )
            e.openElements.pop()
    }
    function oO(e, t) {
        return lb.parse(e, t)
    }
    function iO(e, t, n) {
        "string" == typeof e && (n = t,
        t = e,
        e = null);
        const r = lb.getFragmentParser(e, n);
        return r.tokenizer.write(t, !0),
        r.getFragment()
    }
    Hm.AREA,
    Hm.BASE,
    Hm.BASEFONT,
    Hm.BGSOUND,
    Hm.BR,
    Hm.COL,
    Hm.EMBED,
    Hm.FRAME,
    Hm.HR,
    Hm.IMG,
    Hm.INPUT,
    Hm.KEYGEN,
    Hm.LINK,
    Hm.META,
    Hm.PARAM,
    Hm.SOURCE,
    Hm.TRACK,
    Hm.WBR;
    const aO = lO("end")
      , sO = lO("start");
    function lO(e) {
        return function(t) {
            const n = t && t.position && t.position[e] || {};
            if ("number" == typeof n.line && n.line > 0 && "number" == typeof n.column && n.column > 0)
                return {
                    line: n.line,
                    column: n.column,
                    offset: "number" == typeof n.offset && n.offset > -1 ? n.offset : void 0
                }
        }
    }
    function cO(e) {
        const t = sO(e)
          , n = aO(e);
        if (t && n)
            return {
                start: t,
                end: n
            }
    }
    const uO = new Set(["mdxFlowExpression", "mdxJsxFlowElement", "mdxJsxTextElement", "mdxTextExpression", "mdxjsEsm"])
      , dO = {
        sourceCodeLocationInfo: !0,
        scriptingEnabled: !1
    };
    function pO(e, t) {
        const n = function(e) {
            const t = "root" === e.type ? e.children[0] : e;
            return Boolean(t && ("doctype" === t.type || "element" === t.type && "html" === t.tagName.toLowerCase()))
        }(e)
          , r = Jf("type", {
            handlers: {
                root: fO,
                element: mO,
                text: gO,
                comment: vO,
                doctype: bO,
                raw: yO
            },
            unknown: wO
        })
          , o = {
            parser: n ? new lb(dO) : lb.getFragmentParser(void 0, dO),
            handle(e) {
                r(e, o)
            },
            stitches: !1,
            options: t || {}
        };
        r(e, o),
        _O(o, sO());
        const i = Zf(n ? o.parser.document : o.parser.getFragment(), {
            file: o.options.file
        });
        return o.stitches && eh(i, "comment", (function(e, t, n) {
            const r = e;
            if (r.value.stitch && n && void 0 !== t) {
                return n.children[t] = r.value.stitch,
                t
            }
        }
        )),
        "root" === i.type && 1 === i.children.length && i.children[0].type === e.type ? i.children[0] : i
    }
    function hO(e, t) {
        let n = -1;
        if (e)
            for (; ++n < e.length; )
                t.handle(e[n])
    }
    function fO(e, t) {
        hO(e.children, t)
    }
    function mO(e, t) {
        !function(e, t) {
            const n = e.tagName.toLowerCase();
            if (t.parser.tokenizer.state === lg.PLAINTEXT)
                return;
            _O(t, sO(e));
            const r = t.parser.openElements.current;
            let o = "namespaceURI"in r ? r.namespaceURI : zf.html;
            o === zf.html && "svg" === n && (o = zf.svg);
            const i = function(e, t) {
                const n = (t || em).space;
                return nm(e, "svg" === n ? Pf : Cf)
            }({
                ...e,
                children: []
            }, {
                space: o === zf.svg ? "svg" : "html"
            })
              , a = {
                type: km.START_TAG,
                tagName: n,
                tagID: tg(n),
                selfClosing: !1,
                ackSelfClosing: !1,
                attrs: "attrs"in i ? i.attrs : [],
                location: SO(e)
            };
            t.parser.currentToken = a,
            t.parser._processToken(t.parser.currentToken),
            t.parser.tokenizer.lastStartTagName = n
        }(e, t),
        hO(e.children, t),
        function(e, t) {
            const n = e.tagName.toLowerCase();
            if (!t.parser.tokenizer.inForeignNode && am.includes(n))
                return;
            if (t.parser.tokenizer.state === lg.PLAINTEXT)
                return;
            _O(t, aO(e));
            const r = {
                type: km.END_TAG,
                tagName: n,
                tagID: tg(n),
                selfClosing: !1,
                ackSelfClosing: !1,
                attrs: [],
                location: SO(e)
            };
            t.parser.currentToken = r,
            t.parser._processToken(t.parser.currentToken),
            n !== t.parser.tokenizer.lastStartTagName || t.parser.tokenizer.state !== lg.RCDATA && t.parser.tokenizer.state !== lg.RAWTEXT && t.parser.tokenizer.state !== lg.SCRIPT_DATA || (t.parser.tokenizer.state = lg.DATA)
        }(e, t)
    }
    function gO(e, t) {
        const n = {
            type: km.CHARACTER,
            chars: e.value,
            location: SO(e)
        };
        _O(t, sO(e)),
        t.parser.currentToken = n,
        t.parser._processToken(t.parser.currentToken)
    }
    function bO(e, t) {
        const n = {
            type: km.DOCTYPE,
            name: "html",
            forceQuirks: !1,
            publicId: "",
            systemId: "",
            location: SO(e)
        };
        _O(t, sO(e)),
        t.parser.currentToken = n,
        t.parser._processToken(t.parser.currentToken)
    }
    function OO(e, t) {
        t.stitches = !0;
        const n = function(e) {
            return dh("children"in e ? {
                ...e,
                children: []
            } : e)
        }(e);
        if ("children"in e && "children"in n) {
            const r = pO({
                type: "root",
                children: e.children
            }, t.options);
            n.children = r.children
        }
        vO({
            type: "comment",
            value: {
                stitch: n
            }
        }, t)
    }
    function vO(e, t) {
        const n = e.value
          , r = {
            type: km.COMMENT,
            data: n,
            location: SO(e)
        };
        _O(t, sO(e)),
        t.parser.currentToken = r,
        t.parser._processToken(t.parser.currentToken)
    }
    function yO(e, t) {
        if (t.parser.tokenizer.preprocessor.html = "",
        t.parser.tokenizer.preprocessor.pos = -1,
        t.parser.tokenizer.preprocessor.lastGapPos = -2,
        t.parser.tokenizer.preprocessor.gapStack = [],
        t.parser.tokenizer.preprocessor.skipNextNewLine = !1,
        t.parser.tokenizer.preprocessor.lastChunkWritten = !1,
        t.parser.tokenizer.preprocessor.endOfChunkHit = !1,
        t.parser.tokenizer.preprocessor.isEol = !1,
        kO(t, sO(e)),
        t.parser.tokenizer.write(e.value, !1),
        t.parser.tokenizer._runParsingLoop(),
        72 === t.parser.tokenizer.state || 78 === t.parser.tokenizer.state) {
            t.parser.tokenizer.preprocessor.lastChunkWritten = !0;
            const e = t.parser.tokenizer._consume();
            t.parser.tokenizer._callState(e)
        }
    }
    function wO(e, t) {
        const n = e;
        if (!t.options.passThrough || !t.options.passThrough.includes(n.type)) {
            let e = "";
            throw uO.has(n.type) && (e = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"),
            new Error("Cannot compile `" + n.type + "` node" + e)
        }
        OO(n, t)
    }
    function _O(e, t) {
        kO(e, t);
        const n = e.parser.tokenizer.currentCharacterToken;
        n && n.location && (n.location.endLine = e.parser.tokenizer.preprocessor.line,
        n.location.endCol = e.parser.tokenizer.preprocessor.col + 1,
        n.location.endOffset = e.parser.tokenizer.preprocessor.offset + 1,
        e.parser.currentToken = n,
        e.parser._processToken(e.parser.currentToken)),
        e.parser.tokenizer.paused = !1,
        e.parser.tokenizer.inLoop = !1,
        e.parser.tokenizer.active = !1,
        e.parser.tokenizer.returnState = lg.DATA,
        e.parser.tokenizer.charRefCode = -1,
        e.parser.tokenizer.consumedAfterSnapshot = -1,
        e.parser.tokenizer.currentLocation = null,
        e.parser.tokenizer.currentCharacterToken = null,
        e.parser.tokenizer.currentToken = null,
        e.parser.tokenizer.currentAttr = {
            name: "",
            value: ""
        }
    }
    function kO(e, t) {
        if (t && void 0 !== t.offset) {
            const n = {
                startLine: t.line,
                startCol: t.column,
                startOffset: t.offset,
                endLine: -1,
                endCol: -1,
                endOffset: -1
            };
            e.parser.tokenizer.preprocessor.lineStartPos = 1 - t.column,
            e.parser.tokenizer.preprocessor.droppedBufferSize = t.offset,
            e.parser.tokenizer.preprocessor.line = t.line,
            e.parser.tokenizer.currentLocation = n
        }
    }
    function SO(e) {
        const t = sO(e) || {
            line: void 0,
            column: void 0,
            offset: void 0
        }
          , n = aO(e) || {
            line: void 0,
            column: void 0,
            offset: void 0
        };
        return {
            startLine: t.line,
            startCol: t.column,
            startOffset: t.offset,
            endLine: n.line,
            endCol: n.column,
            endOffset: n.offset
        }
    }
    function EO(e) {
        return function(t, n) {
            return pO(t, {
                ...e,
                file: n
            })
        }
    }
    const xO = ["ariaDescribedBy", "ariaLabel", "ariaLabelledBy"]
      , TO = {
        ancestors: {
            tbody: ["table"],
            td: ["table"],
            th: ["table"],
            thead: ["table"],
            tfoot: ["table"],
            tr: ["table"]
        },
        attributes: {
            a: [...xO, "dataFootnoteBackref", "dataFootnoteRef", ["className", "data-footnote-backref"], "href"],
            blockquote: ["cite"],
            code: [["className", /^language-./]],
            del: ["cite"],
            div: ["itemScope", "itemType"],
            dl: [...xO],
            h2: [["className", "sr-only"]],
            img: [...xO, "longDesc", "src"],
            input: [["disabled", !0], ["type", "checkbox"]],
            ins: ["cite"],
            li: [["className", "task-list-item"]],
            ol: [...xO, ["className", "contains-task-list"]],
            q: ["cite"],
            section: ["dataFootnotes", ["className", "footnotes"]],
            source: ["srcSet"],
            summary: [...xO],
            table: [...xO],
            ul: [...xO, ["className", "contains-task-list"]],
            "*": ["abbr", "accept", "acceptCharset", "accessKey", "action", "align", "alt", "axis", "border", "cellPadding", "cellSpacing", "char", "charOff", "charSet", "checked", "clear", "colSpan", "color", "cols", "compact", "coords", "dateTime", "dir", "encType", "frame", "hSpace", "headers", "height", "hrefLang", "htmlFor", "id", "isMap", "itemProp", "label", "lang", "maxLength", "media", "method", "multiple", "name", "noHref", "noShade", "noWrap", "open", "prompt", "readOnly", "rev", "rowSpan", "rows", "rules", "scope", "selected", "shape", "size", "span", "start", "summary", "tabIndex", "title", "useMap", "vAlign", "value", "width"]
        },
        clobber: ["ariaDescribedBy", "ariaLabelledBy", "id", "name"],
        clobberPrefix: "user-content-",
        protocols: {
            cite: ["http", "https"],
            href: ["http", "https", "irc", "ircs", "mailto", "xmpp"],
            longDesc: ["http", "https"],
            src: ["http", "https"]
        },
        required: {
            input: {
                disabled: !0,
                type: "checkbox"
            }
        },
        strip: ["script"],
        tagNames: ["a", "b", "blockquote", "br", "code", "dd", "del", "details", "div", "dl", "dt", "em", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "i", "img", "input", "ins", "kbd", "li", "ol", "p", "picture", "pre", "q", "rp", "rt", "ruby", "s", "samp", "section", "source", "span", "strike", "strong", "sub", "summary", "sup", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "tt", "ul", "var"]
    }
      , AO = {}.hasOwnProperty;
    function CO(e, t) {
        if (t && "object" == typeof t) {
            const n = t;
            switch ("string" == typeof n.type ? n.type : "") {
            case "comment":
                return function(e, t) {
                    if (e.schema.allowComments) {
                        const e = "string" == typeof t.value ? t.value : ""
                          , n = e.indexOf("--\x3e")
                          , r = {
                            type: "comment",
                            value: n < 0 ? e : e.slice(0, n)
                        };
                        return NO(r, t),
                        r
                    }
                }(e, n);
            case "doctype":
                return function(e, t) {
                    if (e.schema.allowDoctypes) {
                        const e = {
                            type: "doctype"
                        };
                        return NO(e, t),
                        e
                    }
                }(e, n);
            case "element":
                return function(e, t) {
                    const n = "string" == typeof t.tagName ? t.tagName : "";
                    e.stack.push(n);
                    const r = PO(e, t.children)
                      , o = function(e, t) {
                        const n = e.stack[e.stack.length - 1]
                          , r = e.schema.attributes
                          , o = e.schema.required
                          , i = r && AO.call(r, n) ? r[n] : void 0
                          , a = r && AO.call(r, "*") ? r["*"] : void 0
                          , s = t && "object" == typeof t ? t : {}
                          , l = {};
                        let c;
                        for (c in s)
                            if (AO.call(s, c)) {
                                const t = s[c];
                                let n = DO(e, $O(i, c), c, t);
                                null == n && (n = DO(e, $O(a, c), c, t)),
                                null != n && (l[c] = n)
                            }
                        if (o && AO.call(o, n)) {
                            const e = o[n];
                            for (c in e)
                                AO.call(e, c) && !AO.call(l, c) && (l[c] = e[c])
                        }
                        return l
                    }(e, t.properties);
                    e.stack.pop();
                    let i = !1;
                    if (n && "*" !== n && (!e.schema.tagNames || e.schema.tagNames.includes(n)) && (i = !0,
                    e.schema.ancestors && AO.call(e.schema.ancestors, n))) {
                        const t = e.schema.ancestors[n];
                        let r = -1;
                        for (i = !1; ++r < t.length; )
                            e.stack.includes(t[r]) && (i = !0)
                    }
                    if (!i)
                        return e.schema.strip && !e.schema.strip.includes(n) ? r : void 0;
                    const a = {
                        type: "element",
                        tagName: n,
                        properties: o,
                        children: r
                    };
                    return NO(a, t),
                    a
                }(e, n);
            case "root":
                return function(e, t) {
                    const n = PO(e, t.children)
                      , r = {
                        type: "root",
                        children: n
                    };
                    return NO(r, t),
                    r
                }(e, n);
            case "text":
                return function(e, t) {
                    const n = "string" == typeof t.value ? t.value : ""
                      , r = {
                        type: "text",
                        value: n
                    };
                    return NO(r, t),
                    r
                }(0, n)
            }
        }
    }
    function PO(e, t) {
        const n = [];
        if (Array.isArray(t)) {
            const r = t;
            let o = -1;
            for (; ++o < r.length; ) {
                const t = CO(e, r[o]);
                t && (Array.isArray(t) ? n.push(...t) : n.push(t))
            }
        }
        return n
    }
    function DO(e, t, n, r) {
        return t ? Array.isArray(r) ? function(e, t, n, r) {
            let o = -1;
            const i = [];
            for (; ++o < r.length; ) {
                const a = RO(e, t, n, r[o]);
                "number" != typeof a && "string" != typeof a || i.push(a)
            }
            return i
        }(e, t, n, r) : RO(e, t, n, r) : void 0
    }
    function RO(e, t, n, r) {
        if (("boolean" == typeof r || "number" == typeof r || "string" == typeof r) && function(e, t, n) {
            const r = e.schema.protocols && AO.call(e.schema.protocols, t) ? e.schema.protocols[t] : void 0;
            if (!r || 0 === r.length)
                return !0;
            const o = String(n)
              , i = o.indexOf(":")
              , a = o.indexOf("?")
              , s = o.indexOf("#")
              , l = o.indexOf("/");
            if (i < 0 || l > -1 && i > l || a > -1 && i > a || s > -1 && i > s)
                return !0;
            let c = -1;
            for (; ++c < r.length; ) {
                const e = r[c];
                if (i === e.length && o.slice(0, e.length) === e)
                    return !0
            }
            return !1
        }(e, n, r)) {
            if ("object" == typeof t && t.length > 1) {
                let e = !1
                  , n = 0;
                for (; ++n < t.length; ) {
                    const o = t[n];
                    if (o && "object" == typeof o && "flags"in o) {
                        if (o.test(String(r))) {
                            e = !0;
                            break
                        }
                    } else if (o === r) {
                        e = !0;
                        break
                    }
                }
                if (!e)
                    return
            }
            return e.schema.clobber && e.schema.clobberPrefix && e.schema.clobber.includes(n) ? e.schema.clobberPrefix + r : r
        }
    }
    function NO(e, t) {
        const n = cO(t);
        t.data && (e.data = dh(t.data)),
        n && (e.position = n)
    }
    function $O(e, t) {
        let n, r = -1;
        if (e)
            for (; ++r < e.length; ) {
                const o = e[r]
                  , i = "string" == typeof o ? o : o[0];
                if (i === t)
                    return o;
                "data*" === i && (n = o)
            }
        if (t.length > 4 && "data" === t.slice(0, 4).toLowerCase())
            return n
    }
    function IO(e) {
        return function(t) {
            const n = function(e, t) {
                let n = {
                    type: "root",
                    children: []
                };
                const r = CO({
                    schema: t ? {
                        ...TO,
                        ...t
                    } : TO,
                    stack: []
                }, e);
                return r && (Array.isArray(r) ? 1 === r.length ? n = r[0] : n.children = r : n = r),
                n
            }(t, e);
            return n
        }
    }
    const MO = /["&'<>`]/g
      , LO = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g
      , QO = /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
      , BO = /[|\\{}()[\]^$+*?.]/g
      , UO = new WeakMap;
    function FO(e, t) {
        return e = e.replace(t.subset ? function(e) {
            let t = UO.get(e);
            t || (t = function(e) {
                const t = [];
                let n = -1;
                for (; ++n < e.length; )
                    t.push(e[n].replace(BO, "\\$&"));
                return new RegExp("(?:" + t.join("|") + ")","g")
            }(e),
            UO.set(e, t));
            return t
        }(t.subset) : MO, n),
        t.subset || t.escapeOnly ? e : e.replace(LO, (function(e, n, r) {
            return t.format(1024 * (e.charCodeAt(0) - 55296) + e.charCodeAt(1) - 56320 + 65536, r.charCodeAt(n + 2), t)
        }
        )).replace(QO, n);
        function n(e, n, r) {
            return t.format(e.charCodeAt(0), r.charCodeAt(n + 1), t)
        }
    }
    const jO = /[\dA-Fa-f]/;
    const zO = /\d/;
    const qO = ["AElig", "AMP", "Aacute", "Acirc", "Agrave", "Aring", "Atilde", "Auml", "COPY", "Ccedil", "ETH", "Eacute", "Ecirc", "Egrave", "Euml", "GT", "Iacute", "Icirc", "Igrave", "Iuml", "LT", "Ntilde", "Oacute", "Ocirc", "Ograve", "Oslash", "Otilde", "Ouml", "QUOT", "REG", "THORN", "Uacute", "Ucirc", "Ugrave", "Uuml", "Yacute", "aacute", "acirc", "acute", "aelig", "agrave", "amp", "aring", "atilde", "auml", "brvbar", "ccedil", "cedil", "cent", "copy", "curren", "deg", "divide", "eacute", "ecirc", "egrave", "eth", "euml", "frac12", "frac14", "frac34", "gt", "iacute", "icirc", "iexcl", "igrave", "iquest", "iuml", "laquo", "lt", "macr", "micro", "middot", "nbsp", "not", "ntilde", "oacute", "ocirc", "ograve", "ordf", "ordm", "oslash", "otilde", "ouml", "para", "plusmn", "pound", "quot", "raquo", "reg", "sect", "shy", "sup1", "sup2", "sup3", "szlig", "thorn", "times", "uacute", "ucirc", "ugrave", "uml", "uuml", "yacute", "yen", "yuml"]
      , HO = {
        nbsp: " ",
        iexcl: "¡",
        cent: "¢",
        pound: "£",
        curren: "¤",
        yen: "¥",
        brvbar: "¦",
        sect: "§",
        uml: "¨",
        copy: "©",
        ordf: "ª",
        laquo: "«",
        not: "¬",
        shy: "­",
        reg: "®",
        macr: "¯",
        deg: "°",
        plusmn: "±",
        sup2: "²",
        sup3: "³",
        acute: "´",
        micro: "µ",
        para: "¶",
        middot: "·",
        cedil: "¸",
        sup1: "¹",
        ordm: "º",
        raquo: "»",
        frac14: "¼",
        frac12: "½",
        frac34: "¾",
        iquest: "¿",
        Agrave: "À",
        Aacute: "Á",
        Acirc: "Â",
        Atilde: "Ã",
        Auml: "Ä",
        Aring: "Å",
        AElig: "Æ",
        Ccedil: "Ç",
        Egrave: "È",
        Eacute: "É",
        Ecirc: "Ê",
        Euml: "Ë",
        Igrave: "Ì",
        Iacute: "Í",
        Icirc: "Î",
        Iuml: "Ï",
        ETH: "Ð",
        Ntilde: "Ñ",
        Ograve: "Ò",
        Oacute: "Ó",
        Ocirc: "Ô",
        Otilde: "Õ",
        Ouml: "Ö",
        times: "×",
        Oslash: "Ø",
        Ugrave: "Ù",
        Uacute: "Ú",
        Ucirc: "Û",
        Uuml: "Ü",
        Yacute: "Ý",
        THORN: "Þ",
        szlig: "ß",
        agrave: "à",
        aacute: "á",
        acirc: "â",
        atilde: "ã",
        auml: "ä",
        aring: "å",
        aelig: "æ",
        ccedil: "ç",
        egrave: "è",
        eacute: "é",
        ecirc: "ê",
        euml: "ë",
        igrave: "ì",
        iacute: "í",
        icirc: "î",
        iuml: "ï",
        eth: "ð",
        ntilde: "ñ",
        ograve: "ò",
        oacute: "ó",
        ocirc: "ô",
        otilde: "õ",
        ouml: "ö",
        divide: "÷",
        oslash: "ø",
        ugrave: "ù",
        uacute: "ú",
        ucirc: "û",
        uuml: "ü",
        yacute: "ý",
        thorn: "þ",
        yuml: "ÿ",
        fnof: "ƒ",
        Alpha: "Α",
        Beta: "Β",
        Gamma: "Γ",
        Delta: "Δ",
        Epsilon: "Ε",
        Zeta: "Ζ",
        Eta: "Η",
        Theta: "Θ",
        Iota: "Ι",
        Kappa: "Κ",
        Lambda: "Λ",
        Mu: "Μ",
        Nu: "Ν",
        Xi: "Ξ",
        Omicron: "Ο",
        Pi: "Π",
        Rho: "Ρ",
        Sigma: "Σ",
        Tau: "Τ",
        Upsilon: "Υ",
        Phi: "Φ",
        Chi: "Χ",
        Psi: "Ψ",
        Omega: "Ω",
        alpha: "α",
        beta: "β",
        gamma: "γ",
        delta: "δ",
        epsilon: "ε",
        zeta: "ζ",
        eta: "η",
        theta: "θ",
        iota: "ι",
        kappa: "κ",
        lambda: "λ",
        mu: "μ",
        nu: "ν",
        xi: "ξ",
        omicron: "ο",
        pi: "π",
        rho: "ρ",
        sigmaf: "ς",
        sigma: "σ",
        tau: "τ",
        upsilon: "υ",
        phi: "φ",
        chi: "χ",
        psi: "ψ",
        omega: "ω",
        thetasym: "ϑ",
        upsih: "ϒ",
        piv: "ϖ",
        bull: "•",
        hellip: "…",
        prime: "′",
        Prime: "″",
        oline: "‾",
        frasl: "⁄",
        weierp: "℘",
        image: "ℑ",
        real: "ℜ",
        trade: "™",
        alefsym: "ℵ",
        larr: "←",
        uarr: "↑",
        rarr: "→",
        darr: "↓",
        harr: "↔",
        crarr: "↵",
        lArr: "⇐",
        uArr: "⇑",
        rArr: "⇒",
        dArr: "⇓",
        hArr: "⇔",
        forall: "∀",
        part: "∂",
        exist: "∃",
        empty: "∅",
        nabla: "∇",
        isin: "∈",
        notin: "∉",
        ni: "∋",
        prod: "∏",
        sum: "∑",
        minus: "−",
        lowast: "∗",
        radic: "√",
        prop: "∝",
        infin: "∞",
        ang: "∠",
        and: "∧",
        or: "∨",
        cap: "∩",
        cup: "∪",
        int: "∫",
        there4: "∴",
        sim: "∼",
        cong: "≅",
        asymp: "≈",
        ne: "≠",
        equiv: "≡",
        le: "≤",
        ge: "≥",
        sub: "⊂",
        sup: "⊃",
        nsub: "⊄",
        sube: "⊆",
        supe: "⊇",
        oplus: "⊕",
        otimes: "⊗",
        perp: "⊥",
        sdot: "⋅",
        lceil: "⌈",
        rceil: "⌉",
        lfloor: "⌊",
        rfloor: "⌋",
        lang: "〈",
        rang: "〉",
        loz: "◊",
        spades: "♠",
        clubs: "♣",
        hearts: "♥",
        diams: "♦",
        quot: '"',
        amp: "&",
        lt: "<",
        gt: ">",
        OElig: "Œ",
        oelig: "œ",
        Scaron: "Š",
        scaron: "š",
        Yuml: "Ÿ",
        circ: "ˆ",
        tilde: "˜",
        ensp: " ",
        emsp: " ",
        thinsp: " ",
        zwnj: "‌",
        zwj: "‍",
        lrm: "‎",
        rlm: "‏",
        ndash: "–",
        mdash: "—",
        lsquo: "‘",
        rsquo: "’",
        sbquo: "‚",
        ldquo: "“",
        rdquo: "”",
        bdquo: "„",
        dagger: "†",
        Dagger: "‡",
        permil: "‰",
        lsaquo: "‹",
        rsaquo: "›",
        euro: "€"
    }
      , ZO = ["cent", "copy", "divide", "gt", "lt", "not", "para", "times"]
      , WO = {}.hasOwnProperty
      , XO = {};
    let VO;
    for (VO in HO)
        WO.call(HO, VO) && (XO[HO[VO]] = VO);
    const GO = /[^\dA-Za-z]/;
    function YO(e, t, n) {
        let r, o = function(e, t, n) {
            const r = "&#x" + e.toString(16).toUpperCase();
            return n && t && !jO.test(String.fromCharCode(t)) ? r : r + ";"
        }(e, t, n.omitOptionalSemicolons);
        if ((n.useNamedReferences || n.useShortestReferences) && (r = function(e, t, n, r) {
            const o = String.fromCharCode(e);
            if (WO.call(XO, o)) {
                const e = XO[o]
                  , i = "&" + e;
                return n && qO.includes(e) && !ZO.includes(e) && (!r || t && 61 !== t && GO.test(String.fromCharCode(t))) ? i : i + ";"
            }
            return ""
        }(e, t, n.omitOptionalSemicolons, n.attribute)),
        (n.useShortestReferences || !r) && n.useShortestReferences) {
            const r = function(e, t, n) {
                const r = "&#" + String(e);
                return n && t && !zO.test(String.fromCharCode(t)) ? r : r + ";"
            }(e, t, n.omitOptionalSemicolons);
            r.length < o.length && (o = r)
        }
        return r && (!n.useShortestReferences || r.length < o.length) ? r : o
    }
    function KO(e, t) {
        return FO(e, Object.assign({
            format: YO
        }, t))
    }
    const JO = /^>|^->|<!--|-->|--!>|<!-$/g
      , ev = [">"]
      , tv = ["<", ">"];
    function nv(e, t) {
        const n = String(e);
        if ("string" != typeof t)
            throw new TypeError("Expected character");
        let r = 0
          , o = n.indexOf(t);
        for (; -1 !== o; )
            r++,
            o = n.indexOf(t, o + t.length);
        return r
    }
    const rv = av(1)
      , ov = av(-1)
      , iv = [];
    function av(e) {
        return function(t, n, r) {
            const o = t ? t.children : iv;
            let i = (n || 0) + e
              , a = o[i];
            if (!r)
                for (; a && Ah(a); )
                    i += e,
                    a = o[i];
            return a
        }
    }
    const sv = {}.hasOwnProperty;
    function lv(e) {
        return function(t, n, r) {
            return sv.call(e, t.tagName) && e[t.tagName](t, n, r)
        }
    }
    const cv = lv({
        body: function(e, t, n) {
            const r = rv(n, t);
            return !r || "comment" !== r.type
        },
        caption: uv,
        colgroup: uv,
        dd: function(e, t, n) {
            const r = rv(n, t);
            return !r || "element" === r.type && ("dt" === r.tagName || "dd" === r.tagName)
        },
        dt: function(e, t, n) {
            const r = rv(n, t);
            return Boolean(r && "element" === r.type && ("dt" === r.tagName || "dd" === r.tagName))
        },
        head: uv,
        html: function(e, t, n) {
            const r = rv(n, t);
            return !r || "comment" !== r.type
        },
        li: function(e, t, n) {
            const r = rv(n, t);
            return !r || "element" === r.type && "li" === r.tagName
        },
        optgroup: function(e, t, n) {
            const r = rv(n, t);
            return !r || "element" === r.type && "optgroup" === r.tagName
        },
        option: function(e, t, n) {
            const r = rv(n, t);
            return !r || "element" === r.type && ("option" === r.tagName || "optgroup" === r.tagName)
        },
        p: function(e, t, n) {
            const r = rv(n, t);
            return r ? "element" === r.type && ("address" === r.tagName || "article" === r.tagName || "aside" === r.tagName || "blockquote" === r.tagName || "details" === r.tagName || "div" === r.tagName || "dl" === r.tagName || "fieldset" === r.tagName || "figcaption" === r.tagName || "figure" === r.tagName || "footer" === r.tagName || "form" === r.tagName || "h1" === r.tagName || "h2" === r.tagName || "h3" === r.tagName || "h4" === r.tagName || "h5" === r.tagName || "h6" === r.tagName || "header" === r.tagName || "hgroup" === r.tagName || "hr" === r.tagName || "main" === r.tagName || "menu" === r.tagName || "nav" === r.tagName || "ol" === r.tagName || "p" === r.tagName || "pre" === r.tagName || "section" === r.tagName || "table" === r.tagName || "ul" === r.tagName) : !n || !("element" === n.type && ("a" === n.tagName || "audio" === n.tagName || "del" === n.tagName || "ins" === n.tagName || "map" === n.tagName || "noscript" === n.tagName || "video" === n.tagName))
        },
        rp: dv,
        rt: dv,
        tbody: function(e, t, n) {
            const r = rv(n, t);
            return !r || "element" === r.type && ("tbody" === r.tagName || "tfoot" === r.tagName)
        },
        td: pv,
        tfoot: function(e, t, n) {
            return !rv(n, t)
        },
        th: pv,
        thead: function(e, t, n) {
            const r = rv(n, t);
            return Boolean(r && "element" === r.type && ("tbody" === r.tagName || "tfoot" === r.tagName))
        },
        tr: function(e, t, n) {
            const r = rv(n, t);
            return !r || "element" === r.type && "tr" === r.tagName
        }
    });
    function uv(e, t, n) {
        const r = rv(n, t, !0);
        return !r || "comment" !== r.type && !("text" === r.type && Ah(r.value.charAt(0)))
    }
    function dv(e, t, n) {
        const r = rv(n, t);
        return !r || "element" === r.type && ("rp" === r.tagName || "rt" === r.tagName)
    }
    function pv(e, t, n) {
        const r = rv(n, t);
        return !r || "element" === r.type && ("td" === r.tagName || "th" === r.tagName)
    }
    const hv = lv({
        body: function(e) {
            const t = rv(e, -1, !0);
            return !(t && ("comment" === t.type || "text" === t.type && Ah(t.value.charAt(0)) || "element" === t.type && ("meta" === t.tagName || "link" === t.tagName || "script" === t.tagName || "style" === t.tagName || "template" === t.tagName)))
        },
        colgroup: function(e, t, n) {
            const r = ov(n, t)
              , o = rv(e, -1, !0);
            if (n && r && "element" === r.type && "colgroup" === r.tagName && cv(r, n.children.indexOf(r), n))
                return !1;
            return Boolean(o && "element" === o.type && "col" === o.tagName)
        },
        head: function(e) {
            const t = e.children
              , n = [];
            let r = -1;
            for (; ++r < t.length; ) {
                const e = t[r];
                if ("element" === e.type && ("title" === e.tagName || "base" === e.tagName)) {
                    if (n.includes(e.tagName))
                        return !1;
                    n.push(e.tagName)
                }
            }
            return t.length > 0
        },
        html: function(e) {
            const t = rv(e, -1);
            return !t || "comment" !== t.type
        },
        tbody: function(e, t, n) {
            const r = ov(n, t)
              , o = rv(e, -1);
            if (n && r && "element" === r.type && ("thead" === r.tagName || "tbody" === r.tagName) && cv(r, n.children.indexOf(r), n))
                return !1;
            return Boolean(o && "element" === o.type && "tr" === o.tagName)
        }
    });
    const fv = {
        name: [["\t\n\f\r &/=>".split(""), "\t\n\f\r \"&'/=>`".split("")], ["\0\t\n\f\r \"&'/<=>".split(""), "\0\t\n\f\r \"&'/<=>`".split("")]],
        unquoted: [["\t\n\f\r &>".split(""), "\0\t\n\f\r \"&'<=>`".split("")], ["\0\t\n\f\r \"&'<=>`".split(""), "\0\t\n\f\r \"&'<=>`".split("")]],
        single: [["&'".split(""), "\"&'`".split("")], ["\0&'".split(""), "\0\"&'`".split("")]],
        double: [['"&'.split(""), "\"&'`".split("")], ['\0"&'.split(""), "\0\"&'`".split("")]]
    };
    function mv(e, t, n) {
        const r = xf(e.schema, t)
          , o = e.settings.allowParseErrors && "html" === e.schema.space ? 0 : 1
          , i = e.settings.allowDangerousCharacters ? 0 : 1;
        let a, s = e.quote;
        if (!r.overloadedBoolean || n !== r.attribute && "" !== n ? (r.boolean || r.overloadedBoolean && "string" != typeof n) && (n = Boolean(n)) : n = !0,
        null == n || !1 === n || "number" == typeof n && Number.isNaN(n))
            return "";
        const l = KO(r.attribute, Object.assign({}, e.settings.characterReferences, {
            subset: fv.name[o][i]
        }));
        return !0 === n ? l : (n = Array.isArray(n) ? (r.commaSeparated ? Rf : mh)(n, {
            padLeft: !e.settings.tightCommaSeparatedLists
        }) : String(n),
        e.settings.collapseEmptyAttributes && !n ? l : (e.settings.preferUnquoted && (a = KO(n, Object.assign({}, e.settings.characterReferences, {
            attribute: !0,
            subset: fv.unquoted[o][i]
        }))),
        a !== n && (e.settings.quoteSmart && nv(n, s) > nv(n, e.alternative) && (s = e.alternative),
        a = s + KO(n, Object.assign({}, e.settings.characterReferences, {
            subset: ("'" === s ? fv.single : fv.double)[o][i],
            attribute: !0
        })) + s),
        l + (a ? "=" + a : a)))
    }
    const gv = ["<", "&"];
    function bv(e, t, n, r) {
        return !n || "element" !== n.type || "script" !== n.tagName && "style" !== n.tagName ? KO(e.value, Object.assign({}, r.settings.characterReferences, {
            subset: gv
        })) : e.value
    }
    const Ov = Jf("type", {
        invalid: function(e) {
            throw new Error("Expected node, not `" + e + "`")
        },
        unknown: function(e) {
            throw new Error("Cannot compile unknown node `" + e.type + "`")
        },
        handlers: {
            comment: function(e, t, n, r) {
                return r.settings.bogusComments ? "<?" + KO(e.value, Object.assign({}, r.settings.characterReferences, {
                    subset: ev
                })) + ">" : "\x3c!--" + e.value.replace(JO, (function(e) {
                    return KO(e, Object.assign({}, r.settings.characterReferences, {
                        subset: tv
                    }))
                }
                )) + "--\x3e"
            },
            doctype: function(e, t, n, r) {
                return "<!" + (r.settings.upperDoctype ? "DOCTYPE" : "doctype") + (r.settings.tightDoctype ? "" : " ") + "html>"
            },
            element: function(e, t, n, r) {
                const o = r.schema
                  , i = "svg" !== o.space && r.settings.omitOptionalTags;
                let a = "svg" === o.space ? r.settings.closeEmptyElements : r.settings.voids.includes(e.tagName.toLowerCase());
                const s = [];
                let l;
                "html" === o.space && "svg" === e.tagName && (r.schema = Pf);
                const c = function(e, t) {
                    const n = [];
                    let r, o = -1;
                    if (t)
                        for (r in t)
                            if (null !== t[r] && void 0 !== t[r]) {
                                const o = mv(e, r, t[r]);
                                o && n.push(o)
                            }
                    for (; ++o < n.length; ) {
                        const t = e.settings.tightAttributes ? n[o].charAt(n[o].length - 1) : void 0;
                        o !== n.length - 1 && '"' !== t && "'" !== t && (n[o] += " ")
                    }
                    return n.join("")
                }(r, e.properties)
                  , u = r.all("html" === o.space && "template" === e.tagName ? e.content : e);
                return r.schema = o,
                u && (a = !1),
                !c && i && hv(e, t, n) || (s.push("<", e.tagName, c ? " " + c : ""),
                a && ("svg" === o.space || r.settings.closeSelfClosing) && (l = c.charAt(c.length - 1),
                (!r.settings.tightSelfClosing || "/" === l || l && '"' !== l && "'" !== l) && s.push(" "),
                s.push("/")),
                s.push(">")),
                s.push(u),
                a || i && cv(e, t, n) || s.push("</" + e.tagName + ">"),
                s.join("")
            },
            raw: function(e, t, n, r) {
                return r.settings.allowDangerousHtml ? e.value : bv(e, 0, n, r)
            },
            root: function(e, t, n, r) {
                return r.all(e)
            },
            text: bv
        }
    });
    const vv = {}
      , yv = {}
      , wv = [];
    function _v(e, t, n) {
        return Ov(e, t, n, this)
    }
    function kv(e) {
        const t = []
          , n = e && e.children || wv;
        let r = -1;
        for (; ++r < n.length; )
            t[r] = this.one(n[r], r, e);
        return t.join("")
    }
    function Sv(e) {
        const t = {
            ...this.data("settings"),
            ...e
        };
        this.compiler = function(e) {
            return function(e, t) {
                const n = t || vv
                  , r = n.quote || '"'
                  , o = '"' === r ? "'" : '"';
                if ('"' !== r && "'" !== r)
                    throw new Error("Invalid quote `" + r + "`, expected `'` or `\"`");
                return {
                    one: _v,
                    all: kv,
                    settings: {
                        omitOptionalTags: n.omitOptionalTags || !1,
                        allowParseErrors: n.allowParseErrors || !1,
                        allowDangerousCharacters: n.allowDangerousCharacters || !1,
                        quoteSmart: n.quoteSmart || !1,
                        preferUnquoted: n.preferUnquoted || !1,
                        tightAttributes: n.tightAttributes || !1,
                        upperDoctype: n.upperDoctype || !1,
                        tightDoctype: n.tightDoctype || !1,
                        bogusComments: n.bogusComments || !1,
                        tightCommaSeparatedLists: n.tightCommaSeparatedLists || !1,
                        tightSelfClosing: n.tightSelfClosing || !1,
                        collapseEmptyAttributes: n.collapseEmptyAttributes || !1,
                        allowDangerousHtml: n.allowDangerousHtml || !1,
                        voids: n.voids || am,
                        characterReferences: n.characterReferences || yv,
                        closeSelfClosing: n.closeSelfClosing || !1,
                        closeEmptyElements: n.closeEmptyElements || !1
                    },
                    schema: "svg" === n.space ? Pf : Cf,
                    quote: r,
                    alternative: o
                }.one(Array.isArray(e) ? {
                    type: "root",
                    children: e
                } : e, void 0, void 0)
            }(e, t)
        }
    }
    const Ev = Lv(/[A-Za-z]/)
      , xv = Lv(/[\dA-Za-z]/)
      , Tv = Lv(/[#-'*+\--9=?A-Z^-~]/);
    function Av(e) {
        return null !== e && (e < 32 || 127 === e)
    }
    const Cv = Lv(/\d/)
      , Pv = Lv(/[\dA-Fa-f]/)
      , Dv = Lv(/[!-/:-@[-`{-~]/);
    function Rv(e) {
        return null !== e && e < -2
    }
    function Nv(e) {
        return null !== e && (e < 0 || 32 === e)
    }
    function $v(e) {
        return -2 === e || -1 === e || 32 === e
    }
    const Iv = Lv(new RegExp("\\p{P}|\\p{S}","u"))
      , Mv = Lv(/\s/);
    function Lv(e) {
        return function(t) {
            return null !== t && t > -1 && e.test(String.fromCharCode(t))
        }
    }
    function Qv(e, t, n) {
        const r = tu((n || {}).ignore || [])
          , o = function(e) {
            const t = [];
            if (!Array.isArray(e))
                throw new TypeError("Expected find and replace tuple or list of tuples");
            const n = !e[0] || Array.isArray(e[0]) ? e : [e];
            let r = -1;
            for (; ++r < n.length; ) {
                const e = n[r];
                t.push([Bv(e[0]), Uv(e[1])])
            }
            return t
        }(t);
        let i = -1;
        for (; ++i < o.length; )
            Jp(e, "text", a);
        function a(e, t) {
            let n, a = -1;
            for (; ++a < t.length; ) {
                const e = t[a]
                  , o = n ? n.children : void 0;
                if (r(e, o ? o.indexOf(e) : void 0, n))
                    return;
                n = e
            }
            if (n)
                return function(e, t) {
                    const n = t[t.length - 1]
                      , r = o[i][0]
                      , a = o[i][1];
                    let s = 0;
                    const l = n.children.indexOf(e);
                    let c = !1
                      , u = [];
                    r.lastIndex = 0;
                    let d = r.exec(e.value);
                    for (; d; ) {
                        const n = d.index
                          , o = {
                            index: d.index,
                            input: d.input,
                            stack: [...t, e]
                        };
                        let i = a(...d, o);
                        if ("string" == typeof i && (i = i.length > 0 ? {
                            type: "text",
                            value: i
                        } : void 0),
                        !1 === i ? r.lastIndex = n + 1 : (s !== n && u.push({
                            type: "text",
                            value: e.value.slice(s, n)
                        }),
                        Array.isArray(i) ? u.push(...i) : i && u.push(i),
                        s = n + d[0].length,
                        c = !0),
                        !r.global)
                            break;
                        d = r.exec(e.value)
                    }
                    c ? (s < e.value.length && u.push({
                        type: "text",
                        value: e.value.slice(s)
                    }),
                    n.children.splice(l, 1, ...u)) : u = [e];
                    return l + u.length
                }(e, t)
        }
    }
    function Bv(e) {
        return "string" == typeof e ? new RegExp(function(e) {
            if ("string" != typeof e)
                throw new TypeError("Expected a string");
            return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d")
        }(e),"g") : e
    }
    function Uv(e) {
        return "function" == typeof e ? e : function() {
            return e
        }
    }
    const Fv = "phrasing"
      , jv = ["autolink", "link", "image", "label"];
    function zv(e) {
        this.enter({
            type: "link",
            title: null,
            url: "",
            children: []
        }, e)
    }
    function qv(e) {
        this.config.enter.autolinkProtocol.call(this, e)
    }
    function Hv(e) {
        this.config.exit.autolinkProtocol.call(this, e)
    }
    function Zv(e) {
        this.config.exit.data.call(this, e);
        const t = this.stack[this.stack.length - 1];
        t.type,
        t.url = "http://" + this.sliceSerialize(e)
    }
    function Wv(e) {
        this.config.exit.autolinkEmail.call(this, e)
    }
    function Xv(e) {
        this.exit(e)
    }
    function Vv(e) {
        Qv(e, [[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, Gv], [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, Yv]], {
            ignore: ["link", "linkReference"]
        })
    }
    function Gv(e, t, n, r, o) {
        let i = "";
        if (!Kv(o))
            return !1;
        if (/^w/i.test(t) && (n = t + n,
        t = "",
        i = "http://"),
        !function(e) {
            const t = e.split(".");
            if (t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])))
                return !1;
            return !0
        }(n))
            return !1;
        const a = function(e) {
            const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
            if (!t)
                return [e, void 0];
            e = e.slice(0, t.index);
            let n = t[0]
              , r = n.indexOf(")");
            const o = nv(e, "(");
            let i = nv(e, ")");
            for (; -1 !== r && o > i; )
                e += n.slice(0, r + 1),
                n = n.slice(r + 1),
                r = n.indexOf(")"),
                i++;
            return [e, n]
        }(n + r);
        if (!a[0])
            return !1;
        const s = {
            type: "link",
            title: null,
            url: i + t + a[0],
            children: [{
                type: "text",
                value: t + a[0]
            }]
        };
        return a[1] ? [s, {
            type: "text",
            value: a[1]
        }] : s
    }
    function Yv(e, t, n, r) {
        return !(!Kv(r, !0) || /[-\d_]$/.test(n)) && {
            type: "link",
            title: null,
            url: "mailto:" + t + "@" + n,
            children: [{
                type: "text",
                value: t + "@" + n
            }]
        }
    }
    function Kv(e, t) {
        const n = e.input.charCodeAt(e.index - 1);
        return (0 === e.index || Mv(n) || Iv(n)) && (!t || 47 !== n)
    }
    function Jv(e) {
        return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase()
    }
    function ey(e) {
        this.enter({
            type: "footnoteDefinition",
            identifier: "",
            label: "",
            children: []
        }, e)
    }
    function ty() {
        this.buffer()
    }
    function ny(e) {
        const t = this.resume()
          , n = this.stack[this.stack.length - 1];
        n.type,
        n.label = t,
        n.identifier = Jv(this.sliceSerialize(e)).toLowerCase()
    }
    function ry(e) {
        this.exit(e)
    }
    function oy(e) {
        this.enter({
            type: "footnoteReference",
            identifier: "",
            label: ""
        }, e)
    }
    function iy() {
        this.buffer()
    }
    function ay(e) {
        const t = this.resume()
          , n = this.stack[this.stack.length - 1];
        n.type,
        n.label = t,
        n.identifier = Jv(this.sliceSerialize(e)).toLowerCase()
    }
    function sy(e) {
        this.exit(e)
    }
    function ly(e, t, n, r) {
        const o = n.createTracker(r);
        let i = o.move("[^");
        const a = n.enter("footnoteReference")
          , s = n.enter("reference");
        return i += o.move(n.safe(n.associationId(e), {
            ...o.current(),
            before: i,
            after: "]"
        })),
        s(),
        a(),
        i += o.move("]"),
        i
    }
    function cy(e, t, n, r) {
        const o = n.createTracker(r);
        let i = o.move("[^");
        const a = n.enter("footnoteDefinition")
          , s = n.enter("label");
        return i += o.move(n.safe(n.associationId(e), {
            ...o.current(),
            before: i,
            after: "]"
        })),
        s(),
        i += o.move("]:" + (e.children && e.children.length > 0 ? " " : "")),
        o.shift(4),
        i += o.move(n.indentLines(n.containerFlow(e, o.current()), uy)),
        a(),
        i
    }
    function uy(e, t, n) {
        return 0 === t ? e : (n ? "" : "    ") + e
    }
    ly.peek = function() {
        return "["
    }
    ;
    const dy = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"];
    function py(e) {
        this.enter({
            type: "delete",
            children: []
        }, e)
    }
    function hy(e) {
        this.exit(e)
    }
    function fy(e, t, n, r) {
        const o = n.createTracker(r)
          , i = n.enter("strikethrough");
        let a = o.move("~~");
        return a += n.containerPhrasing(e, {
            ...o.current(),
            before: a,
            after: "~"
        }),
        a += o.move("~~"),
        i(),
        a
    }
    function my(e) {
        return e.length
    }
    function gy(e) {
        const t = "string" == typeof e ? e.codePointAt(0) : 0;
        return 67 === t || 99 === t ? 99 : 76 === t || 108 === t ? 108 : 82 === t || 114 === t ? 114 : 0
    }
    function by(e, t, n) {
        return ">" + (n ? "" : " ") + e
    }
    function Oy(e, t, n) {
        if ("string" == typeof t && (t = [t]),
        !t || 0 === t.length)
            return n;
        let r = -1;
        for (; ++r < t.length; )
            if (e.includes(t[r]))
                return !0;
        return !1
    }
    function vy(e, t, n, r) {
        let o = -1;
        for (; ++o < n.unsafe.length; )
            if ("\n" === n.unsafe[o].character && (i = n.stack,
            a = n.unsafe[o],
            Oy(i, a.inConstruct, !0) && !Oy(i, a.notInConstruct, !1)))
                return /[ \t]/.test(r.before) ? "" : " ";
        var i, a;
        return "\\\n"
    }
    function yy(e, t, n) {
        return (n ? "" : "    ") + e
    }
    function wy(e) {
        const t = e.options.quote || '"';
        if ('"' !== t && "'" !== t)
            throw new Error("Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`");
        return t
    }
    function _y(e, t, n, r) {
        const o = function(e) {
            const t = e.options.emphasis || "*";
            if ("*" !== t && "_" !== t)
                throw new Error("Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`");
            return t
        }(n)
          , i = n.enter("emphasis")
          , a = n.createTracker(r);
        let s = a.move(o);
        return s += a.move(n.containerPhrasing(e, {
            before: s,
            after: o,
            ...a.current()
        })),
        s += a.move(o),
        i(),
        s
    }
    fy.peek = function() {
        return "~"
    }
    ,
    _y.peek = function(e, t, n) {
        return n.options.emphasis || "*"
    }
    ;
    const ky = {};
    function Sy(e, t) {
        const n = ky;
        return Ey(e, "boolean" != typeof n.includeImageAlt || n.includeImageAlt, "boolean" != typeof n.includeHtml || n.includeHtml)
    }
    function Ey(e, t, n) {
        if (function(e) {
            return Boolean(e && "object" == typeof e)
        }(e)) {
            if ("value"in e)
                return "html" !== e.type || n ? e.value : "";
            if (t && "alt"in e && e.alt)
                return e.alt;
            if ("children"in e)
                return xy(e.children, t, n)
        }
        return Array.isArray(e) ? xy(e, t, n) : ""
    }
    function xy(e, t, n) {
        const r = [];
        let o = -1;
        for (; ++o < e.length; )
            r[o] = Ey(e[o], t, n);
        return r.join("")
    }
    function Ty(e) {
        return e.value || ""
    }
    function Ay(e, t, n, r) {
        const o = wy(n)
          , i = '"' === o ? "Quote" : "Apostrophe"
          , a = n.enter("image");
        let s = n.enter("label");
        const l = n.createTracker(r);
        let c = l.move("![");
        return c += l.move(n.safe(e.alt, {
            before: c,
            after: "]",
            ...l.current()
        })),
        c += l.move("]("),
        s(),
        !e.url && e.title || /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"),
        c += l.move("<"),
        c += l.move(n.safe(e.url, {
            before: c,
            after: ">",
            ...l.current()
        })),
        c += l.move(">")) : (s = n.enter("destinationRaw"),
        c += l.move(n.safe(e.url, {
            before: c,
            after: e.title ? " " : ")",
            ...l.current()
        }))),
        s(),
        e.title && (s = n.enter(`title${i}`),
        c += l.move(" " + o),
        c += l.move(n.safe(e.title, {
            before: c,
            after: o,
            ...l.current()
        })),
        c += l.move(o),
        s()),
        c += l.move(")"),
        a(),
        c
    }
    function Cy(e, t, n, r) {
        const o = e.referenceType
          , i = n.enter("imageReference");
        let a = n.enter("label");
        const s = n.createTracker(r);
        let l = s.move("![");
        const c = n.safe(e.alt, {
            before: l,
            after: "]",
            ...s.current()
        });
        l += s.move(c + "]["),
        a();
        const u = n.stack;
        n.stack = [],
        a = n.enter("reference");
        const d = n.safe(n.associationId(e), {
            before: l,
            after: "]",
            ...s.current()
        });
        return a(),
        n.stack = u,
        i(),
        "full" !== o && c && c === d ? "shortcut" === o ? l = l.slice(0, -1) : l += s.move("]") : l += s.move(d + "]"),
        l
    }
    function Py(e, t, n) {
        let r = e.value || ""
          , o = "`"
          , i = -1;
        for (; new RegExp("(^|[^`])" + o + "([^`]|$)").test(r); )
            o += "`";
        for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++i < n.unsafe.length; ) {
            const e = n.unsafe[i]
              , t = n.compilePattern(e);
            let o;
            if (e.atBreak)
                for (; o = t.exec(r); ) {
                    let e = o.index;
                    10 === r.charCodeAt(e) && 13 === r.charCodeAt(e - 1) && e--,
                    r = r.slice(0, e) + " " + r.slice(o.index + 1)
                }
        }
        return o + r + o
    }
    function Dy(e, t) {
        const n = Sy(e);
        return Boolean(!t.options.resourceLink && e.url && !e.title && e.children && 1 === e.children.length && "text" === e.children[0].type && (n === e.url || "mailto:" + n === e.url) && /^[a-z][a-z+.-]+:/i.test(e.url) && !/[\0- <>\u007F]/.test(e.url))
    }
    function Ry(e, t, n, r) {
        const o = wy(n)
          , i = '"' === o ? "Quote" : "Apostrophe"
          , a = n.createTracker(r);
        let s, l;
        if (Dy(e, n)) {
            const t = n.stack;
            n.stack = [],
            s = n.enter("autolink");
            let r = a.move("<");
            return r += a.move(n.containerPhrasing(e, {
                before: r,
                after: ">",
                ...a.current()
            })),
            r += a.move(">"),
            s(),
            n.stack = t,
            r
        }
        s = n.enter("link"),
        l = n.enter("label");
        let c = a.move("[");
        return c += a.move(n.containerPhrasing(e, {
            before: c,
            after: "](",
            ...a.current()
        })),
        c += a.move("]("),
        l(),
        !e.url && e.title || /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"),
        c += a.move("<"),
        c += a.move(n.safe(e.url, {
            before: c,
            after: ">",
            ...a.current()
        })),
        c += a.move(">")) : (l = n.enter("destinationRaw"),
        c += a.move(n.safe(e.url, {
            before: c,
            after: e.title ? " " : ")",
            ...a.current()
        }))),
        l(),
        e.title && (l = n.enter(`title${i}`),
        c += a.move(" " + o),
        c += a.move(n.safe(e.title, {
            before: c,
            after: o,
            ...a.current()
        })),
        c += a.move(o),
        l()),
        c += a.move(")"),
        s(),
        c
    }
    function Ny(e, t, n, r) {
        const o = e.referenceType
          , i = n.enter("linkReference");
        let a = n.enter("label");
        const s = n.createTracker(r);
        let l = s.move("[");
        const c = n.containerPhrasing(e, {
            before: l,
            after: "]",
            ...s.current()
        });
        l += s.move(c + "]["),
        a();
        const u = n.stack;
        n.stack = [],
        a = n.enter("reference");
        const d = n.safe(n.associationId(e), {
            before: l,
            after: "]",
            ...s.current()
        });
        return a(),
        n.stack = u,
        i(),
        "full" !== o && c && c === d ? "shortcut" === o ? l = l.slice(0, -1) : l += s.move("]") : l += s.move(d + "]"),
        l
    }
    function $y(e) {
        const t = e.options.bullet || "*";
        if ("*" !== t && "+" !== t && "-" !== t)
            throw new Error("Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`");
        return t
    }
    function Iy(e) {
        const t = e.options.rule || "*";
        if ("*" !== t && "-" !== t && "_" !== t)
            throw new Error("Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`");
        return t
    }
    Ty.peek = function() {
        return "<"
    }
    ,
    Ay.peek = function() {
        return "!"
    }
    ,
    Cy.peek = function() {
        return "!"
    }
    ,
    Py.peek = function() {
        return "`"
    }
    ,
    Ry.peek = function(e, t, n) {
        return Dy(e, n) ? "<" : "["
    }
    ,
    Ny.peek = function() {
        return "["
    }
    ;
    const My = tu(["break", "delete", "emphasis", "footnote", "footnoteReference", "image", "imageReference", "inlineCode", "inlineMath", "link", "linkReference", "mdxJsxTextElement", "mdxTextExpression", "strong", "text", "textDirective"]);
    function Ly(e, t, n, r) {
        const o = function(e) {
            const t = e.options.strong || "*";
            if ("*" !== t && "_" !== t)
                throw new Error("Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`");
            return t
        }(n)
          , i = n.enter("strong")
          , a = n.createTracker(r);
        let s = a.move(o + o);
        return s += a.move(n.containerPhrasing(e, {
            before: s,
            after: o,
            ...a.current()
        })),
        s += a.move(o + o),
        i(),
        s
    }
    Ly.peek = function(e, t, n) {
        return n.options.strong || "*"
    }
    ;
    const Qy = {
        blockquote: function(e, t, n, r) {
            const o = n.enter("blockquote")
              , i = n.createTracker(r);
            i.move("> "),
            i.shift(2);
            const a = n.indentLines(n.containerFlow(e, i.current()), by);
            return o(),
            a
        },
        break: vy,
        code: function(e, t, n, r) {
            const o = function(e) {
                const t = e.options.fence || "`";
                if ("`" !== t && "~" !== t)
                    throw new Error("Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`");
                return t
            }(n)
              , i = e.value || ""
              , a = "`" === o ? "GraveAccent" : "Tilde";
            if (function(e, t) {
                return Boolean(!1 === t.options.fences && e.value && !e.lang && /[^ \r\n]/.test(e.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value))
            }(e, n)) {
                const e = n.enter("codeIndented")
                  , t = n.indentLines(i, yy);
                return e(),
                t
            }
            const s = n.createTracker(r)
              , l = o.repeat(Math.max(function(e, t) {
                const n = String(e);
                let r = n.indexOf(t)
                  , o = r
                  , i = 0
                  , a = 0;
                if ("string" != typeof t)
                    throw new TypeError("Expected substring");
                for (; -1 !== r; )
                    r === o ? ++i > a && (a = i) : i = 1,
                    o = r + t.length,
                    r = n.indexOf(t, o);
                return a
            }(i, o) + 1, 3))
              , c = n.enter("codeFenced");
            let u = s.move(l);
            if (e.lang) {
                const t = n.enter(`codeFencedLang${a}`);
                u += s.move(n.safe(e.lang, {
                    before: u,
                    after: " ",
                    encode: ["`"],
                    ...s.current()
                })),
                t()
            }
            if (e.lang && e.meta) {
                const t = n.enter(`codeFencedMeta${a}`);
                u += s.move(" "),
                u += s.move(n.safe(e.meta, {
                    before: u,
                    after: "\n",
                    encode: ["`"],
                    ...s.current()
                })),
                t()
            }
            return u += s.move("\n"),
            i && (u += s.move(i + "\n")),
            u += s.move(l),
            c(),
            u
        },
        definition: function(e, t, n, r) {
            const o = wy(n)
              , i = '"' === o ? "Quote" : "Apostrophe"
              , a = n.enter("definition");
            let s = n.enter("label");
            const l = n.createTracker(r);
            let c = l.move("[");
            return c += l.move(n.safe(n.associationId(e), {
                before: c,
                after: "]",
                ...l.current()
            })),
            c += l.move("]: "),
            s(),
            !e.url || /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"),
            c += l.move("<"),
            c += l.move(n.safe(e.url, {
                before: c,
                after: ">",
                ...l.current()
            })),
            c += l.move(">")) : (s = n.enter("destinationRaw"),
            c += l.move(n.safe(e.url, {
                before: c,
                after: e.title ? " " : "\n",
                ...l.current()
            }))),
            s(),
            e.title && (s = n.enter(`title${i}`),
            c += l.move(" " + o),
            c += l.move(n.safe(e.title, {
                before: c,
                after: o,
                ...l.current()
            })),
            c += l.move(o),
            s()),
            a(),
            c
        },
        emphasis: _y,
        hardBreak: vy,
        heading: function(e, t, n, r) {
            const o = Math.max(Math.min(6, e.depth || 1), 1)
              , i = n.createTracker(r);
            if (function(e, t) {
                let n = !1;
                return eh(e, (function(e) {
                    if ("value"in e && /\r?\n|\r/.test(e.value) || "break" === e.type)
                        return n = !0,
                        Yp
                }
                )),
                Boolean((!e.depth || e.depth < 3) && Sy(e) && (t.options.setext || n))
            }(e, n)) {
                const t = n.enter("headingSetext")
                  , r = n.enter("phrasing")
                  , a = n.containerPhrasing(e, {
                    ...i.current(),
                    before: "\n",
                    after: "\n"
                });
                return r(),
                t(),
                a + "\n" + (1 === o ? "=" : "-").repeat(a.length - (Math.max(a.lastIndexOf("\r"), a.lastIndexOf("\n")) + 1))
            }
            const a = "#".repeat(o)
              , s = n.enter("headingAtx")
              , l = n.enter("phrasing");
            i.move(a + " ");
            let c = n.containerPhrasing(e, {
                before: "# ",
                after: "\n",
                ...i.current()
            });
            return /^[\t ]/.test(c) && (c = "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";" + c.slice(1)),
            c = c ? a + " " + c : a,
            n.options.closeAtx && (c += " " + a),
            l(),
            s(),
            c
        },
        html: Ty,
        image: Ay,
        imageReference: Cy,
        inlineCode: Py,
        link: Ry,
        linkReference: Ny,
        list: function(e, t, n, r) {
            const o = n.enter("list")
              , i = n.bulletCurrent;
            let a = e.ordered ? function(e) {
                const t = e.options.bulletOrdered || ".";
                if ("." !== t && ")" !== t)
                    throw new Error("Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`");
                return t
            }(n) : $y(n);
            const s = e.ordered ? "." === a ? ")" : "." : function(e) {
                const t = $y(e)
                  , n = e.options.bulletOther;
                if (!n)
                    return "*" === t ? "-" : "*";
                if ("*" !== n && "+" !== n && "-" !== n)
                    throw new Error("Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`");
                if (n === t)
                    throw new Error("Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different");
                return n
            }(n);
            let l = !(!t || !n.bulletLastUsed) && a === n.bulletLastUsed;
            if (!e.ordered) {
                const t = e.children ? e.children[0] : void 0;
                if ("*" !== a && "-" !== a || !t || t.children && t.children[0] || "list" !== n.stack[n.stack.length - 1] || "listItem" !== n.stack[n.stack.length - 2] || "list" !== n.stack[n.stack.length - 3] || "listItem" !== n.stack[n.stack.length - 4] || 0 !== n.indexStack[n.indexStack.length - 1] || 0 !== n.indexStack[n.indexStack.length - 2] || 0 !== n.indexStack[n.indexStack.length - 3] || (l = !0),
                Iy(n) === a && t) {
                    let t = -1;
                    for (; ++t < e.children.length; ) {
                        const n = e.children[t];
                        if (n && "listItem" === n.type && n.children && n.children[0] && "thematicBreak" === n.children[0].type) {
                            l = !0;
                            break
                        }
                    }
                }
            }
            l && (a = s),
            n.bulletCurrent = a;
            const c = n.containerFlow(e, r);
            return n.bulletLastUsed = a,
            n.bulletCurrent = i,
            o(),
            c
        },
        listItem: function(e, t, n, r) {
            const o = function(e) {
                const t = e.options.listItemIndent || "one";
                if ("tab" !== t && "one" !== t && "mixed" !== t)
                    throw new Error("Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`");
                return t
            }(n);
            let i = n.bulletCurrent || $y(n);
            t && "list" === t.type && t.ordered && (i = ("number" == typeof t.start && t.start > -1 ? t.start : 1) + (!1 === n.options.incrementListMarker ? 0 : t.children.indexOf(e)) + i);
            let a = i.length + 1;
            ("tab" === o || "mixed" === o && (t && "list" === t.type && t.spread || e.spread)) && (a = 4 * Math.ceil(a / 4));
            const s = n.createTracker(r);
            s.move(i + " ".repeat(a - i.length)),
            s.shift(a);
            const l = n.enter("listItem")
              , c = n.indentLines(n.containerFlow(e, s.current()), (function(e, t, n) {
                if (t)
                    return (n ? "" : " ".repeat(a)) + e;
                return (n ? i : i + " ".repeat(a - i.length)) + e
            }
            ));
            return l(),
            c
        },
        paragraph: function(e, t, n, r) {
            const o = n.enter("paragraph")
              , i = n.enter("phrasing")
              , a = n.containerPhrasing(e, r);
            return i(),
            o(),
            a
        },
        root: function(e, t, n, r) {
            const o = e.children.some((function(e) {
                return My(e)
            }
            ));
            return (o ? n.containerPhrasing : n.containerFlow).call(n, e, r)
        },
        strong: Ly,
        text: function(e, t, n, r) {
            return n.safe(e.value, r)
        },
        thematicBreak: function(e, t, n) {
            const r = (Iy(n) + (n.options.ruleSpaces ? " " : "")).repeat(function(e) {
                const t = e.options.ruleRepetition || 3;
                if (t < 3)
                    throw new Error("Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more");
                return t
            }(n));
            return n.options.ruleSpaces ? r.slice(0, -1) : r
        }
    }
      , By = document.createElement("i");
    function Uy(e) {
        const t = "&" + e + ";";
        By.innerHTML = t;
        const n = By.textContent;
        return (59 !== n.charCodeAt(n.length - 1) || "semi" === e) && (n !== t && n)
    }
    function Fy(e, t) {
        const n = Number.parseInt(e, t);
        return n < 9 || 11 === n || n > 13 && n < 32 || n > 126 && n < 160 || n > 55295 && n < 57344 || n > 64975 && n < 65008 || !(65535 & ~n) || 65534 == (65535 & n) || n > 1114111 ? "�" : String.fromCodePoint(n)
    }
    const jy = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
    function zy(e, t, n) {
        if (t)
            return t;
        if (35 === n.charCodeAt(0)) {
            const e = n.charCodeAt(1)
              , t = 120 === e || 88 === e;
            return Fy(n.slice(t ? 2 : 1), t ? 16 : 10)
        }
        return Uy(n) || e
    }
    function qy(e) {
        const t = e._align;
        this.enter({
            type: "table",
            align: t.map((function(e) {
                return "none" === e ? null : e
            }
            )),
            children: []
        }, e),
        this.data.inTable = !0
    }
    function Hy(e) {
        this.exit(e),
        this.data.inTable = void 0
    }
    function Zy(e) {
        this.enter({
            type: "tableRow",
            children: []
        }, e)
    }
    function Wy(e) {
        this.exit(e)
    }
    function Xy(e) {
        this.enter({
            type: "tableCell",
            children: []
        }, e)
    }
    function Vy(e) {
        let t = this.resume();
        this.data.inTable && (t = t.replace(/\\([\\|])/g, Gy));
        const n = this.stack[this.stack.length - 1];
        n.type,
        n.value = t,
        this.exit(e)
    }
    function Gy(e, t) {
        return "|" === t ? t : e
    }
    function Yy(e) {
        const t = e || {}
          , n = t.tableCellPadding
          , r = t.tablePipeAlign
          , o = t.stringLength
          , i = n ? " " : "|";
        return {
            unsafe: [{
                character: "\r",
                inConstruct: "tableCell"
            }, {
                character: "\n",
                inConstruct: "tableCell"
            }, {
                atBreak: !0,
                character: "|",
                after: "[\t :-]"
            }, {
                character: "|",
                inConstruct: "tableCell"
            }, {
                atBreak: !0,
                character: ":",
                after: "-"
            }, {
                atBreak: !0,
                character: "-",
                after: "[:|-]"
            }],
            handlers: {
                inlineCode: function(e, t, n) {
                    let r = Qy.inlineCode(e, t, n);
                    n.stack.includes("tableCell") && (r = r.replace(/\|/g, "\\$&"));
                    return r
                },
                table: function(e, t, n, r) {
                    return s(function(e, t, n) {
                        const r = e.children;
                        let o = -1;
                        const i = []
                          , a = t.enter("table");
                        for (; ++o < r.length; )
                            i[o] = l(r[o], t, n);
                        return a(),
                        i
                    }(e, n, r), e.align)
                },
                tableCell: a,
                tableRow: function(e, t, n, r) {
                    const o = s([l(e, n, r)]);
                    return o.slice(0, o.indexOf("\n"))
                }
            }
        };
        function a(e, t, n, r) {
            const o = n.enter("tableCell")
              , a = n.enter("phrasing")
              , s = n.containerPhrasing(e, {
                ...r,
                before: i,
                after: i
            });
            return a(),
            o(),
            s
        }
        function s(e, t) {
            return function(e, t={}) {
                const n = (t.align || []).concat()
                  , r = t.stringLength || my
                  , o = []
                  , i = []
                  , a = []
                  , s = [];
                let l = 0
                  , c = -1;
                for (; ++c < e.length; ) {
                    const n = []
                      , o = [];
                    let d = -1;
                    for (e[c].length > l && (l = e[c].length); ++d < e[c].length; ) {
                        const i = null == (u = e[c][d]) ? "" : String(u);
                        if (!1 !== t.alignDelimiters) {
                            const e = r(i);
                            o[d] = e,
                            (void 0 === s[d] || e > s[d]) && (s[d] = e)
                        }
                        n.push(i)
                    }
                    i[c] = n,
                    a[c] = o
                }
                var u;
                let d = -1;
                if ("object" == typeof n && "length"in n)
                    for (; ++d < l; )
                        o[d] = gy(n[d]);
                else {
                    const e = gy(n);
                    for (; ++d < l; )
                        o[d] = e
                }
                d = -1;
                const p = []
                  , h = [];
                for (; ++d < l; ) {
                    const e = o[d];
                    let n = ""
                      , r = "";
                    99 === e ? (n = ":",
                    r = ":") : 108 === e ? n = ":" : 114 === e && (r = ":");
                    let i = !1 === t.alignDelimiters ? 1 : Math.max(1, s[d] - n.length - r.length);
                    const a = n + "-".repeat(i) + r;
                    !1 !== t.alignDelimiters && (i = n.length + i + r.length,
                    i > s[d] && (s[d] = i),
                    h[d] = i),
                    p[d] = a
                }
                i.splice(1, 0, p),
                a.splice(1, 0, h),
                c = -1;
                const f = [];
                for (; ++c < i.length; ) {
                    const e = i[c]
                      , n = a[c];
                    d = -1;
                    const r = [];
                    for (; ++d < l; ) {
                        const i = e[d] || "";
                        let a = ""
                          , c = "";
                        if (!1 !== t.alignDelimiters) {
                            const e = s[d] - (n[d] || 0)
                              , t = o[d];
                            114 === t ? a = " ".repeat(e) : 99 === t ? e % 2 ? (a = " ".repeat(e / 2 + .5),
                            c = " ".repeat(e / 2 - .5)) : (a = " ".repeat(e / 2),
                            c = a) : c = " ".repeat(e)
                        }
                        !1 === t.delimiterStart || d || r.push("|"),
                        !1 === t.padding || !1 === t.alignDelimiters && "" === i || !1 === t.delimiterStart && !d || r.push(" "),
                        !1 !== t.alignDelimiters && r.push(a),
                        r.push(i),
                        !1 !== t.alignDelimiters && r.push(c),
                        !1 !== t.padding && r.push(" "),
                        !1 === t.delimiterEnd && d === l - 1 || r.push("|")
                    }
                    f.push(!1 === t.delimiterEnd ? r.join("").replace(/ +$/, "") : r.join(""))
                }
                return f.join("\n")
            }(e, {
                align: t,
                alignDelimiters: r,
                padding: n,
                stringLength: o
            })
        }
        function l(e, t, n) {
            const r = e.children;
            let o = -1;
            const i = []
              , s = t.enter("tableRow");
            for (; ++o < r.length; )
                i[o] = a(r[o], 0, t, n);
            return s(),
            i
        }
    }
    function Ky(e) {
        const t = this.stack[this.stack.length - 2];
        t.type,
        t.checked = "taskListCheckValueChecked" === e.type
    }
    function Jy(e) {
        const t = this.stack[this.stack.length - 2];
        if (t && "listItem" === t.type && "boolean" == typeof t.checked) {
            const e = this.stack[this.stack.length - 1];
            e.type;
            const n = e.children[0];
            if (n && "text" === n.type) {
                const r = t.children;
                let o, i = -1;
                for (; ++i < r.length; ) {
                    const e = r[i];
                    if ("paragraph" === e.type) {
                        o = e;
                        break
                    }
                }
                o === e && (n.value = n.value.slice(1),
                0 === n.value.length ? e.children.shift() : e.position && n.position && "number" == typeof n.position.start.offset && (n.position.start.column++,
                n.position.start.offset++,
                e.position.start = Object.assign({}, n.position.start)))
            }
        }
        this.exit(e)
    }
    function ew(e, t, n, r) {
        const o = e.children[0]
          , i = "boolean" == typeof e.checked && o && "paragraph" === o.type
          , a = "[" + (e.checked ? "x" : " ") + "] "
          , s = n.createTracker(r);
        i && s.move(a);
        let l = Qy.listItem(e, t, n, {
            ...r,
            ...s.current()
        });
        return i && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, (function(e) {
            return e + a
        }
        ))),
        l
    }
    function tw(e, t, n, r) {
        const o = e.length;
        let i, a = 0;
        if (t = t < 0 ? -t > o ? 0 : o + t : t > o ? o : t,
        n = n > 0 ? n : 0,
        r.length < 1e4)
            i = Array.from(r),
            i.unshift(t, n),
            e.splice(...i);
        else
            for (n && e.splice(t, n); a < r.length; )
                i = r.slice(a, a + 1e4),
                i.unshift(t, 0),
                e.splice(...i),
                a += 1e4,
                t += 1e4
    }
    function nw(e, t) {
        return e.length > 0 ? (tw(e, e.length, 0, t),
        e) : t
    }
    const rw = {}.hasOwnProperty;
    function ow(e) {
        const t = {};
        let n = -1;
        for (; ++n < e.length; )
            iw(t, e[n]);
        return t
    }
    function iw(e, t) {
        let n;
        for (n in t) {
            const r = (rw.call(e, n) ? e[n] : void 0) || (e[n] = {})
              , o = t[n];
            let i;
            if (o)
                for (i in o) {
                    rw.call(r, i) || (r[i] = []);
                    const e = o[i];
                    aw(r[i], Array.isArray(e) ? e : e ? [e] : [])
                }
        }
    }
    function aw(e, t) {
        let n = -1;
        const r = [];
        for (; ++n < t.length; )
            ("after" === t[n].add ? e : r).push(t[n]);
        tw(e, 0, 0, r)
    }
    const sw = {
        tokenize: function(e, t, n) {
            let r = 0;
            return function t(i) {
                if ((87 === i || 119 === i) && r < 3)
                    return r++,
                    e.consume(i),
                    t;
                if (46 === i && 3 === r)
                    return e.consume(i),
                    o;
                return n(i)
            }
            ;
            function o(e) {
                return null === e ? n(e) : t(e)
            }
        },
        partial: !0
    }
      , lw = {
        tokenize: function(e, t, n) {
            let r, o, i;
            return a;
            function a(t) {
                return 46 === t || 95 === t ? e.check(uw, l, s)(t) : null === t || Nv(t) || Mv(t) || 45 !== t && Iv(t) ? l(t) : (i = !0,
                e.consume(t),
                a)
            }
            function s(t) {
                return 95 === t ? r = !0 : (o = r,
                r = void 0),
                e.consume(t),
                a
            }
            function l(e) {
                return o || r || !i ? n(e) : t(e)
            }
        },
        partial: !0
    }
      , cw = {
        tokenize: function(e, t) {
            let n = 0
              , r = 0;
            return o;
            function o(a) {
                return 40 === a ? (n++,
                e.consume(a),
                o) : 41 === a && r < n ? i(a) : 33 === a || 34 === a || 38 === a || 39 === a || 41 === a || 42 === a || 44 === a || 46 === a || 58 === a || 59 === a || 60 === a || 63 === a || 93 === a || 95 === a || 126 === a ? e.check(uw, t, i)(a) : null === a || Nv(a) || Mv(a) ? t(a) : (e.consume(a),
                o)
            }
            function i(t) {
                return 41 === t && r++,
                e.consume(t),
                o
            }
        },
        partial: !0
    }
      , uw = {
        tokenize: function(e, t, n) {
            return r;
            function r(a) {
                return 33 === a || 34 === a || 39 === a || 41 === a || 42 === a || 44 === a || 46 === a || 58 === a || 59 === a || 63 === a || 95 === a || 126 === a ? (e.consume(a),
                r) : 38 === a ? (e.consume(a),
                i) : 93 === a ? (e.consume(a),
                o) : 60 === a || null === a || Nv(a) || Mv(a) ? t(a) : n(a)
            }
            function o(e) {
                return null === e || 40 === e || 91 === e || Nv(e) || Mv(e) ? t(e) : r(e)
            }
            function i(e) {
                return Ev(e) ? a(e) : n(e)
            }
            function a(t) {
                return 59 === t ? (e.consume(t),
                r) : Ev(t) ? (e.consume(t),
                a) : n(t)
            }
        },
        partial: !0
    }
      , dw = {
        tokenize: function(e, t, n) {
            return function(t) {
                return e.consume(t),
                r
            }
            ;
            function r(e) {
                return xv(e) ? n(e) : t(e)
            }
        },
        partial: !0
    }
      , pw = {
        tokenize: function(e, t, n) {
            const r = this;
            return function(t) {
                if (87 !== t && 119 !== t || !bw.call(r, r.previous) || ww(r.events))
                    return n(t);
                return e.enter("literalAutolink"),
                e.enter("literalAutolinkWww"),
                e.check(sw, e.attempt(lw, e.attempt(cw, o), n), n)(t)
            }
            ;
            function o(n) {
                return e.exit("literalAutolinkWww"),
                e.exit("literalAutolink"),
                t(n)
            }
        },
        previous: bw
    }
      , hw = {
        tokenize: function(e, t, n) {
            const r = this;
            let o = ""
              , i = !1;
            return function(t) {
                if ((72 === t || 104 === t) && Ow.call(r, r.previous) && !ww(r.events))
                    return e.enter("literalAutolink"),
                    e.enter("literalAutolinkHttp"),
                    o += String.fromCodePoint(t),
                    e.consume(t),
                    a;
                return n(t)
            }
            ;
            function a(t) {
                if (Ev(t) && o.length < 5)
                    return o += String.fromCodePoint(t),
                    e.consume(t),
                    a;
                if (58 === t) {
                    const n = o.toLowerCase();
                    if ("http" === n || "https" === n)
                        return e.consume(t),
                        s
                }
                return n(t)
            }
            function s(t) {
                return 47 === t ? (e.consume(t),
                i ? l : (i = !0,
                s)) : n(t)
            }
            function l(t) {
                return null === t || Av(t) || Nv(t) || Mv(t) || Iv(t) ? n(t) : e.attempt(lw, e.attempt(cw, c), n)(t)
            }
            function c(n) {
                return e.exit("literalAutolinkHttp"),
                e.exit("literalAutolink"),
                t(n)
            }
        },
        previous: Ow
    }
      , fw = {
        tokenize: function(e, t, n) {
            const r = this;
            let o, i;
            return function(t) {
                if (!yw(t) || !vw.call(r, r.previous) || ww(r.events))
                    return n(t);
                return e.enter("literalAutolink"),
                e.enter("literalAutolinkEmail"),
                a(t)
            }
            ;
            function a(t) {
                return yw(t) ? (e.consume(t),
                a) : 64 === t ? (e.consume(t),
                s) : n(t)
            }
            function s(t) {
                return 46 === t ? e.check(dw, c, l)(t) : 45 === t || 95 === t || xv(t) ? (i = !0,
                e.consume(t),
                s) : c(t)
            }
            function l(t) {
                return e.consume(t),
                o = !0,
                s
            }
            function c(a) {
                return i && o && Ev(r.previous) ? (e.exit("literalAutolinkEmail"),
                e.exit("literalAutolink"),
                t(a)) : n(a)
            }
        },
        previous: vw
    }
      , mw = {};
    let gw = 48;
    for (; gw < 123; )
        mw[gw] = fw,
        gw++,
        58 === gw ? gw = 65 : 91 === gw && (gw = 97);
    function bw(e) {
        return null === e || 40 === e || 42 === e || 95 === e || 91 === e || 93 === e || 126 === e || Nv(e)
    }
    function Ow(e) {
        return !Ev(e)
    }
    function vw(e) {
        return !(47 === e || yw(e))
    }
    function yw(e) {
        return 43 === e || 45 === e || 46 === e || 95 === e || xv(e)
    }
    function ww(e) {
        let t = e.length
          , n = !1;
        for (; t--; ) {
            const r = e[t][1];
            if (("labelLink" === r.type || "labelImage" === r.type) && !r._balanced) {
                n = !0;
                break
            }
            if (r._gfmAutolinkLiteralWalkedInto) {
                n = !1;
                break
            }
        }
        return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0),
        n
    }
    function _w(e) {
        const t = [];
        let n = -1
          , r = 0
          , o = 0;
        for (; ++n < e.length; ) {
            const i = e.charCodeAt(n);
            let a = "";
            if (37 === i && xv(e.charCodeAt(n + 1)) && xv(e.charCodeAt(n + 2)))
                o = 2;
            else if (i < 128)
                /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(i)) || (a = String.fromCharCode(i));
            else if (i > 55295 && i < 57344) {
                const t = e.charCodeAt(n + 1);
                i < 56320 && t > 56319 && t < 57344 ? (a = String.fromCharCode(i, t),
                o = 1) : a = "�"
            } else
                a = String.fromCharCode(i);
            a && (t.push(e.slice(r, n), encodeURIComponent(a)),
            r = n + o + 1,
            a = ""),
            o && (n += o,
            o = 0)
        }
        return t.join("") + e.slice(r)
    }
    function kw(e) {
        return null === e || Nv(e) || Mv(e) ? 1 : Iv(e) ? 2 : void 0
    }
    function Sw(e, t, n) {
        const r = [];
        let o = -1;
        for (; ++o < e.length; ) {
            const i = e[o].resolveAll;
            i && !r.includes(i) && (t = i(t, n),
            r.push(i))
        }
        return t
    }
    mw[43] = fw,
    mw[45] = fw,
    mw[46] = fw,
    mw[95] = fw,
    mw[72] = [fw, hw],
    mw[104] = [fw, hw],
    mw[87] = [fw, pw],
    mw[119] = [fw, pw];
    const Ew = {
        name: "attention",
        tokenize: function(e, t) {
            const n = this.parser.constructs.attentionMarkers.null
              , r = this.previous
              , o = kw(r);
            let i;
            return function(t) {
                return i = t,
                e.enter("attentionSequence"),
                a(t)
            }
            ;
            function a(s) {
                if (s === i)
                    return e.consume(s),
                    a;
                const l = e.exit("attentionSequence")
                  , c = kw(s)
                  , u = !c || 2 === c && o || n.includes(s)
                  , d = !o || 2 === o && c || n.includes(r);
                return l._open = Boolean(42 === i ? u : u && (o || !d)),
                l._close = Boolean(42 === i ? d : d && (c || !u)),
                t(s)
            }
        },
        resolveAll: function(e, t) {
            let n, r, o, i, a, s, l, c, u = -1;
            for (; ++u < e.length; )
                if ("enter" === e[u][0] && "attentionSequence" === e[u][1].type && e[u][1]._close)
                    for (n = u; n--; )
                        if ("exit" === e[n][0] && "attentionSequence" === e[n][1].type && e[n][1]._open && t.sliceSerialize(e[n][1]).charCodeAt(0) === t.sliceSerialize(e[u][1]).charCodeAt(0)) {
                            if ((e[n][1]._close || e[u][1]._open) && (e[u][1].end.offset - e[u][1].start.offset) % 3 && !((e[n][1].end.offset - e[n][1].start.offset + e[u][1].end.offset - e[u][1].start.offset) % 3))
                                continue;
                            s = e[n][1].end.offset - e[n][1].start.offset > 1 && e[u][1].end.offset - e[u][1].start.offset > 1 ? 2 : 1;
                            const d = Object.assign({}, e[n][1].end)
                              , p = Object.assign({}, e[u][1].start);
                            xw(d, -s),
                            xw(p, s),
                            i = {
                                type: s > 1 ? "strongSequence" : "emphasisSequence",
                                start: d,
                                end: Object.assign({}, e[n][1].end)
                            },
                            a = {
                                type: s > 1 ? "strongSequence" : "emphasisSequence",
                                start: Object.assign({}, e[u][1].start),
                                end: p
                            },
                            o = {
                                type: s > 1 ? "strongText" : "emphasisText",
                                start: Object.assign({}, e[n][1].end),
                                end: Object.assign({}, e[u][1].start)
                            },
                            r = {
                                type: s > 1 ? "strong" : "emphasis",
                                start: Object.assign({}, i.start),
                                end: Object.assign({}, a.end)
                            },
                            e[n][1].end = Object.assign({}, i.start),
                            e[u][1].start = Object.assign({}, a.end),
                            l = [],
                            e[n][1].end.offset - e[n][1].start.offset && (l = nw(l, [["enter", e[n][1], t], ["exit", e[n][1], t]])),
                            l = nw(l, [["enter", r, t], ["enter", i, t], ["exit", i, t], ["enter", o, t]]),
                            l = nw(l, Sw(t.parser.constructs.insideSpan.null, e.slice(n + 1, u), t)),
                            l = nw(l, [["exit", o, t], ["enter", a, t], ["exit", a, t], ["exit", r, t]]),
                            e[u][1].end.offset - e[u][1].start.offset ? (c = 2,
                            l = nw(l, [["enter", e[u][1], t], ["exit", e[u][1], t]])) : c = 0,
                            tw(e, n - 1, u - n + 3, l),
                            u = n + l.length - c - 2;
                            break
                        }
            u = -1;
            for (; ++u < e.length; )
                "attentionSequence" === e[u][1].type && (e[u][1].type = "data");
            return e
        }
    };
    function xw(e, t) {
        e.column += t,
        e.offset += t,
        e._bufferIndex += t
    }
    const Tw = {
        name: "autolink",
        tokenize: function(e, t, n) {
            let r = 0;
            return function(t) {
                return e.enter("autolink"),
                e.enter("autolinkMarker"),
                e.consume(t),
                e.exit("autolinkMarker"),
                e.enter("autolinkProtocol"),
                o
            }
            ;
            function o(t) {
                return Ev(t) ? (e.consume(t),
                i) : 64 === t ? n(t) : l(t)
            }
            function i(e) {
                return 43 === e || 45 === e || 46 === e || xv(e) ? (r = 1,
                a(e)) : l(e)
            }
            function a(t) {
                return 58 === t ? (e.consume(t),
                r = 0,
                s) : (43 === t || 45 === t || 46 === t || xv(t)) && r++ < 32 ? (e.consume(t),
                a) : (r = 0,
                l(t))
            }
            function s(r) {
                return 62 === r ? (e.exit("autolinkProtocol"),
                e.enter("autolinkMarker"),
                e.consume(r),
                e.exit("autolinkMarker"),
                e.exit("autolink"),
                t) : null === r || 32 === r || 60 === r || Av(r) ? n(r) : (e.consume(r),
                s)
            }
            function l(t) {
                return 64 === t ? (e.consume(t),
                c) : Tv(t) ? (e.consume(t),
                l) : n(t)
            }
            function c(e) {
                return xv(e) ? u(e) : n(e)
            }
            function u(n) {
                return 46 === n ? (e.consume(n),
                r = 0,
                c) : 62 === n ? (e.exit("autolinkProtocol").type = "autolinkEmail",
                e.enter("autolinkMarker"),
                e.consume(n),
                e.exit("autolinkMarker"),
                e.exit("autolink"),
                t) : d(n)
            }
            function d(t) {
                if ((45 === t || xv(t)) && r++ < 63) {
                    const n = 45 === t ? d : u;
                    return e.consume(t),
                    n
                }
                return n(t)
            }
        }
    };
    function Aw(e, t, n, r) {
        const o = r ? r - 1 : Number.POSITIVE_INFINITY;
        let i = 0;
        return function(r) {
            if ($v(r))
                return e.enter(n),
                a(r);
            return t(r)
        }
        ;
        function a(r) {
            return $v(r) && i++ < o ? (e.consume(r),
            a) : (e.exit(n),
            t(r))
        }
    }
    const Cw = {
        tokenize: function(e, t, n) {
            return function(t) {
                return $v(t) ? Aw(e, r, "linePrefix")(t) : r(t)
            }
            ;
            function r(e) {
                return null === e || Rv(e) ? t(e) : n(e)
            }
        },
        partial: !0
    };
    const Pw = {
        name: "blockQuote",
        tokenize: function(e, t, n) {
            const r = this;
            return function(t) {
                if (62 === t) {
                    const n = r.containerState;
                    return n.open || (e.enter("blockQuote", {
                        _container: !0
                    }),
                    n.open = !0),
                    e.enter("blockQuotePrefix"),
                    e.enter("blockQuoteMarker"),
                    e.consume(t),
                    e.exit("blockQuoteMarker"),
                    o
                }
                return n(t)
            }
            ;
            function o(n) {
                return $v(n) ? (e.enter("blockQuotePrefixWhitespace"),
                e.consume(n),
                e.exit("blockQuotePrefixWhitespace"),
                e.exit("blockQuotePrefix"),
                t) : (e.exit("blockQuotePrefix"),
                t(n))
            }
        },
        continuation: {
            tokenize: function(e, t, n) {
                const r = this;
                return function(t) {
                    if ($v(t))
                        return Aw(e, o, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t);
                    return o(t)
                }
                ;
                function o(r) {
                    return e.attempt(Pw, t, n)(r)
                }
            }
        },
        exit: function(e) {
            e.exit("blockQuote")
        }
    };
    const Dw = {
        name: "characterEscape",
        tokenize: function(e, t, n) {
            return function(t) {
                return e.enter("characterEscape"),
                e.enter("escapeMarker"),
                e.consume(t),
                e.exit("escapeMarker"),
                r
            }
            ;
            function r(r) {
                return Dv(r) ? (e.enter("characterEscapeValue"),
                e.consume(r),
                e.exit("characterEscapeValue"),
                e.exit("characterEscape"),
                t) : n(r)
            }
        }
    };
    const Rw = {
        name: "characterReference",
        tokenize: function(e, t, n) {
            const r = this;
            let o, i, a = 0;
            return function(t) {
                return e.enter("characterReference"),
                e.enter("characterReferenceMarker"),
                e.consume(t),
                e.exit("characterReferenceMarker"),
                s
            }
            ;
            function s(t) {
                return 35 === t ? (e.enter("characterReferenceMarkerNumeric"),
                e.consume(t),
                e.exit("characterReferenceMarkerNumeric"),
                l) : (e.enter("characterReferenceValue"),
                o = 31,
                i = xv,
                c(t))
            }
            function l(t) {
                return 88 === t || 120 === t ? (e.enter("characterReferenceMarkerHexadecimal"),
                e.consume(t),
                e.exit("characterReferenceMarkerHexadecimal"),
                e.enter("characterReferenceValue"),
                o = 6,
                i = Pv,
                c) : (e.enter("characterReferenceValue"),
                o = 7,
                i = Cv,
                c(t))
            }
            function c(s) {
                if (59 === s && a) {
                    const o = e.exit("characterReferenceValue");
                    return i !== xv || Uy(r.sliceSerialize(o)) ? (e.enter("characterReferenceMarker"),
                    e.consume(s),
                    e.exit("characterReferenceMarker"),
                    e.exit("characterReference"),
                    t) : n(s)
                }
                return i(s) && a++ < o ? (e.consume(s),
                c) : n(s)
            }
        }
    };
    const Nw = {
        tokenize: function(e, t, n) {
            const r = this;
            return function(t) {
                if (null === t)
                    return n(t);
                return e.enter("lineEnding"),
                e.consume(t),
                e.exit("lineEnding"),
                o
            }
            ;
            function o(e) {
                return r.parser.lazy[r.now().line] ? n(e) : t(e)
            }
        },
        partial: !0
    }
      , $w = {
        name: "codeFenced",
        tokenize: function(e, t, n) {
            const r = this
              , o = {
                tokenize: function(e, t, n) {
                    let o = 0;
                    return a;
                    function a(t) {
                        return e.enter("lineEnding"),
                        e.consume(t),
                        e.exit("lineEnding"),
                        l
                    }
                    function l(t) {
                        return e.enter("codeFencedFence"),
                        $v(t) ? Aw(e, c, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t) : c(t)
                    }
                    function c(t) {
                        return t === i ? (e.enter("codeFencedFenceSequence"),
                        u(t)) : n(t)
                    }
                    function u(t) {
                        return t === i ? (o++,
                        e.consume(t),
                        u) : o >= s ? (e.exit("codeFencedFenceSequence"),
                        $v(t) ? Aw(e, d, "whitespace")(t) : d(t)) : n(t)
                    }
                    function d(r) {
                        return null === r || Rv(r) ? (e.exit("codeFencedFence"),
                        t(r)) : n(r)
                    }
                },
                partial: !0
            };
            let i, a = 0, s = 0;
            return function(t) {
                return function(t) {
                    const n = r.events[r.events.length - 1];
                    return a = n && "linePrefix" === n[1].type ? n[2].sliceSerialize(n[1], !0).length : 0,
                    i = t,
                    e.enter("codeFenced"),
                    e.enter("codeFencedFence"),
                    e.enter("codeFencedFenceSequence"),
                    l(t)
                }(t)
            }
            ;
            function l(t) {
                return t === i ? (s++,
                e.consume(t),
                l) : s < 3 ? n(t) : (e.exit("codeFencedFenceSequence"),
                $v(t) ? Aw(e, c, "whitespace")(t) : c(t))
            }
            function c(n) {
                return null === n || Rv(n) ? (e.exit("codeFencedFence"),
                r.interrupt ? t(n) : e.check(Nw, h, O)(n)) : (e.enter("codeFencedFenceInfo"),
                e.enter("chunkString", {
                    contentType: "string"
                }),
                u(n))
            }
            function u(t) {
                return null === t || Rv(t) ? (e.exit("chunkString"),
                e.exit("codeFencedFenceInfo"),
                c(t)) : $v(t) ? (e.exit("chunkString"),
                e.exit("codeFencedFenceInfo"),
                Aw(e, d, "whitespace")(t)) : 96 === t && t === i ? n(t) : (e.consume(t),
                u)
            }
            function d(t) {
                return null === t || Rv(t) ? c(t) : (e.enter("codeFencedFenceMeta"),
                e.enter("chunkString", {
                    contentType: "string"
                }),
                p(t))
            }
            function p(t) {
                return null === t || Rv(t) ? (e.exit("chunkString"),
                e.exit("codeFencedFenceMeta"),
                c(t)) : 96 === t && t === i ? n(t) : (e.consume(t),
                p)
            }
            function h(t) {
                return e.attempt(o, O, f)(t)
            }
            function f(t) {
                return e.enter("lineEnding"),
                e.consume(t),
                e.exit("lineEnding"),
                m
            }
            function m(t) {
                return a > 0 && $v(t) ? Aw(e, g, "linePrefix", a + 1)(t) : g(t)
            }
            function g(t) {
                return null === t || Rv(t) ? e.check(Nw, h, O)(t) : (e.enter("codeFlowValue"),
                b(t))
            }
            function b(t) {
                return null === t || Rv(t) ? (e.exit("codeFlowValue"),
                g(t)) : (e.consume(t),
                b)
            }
            function O(n) {
                return e.exit("codeFenced"),
                t(n)
            }
        },
        concrete: !0
    };
    const Iw = {
        name: "codeIndented",
        tokenize: function(e, t, n) {
            const r = this;
            return function(t) {
                return e.enter("codeIndented"),
                Aw(e, o, "linePrefix", 5)(t)
            }
            ;
            function o(e) {
                const t = r.events[r.events.length - 1];
                return t && "linePrefix" === t[1].type && t[2].sliceSerialize(t[1], !0).length >= 4 ? i(e) : n(e)
            }
            function i(t) {
                return null === t ? s(t) : Rv(t) ? e.attempt(Mw, i, s)(t) : (e.enter("codeFlowValue"),
                a(t))
            }
            function a(t) {
                return null === t || Rv(t) ? (e.exit("codeFlowValue"),
                i(t)) : (e.consume(t),
                a)
            }
            function s(n) {
                return e.exit("codeIndented"),
                t(n)
            }
        }
    }
      , Mw = {
        tokenize: function(e, t, n) {
            const r = this;
            return o;
            function o(t) {
                return r.parser.lazy[r.now().line] ? n(t) : Rv(t) ? (e.enter("lineEnding"),
                e.consume(t),
                e.exit("lineEnding"),
                o) : Aw(e, i, "linePrefix", 5)(t)
            }
            function i(e) {
                const i = r.events[r.events.length - 1];
                return i && "linePrefix" === i[1].type && i[2].sliceSerialize(i[1], !0).length >= 4 ? t(e) : Rv(e) ? o(e) : n(e)
            }
        },
        partial: !0
    };
    const Lw = {
        name: "codeText",
        tokenize: function(e, t, n) {
            let r, o, i = 0;
            return function(t) {
                return e.enter("codeText"),
                e.enter("codeTextSequence"),
                a(t)
            }
            ;
            function a(t) {
                return 96 === t ? (e.consume(t),
                i++,
                a) : (e.exit("codeTextSequence"),
                s(t))
            }
            function s(t) {
                return null === t ? n(t) : 32 === t ? (e.enter("space"),
                e.consume(t),
                e.exit("space"),
                s) : 96 === t ? (o = e.enter("codeTextSequence"),
                r = 0,
                c(t)) : Rv(t) ? (e.enter("lineEnding"),
                e.consume(t),
                e.exit("lineEnding"),
                s) : (e.enter("codeTextData"),
                l(t))
            }
            function l(t) {
                return null === t || 32 === t || 96 === t || Rv(t) ? (e.exit("codeTextData"),
                s(t)) : (e.consume(t),
                l)
            }
            function c(n) {
                return 96 === n ? (e.consume(n),
                r++,
                c) : r === i ? (e.exit("codeTextSequence"),
                e.exit("codeText"),
                t(n)) : (o.type = "codeTextData",
                l(n))
            }
        },
        resolve: function(e) {
            let t, n, r = e.length - 4, o = 3;
            if (!("lineEnding" !== e[o][1].type && "space" !== e[o][1].type || "lineEnding" !== e[r][1].type && "space" !== e[r][1].type))
                for (t = o; ++t < r; )
                    if ("codeTextData" === e[t][1].type) {
                        e[o][1].type = "codeTextPadding",
                        e[r][1].type = "codeTextPadding",
                        o += 2,
                        r -= 2;
                        break
                    }
            t = o - 1,
            r++;
            for (; ++t <= r; )
                void 0 === n ? t !== r && "lineEnding" !== e[t][1].type && (n = t) : t !== r && "lineEnding" !== e[t][1].type || (e[n][1].type = "codeTextData",
                t !== n + 2 && (e[n][1].end = e[t - 1][1].end,
                e.splice(n + 2, t - n - 2),
                r -= t - n - 2,
                t = n + 2),
                n = void 0);
            return e
        },
        previous: function(e) {
            return 96 !== e || "characterEscape" === this.events[this.events.length - 1][1].type
        }
    };
    class Qw {
        constructor(e) {
            this.left = e ? [...e] : [],
            this.right = []
        }
        get(e) {
            if (e < 0 || e >= this.left.length + this.right.length)
                throw new RangeError("Cannot access index `" + e + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
            return e < this.left.length ? this.left[e] : this.right[this.right.length - e + this.left.length - 1]
        }
        get length() {
            return this.left.length + this.right.length
        }
        shift() {
            return this.setCursor(0),
            this.right.pop()
        }
        slice(e, t) {
            const n = null == t ? Number.POSITIVE_INFINITY : t;
            return n < this.left.length ? this.left.slice(e, n) : e > this.left.length ? this.right.slice(this.right.length - n + this.left.length, this.right.length - e + this.left.length).reverse() : this.left.slice(e).concat(this.right.slice(this.right.length - n + this.left.length).reverse())
        }
        splice(e, t, n) {
            const r = t || 0;
            this.setCursor(Math.trunc(e));
            const o = this.right.splice(this.right.length - r, Number.POSITIVE_INFINITY);
            return n && Bw(this.left, n),
            o.reverse()
        }
        pop() {
            return this.setCursor(Number.POSITIVE_INFINITY),
            this.left.pop()
        }
        push(e) {
            this.setCursor(Number.POSITIVE_INFINITY),
            this.left.push(e)
        }
        pushMany(e) {
            this.setCursor(Number.POSITIVE_INFINITY),
            Bw(this.left, e)
        }
        unshift(e) {
            this.setCursor(0),
            this.right.push(e)
        }
        unshiftMany(e) {
            this.setCursor(0),
            Bw(this.right, e.reverse())
        }
        setCursor(e) {
            if (!(e === this.left.length || e > this.left.length && 0 === this.right.length || e < 0 && 0 === this.left.length))
                if (e < this.left.length) {
                    const t = this.left.splice(e, Number.POSITIVE_INFINITY);
                    Bw(this.right, t.reverse())
                } else {
                    const t = this.right.splice(this.left.length + this.right.length - e, Number.POSITIVE_INFINITY);
                    Bw(this.left, t.reverse())
                }
        }
    }
    function Bw(e, t) {
        let n = 0;
        if (t.length < 1e4)
            e.push(...t);
        else
            for (; n < t.length; )
                e.push(...t.slice(n, n + 1e4)),
                n += 1e4
    }
    function Uw(e) {
        const t = {};
        let n, r, o, i, a, s, l, c = -1;
        const u = new Qw(e);
        for (; ++c < u.length; ) {
            for (; c in t; )
                c = t[c];
            if (n = u.get(c),
            c && "chunkFlow" === n[1].type && "listItemPrefix" === u.get(c - 1)[1].type && (s = n[1]._tokenizer.events,
            o = 0,
            o < s.length && "lineEndingBlank" === s[o][1].type && (o += 2),
            o < s.length && "content" === s[o][1].type))
                for (; ++o < s.length && "content" !== s[o][1].type; )
                    "chunkText" === s[o][1].type && (s[o][1]._isInFirstContentOfListItem = !0,
                    o++);
            if ("enter" === n[0])
                n[1].contentType && (Object.assign(t, Fw(u, c)),
                c = t[c],
                l = !0);
            else if (n[1]._container) {
                for (o = c,
                r = void 0; o-- && (i = u.get(o),
                "lineEnding" === i[1].type || "lineEndingBlank" === i[1].type); )
                    "enter" === i[0] && (r && (u.get(r)[1].type = "lineEndingBlank"),
                    i[1].type = "lineEnding",
                    r = o);
                r && (n[1].end = Object.assign({}, u.get(r)[1].start),
                a = u.slice(r, c),
                a.unshift(n),
                u.splice(r, c - r + 1, a))
            }
        }
        return tw(e, 0, Number.POSITIVE_INFINITY, u.slice(0)),
        !l
    }
    function Fw(e, t) {
        const n = e.get(t)[1]
          , r = e.get(t)[2];
        let o = t - 1;
        const i = []
          , a = n._tokenizer || r.parser[n.contentType](n.start)
          , s = a.events
          , l = []
          , c = {};
        let u, d, p = -1, h = n, f = 0, m = 0;
        const g = [m];
        for (; h; ) {
            for (; e.get(++o)[1] !== h; )
                ;
            i.push(o),
            h._tokenizer || (u = r.sliceStream(h),
            h.next || u.push(null),
            d && a.defineSkip(h.start),
            h._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = !0),
            a.write(u),
            h._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = void 0)),
            d = h,
            h = h.next
        }
        for (h = n; ++p < s.length; )
            "exit" === s[p][0] && "enter" === s[p - 1][0] && s[p][1].type === s[p - 1][1].type && s[p][1].start.line !== s[p][1].end.line && (m = p + 1,
            g.push(m),
            h._tokenizer = void 0,
            h.previous = void 0,
            h = h.next);
        for (a.events = [],
        h ? (h._tokenizer = void 0,
        h.previous = void 0) : g.pop(),
        p = g.length; p--; ) {
            const t = s.slice(g[p], g[p + 1])
              , n = i.pop();
            l.push([n, n + t.length - 1]),
            e.splice(n, 2, t)
        }
        for (l.reverse(),
        p = -1; ++p < l.length; )
            c[f + l[p][0]] = f + l[p][1],
            f += l[p][1] - l[p][0] - 1;
        return c
    }
    const jw = {
        tokenize: function(e, t) {
            let n;
            return function(t) {
                return e.enter("content"),
                n = e.enter("chunkContent", {
                    contentType: "content"
                }),
                r(t)
            }
            ;
            function r(t) {
                return null === t ? o(t) : Rv(t) ? e.check(zw, i, o)(t) : (e.consume(t),
                r)
            }
            function o(n) {
                return e.exit("chunkContent"),
                e.exit("content"),
                t(n)
            }
            function i(t) {
                return e.consume(t),
                e.exit("chunkContent"),
                n.next = e.enter("chunkContent", {
                    contentType: "content",
                    previous: n
                }),
                n = n.next,
                r
            }
        },
        resolve: function(e) {
            return Uw(e),
            e
        }
    }
      , zw = {
        tokenize: function(e, t, n) {
            const r = this;
            return function(t) {
                return e.exit("chunkContent"),
                e.enter("lineEnding"),
                e.consume(t),
                e.exit("lineEnding"),
                Aw(e, o, "linePrefix")
            }
            ;
            function o(o) {
                if (null === o || Rv(o))
                    return n(o);
                const i = r.events[r.events.length - 1];
                return !r.parser.constructs.disable.null.includes("codeIndented") && i && "linePrefix" === i[1].type && i[2].sliceSerialize(i[1], !0).length >= 4 ? t(o) : e.interrupt(r.parser.constructs.flow, n, t)(o)
            }
        },
        partial: !0
    };
    function qw(e, t, n, r, o, i, a, s, l) {
        const c = l || Number.POSITIVE_INFINITY;
        let u = 0;
        return function(t) {
            if (60 === t)
                return e.enter(r),
                e.enter(o),
                e.enter(i),
                e.consume(t),
                e.exit(i),
                d;
            if (null === t || 32 === t || 41 === t || Av(t))
                return n(t);
            return e.enter(r),
            e.enter(a),
            e.enter(s),
            e.enter("chunkString", {
                contentType: "string"
            }),
            f(t)
        }
        ;
        function d(n) {
            return 62 === n ? (e.enter(i),
            e.consume(n),
            e.exit(i),
            e.exit(o),
            e.exit(r),
            t) : (e.enter(s),
            e.enter("chunkString", {
                contentType: "string"
            }),
            p(n))
        }
        function p(t) {
            return 62 === t ? (e.exit("chunkString"),
            e.exit(s),
            d(t)) : null === t || 60 === t || Rv(t) ? n(t) : (e.consume(t),
            92 === t ? h : p)
        }
        function h(t) {
            return 60 === t || 62 === t || 92 === t ? (e.consume(t),
            p) : p(t)
        }
        function f(o) {
            return u || null !== o && 41 !== o && !Nv(o) ? u < c && 40 === o ? (e.consume(o),
            u++,
            f) : 41 === o ? (e.consume(o),
            u--,
            f) : null === o || 32 === o || 40 === o || Av(o) ? n(o) : (e.consume(o),
            92 === o ? m : f) : (e.exit("chunkString"),
            e.exit(s),
            e.exit(a),
            e.exit(r),
            t(o))
        }
        function m(t) {
            return 40 === t || 41 === t || 92 === t ? (e.consume(t),
            f) : f(t)
        }
    }
    function Hw(e, t, n, r, o, i) {
        const a = this;
        let s, l = 0;
        return function(t) {
            return e.enter(r),
            e.enter(o),
            e.consume(t),
            e.exit(o),
            e.enter(i),
            c
        }
        ;
        function c(d) {
            return l > 999 || null === d || 91 === d || 93 === d && !s || 94 === d && !l && "_hiddenFootnoteSupport"in a.parser.constructs ? n(d) : 93 === d ? (e.exit(i),
            e.enter(o),
            e.consume(d),
            e.exit(o),
            e.exit(r),
            t) : Rv(d) ? (e.enter("lineEnding"),
            e.consume(d),
            e.exit("lineEnding"),
            c) : (e.enter("chunkString", {
                contentType: "string"
            }),
            u(d))
        }
        function u(t) {
            return null === t || 91 === t || 93 === t || Rv(t) || l++ > 999 ? (e.exit("chunkString"),
            c(t)) : (e.consume(t),
            s || (s = !$v(t)),
            92 === t ? d : u)
        }
        function d(t) {
            return 91 === t || 92 === t || 93 === t ? (e.consume(t),
            l++,
            u) : u(t)
        }
    }
    function Zw(e, t, n, r, o, i) {
        let a;
        return function(t) {
            if (34 === t || 39 === t || 40 === t)
                return e.enter(r),
                e.enter(o),
                e.consume(t),
                e.exit(o),
                a = 40 === t ? 41 : t,
                s;
            return n(t)
        }
        ;
        function s(n) {
            return n === a ? (e.enter(o),
            e.consume(n),
            e.exit(o),
            e.exit(r),
            t) : (e.enter(i),
            l(n))
        }
        function l(t) {
            return t === a ? (e.exit(i),
            s(a)) : null === t ? n(t) : Rv(t) ? (e.enter("lineEnding"),
            e.consume(t),
            e.exit("lineEnding"),
            Aw(e, l, "linePrefix")) : (e.enter("chunkString", {
                contentType: "string"
            }),
            c(t))
        }
        function c(t) {
            return t === a || null === t || Rv(t) ? (e.exit("chunkString"),
            l(t)) : (e.consume(t),
            92 === t ? u : c)
        }
        function u(t) {
            return t === a || 92 === t ? (e.consume(t),
            c) : c(t)
        }
    }
    function Ww(e, t) {
        let n;
        return function r(o) {
            if (Rv(o))
                return e.enter("lineEnding"),
                e.consume(o),
                e.exit("lineEnding"),
                n = !0,
                r;
            if ($v(o))
                return Aw(e, r, n ? "linePrefix" : "lineSuffix")(o);
            return t(o)
        }
    }
    const Xw = {
        name: "definition",
        tokenize: function(e, t, n) {
            const r = this;
            let o;
            return function(t) {
                return e.enter("definition"),
                function(t) {
                    return Hw.call(r, e, i, n, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(t)
                }(t)
            }
            ;
            function i(t) {
                return o = Jv(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)),
                58 === t ? (e.enter("definitionMarker"),
                e.consume(t),
                e.exit("definitionMarker"),
                a) : n(t)
            }
            function a(t) {
                return Nv(t) ? Ww(e, s)(t) : s(t)
            }
            function s(t) {
                return qw(e, l, n, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")(t)
            }
            function l(t) {
                return e.attempt(Vw, c, c)(t)
            }
            function c(t) {
                return $v(t) ? Aw(e, u, "whitespace")(t) : u(t)
            }
            function u(i) {
                return null === i || Rv(i) ? (e.exit("definition"),
                r.parser.defined.push(o),
                t(i)) : n(i)
            }
        }
    }
      , Vw = {
        tokenize: function(e, t, n) {
            return function(t) {
                return Nv(t) ? Ww(e, r)(t) : n(t)
            }
            ;
            function r(t) {
                return Zw(e, o, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(t)
            }
            function o(t) {
                return $v(t) ? Aw(e, i, "whitespace")(t) : i(t)
            }
            function i(e) {
                return null === e || Rv(e) ? t(e) : n(e)
            }
        },
        partial: !0
    };
    const Gw = {
        name: "hardBreakEscape",
        tokenize: function(e, t, n) {
            return function(t) {
                return e.enter("hardBreakEscape"),
                e.consume(t),
                r
            }
            ;
            function r(r) {
                return Rv(r) ? (e.exit("hardBreakEscape"),
                t(r)) : n(r)
            }
        }
    };
    const Yw = {
        name: "headingAtx",
        tokenize: function(e, t, n) {
            let r = 0;
            return function(t) {
                return e.enter("atxHeading"),
                function(t) {
                    return e.enter("atxHeadingSequence"),
                    o(t)
                }(t)
            }
            ;
            function o(t) {
                return 35 === t && r++ < 6 ? (e.consume(t),
                o) : null === t || Nv(t) ? (e.exit("atxHeadingSequence"),
                i(t)) : n(t)
            }
            function i(n) {
                return 35 === n ? (e.enter("atxHeadingSequence"),
                a(n)) : null === n || Rv(n) ? (e.exit("atxHeading"),
                t(n)) : $v(n) ? Aw(e, i, "whitespace")(n) : (e.enter("atxHeadingText"),
                s(n))
            }
            function a(t) {
                return 35 === t ? (e.consume(t),
                a) : (e.exit("atxHeadingSequence"),
                i(t))
            }
            function s(t) {
                return null === t || 35 === t || Nv(t) ? (e.exit("atxHeadingText"),
                i(t)) : (e.consume(t),
                s)
            }
        },
        resolve: function(e, t) {
            let n, r, o = e.length - 2, i = 3;
            "whitespace" === e[i][1].type && (i += 2);
            o - 2 > i && "whitespace" === e[o][1].type && (o -= 2);
            "atxHeadingSequence" === e[o][1].type && (i === o - 1 || o - 4 > i && "whitespace" === e[o - 2][1].type) && (o -= i + 1 === o ? 2 : 4);
            o > i && (n = {
                type: "atxHeadingText",
                start: e[i][1].start,
                end: e[o][1].end
            },
            r = {
                type: "chunkText",
                start: e[i][1].start,
                end: e[o][1].end,
                contentType: "text"
            },
            tw(e, i, o - i + 1, [["enter", n, t], ["enter", r, t], ["exit", r, t], ["exit", n, t]]));
            return e
        }
    };
    const Kw = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"]
      , Jw = ["pre", "script", "style", "textarea"]
      , e_ = {
        name: "htmlFlow",
        tokenize: function(e, t, n) {
            const r = this;
            let o, i, a, s, l;
            return function(t) {
                return function(t) {
                    return e.enter("htmlFlow"),
                    e.enter("htmlFlowData"),
                    e.consume(t),
                    c
                }(t)
            }
            ;
            function c(s) {
                return 33 === s ? (e.consume(s),
                u) : 47 === s ? (e.consume(s),
                i = !0,
                h) : 63 === s ? (e.consume(s),
                o = 3,
                r.interrupt ? t : $) : Ev(s) ? (e.consume(s),
                a = String.fromCharCode(s),
                f) : n(s)
            }
            function u(i) {
                return 45 === i ? (e.consume(i),
                o = 2,
                d) : 91 === i ? (e.consume(i),
                o = 5,
                s = 0,
                p) : Ev(i) ? (e.consume(i),
                o = 4,
                r.interrupt ? t : $) : n(i)
            }
            function d(o) {
                return 45 === o ? (e.consume(o),
                r.interrupt ? t : $) : n(o)
            }
            function p(o) {
                const i = "CDATA[";
                return o === i.charCodeAt(s++) ? (e.consume(o),
                6 === s ? r.interrupt ? t : x : p) : n(o)
            }
            function h(t) {
                return Ev(t) ? (e.consume(t),
                a = String.fromCharCode(t),
                f) : n(t)
            }
            function f(s) {
                if (null === s || 47 === s || 62 === s || Nv(s)) {
                    const l = 47 === s
                      , c = a.toLowerCase();
                    return l || i || !Jw.includes(c) ? Kw.includes(a.toLowerCase()) ? (o = 6,
                    l ? (e.consume(s),
                    m) : r.interrupt ? t(s) : x(s)) : (o = 7,
                    r.interrupt && !r.parser.lazy[r.now().line] ? n(s) : i ? g(s) : b(s)) : (o = 1,
                    r.interrupt ? t(s) : x(s))
                }
                return 45 === s || xv(s) ? (e.consume(s),
                a += String.fromCharCode(s),
                f) : n(s)
            }
            function m(o) {
                return 62 === o ? (e.consume(o),
                r.interrupt ? t : x) : n(o)
            }
            function g(t) {
                return $v(t) ? (e.consume(t),
                g) : S(t)
            }
            function b(t) {
                return 47 === t ? (e.consume(t),
                S) : 58 === t || 95 === t || Ev(t) ? (e.consume(t),
                O) : $v(t) ? (e.consume(t),
                b) : S(t)
            }
            function O(t) {
                return 45 === t || 46 === t || 58 === t || 95 === t || xv(t) ? (e.consume(t),
                O) : v(t)
            }
            function v(t) {
                return 61 === t ? (e.consume(t),
                y) : $v(t) ? (e.consume(t),
                v) : b(t)
            }
            function y(t) {
                return null === t || 60 === t || 61 === t || 62 === t || 96 === t ? n(t) : 34 === t || 39 === t ? (e.consume(t),
                l = t,
                w) : $v(t) ? (e.consume(t),
                y) : _(t)
            }
            function w(t) {
                return t === l ? (e.consume(t),
                l = null,
                k) : null === t || Rv(t) ? n(t) : (e.consume(t),
                w)
            }
            function _(t) {
                return null === t || 34 === t || 39 === t || 47 === t || 60 === t || 61 === t || 62 === t || 96 === t || Nv(t) ? v(t) : (e.consume(t),
                _)
            }
            function k(e) {
                return 47 === e || 62 === e || $v(e) ? b(e) : n(e)
            }
            function S(t) {
                return 62 === t ? (e.consume(t),
                E) : n(t)
            }
            function E(t) {
                return null === t || Rv(t) ? x(t) : $v(t) ? (e.consume(t),
                E) : n(t)
            }
            function x(t) {
                return 45 === t && 2 === o ? (e.consume(t),
                P) : 60 === t && 1 === o ? (e.consume(t),
                D) : 62 === t && 4 === o ? (e.consume(t),
                I) : 63 === t && 3 === o ? (e.consume(t),
                $) : 93 === t && 5 === o ? (e.consume(t),
                N) : !Rv(t) || 6 !== o && 7 !== o ? null === t || Rv(t) ? (e.exit("htmlFlowData"),
                T(t)) : (e.consume(t),
                x) : (e.exit("htmlFlowData"),
                e.check(t_, M, T)(t))
            }
            function T(t) {
                return e.check(n_, A, M)(t)
            }
            function A(t) {
                return e.enter("lineEnding"),
                e.consume(t),
                e.exit("lineEnding"),
                C
            }
            function C(t) {
                return null === t || Rv(t) ? T(t) : (e.enter("htmlFlowData"),
                x(t))
            }
            function P(t) {
                return 45 === t ? (e.consume(t),
                $) : x(t)
            }
            function D(t) {
                return 47 === t ? (e.consume(t),
                a = "",
                R) : x(t)
            }
            function R(t) {
                if (62 === t) {
                    const n = a.toLowerCase();
                    return Jw.includes(n) ? (e.consume(t),
                    I) : x(t)
                }
                return Ev(t) && a.length < 8 ? (e.consume(t),
                a += String.fromCharCode(t),
                R) : x(t)
            }
            function N(t) {
                return 93 === t ? (e.consume(t),
                $) : x(t)
            }
            function $(t) {
                return 62 === t ? (e.consume(t),
                I) : 45 === t && 2 === o ? (e.consume(t),
                $) : x(t)
            }
            function I(t) {
                return null === t || Rv(t) ? (e.exit("htmlFlowData"),
                M(t)) : (e.consume(t),
                I)
            }
            function M(n) {
                return e.exit("htmlFlow"),
                t(n)
            }
        },
        resolveTo: function(e) {
            let t = e.length;
            for (; t-- && ("enter" !== e[t][0] || "htmlFlow" !== e[t][1].type); )
                ;
            t > 1 && "linePrefix" === e[t - 2][1].type && (e[t][1].start = e[t - 2][1].start,
            e[t + 1][1].start = e[t - 2][1].start,
            e.splice(t - 2, 2));
            return e
        },
        concrete: !0
    }
      , t_ = {
        tokenize: function(e, t, n) {
            return function(r) {
                return e.enter("lineEnding"),
                e.consume(r),
                e.exit("lineEnding"),
                e.attempt(Cw, t, n)
            }
        },
        partial: !0
    }
      , n_ = {
        tokenize: function(e, t, n) {
            const r = this;
            return function(t) {
                if (Rv(t))
                    return e.enter("lineEnding"),
                    e.consume(t),
                    e.exit("lineEnding"),
                    o;
                return n(t)
            }
            ;
            function o(e) {
                return r.parser.lazy[r.now().line] ? n(e) : t(e)
            }
        },
        partial: !0
    };
    const r_ = {
        name: "htmlText",
        tokenize: function(e, t, n) {
            const r = this;
            let o, i, a;
            return function(t) {
                return e.enter("htmlText"),
                e.enter("htmlTextData"),
                e.consume(t),
                s
            }
            ;
            function s(t) {
                return 33 === t ? (e.consume(t),
                l) : 47 === t ? (e.consume(t),
                y) : 63 === t ? (e.consume(t),
                O) : Ev(t) ? (e.consume(t),
                k) : n(t)
            }
            function l(t) {
                return 45 === t ? (e.consume(t),
                c) : 91 === t ? (e.consume(t),
                i = 0,
                h) : Ev(t) ? (e.consume(t),
                b) : n(t)
            }
            function c(t) {
                return 45 === t ? (e.consume(t),
                p) : n(t)
            }
            function u(t) {
                return null === t ? n(t) : 45 === t ? (e.consume(t),
                d) : Rv(t) ? (a = u,
                R(t)) : (e.consume(t),
                u)
            }
            function d(t) {
                return 45 === t ? (e.consume(t),
                p) : u(t)
            }
            function p(e) {
                return 62 === e ? D(e) : 45 === e ? d(e) : u(e)
            }
            function h(t) {
                const r = "CDATA[";
                return t === r.charCodeAt(i++) ? (e.consume(t),
                6 === i ? f : h) : n(t)
            }
            function f(t) {
                return null === t ? n(t) : 93 === t ? (e.consume(t),
                m) : Rv(t) ? (a = f,
                R(t)) : (e.consume(t),
                f)
            }
            function m(t) {
                return 93 === t ? (e.consume(t),
                g) : f(t)
            }
            function g(t) {
                return 62 === t ? D(t) : 93 === t ? (e.consume(t),
                g) : f(t)
            }
            function b(t) {
                return null === t || 62 === t ? D(t) : Rv(t) ? (a = b,
                R(t)) : (e.consume(t),
                b)
            }
            function O(t) {
                return null === t ? n(t) : 63 === t ? (e.consume(t),
                v) : Rv(t) ? (a = O,
                R(t)) : (e.consume(t),
                O)
            }
            function v(e) {
                return 62 === e ? D(e) : O(e)
            }
            function y(t) {
                return Ev(t) ? (e.consume(t),
                w) : n(t)
            }
            function w(t) {
                return 45 === t || xv(t) ? (e.consume(t),
                w) : _(t)
            }
            function _(t) {
                return Rv(t) ? (a = _,
                R(t)) : $v(t) ? (e.consume(t),
                _) : D(t)
            }
            function k(t) {
                return 45 === t || xv(t) ? (e.consume(t),
                k) : 47 === t || 62 === t || Nv(t) ? S(t) : n(t)
            }
            function S(t) {
                return 47 === t ? (e.consume(t),
                D) : 58 === t || 95 === t || Ev(t) ? (e.consume(t),
                E) : Rv(t) ? (a = S,
                R(t)) : $v(t) ? (e.consume(t),
                S) : D(t)
            }
            function E(t) {
                return 45 === t || 46 === t || 58 === t || 95 === t || xv(t) ? (e.consume(t),
                E) : x(t)
            }
            function x(t) {
                return 61 === t ? (e.consume(t),
                T) : Rv(t) ? (a = x,
                R(t)) : $v(t) ? (e.consume(t),
                x) : S(t)
            }
            function T(t) {
                return null === t || 60 === t || 61 === t || 62 === t || 96 === t ? n(t) : 34 === t || 39 === t ? (e.consume(t),
                o = t,
                A) : Rv(t) ? (a = T,
                R(t)) : $v(t) ? (e.consume(t),
                T) : (e.consume(t),
                C)
            }
            function A(t) {
                return t === o ? (e.consume(t),
                o = void 0,
                P) : null === t ? n(t) : Rv(t) ? (a = A,
                R(t)) : (e.consume(t),
                A)
            }
            function C(t) {
                return null === t || 34 === t || 39 === t || 60 === t || 61 === t || 96 === t ? n(t) : 47 === t || 62 === t || Nv(t) ? S(t) : (e.consume(t),
                C)
            }
            function P(e) {
                return 47 === e || 62 === e || Nv(e) ? S(e) : n(e)
            }
            function D(r) {
                return 62 === r ? (e.consume(r),
                e.exit("htmlTextData"),
                e.exit("htmlText"),
                t) : n(r)
            }
            function R(t) {
                return e.exit("htmlTextData"),
                e.enter("lineEnding"),
                e.consume(t),
                e.exit("lineEnding"),
                N
            }
            function N(t) {
                return $v(t) ? Aw(e, $, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t) : $(t)
            }
            function $(t) {
                return e.enter("htmlTextData"),
                a(t)
            }
        }
    };
    const o_ = {
        name: "labelEnd",
        tokenize: function(e, t, n) {
            const r = this;
            let o, i, a = r.events.length;
            for (; a--; )
                if (("labelImage" === r.events[a][1].type || "labelLink" === r.events[a][1].type) && !r.events[a][1]._balanced) {
                    o = r.events[a][1];
                    break
                }
            return function(t) {
                if (!o)
                    return n(t);
                if (o._inactive)
                    return u(t);
                return i = r.parser.defined.includes(Jv(r.sliceSerialize({
                    start: o.end,
                    end: r.now()
                }))),
                e.enter("labelEnd"),
                e.enter("labelMarker"),
                e.consume(t),
                e.exit("labelMarker"),
                e.exit("labelEnd"),
                s
            }
            ;
            function s(t) {
                return 40 === t ? e.attempt(i_, c, i ? c : u)(t) : 91 === t ? e.attempt(a_, c, i ? l : u)(t) : i ? c(t) : u(t)
            }
            function l(t) {
                return e.attempt(s_, c, u)(t)
            }
            function c(e) {
                return t(e)
            }
            function u(e) {
                return o._balanced = !0,
                n(e)
            }
        },
        resolveTo: function(e, t) {
            let n, r, o, i, a = e.length, s = 0;
            for (; a--; )
                if (n = e[a][1],
                r) {
                    if ("link" === n.type || "labelLink" === n.type && n._inactive)
                        break;
                    "enter" === e[a][0] && "labelLink" === n.type && (n._inactive = !0)
                } else if (o) {
                    if ("enter" === e[a][0] && ("labelImage" === n.type || "labelLink" === n.type) && !n._balanced && (r = a,
                    "labelLink" !== n.type)) {
                        s = 2;
                        break
                    }
                } else
                    "labelEnd" === n.type && (o = a);
            const l = {
                type: "labelLink" === e[r][1].type ? "link" : "image",
                start: Object.assign({}, e[r][1].start),
                end: Object.assign({}, e[e.length - 1][1].end)
            }
              , c = {
                type: "label",
                start: Object.assign({}, e[r][1].start),
                end: Object.assign({}, e[o][1].end)
            }
              , u = {
                type: "labelText",
                start: Object.assign({}, e[r + s + 2][1].end),
                end: Object.assign({}, e[o - 2][1].start)
            };
            return i = [["enter", l, t], ["enter", c, t]],
            i = nw(i, e.slice(r + 1, r + s + 3)),
            i = nw(i, [["enter", u, t]]),
            i = nw(i, Sw(t.parser.constructs.insideSpan.null, e.slice(r + s + 4, o - 3), t)),
            i = nw(i, [["exit", u, t], e[o - 2], e[o - 1], ["exit", c, t]]),
            i = nw(i, e.slice(o + 1)),
            i = nw(i, [["exit", l, t]]),
            tw(e, r, e.length, i),
            e
        },
        resolveAll: function(e) {
            let t = -1;
            for (; ++t < e.length; ) {
                const n = e[t][1];
                "labelImage" !== n.type && "labelLink" !== n.type && "labelEnd" !== n.type || (e.splice(t + 1, "labelImage" === n.type ? 4 : 2),
                n.type = "data",
                t++)
            }
            return e
        }
    }
      , i_ = {
        tokenize: function(e, t, n) {
            return function(t) {
                return e.enter("resource"),
                e.enter("resourceMarker"),
                e.consume(t),
                e.exit("resourceMarker"),
                r
            }
            ;
            function r(t) {
                return Nv(t) ? Ww(e, o)(t) : o(t)
            }
            function o(t) {
                return 41 === t ? c(t) : qw(e, i, a, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(t)
            }
            function i(t) {
                return Nv(t) ? Ww(e, s)(t) : c(t)
            }
            function a(e) {
                return n(e)
            }
            function s(t) {
                return 34 === t || 39 === t || 40 === t ? Zw(e, l, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(t) : c(t)
            }
            function l(t) {
                return Nv(t) ? Ww(e, c)(t) : c(t)
            }
            function c(r) {
                return 41 === r ? (e.enter("resourceMarker"),
                e.consume(r),
                e.exit("resourceMarker"),
                e.exit("resource"),
                t) : n(r)
            }
        }
    }
      , a_ = {
        tokenize: function(e, t, n) {
            const r = this;
            return function(t) {
                return Hw.call(r, e, o, i, "reference", "referenceMarker", "referenceString")(t)
            }
            ;
            function o(e) {
                return r.parser.defined.includes(Jv(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(e) : n(e)
            }
            function i(e) {
                return n(e)
            }
        }
    }
      , s_ = {
        tokenize: function(e, t, n) {
            return function(t) {
                return e.enter("reference"),
                e.enter("referenceMarker"),
                e.consume(t),
                e.exit("referenceMarker"),
                r
            }
            ;
            function r(r) {
                return 93 === r ? (e.enter("referenceMarker"),
                e.consume(r),
                e.exit("referenceMarker"),
                e.exit("reference"),
                t) : n(r)
            }
        }
    };
    const l_ = {
        name: "labelStartImage",
        tokenize: function(e, t, n) {
            const r = this;
            return function(t) {
                return e.enter("labelImage"),
                e.enter("labelImageMarker"),
                e.consume(t),
                e.exit("labelImageMarker"),
                o
            }
            ;
            function o(t) {
                return 91 === t ? (e.enter("labelMarker"),
                e.consume(t),
                e.exit("labelMarker"),
                e.exit("labelImage"),
                i) : n(t)
            }
            function i(e) {
                return 94 === e && "_hiddenFootnoteSupport"in r.parser.constructs ? n(e) : t(e)
            }
        },
        resolveAll: o_.resolveAll
    };
    const c_ = {
        name: "labelStartLink",
        tokenize: function(e, t, n) {
            const r = this;
            return function(t) {
                return e.enter("labelLink"),
                e.enter("labelMarker"),
                e.consume(t),
                e.exit("labelMarker"),
                e.exit("labelLink"),
                o
            }
            ;
            function o(e) {
                return 94 === e && "_hiddenFootnoteSupport"in r.parser.constructs ? n(e) : t(e)
            }
        },
        resolveAll: o_.resolveAll
    };
    const u_ = {
        name: "lineEnding",
        tokenize: function(e, t) {
            return function(n) {
                return e.enter("lineEnding"),
                e.consume(n),
                e.exit("lineEnding"),
                Aw(e, t, "linePrefix")
            }
        }
    };
    const d_ = {
        name: "thematicBreak",
        tokenize: function(e, t, n) {
            let r, o = 0;
            return function(t) {
                return e.enter("thematicBreak"),
                function(e) {
                    return r = e,
                    i(e)
                }(t)
            }
            ;
            function i(i) {
                return i === r ? (e.enter("thematicBreakSequence"),
                a(i)) : o >= 3 && (null === i || Rv(i)) ? (e.exit("thematicBreak"),
                t(i)) : n(i)
            }
            function a(t) {
                return t === r ? (e.consume(t),
                o++,
                a) : (e.exit("thematicBreakSequence"),
                $v(t) ? Aw(e, i, "whitespace")(t) : i(t))
            }
        }
    };
    const p_ = {
        name: "list",
        tokenize: function(e, t, n) {
            const r = this
              , o = r.events[r.events.length - 1];
            let i = o && "linePrefix" === o[1].type ? o[2].sliceSerialize(o[1], !0).length : 0
              , a = 0;
            return function(t) {
                const o = r.containerState.type || (42 === t || 43 === t || 45 === t ? "listUnordered" : "listOrdered");
                if ("listUnordered" === o ? !r.containerState.marker || t === r.containerState.marker : Cv(t)) {
                    if (r.containerState.type || (r.containerState.type = o,
                    e.enter(o, {
                        _container: !0
                    })),
                    "listUnordered" === o)
                        return e.enter("listItemPrefix"),
                        42 === t || 45 === t ? e.check(d_, n, l)(t) : l(t);
                    if (!r.interrupt || 49 === t)
                        return e.enter("listItemPrefix"),
                        e.enter("listItemValue"),
                        s(t)
                }
                return n(t)
            }
            ;
            function s(t) {
                return Cv(t) && ++a < 10 ? (e.consume(t),
                s) : (!r.interrupt || a < 2) && (r.containerState.marker ? t === r.containerState.marker : 41 === t || 46 === t) ? (e.exit("listItemValue"),
                l(t)) : n(t)
            }
            function l(t) {
                return e.enter("listItemMarker"),
                e.consume(t),
                e.exit("listItemMarker"),
                r.containerState.marker = r.containerState.marker || t,
                e.check(Cw, r.interrupt ? n : c, e.attempt(h_, d, u))
            }
            function c(e) {
                return r.containerState.initialBlankLine = !0,
                i++,
                d(e)
            }
            function u(t) {
                return $v(t) ? (e.enter("listItemPrefixWhitespace"),
                e.consume(t),
                e.exit("listItemPrefixWhitespace"),
                d) : n(t)
            }
            function d(n) {
                return r.containerState.size = i + r.sliceSerialize(e.exit("listItemPrefix"), !0).length,
                t(n)
            }
        },
        continuation: {
            tokenize: function(e, t, n) {
                const r = this;
                return r.containerState._closeFlow = void 0,
                e.check(Cw, (function(n) {
                    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine,
                    Aw(e, t, "listItemIndent", r.containerState.size + 1)(n)
                }
                ), (function(n) {
                    if (r.containerState.furtherBlankLines || !$v(n))
                        return r.containerState.furtherBlankLines = void 0,
                        r.containerState.initialBlankLine = void 0,
                        o(n);
                    return r.containerState.furtherBlankLines = void 0,
                    r.containerState.initialBlankLine = void 0,
                    e.attempt(f_, t, o)(n)
                }
                ));
                function o(o) {
                    return r.containerState._closeFlow = !0,
                    r.interrupt = void 0,
                    Aw(e, e.attempt(p_, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o)
                }
            }
        },
        exit: function(e) {
            e.exit(this.containerState.type)
        }
    }
      , h_ = {
        tokenize: function(e, t, n) {
            const r = this;
            return Aw(e, (function(e) {
                const o = r.events[r.events.length - 1];
                return !$v(e) && o && "listItemPrefixWhitespace" === o[1].type ? t(e) : n(e)
            }
            ), "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5)
        },
        partial: !0
    }
      , f_ = {
        tokenize: function(e, t, n) {
            const r = this;
            return Aw(e, (function(e) {
                const o = r.events[r.events.length - 1];
                return o && "listItemIndent" === o[1].type && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? t(e) : n(e)
            }
            ), "listItemIndent", r.containerState.size + 1)
        },
        partial: !0
    };
    const m_ = {
        name: "setextUnderline",
        tokenize: function(e, t, n) {
            const r = this;
            let o;
            return function(t) {
                let a, s = r.events.length;
                for (; s--; )
                    if ("lineEnding" !== r.events[s][1].type && "linePrefix" !== r.events[s][1].type && "content" !== r.events[s][1].type) {
                        a = "paragraph" === r.events[s][1].type;
                        break
                    }
                if (!r.parser.lazy[r.now().line] && (r.interrupt || a))
                    return e.enter("setextHeadingLine"),
                    o = t,
                    function(t) {
                        return e.enter("setextHeadingLineSequence"),
                        i(t)
                    }(t);
                return n(t)
            }
            ;
            function i(t) {
                return t === o ? (e.consume(t),
                i) : (e.exit("setextHeadingLineSequence"),
                $v(t) ? Aw(e, a, "lineSuffix")(t) : a(t))
            }
            function a(r) {
                return null === r || Rv(r) ? (e.exit("setextHeadingLine"),
                t(r)) : n(r)
            }
        },
        resolveTo: function(e, t) {
            let n, r, o, i = e.length;
            for (; i--; )
                if ("enter" === e[i][0]) {
                    if ("content" === e[i][1].type) {
                        n = i;
                        break
                    }
                    "paragraph" === e[i][1].type && (r = i)
                } else
                    "content" === e[i][1].type && e.splice(i, 1),
                    o || "definition" !== e[i][1].type || (o = i);
            const a = {
                type: "setextHeading",
                start: Object.assign({}, e[r][1].start),
                end: Object.assign({}, e[e.length - 1][1].end)
            };
            e[r][1].type = "setextHeadingText",
            o ? (e.splice(r, 0, ["enter", a, t]),
            e.splice(o + 1, 0, ["exit", e[n][1], t]),
            e[n][1].end = Object.assign({}, e[o][1].end)) : e[n][1] = a;
            return e.push(["exit", a, t]),
            e
        }
    };
    const g_ = {
        tokenize: function(e, t, n) {
            const r = this;
            return Aw(e, (function(e) {
                const o = r.events[r.events.length - 1];
                return o && "gfmFootnoteDefinitionIndent" === o[1].type && 4 === o[2].sliceSerialize(o[1], !0).length ? t(e) : n(e)
            }
            ), "gfmFootnoteDefinitionIndent", 5)
        },
        partial: !0
    };
    function b_(e, t, n) {
        const r = this;
        let o = r.events.length;
        const i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
        let a;
        for (; o--; ) {
            const e = r.events[o][1];
            if ("labelImage" === e.type) {
                a = e;
                break
            }
            if ("gfmFootnoteCall" === e.type || "labelLink" === e.type || "label" === e.type || "image" === e.type || "link" === e.type)
                break
        }
        return function(o) {
            if (!a || !a._balanced)
                return n(o);
            const s = Jv(r.sliceSerialize({
                start: a.end,
                end: r.now()
            }));
            if (94 !== s.codePointAt(0) || !i.includes(s.slice(1)))
                return n(o);
            return e.enter("gfmFootnoteCallLabelMarker"),
            e.consume(o),
            e.exit("gfmFootnoteCallLabelMarker"),
            t(o)
        }
    }
    function O_(e, t) {
        let n = e.length;
        for (; n--; )
            if ("labelImage" === e[n][1].type && "enter" === e[n][0]) {
                e[n][1];
                break
            }
        e[n + 1][1].type = "data",
        e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
        const r = {
            type: "gfmFootnoteCall",
            start: Object.assign({}, e[n + 3][1].start),
            end: Object.assign({}, e[e.length - 1][1].end)
        }
          , o = {
            type: "gfmFootnoteCallMarker",
            start: Object.assign({}, e[n + 3][1].end),
            end: Object.assign({}, e[n + 3][1].end)
        };
        o.end.column++,
        o.end.offset++,
        o.end._bufferIndex++;
        const i = {
            type: "gfmFootnoteCallString",
            start: Object.assign({}, o.end),
            end: Object.assign({}, e[e.length - 1][1].start)
        }
          , a = {
            type: "chunkString",
            contentType: "string",
            start: Object.assign({}, i.start),
            end: Object.assign({}, i.end)
        }
          , s = [e[n + 1], e[n + 2], ["enter", r, t], e[n + 3], e[n + 4], ["enter", o, t], ["exit", o, t], ["enter", i, t], ["enter", a, t], ["exit", a, t], ["exit", i, t], e[e.length - 2], e[e.length - 1], ["exit", r, t]];
        return e.splice(n, e.length - n + 1, ...s),
        e
    }
    function v_(e, t, n) {
        const r = this
          , o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
        let i, a = 0;
        return function(t) {
            return e.enter("gfmFootnoteCall"),
            e.enter("gfmFootnoteCallLabelMarker"),
            e.consume(t),
            e.exit("gfmFootnoteCallLabelMarker"),
            s
        }
        ;
        function s(t) {
            return 94 !== t ? n(t) : (e.enter("gfmFootnoteCallMarker"),
            e.consume(t),
            e.exit("gfmFootnoteCallMarker"),
            e.enter("gfmFootnoteCallString"),
            e.enter("chunkString").contentType = "string",
            l)
        }
        function l(s) {
            if (a > 999 || 93 === s && !i || null === s || 91 === s || Nv(s))
                return n(s);
            if (93 === s) {
                e.exit("chunkString");
                const i = e.exit("gfmFootnoteCallString");
                return o.includes(Jv(r.sliceSerialize(i))) ? (e.enter("gfmFootnoteCallLabelMarker"),
                e.consume(s),
                e.exit("gfmFootnoteCallLabelMarker"),
                e.exit("gfmFootnoteCall"),
                t) : n(s)
            }
            return Nv(s) || (i = !0),
            a++,
            e.consume(s),
            92 === s ? c : l
        }
        function c(t) {
            return 91 === t || 92 === t || 93 === t ? (e.consume(t),
            a++,
            l) : l(t)
        }
    }
    function y_(e, t, n) {
        const r = this
          , o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
        let i, a, s = 0;
        return function(t) {
            return e.enter("gfmFootnoteDefinition")._container = !0,
            e.enter("gfmFootnoteDefinitionLabel"),
            e.enter("gfmFootnoteDefinitionLabelMarker"),
            e.consume(t),
            e.exit("gfmFootnoteDefinitionLabelMarker"),
            l
        }
        ;
        function l(t) {
            return 94 === t ? (e.enter("gfmFootnoteDefinitionMarker"),
            e.consume(t),
            e.exit("gfmFootnoteDefinitionMarker"),
            e.enter("gfmFootnoteDefinitionLabelString"),
            e.enter("chunkString").contentType = "string",
            c) : n(t)
        }
        function c(t) {
            if (s > 999 || 93 === t && !a || null === t || 91 === t || Nv(t))
                return n(t);
            if (93 === t) {
                e.exit("chunkString");
                const n = e.exit("gfmFootnoteDefinitionLabelString");
                return i = Jv(r.sliceSerialize(n)),
                e.enter("gfmFootnoteDefinitionLabelMarker"),
                e.consume(t),
                e.exit("gfmFootnoteDefinitionLabelMarker"),
                e.exit("gfmFootnoteDefinitionLabel"),
                d
            }
            return Nv(t) || (a = !0),
            s++,
            e.consume(t),
            92 === t ? u : c
        }
        function u(t) {
            return 91 === t || 92 === t || 93 === t ? (e.consume(t),
            s++,
            c) : c(t)
        }
        function d(t) {
            return 58 === t ? (e.enter("definitionMarker"),
            e.consume(t),
            e.exit("definitionMarker"),
            o.includes(i) || o.push(i),
            Aw(e, p, "gfmFootnoteDefinitionWhitespace")) : n(t)
        }
        function p(e) {
            return t(e)
        }
    }
    function w_(e, t, n) {
        return e.check(Cw, t, e.attempt(g_, t, n))
    }
    function __(e) {
        e.exit("gfmFootnoteDefinition")
    }
    function k_(e) {
        let t = (e || {}).singleTilde;
        const n = {
            tokenize: function(e, n, r) {
                const o = this.previous
                  , i = this.events;
                let a = 0;
                return function(t) {
                    if (126 === o && "characterEscape" !== i[i.length - 1][1].type)
                        return r(t);
                    return e.enter("strikethroughSequenceTemporary"),
                    s(t)
                }
                ;
                function s(i) {
                    const l = kw(o);
                    if (126 === i)
                        return a > 1 ? r(i) : (e.consume(i),
                        a++,
                        s);
                    if (a < 2 && !t)
                        return r(i);
                    const c = e.exit("strikethroughSequenceTemporary")
                      , u = kw(i);
                    return c._open = !u || 2 === u && Boolean(l),
                    c._close = !l || 2 === l && Boolean(u),
                    n(i)
                }
            },
            resolveAll: function(e, t) {
                let n = -1;
                for (; ++n < e.length; )
                    if ("enter" === e[n][0] && "strikethroughSequenceTemporary" === e[n][1].type && e[n][1]._close) {
                        let r = n;
                        for (; r--; )
                            if ("exit" === e[r][0] && "strikethroughSequenceTemporary" === e[r][1].type && e[r][1]._open && e[n][1].end.offset - e[n][1].start.offset == e[r][1].end.offset - e[r][1].start.offset) {
                                e[n][1].type = "strikethroughSequence",
                                e[r][1].type = "strikethroughSequence";
                                const o = {
                                    type: "strikethrough",
                                    start: Object.assign({}, e[r][1].start),
                                    end: Object.assign({}, e[n][1].end)
                                }
                                  , i = {
                                    type: "strikethroughText",
                                    start: Object.assign({}, e[r][1].end),
                                    end: Object.assign({}, e[n][1].start)
                                }
                                  , a = [["enter", o, t], ["enter", e[r][1], t], ["exit", e[r][1], t], ["enter", i, t]]
                                  , s = t.parser.constructs.insideSpan.null;
                                s && tw(a, a.length, 0, Sw(s, e.slice(r + 1, n), t)),
                                tw(a, a.length, 0, [["exit", i, t], ["enter", e[n][1], t], ["exit", e[n][1], t], ["exit", o, t]]),
                                tw(e, r - 1, n - r + 3, a),
                                n = r + a.length - 2;
                                break
                            }
                    }
                n = -1;
                for (; ++n < e.length; )
                    "strikethroughSequenceTemporary" === e[n][1].type && (e[n][1].type = "data");
                return e
            }
        };
        return null == t && (t = !0),
        {
            text: {
                126: n
            },
            insideSpan: {
                null: [n]
            },
            attentionMarkers: {
                null: [126]
            }
        }
    }
    class S_ {
        constructor() {
            this.map = []
        }
        add(e, t, n) {
            !function(e, t, n, r) {
                let o = 0;
                if (0 === n && 0 === r.length)
                    return;
                for (; o < e.map.length; ) {
                    if (e.map[o][0] === t)
                        return e.map[o][1] += n,
                        void e.map[o][2].push(...r);
                    o += 1
                }
                e.map.push([t, n, r])
            }(this, e, t, n)
        }
        consume(e) {
            if (this.map.sort((function(e, t) {
                return e[0] - t[0]
            }
            )),
            0 === this.map.length)
                return;
            let t = this.map.length;
            const n = [];
            for (; t > 0; )
                t -= 1,
                n.push(e.slice(this.map[t][0] + this.map[t][1]), this.map[t][2]),
                e.length = this.map[t][0];
            n.push([...e]),
            e.length = 0;
            let r = n.pop();
            for (; r; )
                e.push(...r),
                r = n.pop();
            this.map.length = 0
        }
    }
    function E_(e, t) {
        let n = !1;
        const r = [];
        for (; t < e.length; ) {
            const o = e[t];
            if (n) {
                if ("enter" === o[0])
                    "tableContent" === o[1].type && r.push("tableDelimiterMarker" === e[t + 1][1].type ? "left" : "none");
                else if ("tableContent" === o[1].type) {
                    if ("tableDelimiterMarker" === e[t - 1][1].type) {
                        const e = r.length - 1;
                        r[e] = "left" === r[e] ? "center" : "right"
                    }
                } else if ("tableDelimiterRow" === o[1].type)
                    break
            } else
                "enter" === o[0] && "tableDelimiterRow" === o[1].type && (n = !0);
            t += 1
        }
        return r
    }
    function x_(e, t, n) {
        const r = this;
        let o, i = 0, a = 0;
        return function(e) {
            let t = r.events.length - 1;
            for (; t > -1; ) {
                const e = r.events[t][1].type;
                if ("lineEnding" !== e && "linePrefix" !== e)
                    break;
                t--
            }
            const o = t > -1 ? r.events[t][1].type : null
              , i = "tableHead" === o || "tableRow" === o ? y : s;
            if (i === y && r.parser.lazy[r.now().line])
                return n(e);
            return i(e)
        }
        ;
        function s(t) {
            return e.enter("tableHead"),
            e.enter("tableRow"),
            function(e) {
                if (124 === e)
                    return l(e);
                return o = !0,
                a += 1,
                l(e)
            }(t)
        }
        function l(t) {
            return null === t ? n(t) : Rv(t) ? a > 1 ? (a = 0,
            r.interrupt = !0,
            e.exit("tableRow"),
            e.enter("lineEnding"),
            e.consume(t),
            e.exit("lineEnding"),
            d) : n(t) : $v(t) ? Aw(e, l, "whitespace")(t) : (a += 1,
            o && (o = !1,
            i += 1),
            124 === t ? (e.enter("tableCellDivider"),
            e.consume(t),
            e.exit("tableCellDivider"),
            o = !0,
            l) : (e.enter("data"),
            c(t)))
        }
        function c(t) {
            return null === t || 124 === t || Nv(t) ? (e.exit("data"),
            l(t)) : (e.consume(t),
            92 === t ? u : c)
        }
        function u(t) {
            return 92 === t || 124 === t ? (e.consume(t),
            c) : c(t)
        }
        function d(t) {
            return r.interrupt = !1,
            r.parser.lazy[r.now().line] ? n(t) : (e.enter("tableDelimiterRow"),
            o = !1,
            $v(t) ? Aw(e, p, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t) : p(t))
        }
        function p(t) {
            return 45 === t || 58 === t ? f(t) : 124 === t ? (o = !0,
            e.enter("tableCellDivider"),
            e.consume(t),
            e.exit("tableCellDivider"),
            h) : v(t)
        }
        function h(t) {
            return $v(t) ? Aw(e, f, "whitespace")(t) : f(t)
        }
        function f(t) {
            return 58 === t ? (a += 1,
            o = !0,
            e.enter("tableDelimiterMarker"),
            e.consume(t),
            e.exit("tableDelimiterMarker"),
            m) : 45 === t ? (a += 1,
            m(t)) : null === t || Rv(t) ? O(t) : v(t)
        }
        function m(t) {
            return 45 === t ? (e.enter("tableDelimiterFiller"),
            g(t)) : v(t)
        }
        function g(t) {
            return 45 === t ? (e.consume(t),
            g) : 58 === t ? (o = !0,
            e.exit("tableDelimiterFiller"),
            e.enter("tableDelimiterMarker"),
            e.consume(t),
            e.exit("tableDelimiterMarker"),
            b) : (e.exit("tableDelimiterFiller"),
            b(t))
        }
        function b(t) {
            return $v(t) ? Aw(e, O, "whitespace")(t) : O(t)
        }
        function O(n) {
            return 124 === n ? p(n) : (null === n || Rv(n)) && o && i === a ? (e.exit("tableDelimiterRow"),
            e.exit("tableHead"),
            t(n)) : v(n)
        }
        function v(e) {
            return n(e)
        }
        function y(t) {
            return e.enter("tableRow"),
            w(t)
        }
        function w(n) {
            return 124 === n ? (e.enter("tableCellDivider"),
            e.consume(n),
            e.exit("tableCellDivider"),
            w) : null === n || Rv(n) ? (e.exit("tableRow"),
            t(n)) : $v(n) ? Aw(e, w, "whitespace")(n) : (e.enter("data"),
            _(n))
        }
        function _(t) {
            return null === t || 124 === t || Nv(t) ? (e.exit("data"),
            w(t)) : (e.consume(t),
            92 === t ? k : _)
        }
        function k(t) {
            return 92 === t || 124 === t ? (e.consume(t),
            _) : _(t)
        }
    }
    function T_(e, t) {
        let n, r, o, i = -1, a = !0, s = 0, l = [0, 0, 0, 0], c = [0, 0, 0, 0], u = !1, d = 0;
        const p = new S_;
        for (; ++i < e.length; ) {
            const h = e[i]
              , f = h[1];
            "enter" === h[0] ? "tableHead" === f.type ? (u = !1,
            0 !== d && (C_(p, t, d, n, r),
            r = void 0,
            d = 0),
            n = {
                type: "table",
                start: Object.assign({}, f.start),
                end: Object.assign({}, f.end)
            },
            p.add(i, 0, [["enter", n, t]])) : "tableRow" === f.type || "tableDelimiterRow" === f.type ? (a = !0,
            o = void 0,
            l = [0, 0, 0, 0],
            c = [0, i + 1, 0, 0],
            u && (u = !1,
            r = {
                type: "tableBody",
                start: Object.assign({}, f.start),
                end: Object.assign({}, f.end)
            },
            p.add(i, 0, [["enter", r, t]])),
            s = "tableDelimiterRow" === f.type ? 2 : r ? 3 : 1) : !s || "data" !== f.type && "tableDelimiterMarker" !== f.type && "tableDelimiterFiller" !== f.type ? "tableCellDivider" === f.type && (a ? a = !1 : (0 !== l[1] && (c[0] = c[1],
            o = A_(p, t, l, s, void 0, o)),
            l = c,
            c = [l[1], i, 0, 0])) : (a = !1,
            0 === c[2] && (0 !== l[1] && (c[0] = c[1],
            o = A_(p, t, l, s, void 0, o),
            l = [0, 0, 0, 0]),
            c[2] = i)) : "tableHead" === f.type ? (u = !0,
            d = i) : "tableRow" === f.type || "tableDelimiterRow" === f.type ? (d = i,
            0 !== l[1] ? (c[0] = c[1],
            o = A_(p, t, l, s, i, o)) : 0 !== c[1] && (o = A_(p, t, c, s, i, o)),
            s = 0) : !s || "data" !== f.type && "tableDelimiterMarker" !== f.type && "tableDelimiterFiller" !== f.type || (c[3] = i)
        }
        for (0 !== d && C_(p, t, d, n, r),
        p.consume(t.events),
        i = -1; ++i < t.events.length; ) {
            const e = t.events[i];
            "enter" === e[0] && "table" === e[1].type && (e[1]._align = E_(t.events, i))
        }
        return e
    }
    function A_(e, t, n, r, o, i) {
        const a = 1 === r ? "tableHeader" : 2 === r ? "tableDelimiter" : "tableData";
        0 !== n[0] && (i.end = Object.assign({}, P_(t.events, n[0])),
        e.add(n[0], 0, [["exit", i, t]]));
        const s = P_(t.events, n[1]);
        if (i = {
            type: a,
            start: Object.assign({}, s),
            end: Object.assign({}, s)
        },
        e.add(n[1], 0, [["enter", i, t]]),
        0 !== n[2]) {
            const o = P_(t.events, n[2])
              , i = P_(t.events, n[3])
              , a = {
                type: "tableContent",
                start: Object.assign({}, o),
                end: Object.assign({}, i)
            };
            if (e.add(n[2], 0, [["enter", a, t]]),
            2 !== r) {
                const r = t.events[n[2]]
                  , o = t.events[n[3]];
                if (r[1].end = Object.assign({}, o[1].end),
                r[1].type = "chunkText",
                r[1].contentType = "text",
                n[3] > n[2] + 1) {
                    const t = n[2] + 1
                      , r = n[3] - n[2] - 1;
                    e.add(t, r, [])
                }
            }
            e.add(n[3] + 1, 0, [["exit", a, t]])
        }
        return void 0 !== o && (i.end = Object.assign({}, P_(t.events, o)),
        e.add(o, 0, [["exit", i, t]]),
        i = void 0),
        i
    }
    function C_(e, t, n, r, o) {
        const i = []
          , a = P_(t.events, n);
        o && (o.end = Object.assign({}, a),
        i.push(["exit", o, t])),
        r.end = Object.assign({}, a),
        i.push(["exit", r, t]),
        e.add(n + 1, 0, i)
    }
    function P_(e, t) {
        const n = e[t]
          , r = "enter" === n[0] ? "start" : "end";
        return n[1][r]
    }
    const D_ = {
        tokenize: function(e, t, n) {
            const r = this;
            return function(t) {
                if (null !== r.previous || !r._gfmTasklistFirstContentOfListItem)
                    return n(t);
                return e.enter("taskListCheck"),
                e.enter("taskListCheckMarker"),
                e.consume(t),
                e.exit("taskListCheckMarker"),
                o
            }
            ;
            function o(t) {
                return Nv(t) ? (e.enter("taskListCheckValueUnchecked"),
                e.consume(t),
                e.exit("taskListCheckValueUnchecked"),
                i) : 88 === t || 120 === t ? (e.enter("taskListCheckValueChecked"),
                e.consume(t),
                e.exit("taskListCheckValueChecked"),
                i) : n(t)
            }
            function i(t) {
                return 93 === t ? (e.enter("taskListCheckMarker"),
                e.consume(t),
                e.exit("taskListCheckMarker"),
                e.exit("taskListCheck"),
                a) : n(t)
            }
            function a(r) {
                return Rv(r) ? t(r) : $v(r) ? e.check({
                    tokenize: R_
                }, t, n)(r) : n(r)
            }
        }
    };
    function R_(e, t, n) {
        return Aw(e, (function(e) {
            return null === e ? n(e) : t(e)
        }
        ), "whitespace")
    }
    const N_ = {};
    function $_(e) {
        const t = e || N_
          , n = this.data()
          , r = n.micromarkExtensions || (n.micromarkExtensions = [])
          , o = n.fromMarkdownExtensions || (n.fromMarkdownExtensions = [])
          , i = n.toMarkdownExtensions || (n.toMarkdownExtensions = []);
        r.push(function(e) {
            return ow([{
                text: mw
            }, {
                document: {
                    91: {
                        tokenize: y_,
                        continuation: {
                            tokenize: w_
                        },
                        exit: __
                    }
                },
                text: {
                    91: {
                        tokenize: v_
                    },
                    93: {
                        add: "after",
                        tokenize: b_,
                        resolveTo: O_
                    }
                }
            }, k_(e), {
                flow: {
                    null: {
                        tokenize: x_,
                        resolveAll: T_
                    }
                }
            }, {
                text: {
                    91: D_
                }
            }])
        }(t)),
        o.push([{
            transforms: [Vv],
            enter: {
                literalAutolink: zv,
                literalAutolinkEmail: qv,
                literalAutolinkHttp: qv,
                literalAutolinkWww: qv
            },
            exit: {
                literalAutolink: Xv,
                literalAutolinkEmail: Wv,
                literalAutolinkHttp: Hv,
                literalAutolinkWww: Zv
            }
        }, {
            enter: {
                gfmFootnoteDefinition: ey,
                gfmFootnoteDefinitionLabelString: ty,
                gfmFootnoteCall: oy,
                gfmFootnoteCallString: iy
            },
            exit: {
                gfmFootnoteDefinition: ry,
                gfmFootnoteDefinitionLabelString: ny,
                gfmFootnoteCall: sy,
                gfmFootnoteCallString: ay
            }
        }, {
            canContainEols: ["delete"],
            enter: {
                strikethrough: py
            },
            exit: {
                strikethrough: hy
            }
        }, {
            enter: {
                table: qy,
                tableData: Xy,
                tableHeader: Xy,
                tableRow: Zy
            },
            exit: {
                codeText: Vy,
                table: Hy,
                tableData: Wy,
                tableHeader: Wy,
                tableRow: Wy
            }
        }, {
            exit: {
                taskListCheckValueChecked: Ky,
                taskListCheckValueUnchecked: Ky,
                paragraph: Jy
            }
        }]),
        i.push(function(e) {
            return {
                extensions: [{
                    unsafe: [{
                        character: "@",
                        before: "[+\\-.\\w]",
                        after: "[\\-.\\w]",
                        inConstruct: Fv,
                        notInConstruct: jv
                    }, {
                        character: ".",
                        before: "[Ww]",
                        after: "[\\-.\\w]",
                        inConstruct: Fv,
                        notInConstruct: jv
                    }, {
                        character: ":",
                        before: "[ps]",
                        after: "\\/",
                        inConstruct: Fv,
                        notInConstruct: jv
                    }]
                }, {
                    unsafe: [{
                        character: "[",
                        inConstruct: ["phrasing", "label", "reference"]
                    }],
                    handlers: {
                        footnoteDefinition: cy,
                        footnoteReference: ly
                    }
                }, {
                    unsafe: [{
                        character: "~",
                        inConstruct: "phrasing",
                        notInConstruct: dy
                    }],
                    handlers: {
                        delete: fy
                    }
                }, Yy(e), {
                    unsafe: [{
                        atBreak: !0,
                        character: "-",
                        after: "[:|-]"
                    }],
                    handlers: {
                        listItem: ew
                    }
                }]
            }
        }(t))
    }
    const I_ = {
        tokenize: function(e) {
            const t = e.attempt(this.parser.constructs.contentInitial, (function(n) {
                if (null === n)
                    return void e.consume(n);
                return e.enter("lineEnding"),
                e.consume(n),
                e.exit("lineEnding"),
                Aw(e, t, "linePrefix")
            }
            ), (function(t) {
                return e.enter("paragraph"),
                r(t)
            }
            ));
            let n;
            return t;
            function r(t) {
                const r = e.enter("chunkText", {
                    contentType: "text",
                    previous: n
                });
                return n && (n.next = r),
                n = r,
                o(t)
            }
            function o(t) {
                return null === t ? (e.exit("chunkText"),
                e.exit("paragraph"),
                void e.consume(t)) : Rv(t) ? (e.consume(t),
                e.exit("chunkText"),
                r) : (e.consume(t),
                o)
            }
        }
    };
    const M_ = {
        tokenize: function(e) {
            const t = this
              , n = [];
            let r, o, i, a = 0;
            return s;
            function s(r) {
                if (a < n.length) {
                    const o = n[a];
                    return t.containerState = o[1],
                    e.attempt(o[0].continuation, l, c)(r)
                }
                return c(r)
            }
            function l(e) {
                if (a++,
                t.containerState._closeFlow) {
                    t.containerState._closeFlow = void 0,
                    r && O();
                    const n = t.events.length;
                    let o, i = n;
                    for (; i--; )
                        if ("exit" === t.events[i][0] && "chunkFlow" === t.events[i][1].type) {
                            o = t.events[i][1].end;
                            break
                        }
                    b(a);
                    let s = n;
                    for (; s < t.events.length; )
                        t.events[s][1].end = Object.assign({}, o),
                        s++;
                    return tw(t.events, i + 1, 0, t.events.slice(n)),
                    t.events.length = s,
                    c(e)
                }
                return s(e)
            }
            function c(o) {
                if (a === n.length) {
                    if (!r)
                        return p(o);
                    if (r.currentConstruct && r.currentConstruct.concrete)
                        return f(o);
                    t.interrupt = Boolean(r.currentConstruct && !r._gfmTableDynamicInterruptHack)
                }
                return t.containerState = {},
                e.check(L_, u, d)(o)
            }
            function u(e) {
                return r && O(),
                b(a),
                p(e)
            }
            function d(e) {
                return t.parser.lazy[t.now().line] = a !== n.length,
                i = t.now().offset,
                f(e)
            }
            function p(n) {
                return t.containerState = {},
                e.attempt(L_, h, f)(n)
            }
            function h(e) {
                return a++,
                n.push([t.currentConstruct, t.containerState]),
                p(e)
            }
            function f(n) {
                return null === n ? (r && O(),
                b(0),
                void e.consume(n)) : (r = r || t.parser.flow(t.now()),
                e.enter("chunkFlow", {
                    contentType: "flow",
                    previous: o,
                    _tokenizer: r
                }),
                m(n))
            }
            function m(n) {
                return null === n ? (g(e.exit("chunkFlow"), !0),
                b(0),
                void e.consume(n)) : Rv(n) ? (e.consume(n),
                g(e.exit("chunkFlow")),
                a = 0,
                t.interrupt = void 0,
                s) : (e.consume(n),
                m)
            }
            function g(e, n) {
                const s = t.sliceStream(e);
                if (n && s.push(null),
                e.previous = o,
                o && (o.next = e),
                o = e,
                r.defineSkip(e.start),
                r.write(s),
                t.parser.lazy[e.start.line]) {
                    let e = r.events.length;
                    for (; e--; )
                        if (r.events[e][1].start.offset < i && (!r.events[e][1].end || r.events[e][1].end.offset > i))
                            return;
                    const n = t.events.length;
                    let o, s, l = n;
                    for (; l--; )
                        if ("exit" === t.events[l][0] && "chunkFlow" === t.events[l][1].type) {
                            if (o) {
                                s = t.events[l][1].end;
                                break
                            }
                            o = !0
                        }
                    for (b(a),
                    e = n; e < t.events.length; )
                        t.events[e][1].end = Object.assign({}, s),
                        e++;
                    tw(t.events, l + 1, 0, t.events.slice(n)),
                    t.events.length = e
                }
            }
            function b(r) {
                let o = n.length;
                for (; o-- > r; ) {
                    const r = n[o];
                    t.containerState = r[1],
                    r[0].exit.call(t, e)
                }
                n.length = r
            }
            function O() {
                r.write([null]),
                o = void 0,
                r = void 0,
                t.containerState._closeFlow = void 0
            }
        }
    }
      , L_ = {
        tokenize: function(e, t, n) {
            return Aw(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)
        }
    };
    const Q_ = {
        tokenize: function(e) {
            const t = this
              , n = e.attempt(Cw, (function(r) {
                if (null === r)
                    return void e.consume(r);
                return e.enter("lineEndingBlank"),
                e.consume(r),
                e.exit("lineEndingBlank"),
                t.currentConstruct = void 0,
                n
            }
            ), e.attempt(this.parser.constructs.flowInitial, r, Aw(e, e.attempt(this.parser.constructs.flow, r, e.attempt(jw, r)), "linePrefix")));
            return n;
            function r(r) {
                if (null !== r)
                    return e.enter("lineEnding"),
                    e.consume(r),
                    e.exit("lineEnding"),
                    t.currentConstruct = void 0,
                    n;
                e.consume(r)
            }
        }
    };
    const B_ = {
        resolveAll: z_()
    }
      , U_ = j_("string")
      , F_ = j_("text");
    function j_(e) {
        return {
            tokenize: function(t) {
                const n = this
                  , r = this.parser.constructs[e]
                  , o = t.attempt(r, i, a);
                return i;
                function i(e) {
                    return l(e) ? o(e) : a(e)
                }
                function a(e) {
                    if (null !== e)
                        return t.enter("data"),
                        t.consume(e),
                        s;
                    t.consume(e)
                }
                function s(e) {
                    return l(e) ? (t.exit("data"),
                    o(e)) : (t.consume(e),
                    s)
                }
                function l(e) {
                    if (null === e)
                        return !0;
                    const t = r[e];
                    let o = -1;
                    if (t)
                        for (; ++o < t.length; ) {
                            const e = t[o];
                            if (!e.previous || e.previous.call(n, n.previous))
                                return !0
                        }
                    return !1
                }
            },
            resolveAll: z_("text" === e ? q_ : void 0)
        }
    }
    function z_(e) {
        return function(t, n) {
            let r, o = -1;
            for (; ++o <= t.length; )
                void 0 === r ? t[o] && "data" === t[o][1].type && (r = o,
                o++) : t[o] && "data" === t[o][1].type || (o !== r + 2 && (t[r][1].end = t[o - 1][1].end,
                t.splice(r + 2, o - r - 2),
                o = r + 2),
                r = void 0);
            return e ? e(t, n) : t
        }
    }
    function q_(e, t) {
        let n = 0;
        for (; ++n <= e.length; )
            if ((n === e.length || "lineEnding" === e[n][1].type) && "data" === e[n - 1][1].type) {
                const r = e[n - 1][1]
                  , o = t.sliceStream(r);
                let i, a = o.length, s = -1, l = 0;
                for (; a--; ) {
                    const e = o[a];
                    if ("string" == typeof e) {
                        for (s = e.length; 32 === e.charCodeAt(s - 1); )
                            l++,
                            s--;
                        if (s)
                            break;
                        s = -1
                    } else if (-2 === e)
                        i = !0,
                        l++;
                    else if (-1 !== e) {
                        a++;
                        break
                    }
                }
                if (l) {
                    const o = {
                        type: n === e.length || i || l < 2 ? "lineSuffix" : "hardBreakTrailing",
                        start: {
                            line: r.end.line,
                            column: r.end.column - l,
                            offset: r.end.offset - l,
                            _index: r.start._index + a,
                            _bufferIndex: a ? s : r.start._bufferIndex + s
                        },
                        end: Object.assign({}, r.end)
                    };
                    r.end = Object.assign({}, o.start),
                    r.start.offset === r.end.offset ? Object.assign(r, o) : (e.splice(n, 0, ["enter", o, t], ["exit", o, t]),
                    n += 2)
                }
                n++
            }
        return e
    }
    function H_(e, t, n) {
        let r = Object.assign(n ? Object.assign({}, n) : {
            line: 1,
            column: 1,
            offset: 0
        }, {
            _index: 0,
            _bufferIndex: -1
        });
        const o = {}
          , i = [];
        let a = []
          , s = [];
        const l = {
            consume: function(e) {
                Rv(e) ? (r.line++,
                r.column = 1,
                r.offset += -3 === e ? 2 : 1,
                O()) : -1 !== e && (r.column++,
                r.offset++);
                r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++,
                r._bufferIndex === a[r._index].length && (r._bufferIndex = -1,
                r._index++));
                c.previous = e
            },
            enter: function(e, t) {
                const n = t || {};
                return n.type = e,
                n.start = p(),
                c.events.push(["enter", n, c]),
                s.push(n),
                n
            },
            exit: function(e) {
                const t = s.pop();
                return t.end = p(),
                c.events.push(["exit", t, c]),
                t
            },
            attempt: g((function(e, t) {
                b(e, t.from)
            }
            )),
            check: g(m),
            interrupt: g(m, {
                interrupt: !0
            })
        }
          , c = {
            previous: null,
            code: null,
            containerState: {},
            events: [],
            parser: e,
            sliceStream: d,
            sliceSerialize: function(e, t) {
                return function(e, t) {
                    let n = -1;
                    const r = [];
                    let o;
                    for (; ++n < e.length; ) {
                        const i = e[n];
                        let a;
                        if ("string" == typeof i)
                            a = i;
                        else
                            switch (i) {
                            case -5:
                                a = "\r";
                                break;
                            case -4:
                                a = "\n";
                                break;
                            case -3:
                                a = "\r\n";
                                break;
                            case -2:
                                a = t ? " " : "\t";
                                break;
                            case -1:
                                if (!t && o)
                                    continue;
                                a = " ";
                                break;
                            default:
                                a = String.fromCharCode(i)
                            }
                        o = -2 === i,
                        r.push(a)
                    }
                    return r.join("")
                }(d(e), t)
            },
            now: p,
            defineSkip: function(e) {
                o[e.line] = e.column,
                O()
            },
            write: function(e) {
                if (a = nw(a, e),
                h(),
                null !== a[a.length - 1])
                    return [];
                return b(t, 0),
                c.events = Sw(i, c.events, c),
                c.events
            }
        };
        let u = t.tokenize.call(c, l);
        return t.resolveAll && i.push(t),
        c;
        function d(e) {
            return function(e, t) {
                const n = t.start._index
                  , r = t.start._bufferIndex
                  , o = t.end._index
                  , i = t.end._bufferIndex;
                let a;
                if (n === o)
                    a = [e[n].slice(r, i)];
                else {
                    if (a = e.slice(n, o),
                    r > -1) {
                        const e = a[0];
                        "string" == typeof e ? a[0] = e.slice(r) : a.shift()
                    }
                    i > 0 && a.push(e[o].slice(0, i))
                }
                return a
            }(a, e)
        }
        function p() {
            const {line: e, column: t, offset: n, _index: o, _bufferIndex: i} = r;
            return {
                line: e,
                column: t,
                offset: n,
                _index: o,
                _bufferIndex: i
            }
        }
        function h() {
            let e;
            for (; r._index < a.length; ) {
                const t = a[r._index];
                if ("string" == typeof t)
                    for (e = r._index,
                    r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === e && r._bufferIndex < t.length; )
                        f(t.charCodeAt(r._bufferIndex));
                else
                    f(t)
            }
        }
        function f(e) {
            u = u(e)
        }
        function m(e, t) {
            t.restore()
        }
        function g(e, t) {
            return function(n, o, i) {
                let a, u, d, h;
                return Array.isArray(n) ? f(n) : "tokenize"in n ? f([n]) : function(e) {
                    return t;
                    function t(t) {
                        const n = null !== t && e[t]
                          , r = null !== t && e.null;
                        return f([...Array.isArray(n) ? n : n ? [n] : [], ...Array.isArray(r) ? r : r ? [r] : []])(t)
                    }
                }(n);
                function f(e) {
                    return a = e,
                    u = 0,
                    0 === e.length ? i : m(e[u])
                }
                function m(e) {
                    return function(n) {
                        h = function() {
                            const e = p()
                              , t = c.previous
                              , n = c.currentConstruct
                              , o = c.events.length
                              , i = Array.from(s);
                            return {
                                restore: a,
                                from: o
                            };
                            function a() {
                                r = e,
                                c.previous = t,
                                c.currentConstruct = n,
                                c.events.length = o,
                                s = i,
                                O()
                            }
                        }(),
                        d = e,
                        e.partial || (c.currentConstruct = e);
                        if (e.name && c.parser.constructs.disable.null.includes(e.name))
                            return b();
                        return e.tokenize.call(t ? Object.assign(Object.create(c), t) : c, l, g, b)(n)
                    }
                }
                function g(t) {
                    return e(d, h),
                    o
                }
                function b(e) {
                    return h.restore(),
                    ++u < a.length ? m(a[u]) : i
                }
            }
        }
        function b(e, t) {
            e.resolveAll && !i.includes(e) && i.push(e),
            e.resolve && tw(c.events, t, c.events.length - t, e.resolve(c.events.slice(t), c)),
            e.resolveTo && (c.events = e.resolveTo(c.events, c))
        }
        function O() {
            r.line in o && r.column < 2 && (r.column = o[r.line],
            r.offset += o[r.line] - 1)
        }
    }
    const Z_ = {
        42: p_,
        43: p_,
        45: p_,
        48: p_,
        49: p_,
        50: p_,
        51: p_,
        52: p_,
        53: p_,
        54: p_,
        55: p_,
        56: p_,
        57: p_,
        62: Pw
    }
      , W_ = {
        91: Xw
    }
      , X_ = {
        [-2]: Iw,
        [-1]: Iw,
        32: Iw
    }
      , V_ = {
        35: Yw,
        42: d_,
        45: [m_, d_],
        60: e_,
        61: m_,
        95: d_,
        96: $w,
        126: $w
    }
      , G_ = {
        38: Rw,
        92: Dw
    }
      , Y_ = {
        [-5]: u_,
        [-4]: u_,
        [-3]: u_,
        33: l_,
        38: Rw,
        42: Ew,
        60: [Tw, r_],
        91: c_,
        92: [Gw, Dw],
        93: o_,
        95: Ew,
        96: Lw
    }
      , K_ = {
        null: [Ew, B_]
    }
      , J_ = Object.freeze(Object.defineProperty({
        __proto__: null,
        attentionMarkers: {
            null: [42, 95]
        },
        contentInitial: W_,
        disable: {
            null: []
        },
        document: Z_,
        flow: V_,
        flowInitial: X_,
        insideSpan: K_,
        string: G_,
        text: Y_
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    const ek = /[\0\t\n\r]/g;
    function tk(e) {
        return e && "object" == typeof e ? "position"in e || "type"in e ? rk(e.position) : "start"in e || "end"in e ? rk(e) : "line"in e || "column"in e ? nk(e) : "" : ""
    }
    function nk(e) {
        return ok(e && e.line) + ":" + ok(e && e.column)
    }
    function rk(e) {
        return nk(e && e.start) + "-" + nk(e && e.end)
    }
    function ok(e) {
        return e && "number" == typeof e ? e : 1
    }
    const ik = {}.hasOwnProperty;
    function ak(e, t, n) {
        return "string" != typeof t && (n = t,
        t = void 0),
        function(e) {
            const t = {
                transforms: [],
                canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
                enter: {
                    autolink: i(te),
                    autolinkProtocol: E,
                    autolinkEmail: E,
                    atxHeading: i(Y),
                    blockQuote: i(Z),
                    characterEscape: E,
                    characterReference: E,
                    codeFenced: i(W),
                    codeFencedFenceInfo: a,
                    codeFencedFenceMeta: a,
                    codeIndented: i(W, a),
                    codeText: i(X, a),
                    codeTextData: E,
                    data: E,
                    codeFlowValue: E,
                    definition: i(V),
                    definitionDestinationString: a,
                    definitionLabelString: a,
                    definitionTitleString: a,
                    emphasis: i(G),
                    hardBreakEscape: i(K),
                    hardBreakTrailing: i(K),
                    htmlFlow: i(J, a),
                    htmlFlowData: E,
                    htmlText: i(J, a),
                    htmlTextData: E,
                    image: i(ee),
                    label: a,
                    link: i(te),
                    listItem: i(re),
                    listItemValue: p,
                    listOrdered: i(ne, d),
                    listUnordered: i(ne),
                    paragraph: i(oe),
                    reference: B,
                    referenceString: a,
                    resourceDestinationString: a,
                    resourceTitleString: a,
                    setextHeading: i(Y),
                    strong: i(ie),
                    thematicBreak: i(se)
                },
                exit: {
                    atxHeading: l(),
                    atxHeadingSequence: w,
                    autolink: l(),
                    autolinkEmail: H,
                    autolinkProtocol: q,
                    blockQuote: l(),
                    characterEscapeValue: x,
                    characterReferenceMarkerHexadecimal: F,
                    characterReferenceMarkerNumeric: F,
                    characterReferenceValue: j,
                    characterReference: z,
                    codeFenced: l(g),
                    codeFencedFence: m,
                    codeFencedFenceInfo: h,
                    codeFencedFenceMeta: f,
                    codeFlowValue: x,
                    codeIndented: l(b),
                    codeText: l(D),
                    codeTextData: x,
                    data: x,
                    definition: l(),
                    definitionDestinationString: y,
                    definitionLabelString: O,
                    definitionTitleString: v,
                    emphasis: l(),
                    hardBreakEscape: l(A),
                    hardBreakTrailing: l(A),
                    htmlFlow: l(C),
                    htmlFlowData: x,
                    htmlText: l(P),
                    htmlTextData: x,
                    image: l(N),
                    label: I,
                    labelText: $,
                    lineEnding: T,
                    link: l(R),
                    listItem: l(),
                    listOrdered: l(),
                    listUnordered: l(),
                    paragraph: l(),
                    referenceString: U,
                    resourceDestinationString: M,
                    resourceTitleString: L,
                    resource: Q,
                    setextHeading: l(S),
                    setextHeadingLineSequence: k,
                    setextHeadingText: _,
                    strong: l(),
                    thematicBreak: l()
                }
            };
            lk(t, (e || {}).mdastExtensions || []);
            const n = {};
            return r;
            function r(e) {
                let r = {
                    type: "root",
                    children: []
                };
                const i = {
                    stack: [r],
                    tokenStack: [],
                    config: t,
                    enter: s,
                    exit: c,
                    buffer: a,
                    resume: u,
                    data: n
                }
                  , l = [];
                let d = -1;
                for (; ++d < e.length; )
                    if ("listOrdered" === e[d][1].type || "listUnordered" === e[d][1].type)
                        if ("enter" === e[d][0])
                            l.push(d);
                        else {
                            d = o(e, l.pop(), d)
                        }
                for (d = -1; ++d < e.length; ) {
                    const n = t[e[d][0]];
                    ik.call(n, e[d][1].type) && n[e[d][1].type].call(Object.assign({
                        sliceSerialize: e[d][2].sliceSerialize
                    }, i), e[d][1])
                }
                if (i.tokenStack.length > 0) {
                    const e = i.tokenStack[i.tokenStack.length - 1];
                    (e[1] || uk).call(i, void 0, e[0])
                }
                for (r.position = {
                    start: sk(e.length > 0 ? e[0][1].start : {
                        line: 1,
                        column: 1,
                        offset: 0
                    }),
                    end: sk(e.length > 0 ? e[e.length - 2][1].end : {
                        line: 1,
                        column: 1,
                        offset: 0
                    })
                },
                d = -1; ++d < t.transforms.length; )
                    r = t.transforms[d](r) || r;
                return r
            }
            function o(e, t, n) {
                let r, o, i, a, s = t - 1, l = -1, c = !1;
                for (; ++s <= n; ) {
                    const t = e[s];
                    switch (t[1].type) {
                    case "listUnordered":
                    case "listOrdered":
                    case "blockQuote":
                        "enter" === t[0] ? l++ : l--,
                        a = void 0;
                        break;
                    case "lineEndingBlank":
                        "enter" === t[0] && (!r || a || l || i || (i = s),
                        a = void 0);
                        break;
                    case "linePrefix":
                    case "listItemValue":
                    case "listItemMarker":
                    case "listItemPrefix":
                    case "listItemPrefixWhitespace":
                        break;
                    default:
                        a = void 0
                    }
                    if (!l && "enter" === t[0] && "listItemPrefix" === t[1].type || -1 === l && "exit" === t[0] && ("listUnordered" === t[1].type || "listOrdered" === t[1].type)) {
                        if (r) {
                            let a = s;
                            for (o = void 0; a--; ) {
                                const t = e[a];
                                if ("lineEnding" === t[1].type || "lineEndingBlank" === t[1].type) {
                                    if ("exit" === t[0])
                                        continue;
                                    o && (e[o][1].type = "lineEndingBlank",
                                    c = !0),
                                    t[1].type = "lineEnding",
                                    o = a
                                } else if ("linePrefix" !== t[1].type && "blockQuotePrefix" !== t[1].type && "blockQuotePrefixWhitespace" !== t[1].type && "blockQuoteMarker" !== t[1].type && "listItemIndent" !== t[1].type)
                                    break
                            }
                            i && (!o || i < o) && (r._spread = !0),
                            r.end = Object.assign({}, o ? e[o][1].start : t[1].end),
                            e.splice(o || s, 0, ["exit", r, t[2]]),
                            s++,
                            n++
                        }
                        if ("listItemPrefix" === t[1].type) {
                            const o = {
                                type: "listItem",
                                _spread: !1,
                                start: Object.assign({}, t[1].start),
                                end: void 0
                            };
                            r = o,
                            e.splice(s, 0, ["enter", o, t[2]]),
                            s++,
                            n++,
                            i = void 0,
                            a = !0
                        }
                    }
                }
                return e[t][1]._spread = c,
                n
            }
            function i(e, t) {
                return n;
                function n(n) {
                    s.call(this, e(n), n),
                    t && t.call(this, n)
                }
            }
            function a() {
                this.stack.push({
                    type: "fragment",
                    children: []
                })
            }
            function s(e, t, n) {
                this.stack[this.stack.length - 1].children.push(e),
                this.stack.push(e),
                this.tokenStack.push([t, n]),
                e.position = {
                    start: sk(t.start),
                    end: void 0
                }
            }
            function l(e) {
                return t;
                function t(t) {
                    e && e.call(this, t),
                    c.call(this, t)
                }
            }
            function c(e, t) {
                const n = this.stack.pop()
                  , r = this.tokenStack.pop();
                if (!r)
                    throw new Error("Cannot close `" + e.type + "` (" + tk({
                        start: e.start,
                        end: e.end
                    }) + "): it’s not open");
                if (r[0].type !== e.type)
                    if (t)
                        t.call(this, e, r[0]);
                    else {
                        (r[1] || uk).call(this, e, r[0])
                    }
                n.position.end = sk(e.end)
            }
            function u() {
                return Sy(this.stack.pop())
            }
            function d() {
                this.data.expectingFirstListItemValue = !0
            }
            function p(e) {
                if (this.data.expectingFirstListItemValue) {
                    this.stack[this.stack.length - 2].start = Number.parseInt(this.sliceSerialize(e), 10),
                    this.data.expectingFirstListItemValue = void 0
                }
            }
            function h() {
                const e = this.resume();
                this.stack[this.stack.length - 1].lang = e
            }
            function f() {
                const e = this.resume();
                this.stack[this.stack.length - 1].meta = e
            }
            function m() {
                this.data.flowCodeInside || (this.buffer(),
                this.data.flowCodeInside = !0)
            }
            function g() {
                const e = this.resume();
                this.stack[this.stack.length - 1].value = e.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""),
                this.data.flowCodeInside = void 0
            }
            function b() {
                const e = this.resume();
                this.stack[this.stack.length - 1].value = e.replace(/(\r?\n|\r)$/g, "")
            }
            function O(e) {
                const t = this.resume()
                  , n = this.stack[this.stack.length - 1];
                n.label = t,
                n.identifier = Jv(this.sliceSerialize(e)).toLowerCase()
            }
            function v() {
                const e = this.resume();
                this.stack[this.stack.length - 1].title = e
            }
            function y() {
                const e = this.resume();
                this.stack[this.stack.length - 1].url = e
            }
            function w(e) {
                const t = this.stack[this.stack.length - 1];
                if (!t.depth) {
                    const n = this.sliceSerialize(e).length;
                    t.depth = n
                }
            }
            function _() {
                this.data.setextHeadingSlurpLineEnding = !0
            }
            function k(e) {
                this.stack[this.stack.length - 1].depth = 61 === this.sliceSerialize(e).codePointAt(0) ? 1 : 2
            }
            function S() {
                this.data.setextHeadingSlurpLineEnding = void 0
            }
            function E(e) {
                const t = this.stack[this.stack.length - 1].children;
                let n = t[t.length - 1];
                n && "text" === n.type || (n = ae(),
                n.position = {
                    start: sk(e.start),
                    end: void 0
                },
                t.push(n)),
                this.stack.push(n)
            }
            function x(e) {
                const t = this.stack.pop();
                t.value += this.sliceSerialize(e),
                t.position.end = sk(e.end)
            }
            function T(e) {
                const n = this.stack[this.stack.length - 1];
                if (this.data.atHardBreak) {
                    return n.children[n.children.length - 1].position.end = sk(e.end),
                    void (this.data.atHardBreak = void 0)
                }
                !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(n.type) && (E.call(this, e),
                x.call(this, e))
            }
            function A() {
                this.data.atHardBreak = !0
            }
            function C() {
                const e = this.resume();
                this.stack[this.stack.length - 1].value = e
            }
            function P() {
                const e = this.resume();
                this.stack[this.stack.length - 1].value = e
            }
            function D() {
                const e = this.resume();
                this.stack[this.stack.length - 1].value = e
            }
            function R() {
                const e = this.stack[this.stack.length - 1];
                if (this.data.inReference) {
                    const t = this.data.referenceType || "shortcut";
                    e.type += "Reference",
                    e.referenceType = t,
                    delete e.url,
                    delete e.title
                } else
                    delete e.identifier,
                    delete e.label;
                this.data.referenceType = void 0
            }
            function N() {
                const e = this.stack[this.stack.length - 1];
                if (this.data.inReference) {
                    const t = this.data.referenceType || "shortcut";
                    e.type += "Reference",
                    e.referenceType = t,
                    delete e.url,
                    delete e.title
                } else
                    delete e.identifier,
                    delete e.label;
                this.data.referenceType = void 0
            }
            function $(e) {
                const t = this.sliceSerialize(e)
                  , n = this.stack[this.stack.length - 2];
                n.label = function(e) {
                    return e.replace(jy, zy)
                }(t),
                n.identifier = Jv(t).toLowerCase()
            }
            function I() {
                const e = this.stack[this.stack.length - 1]
                  , t = this.resume()
                  , n = this.stack[this.stack.length - 1];
                if (this.data.inReference = !0,
                "link" === n.type) {
                    const t = e.children;
                    n.children = t
                } else
                    n.alt = t
            }
            function M() {
                const e = this.resume();
                this.stack[this.stack.length - 1].url = e
            }
            function L() {
                const e = this.resume();
                this.stack[this.stack.length - 1].title = e
            }
            function Q() {
                this.data.inReference = void 0
            }
            function B() {
                this.data.referenceType = "collapsed"
            }
            function U(e) {
                const t = this.resume()
                  , n = this.stack[this.stack.length - 1];
                n.label = t,
                n.identifier = Jv(this.sliceSerialize(e)).toLowerCase(),
                this.data.referenceType = "full"
            }
            function F(e) {
                this.data.characterReferenceType = e.type
            }
            function j(e) {
                const t = this.sliceSerialize(e)
                  , n = this.data.characterReferenceType;
                let r;
                if (n)
                    r = Fy(t, "characterReferenceMarkerNumeric" === n ? 10 : 16),
                    this.data.characterReferenceType = void 0;
                else {
                    r = Uy(t)
                }
                this.stack[this.stack.length - 1].value += r
            }
            function z(e) {
                this.stack.pop().position.end = sk(e.end)
            }
            function q(e) {
                x.call(this, e);
                this.stack[this.stack.length - 1].url = this.sliceSerialize(e)
            }
            function H(e) {
                x.call(this, e);
                this.stack[this.stack.length - 1].url = "mailto:" + this.sliceSerialize(e)
            }
            function Z() {
                return {
                    type: "blockquote",
                    children: []
                }
            }
            function W() {
                return {
                    type: "code",
                    lang: null,
                    meta: null,
                    value: ""
                }
            }
            function X() {
                return {
                    type: "inlineCode",
                    value: ""
                }
            }
            function V() {
                return {
                    type: "definition",
                    identifier: "",
                    label: null,
                    title: null,
                    url: ""
                }
            }
            function G() {
                return {
                    type: "emphasis",
                    children: []
                }
            }
            function Y() {
                return {
                    type: "heading",
                    depth: 0,
                    children: []
                }
            }
            function K() {
                return {
                    type: "break"
                }
            }
            function J() {
                return {
                    type: "html",
                    value: ""
                }
            }
            function ee() {
                return {
                    type: "image",
                    title: null,
                    url: "",
                    alt: null
                }
            }
            function te() {
                return {
                    type: "link",
                    title: null,
                    url: "",
                    children: []
                }
            }
            function ne(e) {
                return {
                    type: "list",
                    ordered: "listOrdered" === e.type,
                    start: null,
                    spread: e._spread,
                    children: []
                }
            }
            function re(e) {
                return {
                    type: "listItem",
                    spread: e._spread,
                    checked: null,
                    children: []
                }
            }
            function oe() {
                return {
                    type: "paragraph",
                    children: []
                }
            }
            function ie() {
                return {
                    type: "strong",
                    children: []
                }
            }
            function ae() {
                return {
                    type: "text",
                    value: ""
                }
            }
            function se() {
                return {
                    type: "thematicBreak"
                }
            }
        }(n)(function(e) {
            for (; !Uw(e); )
                ;
            return e
        }(function(e) {
            const t = {
                defined: [],
                lazy: {},
                constructs: ow([J_, ...(e || {}).extensions || []]),
                content: n(I_),
                document: n(M_),
                flow: n(Q_),
                string: n(U_),
                text: n(F_)
            };
            return t;
            function n(e) {
                return function(n) {
                    return H_(t, e, n)
                }
            }
        }(n).document().write(function() {
            let e, t = 1, n = "", r = !0;
            return function(o, i, a) {
                const s = [];
                let l, c, u, d, p;
                for (o = n + ("string" == typeof o ? o.toString() : new TextDecoder(i || void 0).decode(o)),
                u = 0,
                n = "",
                r && (65279 === o.charCodeAt(0) && u++,
                r = void 0); u < o.length; ) {
                    if (ek.lastIndex = u,
                    l = ek.exec(o),
                    d = l && void 0 !== l.index ? l.index : o.length,
                    p = o.charCodeAt(d),
                    !l) {
                        n = o.slice(u);
                        break
                    }
                    if (10 === p && u === d && e)
                        s.push(-3),
                        e = void 0;
                    else
                        switch (e && (s.push(-5),
                        e = void 0),
                        u < d && (s.push(o.slice(u, d)),
                        t += d - u),
                        p) {
                        case 0:
                            s.push(65533),
                            t++;
                            break;
                        case 9:
                            for (c = 4 * Math.ceil(t / 4),
                            s.push(-2); t++ < c; )
                                s.push(-1);
                            break;
                        case 10:
                            s.push(-4),
                            t = 1;
                            break;
                        default:
                            e = !0,
                            t = 1
                        }
                    u = d + 1
                }
                return a && (e && s.push(-5),
                n && s.push(n),
                s.push(null)),
                s
            }
        }()(e, t, !0))))
    }
    function sk(e) {
        return {
            line: e.line,
            column: e.column,
            offset: e.offset
        }
    }
    function lk(e, t) {
        let n = -1;
        for (; ++n < t.length; ) {
            const r = t[n];
            Array.isArray(r) ? lk(e, r) : ck(e, r)
        }
    }
    function ck(e, t) {
        let n;
        for (n in t)
            if (ik.call(t, n))
                switch (n) {
                case "canContainEols":
                    {
                        const r = t[n];
                        r && e[n].push(...r);
                        break
                    }
                case "transforms":
                    {
                        const r = t[n];
                        r && e[n].push(...r);
                        break
                    }
                case "enter":
                case "exit":
                    {
                        const r = t[n];
                        r && Object.assign(e[n], r);
                        break
                    }
                }
    }
    function uk(e, t) {
        throw e ? new Error("Cannot close `" + e.type + "` (" + tk({
            start: e.start,
            end: e.end
        }) + "): a different token (`" + t.type + "`, " + tk({
            start: t.start,
            end: t.end
        }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + tk({
            start: t.start,
            end: t.end
        }) + ") is still open")
    }
    function dk(e) {
        const t = this;
        t.parser = function(n) {
            return ak(n, {
                ...t.data("settings"),
                ...e,
                extensions: t.data("micromarkExtensions") || [],
                mdastExtensions: t.data("fromMarkdownExtensions") || []
            })
        }
    }
    function pk(e, t) {
        const n = t.referenceType;
        let r = "]";
        if ("collapsed" === n ? r += "[]" : "full" === n && (r += "[" + (t.label || t.identifier) + "]"),
        "imageReference" === t.type)
            return [{
                type: "text",
                value: "![" + t.alt + r
            }];
        const o = e.all(t)
          , i = o[0];
        i && "text" === i.type ? i.value = "[" + i.value : o.unshift({
            type: "text",
            value: "["
        });
        const a = o[o.length - 1];
        return a && "text" === a.type ? a.value += r : o.push({
            type: "text",
            value: r
        }),
        o
    }
    function hk(e) {
        const t = e.spread;
        return null == t ? e.children.length > 1 : t
    }
    const fk = 9
      , mk = 32;
    function gk(e) {
        const t = String(e)
          , n = /\r?\n|\r/g;
        let r = n.exec(t)
          , o = 0;
        const i = [];
        for (; r; )
            i.push(bk(t.slice(o, r.index), o > 0, !0), r[0]),
            o = r.index + r[0].length,
            r = n.exec(t);
        return i.push(bk(t.slice(o), o > 0, !1)),
        i.join("")
    }
    function bk(e, t, n) {
        let r = 0
          , o = e.length;
        if (t) {
            let t = e.codePointAt(r);
            for (; t === fk || t === mk; )
                r++,
                t = e.codePointAt(r)
        }
        if (n) {
            let t = e.codePointAt(o - 1);
            for (; t === fk || t === mk; )
                o--,
                t = e.codePointAt(o - 1)
        }
        return o > r ? e.slice(r, o) : ""
    }
    const Ok = {
        blockquote: function(e, t) {
            const n = {
                type: "element",
                tagName: "blockquote",
                properties: {},
                children: e.wrap(e.all(t), !0)
            };
            return e.patch(t, n),
            e.applyData(t, n)
        },
        break: function(e, t) {
            const n = {
                type: "element",
                tagName: "br",
                properties: {},
                children: []
            };
            return e.patch(t, n),
            [e.applyData(t, n), {
                type: "text",
                value: "\n"
            }]
        },
        code: function(e, t) {
            const n = t.value ? t.value + "\n" : ""
              , r = {};
            t.lang && (r.className = ["language-" + t.lang]);
            let o = {
                type: "element",
                tagName: "code",
                properties: r,
                children: [{
                    type: "text",
                    value: n
                }]
            };
            return t.meta && (o.data = {
                meta: t.meta
            }),
            e.patch(t, o),
            o = e.applyData(t, o),
            o = {
                type: "element",
                tagName: "pre",
                properties: {},
                children: [o]
            },
            e.patch(t, o),
            o
        },
        delete: function(e, t) {
            const n = {
                type: "element",
                tagName: "del",
                properties: {},
                children: e.all(t)
            };
            return e.patch(t, n),
            e.applyData(t, n)
        },
        emphasis: function(e, t) {
            const n = {
                type: "element",
                tagName: "em",
                properties: {},
                children: e.all(t)
            };
            return e.patch(t, n),
            e.applyData(t, n)
        },
        footnoteReference: function(e, t) {
            const n = "string" == typeof e.options.clobberPrefix ? e.options.clobberPrefix : "user-content-"
              , r = String(t.identifier).toUpperCase()
              , o = _w(r.toLowerCase())
              , i = e.footnoteOrder.indexOf(r);
            let a, s = e.footnoteCounts.get(r);
            void 0 === s ? (s = 0,
            e.footnoteOrder.push(r),
            a = e.footnoteOrder.length) : a = i + 1,
            s += 1,
            e.footnoteCounts.set(r, s);
            const l = {
                type: "element",
                tagName: "a",
                properties: {
                    href: "#" + n + "fn-" + o,
                    id: n + "fnref-" + o + (s > 1 ? "-" + s : ""),
                    dataFootnoteRef: !0,
                    ariaDescribedBy: ["footnote-label"]
                },
                children: [{
                    type: "text",
                    value: String(a)
                }]
            };
            e.patch(t, l);
            const c = {
                type: "element",
                tagName: "sup",
                properties: {},
                children: [l]
            };
            return e.patch(t, c),
            e.applyData(t, c)
        },
        heading: function(e, t) {
            const n = {
                type: "element",
                tagName: "h" + t.depth,
                properties: {},
                children: e.all(t)
            };
            return e.patch(t, n),
            e.applyData(t, n)
        },
        html: function(e, t) {
            if (e.options.allowDangerousHtml) {
                const n = {
                    type: "raw",
                    value: t.value
                };
                return e.patch(t, n),
                e.applyData(t, n)
            }
        },
        imageReference: function(e, t) {
            const n = String(t.identifier).toUpperCase()
              , r = e.definitionById.get(n);
            if (!r)
                return pk(e, t);
            const o = {
                src: _w(r.url || ""),
                alt: t.alt
            };
            null !== r.title && void 0 !== r.title && (o.title = r.title);
            const i = {
                type: "element",
                tagName: "img",
                properties: o,
                children: []
            };
            return e.patch(t, i),
            e.applyData(t, i)
        },
        image: function(e, t) {
            const n = {
                src: _w(t.url)
            };
            null !== t.alt && void 0 !== t.alt && (n.alt = t.alt),
            null !== t.title && void 0 !== t.title && (n.title = t.title);
            const r = {
                type: "element",
                tagName: "img",
                properties: n,
                children: []
            };
            return e.patch(t, r),
            e.applyData(t, r)
        },
        inlineCode: function(e, t) {
            const n = {
                type: "text",
                value: t.value.replace(/\r?\n|\r/g, " ")
            };
            e.patch(t, n);
            const r = {
                type: "element",
                tagName: "code",
                properties: {},
                children: [n]
            };
            return e.patch(t, r),
            e.applyData(t, r)
        },
        linkReference: function(e, t) {
            const n = String(t.identifier).toUpperCase()
              , r = e.definitionById.get(n);
            if (!r)
                return pk(e, t);
            const o = {
                href: _w(r.url || "")
            };
            null !== r.title && void 0 !== r.title && (o.title = r.title);
            const i = {
                type: "element",
                tagName: "a",
                properties: o,
                children: e.all(t)
            };
            return e.patch(t, i),
            e.applyData(t, i)
        },
        link: function(e, t) {
            const n = {
                href: _w(t.url)
            };
            null !== t.title && void 0 !== t.title && (n.title = t.title);
            const r = {
                type: "element",
                tagName: "a",
                properties: n,
                children: e.all(t)
            };
            return e.patch(t, r),
            e.applyData(t, r)
        },
        listItem: function(e, t, n) {
            const r = e.all(t)
              , o = n ? function(e) {
                let t = !1;
                if ("list" === e.type) {
                    t = e.spread || !1;
                    const n = e.children;
                    let r = -1;
                    for (; !t && ++r < n.length; )
                        t = hk(n[r])
                }
                return t
            }(n) : hk(t)
              , i = {}
              , a = [];
            if ("boolean" == typeof t.checked) {
                const e = r[0];
                let n;
                e && "element" === e.type && "p" === e.tagName ? n = e : (n = {
                    type: "element",
                    tagName: "p",
                    properties: {},
                    children: []
                },
                r.unshift(n)),
                n.children.length > 0 && n.children.unshift({
                    type: "text",
                    value: " "
                }),
                n.children.unshift({
                    type: "element",
                    tagName: "input",
                    properties: {
                        type: "checkbox",
                        checked: t.checked,
                        disabled: !0
                    },
                    children: []
                }),
                i.className = ["task-list-item"]
            }
            let s = -1;
            for (; ++s < r.length; ) {
                const e = r[s];
                (o || 0 !== s || "element" !== e.type || "p" !== e.tagName) && a.push({
                    type: "text",
                    value: "\n"
                }),
                "element" !== e.type || "p" !== e.tagName || o ? a.push(e) : a.push(...e.children)
            }
            const l = r[r.length - 1];
            l && (o || "element" !== l.type || "p" !== l.tagName) && a.push({
                type: "text",
                value: "\n"
            });
            const c = {
                type: "element",
                tagName: "li",
                properties: i,
                children: a
            };
            return e.patch(t, c),
            e.applyData(t, c)
        },
        list: function(e, t) {
            const n = {}
              , r = e.all(t);
            let o = -1;
            for ("number" == typeof t.start && 1 !== t.start && (n.start = t.start); ++o < r.length; ) {
                const e = r[o];
                if ("element" === e.type && "li" === e.tagName && e.properties && Array.isArray(e.properties.className) && e.properties.className.includes("task-list-item")) {
                    n.className = ["contains-task-list"];
                    break
                }
            }
            const i = {
                type: "element",
                tagName: t.ordered ? "ol" : "ul",
                properties: n,
                children: e.wrap(r, !0)
            };
            return e.patch(t, i),
            e.applyData(t, i)
        },
        paragraph: function(e, t) {
            const n = {
                type: "element",
                tagName: "p",
                properties: {},
                children: e.all(t)
            };
            return e.patch(t, n),
            e.applyData(t, n)
        },
        root: function(e, t) {
            const n = {
                type: "root",
                children: e.wrap(e.all(t))
            };
            return e.patch(t, n),
            e.applyData(t, n)
        },
        strong: function(e, t) {
            const n = {
                type: "element",
                tagName: "strong",
                properties: {},
                children: e.all(t)
            };
            return e.patch(t, n),
            e.applyData(t, n)
        },
        table: function(e, t) {
            const n = e.all(t)
              , r = n.shift()
              , o = [];
            if (r) {
                const n = {
                    type: "element",
                    tagName: "thead",
                    properties: {},
                    children: e.wrap([r], !0)
                };
                e.patch(t.children[0], n),
                o.push(n)
            }
            if (n.length > 0) {
                const r = {
                    type: "element",
                    tagName: "tbody",
                    properties: {},
                    children: e.wrap(n, !0)
                }
                  , i = sO(t.children[1])
                  , a = aO(t.children[t.children.length - 1]);
                i && a && (r.position = {
                    start: i,
                    end: a
                }),
                o.push(r)
            }
            const i = {
                type: "element",
                tagName: "table",
                properties: {},
                children: e.wrap(o, !0)
            };
            return e.patch(t, i),
            e.applyData(t, i)
        },
        tableCell: function(e, t) {
            const n = {
                type: "element",
                tagName: "td",
                properties: {},
                children: e.all(t)
            };
            return e.patch(t, n),
            e.applyData(t, n)
        },
        tableRow: function(e, t, n) {
            const r = n ? n.children : void 0
              , o = 0 === (r ? r.indexOf(t) : 1) ? "th" : "td"
              , i = n && "table" === n.type ? n.align : void 0
              , a = i ? i.length : t.children.length;
            let s = -1;
            const l = [];
            for (; ++s < a; ) {
                const n = t.children[s]
                  , r = {}
                  , a = i ? i[s] : void 0;
                a && (r.align = a);
                let c = {
                    type: "element",
                    tagName: o,
                    properties: r,
                    children: []
                };
                n && (c.children = e.all(n),
                e.patch(n, c),
                c = e.applyData(n, c)),
                l.push(c)
            }
            const c = {
                type: "element",
                tagName: "tr",
                properties: {},
                children: e.wrap(l, !0)
            };
            return e.patch(t, c),
            e.applyData(t, c)
        },
        text: function(e, t) {
            const n = {
                type: "text",
                value: gk(String(t.value))
            };
            return e.patch(t, n),
            e.applyData(t, n)
        },
        thematicBreak: function(e, t) {
            const n = {
                type: "element",
                tagName: "hr",
                properties: {},
                children: []
            };
            return e.patch(t, n),
            e.applyData(t, n)
        },
        toml: vk,
        yaml: vk,
        definition: vk,
        footnoteDefinition: vk
    };
    function vk() {}
    function yk(e, t) {
        const n = [{
            type: "text",
            value: "↩"
        }];
        return t > 1 && n.push({
            type: "element",
            tagName: "sup",
            properties: {},
            children: [{
                type: "text",
                value: String(t)
            }]
        }),
        n
    }
    function wk(e, t) {
        return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "")
    }
    const _k = {}.hasOwnProperty
      , kk = {};
    function Sk(e, t) {
        e.position && (t.position = cO(e))
    }
    function Ek(e, t) {
        let n = t;
        if (e && e.data) {
            const t = e.data.hName
              , r = e.data.hChildren
              , o = e.data.hProperties;
            if ("string" == typeof t)
                if ("element" === n.type)
                    n.tagName = t;
                else {
                    n = {
                        type: "element",
                        tagName: t,
                        properties: {},
                        children: "children"in n ? n.children : [n]
                    }
                }
            "element" === n.type && o && Object.assign(n.properties, dh(o)),
            "children"in n && n.children && null != r && (n.children = r)
        }
        return n
    }
    function xk(e, t) {
        const n = t.data || {}
          , r = !("value"in t) || _k.call(n, "hProperties") || _k.call(n, "hChildren") ? {
            type: "element",
            tagName: "div",
            properties: {},
            children: e.all(t)
        } : {
            type: "text",
            value: t.value
        };
        return e.patch(t, r),
        e.applyData(t, r)
    }
    function Tk(e, t) {
        const n = [];
        let r = -1;
        for (t && n.push({
            type: "text",
            value: "\n"
        }); ++r < e.length; )
            r && n.push({
                type: "text",
                value: "\n"
            }),
            n.push(e[r]);
        return t && e.length > 0 && n.push({
            type: "text",
            value: "\n"
        }),
        n
    }
    function Ak(e) {
        let t = 0
          , n = e.charCodeAt(t);
        for (; 9 === n || 32 === n; )
            t++,
            n = e.charCodeAt(t);
        return e.slice(t)
    }
    function Ck(e, t) {
        const n = function(e, t) {
            const n = t || kk
              , r = new Map
              , o = new Map
              , i = new Map
              , a = {
                ...Ok,
                ...n.handlers
            }
              , s = {
                all: function(e) {
                    const t = [];
                    if ("children"in e) {
                        const n = e.children;
                        let r = -1;
                        for (; ++r < n.length; ) {
                            const o = s.one(n[r], e);
                            if (o) {
                                if (r && "break" === n[r - 1].type && (Array.isArray(o) || "text" !== o.type || (o.value = Ak(o.value)),
                                !Array.isArray(o) && "element" === o.type)) {
                                    const e = o.children[0];
                                    e && "text" === e.type && (e.value = Ak(e.value))
                                }
                                Array.isArray(o) ? t.push(...o) : t.push(o)
                            }
                        }
                    }
                    return t
                },
                applyData: Ek,
                definitionById: r,
                footnoteById: o,
                footnoteCounts: i,
                footnoteOrder: [],
                handlers: a,
                one: function(e, t) {
                    const n = e.type
                      , r = s.handlers[n];
                    if (_k.call(s.handlers, n) && r)
                        return r(s, e, t);
                    if (s.options.passThrough && s.options.passThrough.includes(n)) {
                        if ("children"in e) {
                            const {children: t, ...n} = e
                              , r = dh(n);
                            return r.children = s.all(e),
                            r
                        }
                        return dh(e)
                    }
                    return (s.options.unknownHandler || xk)(s, e, t)
                },
                options: n,
                patch: Sk,
                wrap: Tk
            };
            return eh(e, (function(e) {
                if ("definition" === e.type || "footnoteDefinition" === e.type) {
                    const t = "definition" === e.type ? r : o
                      , n = String(e.identifier).toUpperCase();
                    t.has(n) || t.set(n, e)
                }
            }
            )),
            s
        }(e, t)
          , r = n.one(e, void 0)
          , o = function(e) {
            const t = "string" == typeof e.options.clobberPrefix ? e.options.clobberPrefix : "user-content-"
              , n = e.options.footnoteBackContent || yk
              , r = e.options.footnoteBackLabel || wk
              , o = e.options.footnoteLabel || "Footnotes"
              , i = e.options.footnoteLabelTagName || "h2"
              , a = e.options.footnoteLabelProperties || {
                className: ["sr-only"]
            }
              , s = [];
            let l = -1;
            for (; ++l < e.footnoteOrder.length; ) {
                const o = e.footnoteById.get(e.footnoteOrder[l]);
                if (!o)
                    continue;
                const i = e.all(o)
                  , a = String(o.identifier).toUpperCase()
                  , c = _w(a.toLowerCase());
                let u = 0;
                const d = []
                  , p = e.footnoteCounts.get(a);
                for (; void 0 !== p && ++u <= p; ) {
                    d.length > 0 && d.push({
                        type: "text",
                        value: " "
                    });
                    let e = "string" == typeof n ? n : n(l, u);
                    "string" == typeof e && (e = {
                        type: "text",
                        value: e
                    }),
                    d.push({
                        type: "element",
                        tagName: "a",
                        properties: {
                            href: "#" + t + "fnref-" + c + (u > 1 ? "-" + u : ""),
                            dataFootnoteBackref: "",
                            ariaLabel: "string" == typeof r ? r : r(l, u),
                            className: ["data-footnote-backref"]
                        },
                        children: Array.isArray(e) ? e : [e]
                    })
                }
                const h = i[i.length - 1];
                if (h && "element" === h.type && "p" === h.tagName) {
                    const e = h.children[h.children.length - 1];
                    e && "text" === e.type ? e.value += " " : h.children.push({
                        type: "text",
                        value: " "
                    }),
                    h.children.push(...d)
                } else
                    i.push(...d);
                const f = {
                    type: "element",
                    tagName: "li",
                    properties: {
                        id: t + "fn-" + c
                    },
                    children: e.wrap(i, !0)
                };
                e.patch(o, f),
                s.push(f)
            }
            if (0 !== s.length)
                return {
                    type: "element",
                    tagName: "section",
                    properties: {
                        dataFootnotes: !0,
                        className: ["footnotes"]
                    },
                    children: [{
                        type: "element",
                        tagName: i,
                        properties: {
                            ...dh(a),
                            id: "footnote-label"
                        },
                        children: [{
                            type: "text",
                            value: o
                        }]
                    }, {
                        type: "text",
                        value: "\n"
                    }, {
                        type: "element",
                        tagName: "ol",
                        properties: {},
                        children: e.wrap(s, !0)
                    }, {
                        type: "text",
                        value: "\n"
                    }]
                }
        }(n)
          , i = Array.isArray(r) ? {
            type: "root",
            children: r
        } : r || {
            type: "root",
            children: []
        };
        return o && i.children.push({
            type: "text",
            value: "\n"
        }, o),
        i
    }
    function Pk(e, t) {
        return e && "run"in e ? async function(n, r) {
            const o = Ck(n, {
                file: r,
                ...t
            });
            await e.run(o, r)
        }
        : function(n, r) {
            return Ck(n, {
                file: r,
                ...t || e
            })
        }
    }
    function Dk(e) {
        if (e)
            throw e
    }
    var Rk = Object.prototype.hasOwnProperty
      , Nk = Object.prototype.toString
      , $k = Object.defineProperty
      , Ik = Object.getOwnPropertyDescriptor
      , Mk = function(e) {
        return "function" == typeof Array.isArray ? Array.isArray(e) : "[object Array]" === Nk.call(e)
    }
      , Lk = function(e) {
        if (!e || "[object Object]" !== Nk.call(e))
            return !1;
        var t, n = Rk.call(e, "constructor"), r = e.constructor && e.constructor.prototype && Rk.call(e.constructor.prototype, "isPrototypeOf");
        if (e.constructor && !n && !r)
            return !1;
        for (t in e)
            ;
        return void 0 === t || Rk.call(e, t)
    }
      , Qk = function(e, t) {
        $k && "__proto__" === t.name ? $k(e, t.name, {
            enumerable: !0,
            configurable: !0,
            value: t.newValue,
            writable: !0
        }) : e[t.name] = t.newValue
    }
      , Bk = function(e, t) {
        if ("__proto__" === t) {
            if (!Rk.call(e, t))
                return;
            if (Ik)
                return Ik(e, t).value
        }
        return e[t]
    }
      , Uk = function e() {
        var t, n, r, o, i, a, s = arguments[0], l = 1, c = arguments.length, u = !1;
        for ("boolean" == typeof s && (u = s,
        s = arguments[1] || {},
        l = 2),
        (null == s || "object" != typeof s && "function" != typeof s) && (s = {}); l < c; ++l)
            if (null != (t = arguments[l]))
                for (n in t)
                    r = Bk(s, n),
                    s !== (o = Bk(t, n)) && (u && o && (Lk(o) || (i = Mk(o))) ? (i ? (i = !1,
                    a = r && Mk(r) ? r : []) : a = r && Lk(r) ? r : {},
                    Qk(s, {
                        name: n,
                        newValue: e(u, a, o)
                    })) : void 0 !== o && Qk(s, {
                        name: n,
                        newValue: o
                    }));
        return s
    };
    const Fk = Nd(Uk);
    function jk(e) {
        if ("object" != typeof e || null === e)
            return !1;
        const t = Object.getPrototypeOf(e);
        return !(null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t) || Symbol.toStringTag in e || Symbol.iterator in e)
    }
    function zk() {
        const e = []
          , t = {
            run: function(...t) {
                let n = -1;
                const r = t.pop();
                if ("function" != typeof r)
                    throw new TypeError("Expected function as last argument, not " + r);
                !function o(i, ...a) {
                    const s = e[++n];
                    let l = -1;
                    if (i)
                        r(i);
                    else {
                        for (; ++l < t.length; )
                            null !== a[l] && void 0 !== a[l] || (a[l] = t[l]);
                        t = a,
                        s ? function(e, t) {
                            let n;
                            return r;
                            function r(...t) {
                                const r = e.length > t.length;
                                let s;
                                r && t.push(o);
                                try {
                                    s = e.apply(this, t)
                                } catch (i) {
                                    if (r && n)
                                        throw i;
                                    return o(i)
                                }
                                r || (s && s.then && "function" == typeof s.then ? s.then(a, o) : s instanceof Error ? o(s) : a(s))
                            }
                            function o(e, ...r) {
                                n || (n = !0,
                                t(e, ...r))
                            }
                            function a(e) {
                                o(null, e)
                            }
                        }(s, o)(...a) : r(null, ...a)
                    }
                }(null, ...t)
            },
            use: function(n) {
                if ("function" != typeof n)
                    throw new TypeError("Expected `middelware` to be a function, not " + n);
                return e.push(n),
                t
            }
        };
        return t
    }
    class qk extends Error {
        constructor(e, t, n) {
            super(),
            "string" == typeof t && (n = t,
            t = void 0);
            let r = ""
              , o = {}
              , i = !1;
            if (t && (o = "line"in t && "column"in t || "start"in t && "end"in t ? {
                place: t
            } : "type"in t ? {
                ancestors: [t],
                place: t.position
            } : {
                ...t
            }),
            "string" == typeof e ? r = e : !o.cause && e && (i = !0,
            r = e.message,
            o.cause = e),
            !o.ruleId && !o.source && "string" == typeof n) {
                const e = n.indexOf(":");
                -1 === e ? o.ruleId = n : (o.source = n.slice(0, e),
                o.ruleId = n.slice(e + 1))
            }
            if (!o.place && o.ancestors && o.ancestors) {
                const e = o.ancestors[o.ancestors.length - 1];
                e && (o.place = e.position)
            }
            const a = o.place && "start"in o.place ? o.place.start : o.place;
            this.ancestors = o.ancestors || void 0,
            this.cause = o.cause || void 0,
            this.column = a ? a.column : void 0,
            this.fatal = void 0,
            this.file,
            this.message = r,
            this.line = a ? a.line : void 0,
            this.name = tk(o.place) || "1:1",
            this.place = o.place || void 0,
            this.reason = this.message,
            this.ruleId = o.ruleId || void 0,
            this.source = o.source || void 0,
            this.stack = i && o.cause && "string" == typeof o.cause.stack ? o.cause.stack : "",
            this.actual,
            this.expected,
            this.note,
            this.url
        }
    }
    qk.prototype.file = "",
    qk.prototype.name = "",
    qk.prototype.reason = "",
    qk.prototype.message = "",
    qk.prototype.stack = "",
    qk.prototype.column = void 0,
    qk.prototype.line = void 0,
    qk.prototype.ancestors = void 0,
    qk.prototype.cause = void 0,
    qk.prototype.fatal = void 0,
    qk.prototype.place = void 0,
    qk.prototype.ruleId = void 0,
    qk.prototype.source = void 0;
    const Hk = {
        basename: function(e, t) {
            if (void 0 !== t && "string" != typeof t)
                throw new TypeError('"ext" argument must be a string');
            Zk(e);
            let n, r = 0, o = -1, i = e.length;
            if (void 0 === t || 0 === t.length || t.length > e.length) {
                for (; i--; )
                    if (47 === e.codePointAt(i)) {
                        if (n) {
                            r = i + 1;
                            break
                        }
                    } else
                        o < 0 && (n = !0,
                        o = i + 1);
                return o < 0 ? "" : e.slice(r, o)
            }
            if (t === e)
                return "";
            let a = -1
              , s = t.length - 1;
            for (; i--; )
                if (47 === e.codePointAt(i)) {
                    if (n) {
                        r = i + 1;
                        break
                    }
                } else
                    a < 0 && (n = !0,
                    a = i + 1),
                    s > -1 && (e.codePointAt(i) === t.codePointAt(s--) ? s < 0 && (o = i) : (s = -1,
                    o = a));
            r === o ? o = a : o < 0 && (o = e.length);
            return e.slice(r, o)
        },
        dirname: function(e) {
            if (Zk(e),
            0 === e.length)
                return ".";
            let t, n = -1, r = e.length;
            for (; --r; )
                if (47 === e.codePointAt(r)) {
                    if (t) {
                        n = r;
                        break
                    }
                } else
                    t || (t = !0);
            return n < 0 ? 47 === e.codePointAt(0) ? "/" : "." : 1 === n && 47 === e.codePointAt(0) ? "//" : e.slice(0, n)
        },
        extname: function(e) {
            Zk(e);
            let t, n = e.length, r = -1, o = 0, i = -1, a = 0;
            for (; n--; ) {
                const s = e.codePointAt(n);
                if (47 !== s)
                    r < 0 && (t = !0,
                    r = n + 1),
                    46 === s ? i < 0 ? i = n : 1 !== a && (a = 1) : i > -1 && (a = -1);
                else if (t) {
                    o = n + 1;
                    break
                }
            }
            if (i < 0 || r < 0 || 0 === a || 1 === a && i === r - 1 && i === o + 1)
                return "";
            return e.slice(i, r)
        },
        join: function(...e) {
            let t, n = -1;
            for (; ++n < e.length; )
                Zk(e[n]),
                e[n] && (t = void 0 === t ? e[n] : t + "/" + e[n]);
            return void 0 === t ? "." : function(e) {
                Zk(e);
                const t = 47 === e.codePointAt(0);
                let n = function(e, t) {
                    let n, r, o = "", i = 0, a = -1, s = 0, l = -1;
                    for (; ++l <= e.length; ) {
                        if (l < e.length)
                            n = e.codePointAt(l);
                        else {
                            if (47 === n)
                                break;
                            n = 47
                        }
                        if (47 === n) {
                            if (a === l - 1 || 1 === s)
                                ;
                            else if (a !== l - 1 && 2 === s) {
                                if (o.length < 2 || 2 !== i || 46 !== o.codePointAt(o.length - 1) || 46 !== o.codePointAt(o.length - 2))
                                    if (o.length > 2) {
                                        if (r = o.lastIndexOf("/"),
                                        r !== o.length - 1) {
                                            r < 0 ? (o = "",
                                            i = 0) : (o = o.slice(0, r),
                                            i = o.length - 1 - o.lastIndexOf("/")),
                                            a = l,
                                            s = 0;
                                            continue
                                        }
                                    } else if (o.length > 0) {
                                        o = "",
                                        i = 0,
                                        a = l,
                                        s = 0;
                                        continue
                                    }
                                t && (o = o.length > 0 ? o + "/.." : "..",
                                i = 2)
                            } else
                                o.length > 0 ? o += "/" + e.slice(a + 1, l) : o = e.slice(a + 1, l),
                                i = l - a - 1;
                            a = l,
                            s = 0
                        } else
                            46 === n && s > -1 ? s++ : s = -1
                    }
                    return o
                }(e, !t);
                0 !== n.length || t || (n = ".");
                n.length > 0 && 47 === e.codePointAt(e.length - 1) && (n += "/");
                return t ? "/" + n : n
            }(t)
        },
        sep: "/"
    };
    function Zk(e) {
        if ("string" != typeof e)
            throw new TypeError("Path must be a string. Received " + JSON.stringify(e))
    }
    const Wk = {
        cwd: function() {
            return "/"
        }
    };
    function Xk(e) {
        return Boolean(null !== e && "object" == typeof e && "href"in e && e.href && "protocol"in e && e.protocol && void 0 === e.auth)
    }
    function Vk(e) {
        if ("string" == typeof e)
            e = new URL(e);
        else if (!Xk(e)) {
            const t = new TypeError('The "path" argument must be of type string or an instance of URL. Received `' + e + "`");
            throw t.code = "ERR_INVALID_ARG_TYPE",
            t
        }
        if ("file:" !== e.protocol) {
            const e = new TypeError("The URL must be of scheme file");
            throw e.code = "ERR_INVALID_URL_SCHEME",
            e
        }
        return function(e) {
            if ("" !== e.hostname) {
                const e = new TypeError('File URL host must be "localhost" or empty on darwin');
                throw e.code = "ERR_INVALID_FILE_URL_HOST",
                e
            }
            const t = e.pathname;
            let n = -1;
            for (; ++n < t.length; )
                if (37 === t.codePointAt(n) && 50 === t.codePointAt(n + 1)) {
                    const e = t.codePointAt(n + 2);
                    if (70 === e || 102 === e) {
                        const e = new TypeError("File URL path must not include encoded / characters");
                        throw e.code = "ERR_INVALID_FILE_URL_PATH",
                        e
                    }
                }
            return decodeURIComponent(t)
        }(e)
    }
    const Gk = ["history", "path", "basename", "stem", "extname", "dirname"];
    class Yk {
        constructor(e) {
            let t;
            t = e ? Xk(e) ? {
                path: e
            } : "string" == typeof e || function(e) {
                return Boolean(e && "object" == typeof e && "byteLength"in e && "byteOffset"in e)
            }(e) ? {
                value: e
            } : e : {},
            this.cwd = Wk.cwd(),
            this.data = {},
            this.history = [],
            this.messages = [],
            this.value,
            this.map,
            this.result,
            this.stored;
            let n, r = -1;
            for (; ++r < Gk.length; ) {
                const e = Gk[r];
                e in t && void 0 !== t[e] && null !== t[e] && (this[e] = "history" === e ? [...t[e]] : t[e])
            }
            for (n in t)
                Gk.includes(n) || (this[n] = t[n])
        }
        get basename() {
            return "string" == typeof this.path ? Hk.basename(this.path) : void 0
        }
        set basename(e) {
            Jk(e, "basename"),
            Kk(e, "basename"),
            this.path = Hk.join(this.dirname || "", e)
        }
        get dirname() {
            return "string" == typeof this.path ? Hk.dirname(this.path) : void 0
        }
        set dirname(e) {
            eS(this.basename, "dirname"),
            this.path = Hk.join(e || "", this.basename)
        }
        get extname() {
            return "string" == typeof this.path ? Hk.extname(this.path) : void 0
        }
        set extname(e) {
            if (Kk(e, "extname"),
            eS(this.dirname, "extname"),
            e) {
                if (46 !== e.codePointAt(0))
                    throw new Error("`extname` must start with `.`");
                if (e.includes(".", 1))
                    throw new Error("`extname` cannot contain multiple dots")
            }
            this.path = Hk.join(this.dirname, this.stem + (e || ""))
        }
        get path() {
            return this.history[this.history.length - 1]
        }
        set path(e) {
            Xk(e) && (e = Vk(e)),
            Jk(e, "path"),
            this.path !== e && this.history.push(e)
        }
        get stem() {
            return "string" == typeof this.path ? Hk.basename(this.path, this.extname) : void 0
        }
        set stem(e) {
            Jk(e, "stem"),
            Kk(e, "stem"),
            this.path = Hk.join(this.dirname || "", e + (this.extname || ""))
        }
        fail(e, t, n) {
            const r = this.message(e, t, n);
            throw r.fatal = !0,
            r
        }
        info(e, t, n) {
            const r = this.message(e, t, n);
            return r.fatal = void 0,
            r
        }
        message(e, t, n) {
            const r = new qk(e,t,n);
            return this.path && (r.name = this.path + ":" + r.name,
            r.file = this.path),
            r.fatal = !1,
            this.messages.push(r),
            r
        }
        toString(e) {
            if (void 0 === this.value)
                return "";
            if ("string" == typeof this.value)
                return this.value;
            return new TextDecoder(e || void 0).decode(this.value)
        }
    }
    function Kk(e, t) {
        if (e && e.includes(Hk.sep))
            throw new Error("`" + t + "` cannot be a path: did not expect `" + Hk.sep + "`")
    }
    function Jk(e, t) {
        if (!e)
            throw new Error("`" + t + "` cannot be empty")
    }
    function eS(e, t) {
        if (!e)
            throw new Error("Setting `" + t + "` requires `path` to be set too")
    }
    const tS = function(e) {
        const t = this.constructor.prototype
          , n = t[e]
          , r = function() {
            return n.apply(r, arguments)
        };
        Object.setPrototypeOf(r, t);
        const o = Object.getOwnPropertyNames(n);
        for (const i of o) {
            const e = Object.getOwnPropertyDescriptor(n, i);
            e && Object.defineProperty(r, i, e)
        }
        return r
    }
      , nS = {}.hasOwnProperty;
    class rS extends tS {
        constructor() {
            super("copy"),
            this.Compiler = void 0,
            this.Parser = void 0,
            this.attachers = [],
            this.compiler = void 0,
            this.freezeIndex = -1,
            this.frozen = void 0,
            this.namespace = {},
            this.parser = void 0,
            this.transformers = zk()
        }
        copy() {
            const e = new rS;
            let t = -1;
            for (; ++t < this.attachers.length; ) {
                const n = this.attachers[t];
                e.use(...n)
            }
            return e.data(Fk(!0, {}, this.namespace)),
            e
        }
        data(e, t) {
            return "string" == typeof e ? 2 === arguments.length ? (sS("data", this.frozen),
            this.namespace[e] = t,
            this) : nS.call(this.namespace, e) && this.namespace[e] || void 0 : e ? (sS("data", this.frozen),
            this.namespace = e,
            this) : this.namespace
        }
        freeze() {
            if (this.frozen)
                return this;
            const e = this;
            for (; ++this.freezeIndex < this.attachers.length; ) {
                const [t,...n] = this.attachers[this.freezeIndex];
                if (!1 === n[0])
                    continue;
                !0 === n[0] && (n[0] = void 0);
                const r = t.call(e, ...n);
                "function" == typeof r && this.transformers.use(r)
            }
            return this.frozen = !0,
            this.freezeIndex = Number.POSITIVE_INFINITY,
            this
        }
        parse(e) {
            this.freeze();
            const t = uS(e)
              , n = this.parser || this.Parser;
            return iS("parse", n),
            n(String(t), t)
        }
        process(e, t) {
            const n = this;
            return this.freeze(),
            iS("process", this.parser || this.Parser),
            aS("process", this.compiler || this.Compiler),
            t ? r(void 0, t) : new Promise(r);
            function r(r, o) {
                const i = uS(e)
                  , a = n.parse(i);
                function s(e, n) {
                    e || !n ? o(e) : r ? r(n) : t(void 0, n)
                }
                n.run(a, i, (function(e, t, r) {
                    if (e || !t || !r)
                        return s(e);
                    const o = t
                      , i = n.stringify(o, r);
                    var a;
                    "string" == typeof (a = i) || function(e) {
                        return Boolean(e && "object" == typeof e && "byteLength"in e && "byteOffset"in e)
                    }(a) ? r.value = i : r.result = i,
                    s(e, r)
                }
                ))
            }
        }
        processSync(e) {
            let t, n = !1;
            return this.freeze(),
            iS("processSync", this.parser || this.Parser),
            aS("processSync", this.compiler || this.Compiler),
            this.process(e, (function(e, r) {
                n = !0,
                Dk(e),
                t = r
            }
            )),
            cS("processSync", "process", n),
            t
        }
        run(e, t, n) {
            lS(e),
            this.freeze();
            const r = this.transformers;
            return n || "function" != typeof t || (n = t,
            t = void 0),
            n ? o(void 0, n) : new Promise(o);
            function o(o, i) {
                const a = uS(t);
                r.run(e, a, (function(t, r, a) {
                    const s = r || e;
                    t ? i(t) : o ? o(s) : n(void 0, s, a)
                }
                ))
            }
        }
        runSync(e, t) {
            let n, r = !1;
            return this.run(e, t, (function(e, t) {
                Dk(e),
                n = t,
                r = !0
            }
            )),
            cS("runSync", "run", r),
            n
        }
        stringify(e, t) {
            this.freeze();
            const n = uS(t)
              , r = this.compiler || this.Compiler;
            return aS("stringify", r),
            lS(e),
            r(e, n)
        }
        use(e, ...t) {
            const n = this.attachers
              , r = this.namespace;
            if (sS("use", this.frozen),
            null == e)
                ;
            else if ("function" == typeof e)
                s(e, t);
            else {
                if ("object" != typeof e)
                    throw new TypeError("Expected usable value, not `" + e + "`");
                Array.isArray(e) ? a(e) : i(e)
            }
            return this;
            function o(e) {
                if ("function" == typeof e)
                    s(e, []);
                else {
                    if ("object" != typeof e)
                        throw new TypeError("Expected usable value, not `" + e + "`");
                    if (Array.isArray(e)) {
                        const [t,...n] = e;
                        s(t, n)
                    } else
                        i(e)
                }
            }
            function i(e) {
                if (!("plugins"in e) && !("settings"in e))
                    throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither");
                a(e.plugins),
                e.settings && (r.settings = Fk(!0, r.settings, e.settings))
            }
            function a(e) {
                let t = -1;
                if (null == e)
                    ;
                else {
                    if (!Array.isArray(e))
                        throw new TypeError("Expected a list of plugins, not `" + e + "`");
                    for (; ++t < e.length; ) {
                        o(e[t])
                    }
                }
            }
            function s(e, t) {
                let r = -1
                  , o = -1;
                for (; ++r < n.length; )
                    if (n[r][0] === e) {
                        o = r;
                        break
                    }
                if (-1 === o)
                    n.push([e, ...t]);
                else if (t.length > 0) {
                    let[r,...i] = t;
                    const a = n[o][1];
                    jk(a) && jk(r) && (r = Fk(!0, a, r)),
                    n[o] = [e, r, ...i]
                }
            }
        }
    }
    const oS = (new rS).freeze();
    function iS(e, t) {
        if ("function" != typeof t)
            throw new TypeError("Cannot `" + e + "` without `parser`")
    }
    function aS(e, t) {
        if ("function" != typeof t)
            throw new TypeError("Cannot `" + e + "` without `compiler`")
    }
    function sS(e, t) {
        if (t)
            throw new Error("Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.")
    }
    function lS(e) {
        if (!jk(e) || "string" != typeof e.type)
            throw new TypeError("Expected node, got `" + e + "`")
    }
    function cS(e, t, n) {
        if (!n)
            throw new Error("`" + e + "` finished async. Use `" + t + "` instead")
    }
    function uS(e) {
        return function(e) {
            return Boolean(e && "object" == typeof e && "message"in e && "messages"in e)
        }(e) ? e : new Yk(e)
    }
    const dS = {
        bash: function(e) {
            const t = e.regex
              , n = {}
              , r = {
                begin: /\$\{/,
                end: /\}/,
                contains: ["self", {
                    begin: /:-/,
                    contains: [n]
                }]
            };
            Object.assign(n, {
                className: "variable",
                variants: [{
                    begin: t.concat(/\$[\w\d#@][\w\d_]*/, "(?![\\w\\d])(?![$])")
                }, r]
            });
            const o = {
                className: "subst",
                begin: /\$\(/,
                end: /\)/,
                contains: [e.BACKSLASH_ESCAPE]
            }
              , i = {
                begin: /<<-?\s*(?=\w+)/,
                starts: {
                    contains: [e.END_SAME_AS_BEGIN({
                        begin: /(\w+)/,
                        end: /(\w+)/,
                        className: "string"
                    })]
                }
            }
              , a = {
                className: "string",
                begin: /"/,
                end: /"/,
                contains: [e.BACKSLASH_ESCAPE, n, o]
            };
            o.contains.push(a);
            const s = {
                begin: /\$?\(\(/,
                end: /\)\)/,
                contains: [{
                    begin: /\d+#[0-9a-f]+/,
                    className: "number"
                }, e.NUMBER_MODE, n]
            }
              , l = e.SHEBANG({
                binary: `(${["fish", "bash", "zsh", "sh", "csh", "ksh", "tcsh", "dash", "scsh"].join("|")})`,
                relevance: 10
            })
              , c = {
                className: "function",
                begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
                returnBegin: !0,
                contains: [e.inherit(e.TITLE_MODE, {
                    begin: /\w[\w\d_]*/
                })],
                relevance: 0
            };
            return {
                name: "Bash",
                aliases: ["sh"],
                keywords: {
                    $pattern: /\b[a-z][a-z0-9._-]+\b/,
                    keyword: ["if", "then", "else", "elif", "fi", "for", "while", "until", "in", "do", "done", "case", "esac", "function", "select"],
                    literal: ["true", "false"],
                    built_in: ["break", "cd", "continue", "eval", "exec", "exit", "export", "getopts", "hash", "pwd", "readonly", "return", "shift", "test", "times", "trap", "umask", "unset", "alias", "bind", "builtin", "caller", "command", "declare", "echo", "enable", "help", "let", "local", "logout", "mapfile", "printf", "read", "readarray", "source", "type", "typeset", "ulimit", "unalias", "set", "shopt", "autoload", "bg", "bindkey", "bye", "cap", "chdir", "clone", "comparguments", "compcall", "compctl", "compdescribe", "compfiles", "compgroups", "compquote", "comptags", "comptry", "compvalues", "dirs", "disable", "disown", "echotc", "echoti", "emulate", "fc", "fg", "float", "functions", "getcap", "getln", "history", "integer", "jobs", "kill", "limit", "log", "noglob", "popd", "print", "pushd", "pushln", "rehash", "sched", "setcap", "setopt", "stat", "suspend", "ttyctl", "unfunction", "unhash", "unlimit", "unsetopt", "vared", "wait", "whence", "where", "which", "zcompile", "zformat", "zftp", "zle", "zmodload", "zparseopts", "zprof", "zpty", "zregexparse", "zsocket", "zstyle", "ztcp", "chcon", "chgrp", "chown", "chmod", "cp", "dd", "df", "dir", "dircolors", "ln", "ls", "mkdir", "mkfifo", "mknod", "mktemp", "mv", "realpath", "rm", "rmdir", "shred", "sync", "touch", "truncate", "vdir", "b2sum", "base32", "base64", "cat", "cksum", "comm", "csplit", "cut", "expand", "fmt", "fold", "head", "join", "md5sum", "nl", "numfmt", "od", "paste", "ptx", "pr", "sha1sum", "sha224sum", "sha256sum", "sha384sum", "sha512sum", "shuf", "sort", "split", "sum", "tac", "tail", "tr", "tsort", "unexpand", "uniq", "wc", "arch", "basename", "chroot", "date", "dirname", "du", "echo", "env", "expr", "factor", "groups", "hostid", "id", "link", "logname", "nice", "nohup", "nproc", "pathchk", "pinky", "printenv", "printf", "pwd", "readlink", "runcon", "seq", "sleep", "stat", "stdbuf", "stty", "tee", "test", "timeout", "tty", "uname", "unlink", "uptime", "users", "who", "whoami", "yes"]
                },
                contains: [l, e.SHEBANG(), c, s, e.HASH_COMMENT_MODE, i, {
                    match: /(\/[a-z._-]+)+/
                }, a, {
                    match: /\\"/
                }, {
                    className: "string",
                    begin: /'/,
                    end: /'/
                }, {
                    match: /\\'/
                }, n]
            }
        },
        c: function(e) {
            const t = e.regex
              , n = e.COMMENT("//", "$", {
                contains: [{
                    begin: /\\\n/
                }]
            })
              , r = "decltype\\(auto\\)"
              , o = "[a-zA-Z_]\\w*::"
              , i = "(" + r + "|" + t.optional(o) + "[a-zA-Z_]\\w*" + t.optional("<[^<>]+>") + ")"
              , a = {
                className: "type",
                variants: [{
                    begin: "\\b[a-z\\d_]*_t\\b"
                }, {
                    match: /\batomic_[a-z]{3,6}\b/
                }]
            }
              , s = {
                className: "string",
                variants: [{
                    begin: '(u8?|U|L)?"',
                    end: '"',
                    illegal: "\\n",
                    contains: [e.BACKSLASH_ESCAPE]
                }, {
                    begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
                    end: "'",
                    illegal: "."
                }, e.END_SAME_AS_BEGIN({
                    begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
                    end: /\)([^()\\ ]{0,16})"/
                })]
            }
              , l = {
                className: "number",
                variants: [{
                    begin: "\\b(0b[01']+)"
                }, {
                    begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)"
                }, {
                    begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
                }],
                relevance: 0
            }
              , c = {
                className: "meta",
                begin: /#\s*[a-z]+\b/,
                end: /$/,
                keywords: {
                    keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include"
                },
                contains: [{
                    begin: /\\\n/,
                    relevance: 0
                }, e.inherit(s, {
                    className: "string"
                }), {
                    className: "string",
                    begin: /<.*?>/
                }, n, e.C_BLOCK_COMMENT_MODE]
            }
              , u = {
                className: "title",
                begin: t.optional(o) + e.IDENT_RE,
                relevance: 0
            }
              , d = t.optional(o) + e.IDENT_RE + "\\s*\\("
              , p = {
                keyword: ["asm", "auto", "break", "case", "continue", "default", "do", "else", "enum", "extern", "for", "fortran", "goto", "if", "inline", "register", "restrict", "return", "sizeof", "struct", "switch", "typedef", "union", "volatile", "while", "_Alignas", "_Alignof", "_Atomic", "_Generic", "_Noreturn", "_Static_assert", "_Thread_local", "alignas", "alignof", "noreturn", "static_assert", "thread_local", "_Pragma"],
                type: ["float", "double", "signed", "unsigned", "int", "short", "long", "char", "void", "_Bool", "_Complex", "_Imaginary", "_Decimal32", "_Decimal64", "_Decimal128", "const", "static", "complex", "bool", "imaginary"],
                literal: "true false NULL",
                built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
            }
              , h = [c, a, n, e.C_BLOCK_COMMENT_MODE, l, s]
              , f = {
                variants: [{
                    begin: /=/,
                    end: /;/
                }, {
                    begin: /\(/,
                    end: /\)/
                }, {
                    beginKeywords: "new throw return else",
                    end: /;/
                }],
                keywords: p,
                contains: h.concat([{
                    begin: /\(/,
                    end: /\)/,
                    keywords: p,
                    contains: h.concat(["self"]),
                    relevance: 0
                }]),
                relevance: 0
            }
              , m = {
                begin: "(" + i + "[\\*&\\s]+)+" + d,
                returnBegin: !0,
                end: /[{;=]/,
                excludeEnd: !0,
                keywords: p,
                illegal: /[^\w\s\*&:<>.]/,
                contains: [{
                    begin: r,
                    keywords: p,
                    relevance: 0
                }, {
                    begin: d,
                    returnBegin: !0,
                    contains: [e.inherit(u, {
                        className: "title.function"
                    })],
                    relevance: 0
                }, {
                    relevance: 0,
                    match: /,/
                }, {
                    className: "params",
                    begin: /\(/,
                    end: /\)/,
                    keywords: p,
                    relevance: 0,
                    contains: [n, e.C_BLOCK_COMMENT_MODE, s, l, a, {
                        begin: /\(/,
                        end: /\)/,
                        keywords: p,
                        relevance: 0,
                        contains: ["self", n, e.C_BLOCK_COMMENT_MODE, s, l, a]
                    }]
                }, a, n, e.C_BLOCK_COMMENT_MODE, c]
            };
            return {
                name: "C",
                aliases: ["h"],
                keywords: p,
                disableAutodetect: !0,
                illegal: "</",
                contains: [].concat(f, m, h, [c, {
                    begin: e.IDENT_RE + "::",
                    keywords: p
                }, {
                    className: "class",
                    beginKeywords: "enum class struct union",
                    end: /[{;:<>=]/,
                    contains: [{
                        beginKeywords: "final class struct"
                    }, e.TITLE_MODE]
                }]),
                exports: {
                    preprocessor: c,
                    strings: s,
                    keywords: p
                }
            }
        },
        clojure: function(e) {
            const t = "a-zA-Z_\\-!.?+*=<>&'"
              , n = "[#]?[" + t + "][" + t + "0-9/;:$#]*"
              , r = "def defonce defprotocol defstruct defmulti defmethod defn- defn defmacro deftype defrecord"
              , o = {
                $pattern: n,
                built_in: r + " cond apply if-not if-let if not not= =|0 <|0 >|0 <=|0 >=|0 ==|0 +|0 /|0 *|0 -|0 rem quot neg? pos? delay? symbol? keyword? true? false? integer? empty? coll? list? set? ifn? fn? associative? sequential? sorted? counted? reversible? number? decimal? class? distinct? isa? float? rational? reduced? ratio? odd? even? char? seq? vector? string? map? nil? contains? zero? instance? not-every? not-any? libspec? -> ->> .. . inc compare do dotimes mapcat take remove take-while drop letfn drop-last take-last drop-while while intern condp case reduced cycle split-at split-with repeat replicate iterate range merge zipmap declare line-seq sort comparator sort-by dorun doall nthnext nthrest partition eval doseq await await-for let agent atom send send-off release-pending-sends add-watch mapv filterv remove-watch agent-error restart-agent set-error-handler error-handler set-error-mode! error-mode shutdown-agents quote var fn loop recur throw try monitor-enter monitor-exit macroexpand macroexpand-1 for dosync and or when when-not when-let comp juxt partial sequence memoize constantly complement identity assert peek pop doto proxy first rest cons cast coll last butlast sigs reify second ffirst fnext nfirst nnext meta with-meta ns in-ns create-ns import refer keys select-keys vals key val rseq name namespace promise into transient persistent! conj! assoc! dissoc! pop! disj! use class type num float double short byte boolean bigint biginteger bigdec print-method print-dup throw-if printf format load compile get-in update-in pr pr-on newline flush read slurp read-line subvec with-open memfn time re-find re-groups rand-int rand mod locking assert-valid-fdecl alias resolve ref deref refset swap! reset! set-validator! compare-and-set! alter-meta! reset-meta! commute get-validator alter ref-set ref-history-count ref-min-history ref-max-history ensure sync io! new next conj set! to-array future future-call into-array aset gen-class reduce map filter find empty hash-map hash-set sorted-map sorted-map-by sorted-set sorted-set-by vec vector seq flatten reverse assoc dissoc list disj get union difference intersection extend extend-type extend-protocol int nth delay count concat chunk chunk-buffer chunk-append chunk-first chunk-rest max min dec unchecked-inc-int unchecked-inc unchecked-dec-inc unchecked-dec unchecked-negate unchecked-add-int unchecked-add unchecked-subtract-int unchecked-subtract chunk-next chunk-cons chunked-seq? prn vary-meta lazy-seq spread list* str find-keyword keyword symbol gensym force rationalize"
            }
              , i = {
                begin: n,
                relevance: 0
            }
              , a = {
                scope: "number",
                relevance: 0,
                variants: [{
                    match: /[-+]?0[xX][0-9a-fA-F]+N?/
                }, {
                    match: /[-+]?0[0-7]+N?/
                }, {
                    match: /[-+]?[1-9][0-9]?[rR][0-9a-zA-Z]+N?/
                }, {
                    match: /[-+]?[0-9]+\/[0-9]+N?/
                }, {
                    match: /[-+]?[0-9]+((\.[0-9]*([eE][+-]?[0-9]+)?M?)|([eE][+-]?[0-9]+M?|M))/
                }, {
                    match: /[-+]?([1-9][0-9]*|0)N?/
                }]
            }
              , s = {
                scope: "character",
                variants: [{
                    match: /\\o[0-3]?[0-7]{1,2}/
                }, {
                    match: /\\u[0-9a-fA-F]{4}/
                }, {
                    match: /\\(newline|space|tab|formfeed|backspace|return)/
                }, {
                    match: /\\\S/,
                    relevance: 0
                }]
            }
              , l = {
                scope: "regex",
                begin: /#"/,
                end: /"/,
                contains: [e.BACKSLASH_ESCAPE]
            }
              , c = e.inherit(e.QUOTE_STRING_MODE, {
                illegal: null
            })
              , u = {
                scope: "punctuation",
                match: /,/,
                relevance: 0
            }
              , d = e.COMMENT(";", "$", {
                relevance: 0
            })
              , p = {
                className: "literal",
                begin: /\b(true|false|nil)\b/
            }
              , h = {
                begin: "\\[|(#::?" + n + ")?\\{",
                end: "[\\]\\}]",
                relevance: 0
            }
              , f = {
                className: "symbol",
                begin: "[:]{1,2}" + n
            }
              , m = {
                begin: "\\(",
                end: "\\)"
            }
              , g = {
                endsWithParent: !0,
                relevance: 0
            }
              , b = {
                keywords: o,
                className: "name",
                begin: n,
                relevance: 0,
                starts: g
            }
              , O = [u, m, s, l, c, d, f, h, a, p, i]
              , v = {
                beginKeywords: r,
                keywords: {
                    $pattern: n,
                    keyword: r
                },
                end: '(\\[|#|\\d|"|:|\\{|\\)|\\(|$)',
                contains: [{
                    className: "title",
                    begin: n,
                    relevance: 0,
                    excludeEnd: !0,
                    endsParent: !0
                }].concat(O)
            };
            return m.contains = [v, b, g],
            g.contains = O,
            h.contains = O,
            {
                name: "Clojure",
                aliases: ["clj", "edn"],
                illegal: /\S/,
                contains: [u, m, s, l, c, d, f, h, a, p]
            }
        },
        cpp: function(e) {
            const t = e.regex
              , n = e.COMMENT("//", "$", {
                contains: [{
                    begin: /\\\n/
                }]
            })
              , r = "decltype\\(auto\\)"
              , o = "[a-zA-Z_]\\w*::"
              , i = "(?!struct)(" + r + "|" + t.optional(o) + "[a-zA-Z_]\\w*" + t.optional("<[^<>]+>") + ")"
              , a = {
                className: "type",
                begin: "\\b[a-z\\d_]*_t\\b"
            }
              , s = {
                className: "string",
                variants: [{
                    begin: '(u8?|U|L)?"',
                    end: '"',
                    illegal: "\\n",
                    contains: [e.BACKSLASH_ESCAPE]
                }, {
                    begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
                    end: "'",
                    illegal: "."
                }, e.END_SAME_AS_BEGIN({
                    begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
                    end: /\)([^()\\ ]{0,16})"/
                })]
            }
              , l = {
                className: "number",
                variants: [{
                    begin: "\\b(0b[01']+)"
                }, {
                    begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)"
                }, {
                    begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
                }],
                relevance: 0
            }
              , c = {
                className: "meta",
                begin: /#\s*[a-z]+\b/,
                end: /$/,
                keywords: {
                    keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include"
                },
                contains: [{
                    begin: /\\\n/,
                    relevance: 0
                }, e.inherit(s, {
                    className: "string"
                }), {
                    className: "string",
                    begin: /<.*?>/
                }, n, e.C_BLOCK_COMMENT_MODE]
            }
              , u = {
                className: "title",
                begin: t.optional(o) + e.IDENT_RE,
                relevance: 0
            }
              , d = t.optional(o) + e.IDENT_RE + "\\s*\\("
              , p = {
                type: ["bool", "char", "char16_t", "char32_t", "char8_t", "double", "float", "int", "long", "short", "void", "wchar_t", "unsigned", "signed", "const", "static"],
                keyword: ["alignas", "alignof", "and", "and_eq", "asm", "atomic_cancel", "atomic_commit", "atomic_noexcept", "auto", "bitand", "bitor", "break", "case", "catch", "class", "co_await", "co_return", "co_yield", "compl", "concept", "const_cast|10", "consteval", "constexpr", "constinit", "continue", "decltype", "default", "delete", "do", "dynamic_cast|10", "else", "enum", "explicit", "export", "extern", "false", "final", "for", "friend", "goto", "if", "import", "inline", "module", "mutable", "namespace", "new", "noexcept", "not", "not_eq", "nullptr", "operator", "or", "or_eq", "override", "private", "protected", "public", "reflexpr", "register", "reinterpret_cast|10", "requires", "return", "sizeof", "static_assert", "static_cast|10", "struct", "switch", "synchronized", "template", "this", "thread_local", "throw", "transaction_safe", "transaction_safe_dynamic", "true", "try", "typedef", "typeid", "typename", "union", "using", "virtual", "volatile", "while", "xor", "xor_eq"],
                literal: ["NULL", "false", "nullopt", "nullptr", "true"],
                built_in: ["_Pragma"],
                _type_hints: ["any", "auto_ptr", "barrier", "binary_semaphore", "bitset", "complex", "condition_variable", "condition_variable_any", "counting_semaphore", "deque", "false_type", "future", "imaginary", "initializer_list", "istringstream", "jthread", "latch", "lock_guard", "multimap", "multiset", "mutex", "optional", "ostringstream", "packaged_task", "pair", "promise", "priority_queue", "queue", "recursive_mutex", "recursive_timed_mutex", "scoped_lock", "set", "shared_future", "shared_lock", "shared_mutex", "shared_timed_mutex", "shared_ptr", "stack", "string_view", "stringstream", "timed_mutex", "thread", "true_type", "tuple", "unique_lock", "unique_ptr", "unordered_map", "unordered_multimap", "unordered_multiset", "unordered_set", "variant", "vector", "weak_ptr", "wstring", "wstring_view"]
            }
              , h = {
                className: "function.dispatch",
                relevance: 0,
                keywords: {
                    _hint: ["abort", "abs", "acos", "apply", "as_const", "asin", "atan", "atan2", "calloc", "ceil", "cerr", "cin", "clog", "cos", "cosh", "cout", "declval", "endl", "exchange", "exit", "exp", "fabs", "floor", "fmod", "forward", "fprintf", "fputs", "free", "frexp", "fscanf", "future", "invoke", "isalnum", "isalpha", "iscntrl", "isdigit", "isgraph", "islower", "isprint", "ispunct", "isspace", "isupper", "isxdigit", "labs", "launder", "ldexp", "log", "log10", "make_pair", "make_shared", "make_shared_for_overwrite", "make_tuple", "make_unique", "malloc", "memchr", "memcmp", "memcpy", "memset", "modf", "move", "pow", "printf", "putchar", "puts", "realloc", "scanf", "sin", "sinh", "snprintf", "sprintf", "sqrt", "sscanf", "std", "stderr", "stdin", "stdout", "strcat", "strchr", "strcmp", "strcpy", "strcspn", "strlen", "strncat", "strncmp", "strncpy", "strpbrk", "strrchr", "strspn", "strstr", "swap", "tan", "tanh", "terminate", "to_underlying", "tolower", "toupper", "vfprintf", "visit", "vprintf", "vsprintf"]
                },
                begin: t.concat(/\b/, /(?!decltype)/, /(?!if)/, /(?!for)/, /(?!switch)/, /(?!while)/, e.IDENT_RE, t.lookahead(/(<[^<>]+>|)\s*\(/))
            }
              , f = [h, c, a, n, e.C_BLOCK_COMMENT_MODE, l, s]
              , m = {
                variants: [{
                    begin: /=/,
                    end: /;/
                }, {
                    begin: /\(/,
                    end: /\)/
                }, {
                    beginKeywords: "new throw return else",
                    end: /;/
                }],
                keywords: p,
                contains: f.concat([{
                    begin: /\(/,
                    end: /\)/,
                    keywords: p,
                    contains: f.concat(["self"]),
                    relevance: 0
                }]),
                relevance: 0
            }
              , g = {
                className: "function",
                begin: "(" + i + "[\\*&\\s]+)+" + d,
                returnBegin: !0,
                end: /[{;=]/,
                excludeEnd: !0,
                keywords: p,
                illegal: /[^\w\s\*&:<>.]/,
                contains: [{
                    begin: r,
                    keywords: p,
                    relevance: 0
                }, {
                    begin: d,
                    returnBegin: !0,
                    contains: [u],
                    relevance: 0
                }, {
                    begin: /::/,
                    relevance: 0
                }, {
                    begin: /:/,
                    endsWithParent: !0,
                    contains: [s, l]
                }, {
                    relevance: 0,
                    match: /,/
                }, {
                    className: "params",
                    begin: /\(/,
                    end: /\)/,
                    keywords: p,
                    relevance: 0,
                    contains: [n, e.C_BLOCK_COMMENT_MODE, s, l, a, {
                        begin: /\(/,
                        end: /\)/,
                        keywords: p,
                        relevance: 0,
                        contains: ["self", n, e.C_BLOCK_COMMENT_MODE, s, l, a]
                    }]
                }, a, n, e.C_BLOCK_COMMENT_MODE, c]
            };
            return {
                name: "C++",
                aliases: ["cc", "c++", "h++", "hpp", "hh", "hxx", "cxx"],
                keywords: p,
                illegal: "</",
                classNameAliases: {
                    "function.dispatch": "built_in"
                },
                contains: [].concat(m, g, h, f, [c, {
                    begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)",
                    end: ">",
                    keywords: p,
                    contains: ["self", a]
                }, {
                    begin: e.IDENT_RE + "::",
                    keywords: p
                }, {
                    match: [/\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/, /\s+/, /\w+/],
                    className: {
                        1: "keyword",
                        3: "title.class"
                    }
                }])
            }
        },
        css: function(e) {
            const t = e.regex
              , n = (e=>({
                IMPORTANT: {
                    scope: "meta",
                    begin: "!important"
                },
                BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
                HEXCOLOR: {
                    scope: "number",
                    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
                },
                FUNCTION_DISPATCH: {
                    className: "built_in",
                    begin: /[\w-]+(?=\()/
                },
                ATTRIBUTE_SELECTOR_MODE: {
                    scope: "selector-attr",
                    begin: /\[/,
                    end: /\]/,
                    illegal: "$",
                    contains: [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE]
                },
                CSS_NUMBER_MODE: {
                    scope: "number",
                    begin: e.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
                    relevance: 0
                },
                CSS_VARIABLE: {
                    className: "attr",
                    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
                }
            }))(e)
              , r = [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE];
            return {
                name: "CSS",
                case_insensitive: !0,
                illegal: /[=|'\$]/,
                keywords: {
                    keyframePosition: "from to"
                },
                classNameAliases: {
                    keyframePosition: "selector-tag"
                },
                contains: [n.BLOCK_COMMENT, {
                    begin: /-(webkit|moz|ms|o)-(?=[a-z])/
                }, n.CSS_NUMBER_MODE, {
                    className: "selector-id",
                    begin: /#[A-Za-z0-9_-]+/,
                    relevance: 0
                }, {
                    className: "selector-class",
                    begin: "\\.[a-zA-Z-][a-zA-Z0-9_-]*",
                    relevance: 0
                }, n.ATTRIBUTE_SELECTOR_MODE, {
                    className: "selector-pseudo",
                    variants: [{
                        begin: ":(" + Eu.join("|") + ")"
                    }, {
                        begin: ":(:)?(" + xu.join("|") + ")"
                    }]
                }, n.CSS_VARIABLE, {
                    className: "attribute",
                    begin: "\\b(" + Tu.join("|") + ")\\b"
                }, {
                    begin: /:/,
                    end: /[;}{]/,
                    contains: [n.BLOCK_COMMENT, n.HEXCOLOR, n.IMPORTANT, n.CSS_NUMBER_MODE, ...r, {
                        begin: /(url|data-uri)\(/,
                        end: /\)/,
                        relevance: 0,
                        keywords: {
                            built_in: "url data-uri"
                        },
                        contains: [...r, {
                            className: "string",
                            begin: /[^)]/,
                            endsWithParent: !0,
                            excludeEnd: !0
                        }]
                    }, n.FUNCTION_DISPATCH]
                }, {
                    begin: t.lookahead(/@/),
                    end: "[{;]",
                    relevance: 0,
                    illegal: /:/,
                    contains: [{
                        className: "keyword",
                        begin: /@-?\w[\w]*(-\w+)*/
                    }, {
                        begin: /\s/,
                        endsWithParent: !0,
                        excludeEnd: !0,
                        relevance: 0,
                        keywords: {
                            $pattern: /[a-z-]+/,
                            keyword: "and or not only",
                            attribute: Su.join(" ")
                        },
                        contains: [{
                            begin: /[a-z-]+(?=:)/,
                            className: "attribute"
                        }, ...r, n.CSS_NUMBER_MODE]
                    }]
                }, {
                    className: "selector-tag",
                    begin: "\\b(" + ku.join("|") + ")\\b"
                }]
            }
        },
        curl: Nd((function(e) {
            const t = {
                className: "string",
                begin: /"/,
                end: /"/,
                contains: [e.BACKSLASH_ESCAPE, {
                    className: "variable",
                    begin: /\$\(/,
                    end: /\)/,
                    contains: [e.BACKSLASH_ESCAPE]
                }],
                relevance: 0
            }
              , n = {
                className: "number",
                variants: [{
                    begin: e.C_NUMBER_RE
                }],
                relevance: 0
            };
            return {
                name: "curl",
                aliases: ["curl"],
                keywords: "curl",
                case_insensitive: !0,
                contains: [{
                    className: "literal",
                    begin: /(--request|-X)\s/,
                    contains: [{
                        className: "symbol",
                        begin: /(get|post|delete|options|head|put|patch|trace|connect)/,
                        end: /\s/,
                        returnEnd: !0
                    }],
                    returnEnd: !0,
                    relevance: 10
                }, {
                    className: "literal",
                    begin: /--/,
                    end: /[\s"]/,
                    returnEnd: !0,
                    relevance: 0
                }, {
                    className: "literal",
                    begin: /-\w/,
                    end: /[\s"]/,
                    returnEnd: !0,
                    relevance: 0
                }, t, {
                    className: "string",
                    begin: /\\"/,
                    relevance: 0
                }, {
                    className: "string",
                    begin: /'/,
                    end: /'/,
                    relevance: 0
                }, e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, n, {
                    match: /(\/[a-z._-]+)+/
                }]
            }
        }
        )),
        csharp: function(e) {
            const t = {
                keyword: ["abstract", "as", "base", "break", "case", "catch", "class", "const", "continue", "do", "else", "event", "explicit", "extern", "finally", "fixed", "for", "foreach", "goto", "if", "implicit", "in", "interface", "internal", "is", "lock", "namespace", "new", "operator", "out", "override", "params", "private", "protected", "public", "readonly", "record", "ref", "return", "scoped", "sealed", "sizeof", "stackalloc", "static", "struct", "switch", "this", "throw", "try", "typeof", "unchecked", "unsafe", "using", "virtual", "void", "volatile", "while"].concat(["add", "alias", "and", "ascending", "async", "await", "by", "descending", "equals", "from", "get", "global", "group", "init", "into", "join", "let", "nameof", "not", "notnull", "on", "or", "orderby", "partial", "remove", "select", "set", "unmanaged", "value|0", "var", "when", "where", "with", "yield"]),
                built_in: ["bool", "byte", "char", "decimal", "delegate", "double", "dynamic", "enum", "float", "int", "long", "nint", "nuint", "object", "sbyte", "short", "string", "ulong", "uint", "ushort"],
                literal: ["default", "false", "null", "true"]
            }
              , n = e.inherit(e.TITLE_MODE, {
                begin: "[a-zA-Z](\\.?\\w)*"
            })
              , r = {
                className: "number",
                variants: [{
                    begin: "\\b(0b[01']+)"
                }, {
                    begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)"
                }, {
                    begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
                }],
                relevance: 0
            }
              , o = {
                className: "string",
                begin: '@"',
                end: '"',
                contains: [{
                    begin: '""'
                }]
            }
              , i = e.inherit(o, {
                illegal: /\n/
            })
              , a = {
                className: "subst",
                begin: /\{/,
                end: /\}/,
                keywords: t
            }
              , s = e.inherit(a, {
                illegal: /\n/
            })
              , l = {
                className: "string",
                begin: /\$"/,
                end: '"',
                illegal: /\n/,
                contains: [{
                    begin: /\{\{/
                }, {
                    begin: /\}\}/
                }, e.BACKSLASH_ESCAPE, s]
            }
              , c = {
                className: "string",
                begin: /\$@"/,
                end: '"',
                contains: [{
                    begin: /\{\{/
                }, {
                    begin: /\}\}/
                }, {
                    begin: '""'
                }, a]
            }
              , u = e.inherit(c, {
                illegal: /\n/,
                contains: [{
                    begin: /\{\{/
                }, {
                    begin: /\}\}/
                }, {
                    begin: '""'
                }, s]
            });
            a.contains = [c, l, o, e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, r, e.C_BLOCK_COMMENT_MODE],
            s.contains = [u, l, i, e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, r, e.inherit(e.C_BLOCK_COMMENT_MODE, {
                illegal: /\n/
            })];
            const d = {
                variants: [c, l, o, e.APOS_STRING_MODE, e.QUOTE_STRING_MODE]
            }
              , p = {
                begin: "<",
                end: ">",
                contains: [{
                    beginKeywords: "in out"
                }, n]
            }
              , h = e.IDENT_RE + "(<" + e.IDENT_RE + "(\\s*,\\s*" + e.IDENT_RE + ")*>)?(\\[\\])?"
              , f = {
                begin: "@" + e.IDENT_RE,
                relevance: 0
            };
            return {
                name: "C#",
                aliases: ["cs", "c#"],
                keywords: t,
                illegal: /::/,
                contains: [e.COMMENT("///", "$", {
                    returnBegin: !0,
                    contains: [{
                        className: "doctag",
                        variants: [{
                            begin: "///",
                            relevance: 0
                        }, {
                            begin: "\x3c!--|--\x3e"
                        }, {
                            begin: "</?",
                            end: ">"
                        }]
                    }]
                }), e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE, {
                    className: "meta",
                    begin: "#",
                    end: "$",
                    keywords: {
                        keyword: "if else elif endif define undef warning error line region endregion pragma checksum"
                    }
                }, d, r, {
                    beginKeywords: "class interface",
                    relevance: 0,
                    end: /[{;=]/,
                    illegal: /[^\s:,]/,
                    contains: [{
                        beginKeywords: "where class"
                    }, n, p, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE]
                }, {
                    beginKeywords: "namespace",
                    relevance: 0,
                    end: /[{;=]/,
                    illegal: /[^\s:]/,
                    contains: [n, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE]
                }, {
                    beginKeywords: "record",
                    relevance: 0,
                    end: /[{;=]/,
                    illegal: /[^\s:]/,
                    contains: [n, p, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE]
                }, {
                    className: "meta",
                    begin: "^\\s*\\[(?=[\\w])",
                    excludeBegin: !0,
                    end: "\\]",
                    excludeEnd: !0,
                    contains: [{
                        className: "string",
                        begin: /"/,
                        end: /"/
                    }]
                }, {
                    beginKeywords: "new return throw await else",
                    relevance: 0
                }, {
                    className: "function",
                    begin: "(" + h + "\\s+)+" + e.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
                    returnBegin: !0,
                    end: /\s*[{;=]/,
                    excludeEnd: !0,
                    keywords: t,
                    contains: [{
                        beginKeywords: ["public", "private", "protected", "static", "internal", "protected", "abstract", "async", "extern", "override", "unsafe", "virtual", "new", "sealed", "partial"].join(" "),
                        relevance: 0
                    }, {
                        begin: e.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
                        returnBegin: !0,
                        contains: [e.TITLE_MODE, p],
                        relevance: 0
                    }, {
                        match: /\(\)/
                    }, {
                        className: "params",
                        begin: /\(/,
                        end: /\)/,
                        excludeBegin: !0,
                        excludeEnd: !0,
                        keywords: t,
                        relevance: 0,
                        contains: [d, r, e.C_BLOCK_COMMENT_MODE]
                    }, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE]
                }, f]
            }
        },
        elixir: function(e) {
            const t = e.regex
              , n = "[a-zA-Z_][a-zA-Z0-9_.]*(!|\\?)?"
              , r = {
                $pattern: n,
                keyword: ["after", "alias", "and", "case", "catch", "cond", "defstruct", "defguard", "do", "else", "end", "fn", "for", "if", "import", "in", "not", "or", "quote", "raise", "receive", "require", "reraise", "rescue", "try", "unless", "unquote", "unquote_splicing", "use", "when", "with|0"],
                literal: ["false", "nil", "true"]
            }
              , o = {
                className: "subst",
                begin: /#\{/,
                end: /\}/,
                keywords: r
            }
              , i = {
                match: /\\[\s\S]/,
                scope: "char.escape",
                relevance: 0
            }
              , a = "[/|([{<\"']"
              , s = [{
                begin: /"/,
                end: /"/
            }, {
                begin: /'/,
                end: /'/
            }, {
                begin: /\//,
                end: /\//
            }, {
                begin: /\|/,
                end: /\|/
            }, {
                begin: /\(/,
                end: /\)/
            }, {
                begin: /\[/,
                end: /\]/
            }, {
                begin: /\{/,
                end: /\}/
            }, {
                begin: /</,
                end: />/
            }]
              , l = e=>({
                scope: "char.escape",
                begin: t.concat(/\\/, e),
                relevance: 0
            })
              , c = {
                className: "string",
                begin: "~[a-z](?=" + a + ")",
                contains: s.map((t=>e.inherit(t, {
                    contains: [l(t.end), i, o]
                })))
            }
              , u = {
                className: "string",
                begin: "~[A-Z](?=" + a + ")",
                contains: s.map((t=>e.inherit(t, {
                    contains: [l(t.end)]
                })))
            }
              , d = {
                className: "regex",
                variants: [{
                    begin: "~r(?=" + a + ")",
                    contains: s.map((n=>e.inherit(n, {
                        end: t.concat(n.end, /[uismxfU]{0,7}/),
                        contains: [l(n.end), i, o]
                    })))
                }, {
                    begin: "~R(?=" + a + ")",
                    contains: s.map((n=>e.inherit(n, {
                        end: t.concat(n.end, /[uismxfU]{0,7}/),
                        contains: [l(n.end)]
                    })))
                }]
            }
              , p = {
                className: "string",
                contains: [e.BACKSLASH_ESCAPE, o],
                variants: [{
                    begin: /"""/,
                    end: /"""/
                }, {
                    begin: /'''/,
                    end: /'''/
                }, {
                    begin: /~S"""/,
                    end: /"""/,
                    contains: []
                }, {
                    begin: /~S"/,
                    end: /"/,
                    contains: []
                }, {
                    begin: /~S'''/,
                    end: /'''/,
                    contains: []
                }, {
                    begin: /~S'/,
                    end: /'/,
                    contains: []
                }, {
                    begin: /'/,
                    end: /'/
                }, {
                    begin: /"/,
                    end: /"/
                }]
            }
              , h = {
                className: "function",
                beginKeywords: "def defp defmacro defmacrop",
                end: /\B\b/,
                contains: [e.inherit(e.TITLE_MODE, {
                    begin: n,
                    endsParent: !0
                })]
            }
              , f = e.inherit(h, {
                className: "class",
                beginKeywords: "defimpl defmodule defprotocol defrecord",
                end: /\bdo\b|$|;/
            })
              , m = [p, d, u, c, e.HASH_COMMENT_MODE, f, h, {
                begin: "::"
            }, {
                className: "symbol",
                begin: ":(?![\\s:])",
                contains: [p, {
                    begin: "[a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?"
                }],
                relevance: 0
            }, {
                className: "symbol",
                begin: n + ":(?!:)",
                relevance: 0
            }, {
                className: "title.class",
                begin: /(\b[A-Z][a-zA-Z0-9_]+)/,
                relevance: 0
            }, {
                className: "number",
                begin: "(\\b0o[0-7_]+)|(\\b0b[01_]+)|(\\b0x[0-9a-fA-F_]+)|(-?\\b[0-9][0-9_]*(\\.[0-9_]+([eE][-+]?[0-9]+)?)?)",
                relevance: 0
            }, {
                className: "variable",
                begin: "(\\$\\W)|((\\$|@@?)(\\w+))"
            }];
            return o.contains = m,
            {
                name: "Elixir",
                aliases: ["ex", "exs"],
                keywords: r,
                contains: m
            }
        },
        go: function(e) {
            const t = {
                keyword: ["break", "case", "chan", "const", "continue", "default", "defer", "else", "fallthrough", "for", "func", "go", "goto", "if", "import", "interface", "map", "package", "range", "return", "select", "struct", "switch", "type", "var"],
                type: ["bool", "byte", "complex64", "complex128", "error", "float32", "float64", "int8", "int16", "int32", "int64", "string", "uint8", "uint16", "uint32", "uint64", "int", "uint", "uintptr", "rune"],
                literal: ["true", "false", "iota", "nil"],
                built_in: ["append", "cap", "close", "complex", "copy", "imag", "len", "make", "new", "panic", "print", "println", "real", "recover", "delete"]
            };
            return {
                name: "Go",
                aliases: ["golang"],
                keywords: t,
                illegal: "</",
                contains: [e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE, {
                    className: "string",
                    variants: [e.QUOTE_STRING_MODE, e.APOS_STRING_MODE, {
                        begin: "`",
                        end: "`"
                    }]
                }, {
                    className: "number",
                    variants: [{
                        begin: e.C_NUMBER_RE + "[i]",
                        relevance: 1
                    }, e.C_NUMBER_MODE]
                }, {
                    begin: /:=/
                }, {
                    className: "function",
                    beginKeywords: "func",
                    end: "\\s*(\\{|$)",
                    excludeEnd: !0,
                    contains: [e.TITLE_MODE, {
                        className: "params",
                        begin: /\(/,
                        end: /\)/,
                        endsParent: !0,
                        keywords: t,
                        illegal: /["']/
                    }]
                }]
            }
        },
        graphql: function(e) {
            const t = e.regex;
            return {
                name: "GraphQL",
                aliases: ["gql"],
                case_insensitive: !0,
                disableAutodetect: !1,
                keywords: {
                    keyword: ["query", "mutation", "subscription", "type", "input", "schema", "directive", "interface", "union", "scalar", "fragment", "enum", "on"],
                    literal: ["true", "false", "null"]
                },
                contains: [e.HASH_COMMENT_MODE, e.QUOTE_STRING_MODE, e.NUMBER_MODE, {
                    scope: "punctuation",
                    match: /[.]{3}/,
                    relevance: 0
                }, {
                    scope: "punctuation",
                    begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
                    relevance: 0
                }, {
                    scope: "variable",
                    begin: /\$/,
                    end: /\W/,
                    excludeEnd: !0,
                    relevance: 0
                }, {
                    scope: "meta",
                    match: /@\w+/,
                    excludeEnd: !0
                }, {
                    scope: "symbol",
                    begin: t.concat(/[_A-Za-z][_0-9A-Za-z]*/, t.lookahead(/\s*:/)),
                    relevance: 0
                }],
                illegal: [/[;<']/, /BEGIN/]
            }
        },
        html: Rd,
        java: function(e) {
            const t = e.regex
              , n = "[À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*"
              , r = n + Ru("(?:<" + n + "~~~(?:\\s*,\\s*" + n + "~~~)*>)?", /~~~/g, 2)
              , o = {
                keyword: ["synchronized", "abstract", "private", "var", "static", "if", "const ", "for", "while", "strictfp", "finally", "protected", "import", "native", "final", "void", "enum", "else", "break", "transient", "catch", "instanceof", "volatile", "case", "assert", "package", "default", "public", "try", "switch", "continue", "throws", "protected", "public", "private", "module", "requires", "exports", "do", "sealed", "yield", "permits"],
                literal: ["false", "true", "null"],
                type: ["char", "boolean", "long", "float", "int", "byte", "short", "double"],
                built_in: ["super", "this"]
            }
              , i = {
                className: "meta",
                begin: "@" + n,
                contains: [{
                    begin: /\(/,
                    end: /\)/,
                    contains: ["self"]
                }]
            }
              , a = {
                className: "params",
                begin: /\(/,
                end: /\)/,
                keywords: o,
                relevance: 0,
                contains: [e.C_BLOCK_COMMENT_MODE],
                endsParent: !0
            };
            return {
                name: "Java",
                aliases: ["jsp"],
                keywords: o,
                illegal: /<\/|#/,
                contains: [e.COMMENT("/\\*\\*", "\\*/", {
                    relevance: 0,
                    contains: [{
                        begin: /\w+@/,
                        relevance: 0
                    }, {
                        className: "doctag",
                        begin: "@[A-Za-z]+"
                    }]
                }), {
                    begin: /import java\.[a-z]+\./,
                    keywords: "import",
                    relevance: 2
                }, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE, {
                    begin: /"""/,
                    end: /"""/,
                    className: "string",
                    contains: [e.BACKSLASH_ESCAPE]
                }, e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, {
                    match: [/\b(?:class|interface|enum|extends|implements|new)/, /\s+/, n],
                    className: {
                        1: "keyword",
                        3: "title.class"
                    }
                }, {
                    match: /non-sealed/,
                    scope: "keyword"
                }, {
                    begin: [t.concat(/(?!else)/, n), /\s+/, n, /\s+/, /=(?!=)/],
                    className: {
                        1: "type",
                        3: "variable",
                        5: "operator"
                    }
                }, {
                    begin: [/record/, /\s+/, n],
                    className: {
                        1: "keyword",
                        3: "title.class"
                    },
                    contains: [a, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE]
                }, {
                    beginKeywords: "new throw return else",
                    relevance: 0
                }, {
                    begin: ["(?:" + r + "\\s+)", e.UNDERSCORE_IDENT_RE, /\s*(?=\()/],
                    className: {
                        2: "title.function"
                    },
                    keywords: o,
                    contains: [{
                        className: "params",
                        begin: /\(/,
                        end: /\)/,
                        keywords: o,
                        relevance: 0,
                        contains: [i, e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, Du, e.C_BLOCK_COMMENT_MODE]
                    }, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE]
                }, Du, i]
            }
        },
        javascript: function(e) {
            const t = e.regex
              , n = Nu
              , r = "<>"
              , o = "</>"
              , i = {
                begin: /<[A-Za-z0-9\\._:-]+/,
                end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
                isTrulyOpeningTag: (e,t)=>{
                    const n = e[0].length + e.index
                      , r = e.input[n];
                    if ("<" === r || "," === r)
                        return void t.ignoreMatch();
                    let o;
                    ">" === r && (((e,{after: t})=>{
                        const n = "</" + e[0].slice(1);
                        return -1 !== e.input.indexOf(n, t)
                    }
                    )(e, {
                        after: n
                    }) || t.ignoreMatch());
                    const i = e.input.substring(n);
                    ((o = i.match(/^\s*=/)) || (o = i.match(/^\s+extends\s+/)) && 0 === o.index) && t.ignoreMatch()
                }
            }
              , a = {
                $pattern: Nu,
                keyword: $u,
                literal: Iu,
                built_in: Uu,
                "variable.language": Bu
            }
              , s = "[0-9](_?[0-9])*"
              , l = `\\.(${s})`
              , c = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*"
              , u = {
                className: "number",
                variants: [{
                    begin: `(\\b(${c})((${l})|\\.)?|(${l}))[eE][+-]?(${s})\\b`
                }, {
                    begin: `\\b(${c})\\b((${l})\\b|\\.)?|(${l})\\b`
                }, {
                    begin: "\\b(0|[1-9](_?[0-9])*)n\\b"
                }, {
                    begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b"
                }, {
                    begin: "\\b0[bB][0-1](_?[0-1])*n?\\b"
                }, {
                    begin: "\\b0[oO][0-7](_?[0-7])*n?\\b"
                }, {
                    begin: "\\b0[0-7]+n?\\b"
                }],
                relevance: 0
            }
              , d = {
                className: "subst",
                begin: "\\$\\{",
                end: "\\}",
                keywords: a,
                contains: []
            }
              , p = {
                begin: "html`",
                end: "",
                starts: {
                    end: "`",
                    returnEnd: !1,
                    contains: [e.BACKSLASH_ESCAPE, d],
                    subLanguage: "xml"
                }
            }
              , h = {
                begin: "css`",
                end: "",
                starts: {
                    end: "`",
                    returnEnd: !1,
                    contains: [e.BACKSLASH_ESCAPE, d],
                    subLanguage: "css"
                }
            }
              , f = {
                begin: "gql`",
                end: "",
                starts: {
                    end: "`",
                    returnEnd: !1,
                    contains: [e.BACKSLASH_ESCAPE, d],
                    subLanguage: "graphql"
                }
            }
              , m = {
                className: "string",
                begin: "`",
                end: "`",
                contains: [e.BACKSLASH_ESCAPE, d]
            }
              , g = {
                className: "comment",
                variants: [e.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
                    relevance: 0,
                    contains: [{
                        begin: "(?=@[A-Za-z]+)",
                        relevance: 0,
                        contains: [{
                            className: "doctag",
                            begin: "@[A-Za-z]+"
                        }, {
                            className: "type",
                            begin: "\\{",
                            end: "\\}",
                            excludeEnd: !0,
                            excludeBegin: !0,
                            relevance: 0
                        }, {
                            className: "variable",
                            begin: n + "(?=\\s*(-)|$)",
                            endsParent: !0,
                            relevance: 0
                        }, {
                            begin: /(?=[^\n])\s/,
                            relevance: 0
                        }]
                    }]
                }), e.C_BLOCK_COMMENT_MODE, e.C_LINE_COMMENT_MODE]
            }
              , b = [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, p, h, f, m, {
                match: /\$\d+/
            }, u];
            d.contains = b.concat({
                begin: /\{/,
                end: /\}/,
                keywords: a,
                contains: ["self"].concat(b)
            });
            const O = [].concat(g, d.contains)
              , v = O.concat([{
                begin: /\(/,
                end: /\)/,
                keywords: a,
                contains: ["self"].concat(O)
            }])
              , y = {
                className: "params",
                begin: /\(/,
                end: /\)/,
                excludeBegin: !0,
                excludeEnd: !0,
                keywords: a,
                contains: v
            }
              , w = {
                variants: [{
                    match: [/class/, /\s+/, n, /\s+/, /extends/, /\s+/, t.concat(n, "(", t.concat(/\./, n), ")*")],
                    scope: {
                        1: "keyword",
                        3: "title.class",
                        5: "keyword",
                        7: "title.class.inherited"
                    }
                }, {
                    match: [/class/, /\s+/, n],
                    scope: {
                        1: "keyword",
                        3: "title.class"
                    }
                }]
            }
              , _ = {
                relevance: 0,
                match: t.either(/\bJSON/, /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/, /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/, /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/),
                className: "title.class",
                keywords: {
                    _: [...Mu, ...Lu]
                }
            }
              , k = {
                variants: [{
                    match: [/function/, /\s+/, n, /(?=\s*\()/]
                }, {
                    match: [/function/, /\s*(?=\()/]
                }],
                className: {
                    1: "keyword",
                    3: "title.function"
                },
                label: "func.def",
                contains: [y],
                illegal: /%/
            }
              , S = {
                match: t.concat(/\b/, (E = [...Qu, "super", "import"],
                t.concat("(?!", E.join("|"), ")")), n, t.lookahead(/\(/)),
                className: "title.function",
                relevance: 0
            };
            var E;
            const x = {
                begin: t.concat(/\./, t.lookahead(t.concat(n, /(?![0-9A-Za-z$_(])/))),
                end: n,
                excludeBegin: !0,
                keywords: "prototype",
                className: "property",
                relevance: 0
            }
              , T = {
                match: [/get|set/, /\s+/, n, /(?=\()/],
                className: {
                    1: "keyword",
                    3: "title.function"
                },
                contains: [{
                    begin: /\(\)/
                }, y]
            }
              , A = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + e.UNDERSCORE_IDENT_RE + ")\\s*=>"
              , C = {
                match: [/const|var|let/, /\s+/, n, /\s*/, /=\s*/, /(async\s*)?/, t.lookahead(A)],
                keywords: "async",
                className: {
                    1: "keyword",
                    3: "title.function"
                },
                contains: [y]
            };
            return {
                name: "JavaScript",
                aliases: ["js", "jsx", "mjs", "cjs"],
                keywords: a,
                exports: {
                    PARAMS_CONTAINS: v,
                    CLASS_REFERENCE: _
                },
                illegal: /#(?![$_A-z])/,
                contains: [e.SHEBANG({
                    label: "shebang",
                    binary: "node",
                    relevance: 5
                }), {
                    label: "use_strict",
                    className: "meta",
                    relevance: 10,
                    begin: /^\s*['"]use (strict|asm)['"]/
                }, e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, p, h, f, m, g, {
                    match: /\$\d+/
                }, u, _, {
                    className: "attr",
                    begin: n + t.lookahead(":"),
                    relevance: 0
                }, C, {
                    begin: "(" + e.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
                    keywords: "return throw case",
                    relevance: 0,
                    contains: [g, e.REGEXP_MODE, {
                        className: "function",
                        begin: A,
                        returnBegin: !0,
                        end: "\\s*=>",
                        contains: [{
                            className: "params",
                            variants: [{
                                begin: e.UNDERSCORE_IDENT_RE,
                                relevance: 0
                            }, {
                                className: null,
                                begin: /\(\s*\)/,
                                skip: !0
                            }, {
                                begin: /\(/,
                                end: /\)/,
                                excludeBegin: !0,
                                excludeEnd: !0,
                                keywords: a,
                                contains: v
                            }]
                        }]
                    }, {
                        begin: /,/,
                        relevance: 0
                    }, {
                        match: /\s+/,
                        relevance: 0
                    }, {
                        variants: [{
                            begin: r,
                            end: o
                        }, {
                            match: /<[A-Za-z0-9\\._:-]+\s*\/>/
                        }, {
                            begin: i.begin,
                            "on:begin": i.isTrulyOpeningTag,
                            end: i.end
                        }],
                        subLanguage: "xml",
                        contains: [{
                            begin: i.begin,
                            end: i.end,
                            skip: !0,
                            contains: ["self"]
                        }]
                    }]
                }, k, {
                    beginKeywords: "while if switch catch for"
                }, {
                    begin: "\\b(?!function)" + e.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
                    returnBegin: !0,
                    label: "func.def",
                    contains: [y, e.inherit(e.TITLE_MODE, {
                        begin: n,
                        className: "title.function"
                    })]
                }, {
                    match: /\.\.\./,
                    relevance: 0
                }, x, {
                    match: "\\$" + n,
                    relevance: 0
                }, {
                    match: [/\bconstructor(?=\s*\()/],
                    className: {
                        1: "title.function"
                    },
                    contains: [y]
                }, S, {
                    relevance: 0,
                    match: /\b[A-Z][A-Z_0-9]+\b/,
                    className: "variable.constant"
                }, w, T, {
                    match: /\$[(.]/
                }]
            }
        },
        json: function(e) {
            const t = ["true", "false", "null"]
              , n = {
                scope: "literal",
                beginKeywords: t.join(" ")
            };
            return {
                name: "JSON",
                keywords: {
                    literal: t
                },
                contains: [{
                    className: "attr",
                    begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
                    relevance: 1.01
                }, {
                    match: /[{}[\],:]/,
                    className: "punctuation",
                    relevance: 0
                }, e.QUOTE_STRING_MODE, n, e.C_NUMBER_MODE, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE],
                illegal: "\\S"
            }
        },
        kotlin: function(e) {
            const t = {
                keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
                built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
                literal: "true false null"
            }
              , n = {
                className: "symbol",
                begin: e.UNDERSCORE_IDENT_RE + "@"
            }
              , r = {
                className: "subst",
                begin: /\$\{/,
                end: /\}/,
                contains: [e.C_NUMBER_MODE]
            }
              , o = {
                className: "variable",
                begin: "\\$" + e.UNDERSCORE_IDENT_RE
            }
              , i = {
                className: "string",
                variants: [{
                    begin: '"""',
                    end: '"""(?=[^"])',
                    contains: [o, r]
                }, {
                    begin: "'",
                    end: "'",
                    illegal: /\n/,
                    contains: [e.BACKSLASH_ESCAPE]
                }, {
                    begin: '"',
                    end: '"',
                    illegal: /\n/,
                    contains: [e.BACKSLASH_ESCAPE, o, r]
                }]
            };
            r.contains.push(i);
            const a = {
                className: "meta",
                begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + e.UNDERSCORE_IDENT_RE + ")?"
            }
              , s = {
                className: "meta",
                begin: "@" + e.UNDERSCORE_IDENT_RE,
                contains: [{
                    begin: /\(/,
                    end: /\)/,
                    contains: [e.inherit(i, {
                        className: "string"
                    }), "self"]
                }]
            }
              , l = qu
              , c = e.COMMENT("/\\*", "\\*/", {
                contains: [e.C_BLOCK_COMMENT_MODE]
            })
              , u = {
                variants: [{
                    className: "type",
                    begin: e.UNDERSCORE_IDENT_RE
                }, {
                    begin: /\(/,
                    end: /\)/,
                    contains: []
                }]
            }
              , d = u;
            return d.variants[1].contains = [u],
            u.variants[1].contains = [d],
            {
                name: "Kotlin",
                aliases: ["kt", "kts"],
                keywords: t,
                contains: [e.COMMENT("/\\*\\*", "\\*/", {
                    relevance: 0,
                    contains: [{
                        className: "doctag",
                        begin: "@[A-Za-z]+"
                    }]
                }), e.C_LINE_COMMENT_MODE, c, {
                    className: "keyword",
                    begin: /\b(break|continue|return|this)\b/,
                    starts: {
                        contains: [{
                            className: "symbol",
                            begin: /@\w+/
                        }]
                    }
                }, n, a, s, {
                    className: "function",
                    beginKeywords: "fun",
                    end: "[(]|$",
                    returnBegin: !0,
                    excludeEnd: !0,
                    keywords: t,
                    relevance: 5,
                    contains: [{
                        begin: e.UNDERSCORE_IDENT_RE + "\\s*\\(",
                        returnBegin: !0,
                        relevance: 0,
                        contains: [e.UNDERSCORE_TITLE_MODE]
                    }, {
                        className: "type",
                        begin: /</,
                        end: />/,
                        keywords: "reified",
                        relevance: 0
                    }, {
                        className: "params",
                        begin: /\(/,
                        end: /\)/,
                        endsParent: !0,
                        keywords: t,
                        relevance: 0,
                        contains: [{
                            begin: /:/,
                            end: /[=,\/]/,
                            endsWithParent: !0,
                            contains: [u, e.C_LINE_COMMENT_MODE, c],
                            relevance: 0
                        }, e.C_LINE_COMMENT_MODE, c, a, s, i, e.C_NUMBER_MODE]
                    }, c]
                }, {
                    begin: [/class|interface|trait/, /\s+/, e.UNDERSCORE_IDENT_RE],
                    beginScope: {
                        3: "title.class"
                    },
                    keywords: "class interface trait",
                    end: /[:\{(]|$/,
                    excludeEnd: !0,
                    illegal: "extends implements",
                    contains: [{
                        beginKeywords: "public protected internal private constructor"
                    }, e.UNDERSCORE_TITLE_MODE, {
                        className: "type",
                        begin: /</,
                        end: />/,
                        excludeBegin: !0,
                        excludeEnd: !0,
                        relevance: 0
                    }, {
                        className: "type",
                        begin: /[,:]\s*/,
                        end: /[<\(,){\s]|$/,
                        excludeBegin: !0,
                        returnEnd: !0
                    }, a, s]
                }, i, {
                    className: "meta",
                    begin: "^#!/usr/bin/env",
                    end: "$",
                    illegal: "\n"
                }, l]
            }
        },
        less: function(e) {
            const t = (e=>({
                IMPORTANT: {
                    scope: "meta",
                    begin: "!important"
                },
                BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
                HEXCOLOR: {
                    scope: "number",
                    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
                },
                FUNCTION_DISPATCH: {
                    className: "built_in",
                    begin: /[\w-]+(?=\()/
                },
                ATTRIBUTE_SELECTOR_MODE: {
                    scope: "selector-attr",
                    begin: /\[/,
                    end: /\]/,
                    illegal: "$",
                    contains: [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE]
                },
                CSS_NUMBER_MODE: {
                    scope: "number",
                    begin: e.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
                    relevance: 0
                },
                CSS_VARIABLE: {
                    className: "attr",
                    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
                }
            }))(e)
              , n = Gu
              , r = "[\\w-]+"
              , o = "(" + r + "|@\\{" + r + "\\})"
              , i = []
              , a = []
              , s = function(e) {
                return {
                    className: "string",
                    begin: "~?" + e + ".*?" + e
                }
            }
              , l = function(e, t, n) {
                return {
                    className: e,
                    begin: t,
                    relevance: n
                }
            }
              , c = {
                $pattern: /[a-z-]+/,
                keyword: "and or not only",
                attribute: Zu.join(" ")
            }
              , u = {
                begin: "\\(",
                end: "\\)",
                contains: a,
                keywords: c,
                relevance: 0
            };
            a.push(e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE, s("'"), s('"'), t.CSS_NUMBER_MODE, {
                begin: "(url|data-uri)\\(",
                starts: {
                    className: "string",
                    end: "[\\)\\n]",
                    excludeEnd: !0
                }
            }, t.HEXCOLOR, u, l("variable", "@@?" + r, 10), l("variable", "@\\{" + r + "\\}"), l("built_in", "~?`[^`]*?`"), {
                className: "attribute",
                begin: r + "\\s*:",
                end: ":",
                returnBegin: !0,
                excludeEnd: !0
            }, t.IMPORTANT, {
                beginKeywords: "and not"
            }, t.FUNCTION_DISPATCH);
            const d = a.concat({
                begin: /\{/,
                end: /\}/,
                contains: i
            })
              , p = {
                beginKeywords: "when",
                endsWithParent: !0,
                contains: [{
                    beginKeywords: "and not"
                }].concat(a)
            }
              , h = {
                begin: o + "\\s*:",
                returnBegin: !0,
                end: /[;}]/,
                relevance: 0,
                contains: [{
                    begin: /-(webkit|moz|ms|o)-/
                }, t.CSS_VARIABLE, {
                    className: "attribute",
                    begin: "\\b(" + Vu.join("|") + ")\\b",
                    end: /(?=:)/,
                    starts: {
                        endsWithParent: !0,
                        illegal: "[<=$]",
                        relevance: 0,
                        contains: a
                    }
                }]
            }
              , f = {
                className: "keyword",
                begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
                starts: {
                    end: "[;{}]",
                    keywords: c,
                    returnEnd: !0,
                    contains: a,
                    relevance: 0
                }
            }
              , m = {
                className: "variable",
                variants: [{
                    begin: "@" + r + "\\s*:",
                    relevance: 15
                }, {
                    begin: "@" + r
                }],
                starts: {
                    end: "[;}]",
                    returnEnd: !0,
                    contains: d
                }
            }
              , g = {
                variants: [{
                    begin: "[\\.#:&\\[>]",
                    end: "[;{}]"
                }, {
                    begin: o,
                    end: /\{/
                }],
                returnBegin: !0,
                returnEnd: !0,
                illegal: "[<='$\"]",
                relevance: 0,
                contains: [e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE, p, l("keyword", "all\\b"), l("variable", "@\\{" + r + "\\}"), {
                    begin: "\\b(" + Hu.join("|") + ")\\b",
                    className: "selector-tag"
                }, t.CSS_NUMBER_MODE, l("selector-tag", o, 0), l("selector-id", "#" + o), l("selector-class", "\\." + o, 0), l("selector-tag", "&", 0), t.ATTRIBUTE_SELECTOR_MODE, {
                    className: "selector-pseudo",
                    begin: ":(" + Wu.join("|") + ")"
                }, {
                    className: "selector-pseudo",
                    begin: ":(:)?(" + Xu.join("|") + ")"
                }, {
                    begin: /\(/,
                    end: /\)/,
                    relevance: 0,
                    contains: d
                }, {
                    begin: "!important"
                }, t.FUNCTION_DISPATCH]
            }
              , b = {
                begin: r + `:(:)?(${n.join("|")})`,
                returnBegin: !0,
                contains: [g]
            };
            return i.push(e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE, f, m, b, h, g, p, t.FUNCTION_DISPATCH),
            {
                name: "Less",
                case_insensitive: !0,
                illegal: "[=>'/<($\"]",
                contains: i
            }
        },
        makefile: function(e) {
            const t = {
                className: "variable",
                variants: [{
                    begin: "\\$\\(" + e.UNDERSCORE_IDENT_RE + "\\)",
                    contains: [e.BACKSLASH_ESCAPE]
                }, {
                    begin: /\$[@%<?\^\+\*]/
                }]
            }
              , n = {
                className: "string",
                begin: /"/,
                end: /"/,
                contains: [e.BACKSLASH_ESCAPE, t]
            }
              , r = {
                className: "variable",
                begin: /\$\([\w-]+\s/,
                end: /\)/,
                keywords: {
                    built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value"
                },
                contains: [t]
            }
              , o = {
                begin: "^" + e.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)"
            }
              , i = {
                className: "section",
                begin: /^[^\s]+:/,
                end: /$/,
                contains: [t]
            };
            return {
                name: "Makefile",
                aliases: ["mk", "mak", "make"],
                keywords: {
                    $pattern: /[\w-]+/,
                    keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
                },
                contains: [e.HASH_COMMENT_MODE, t, n, r, o, {
                    className: "meta",
                    begin: /^\.PHONY:/,
                    end: /$/,
                    keywords: {
                        $pattern: /[\.\w]+/,
                        keyword: ".PHONY"
                    }
                }, i]
            }
        },
        markdown: function(e) {
            const t = {
                begin: /<\/?[A-Za-z_]/,
                end: ">",
                subLanguage: "xml",
                relevance: 0
            }
              , n = {
                variants: [{
                    begin: /\[.+?\]\[.*?\]/,
                    relevance: 0
                }, {
                    begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
                    relevance: 2
                }, {
                    begin: e.regex.concat(/\[.+?\]\(/, /[A-Za-z][A-Za-z0-9+.-]*/, /:\/\/.*?\)/),
                    relevance: 2
                }, {
                    begin: /\[.+?\]\([./?&#].*?\)/,
                    relevance: 1
                }, {
                    begin: /\[.*?\]\(.*?\)/,
                    relevance: 0
                }],
                returnBegin: !0,
                contains: [{
                    match: /\[(?=\])/
                }, {
                    className: "string",
                    relevance: 0,
                    begin: "\\[",
                    end: "\\]",
                    excludeBegin: !0,
                    returnEnd: !0
                }, {
                    className: "link",
                    relevance: 0,
                    begin: "\\]\\(",
                    end: "\\)",
                    excludeBegin: !0,
                    excludeEnd: !0
                }, {
                    className: "symbol",
                    relevance: 0,
                    begin: "\\]\\[",
                    end: "\\]",
                    excludeBegin: !0,
                    excludeEnd: !0
                }]
            }
              , r = {
                className: "strong",
                contains: [],
                variants: [{
                    begin: /_{2}(?!\s)/,
                    end: /_{2}/
                }, {
                    begin: /\*{2}(?!\s)/,
                    end: /\*{2}/
                }]
            }
              , o = {
                className: "emphasis",
                contains: [],
                variants: [{
                    begin: /\*(?![*\s])/,
                    end: /\*/
                }, {
                    begin: /_(?![_\s])/,
                    end: /_/,
                    relevance: 0
                }]
            }
              , i = e.inherit(r, {
                contains: []
            })
              , a = e.inherit(o, {
                contains: []
            });
            r.contains.push(a),
            o.contains.push(i);
            let s = [t, n];
            return [r, o, i, a].forEach((e=>{
                e.contains = e.contains.concat(s)
            }
            )),
            s = s.concat(r, o),
            {
                name: "Markdown",
                aliases: ["md", "mkdown", "mkd"],
                contains: [{
                    className: "section",
                    variants: [{
                        begin: "^#{1,6}",
                        end: "$",
                        contains: s
                    }, {
                        begin: "(?=^.+?\\n[=-]{2,}$)",
                        contains: [{
                            begin: "^[=-]*$"
                        }, {
                            begin: "^",
                            end: "\\n",
                            contains: s
                        }]
                    }]
                }, t, {
                    className: "bullet",
                    begin: "^[ \t]*([*+-]|(\\d+\\.))(?=\\s+)",
                    end: "\\s+",
                    excludeEnd: !0
                }, r, o, {
                    className: "quote",
                    begin: "^>\\s+",
                    contains: s,
                    end: "$"
                }, {
                    className: "code",
                    variants: [{
                        begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*"
                    }, {
                        begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*"
                    }, {
                        begin: "```",
                        end: "```+[ ]*$"
                    }, {
                        begin: "~~~",
                        end: "~~~+[ ]*$"
                    }, {
                        begin: "`.+?`"
                    }, {
                        begin: "(?=^( {4}|\\t))",
                        contains: [{
                            begin: "^( {4}|\\t)",
                            end: "(\\n)$"
                        }],
                        relevance: 0
                    }]
                }, {
                    begin: "^[-\\*]{3,}",
                    end: "$"
                }, n, {
                    begin: /^\[[^\n]+\]:/,
                    returnBegin: !0,
                    contains: [{
                        className: "symbol",
                        begin: /\[/,
                        end: /\]/,
                        excludeBegin: !0,
                        excludeEnd: !0
                    }, {
                        className: "link",
                        begin: /:\s*/,
                        end: /$/,
                        excludeBegin: !0
                    }]
                }]
            }
        },
        matlab: function(e) {
            const t = "('|\\.')+"
              , n = {
                relevance: 0,
                contains: [{
                    begin: t
                }]
            };
            return {
                name: "Matlab",
                keywords: {
                    keyword: "arguments break case catch classdef continue else elseif end enumeration events for function global if methods otherwise parfor persistent properties return spmd switch try while",
                    built_in: "sin sind sinh asin asind asinh cos cosd cosh acos acosd acosh tan tand tanh atan atand atan2 atanh sec secd sech asec asecd asech csc cscd csch acsc acscd acsch cot cotd coth acot acotd acoth hypot exp expm1 log log1p log10 log2 pow2 realpow reallog realsqrt sqrt nthroot nextpow2 abs angle complex conj imag real unwrap isreal cplxpair fix floor ceil round mod rem sign airy besselj bessely besselh besseli besselk beta betainc betaln ellipj ellipke erf erfc erfcx erfinv expint gamma gammainc gammaln psi legendre cross dot factor isprime primes gcd lcm rat rats perms nchoosek factorial cart2sph cart2pol pol2cart sph2cart hsv2rgb rgb2hsv zeros ones eye repmat rand randn linspace logspace freqspace meshgrid accumarray size length ndims numel disp isempty isequal isequalwithequalnans cat reshape diag blkdiag tril triu fliplr flipud flipdim rot90 find sub2ind ind2sub bsxfun ndgrid permute ipermute shiftdim circshift squeeze isscalar isvector ans eps realmax realmin pi i|0 inf nan isnan isinf isfinite j|0 why compan gallery hadamard hankel hilb invhilb magic pascal rosser toeplitz vander wilkinson max min nanmax nanmin mean nanmean type table readtable writetable sortrows sort figure plot plot3 scatter scatter3 cellfun legend intersect ismember procrustes hold num2cell "
                },
                illegal: '(//|"|#|/\\*|\\s+/\\w+)',
                contains: [{
                    className: "function",
                    beginKeywords: "function",
                    end: "$",
                    contains: [e.UNDERSCORE_TITLE_MODE, {
                        className: "params",
                        variants: [{
                            begin: "\\(",
                            end: "\\)"
                        }, {
                            begin: "\\[",
                            end: "\\]"
                        }]
                    }]
                }, {
                    className: "built_in",
                    begin: /true|false/,
                    relevance: 0,
                    starts: n
                }, {
                    begin: "[a-zA-Z][a-zA-Z_0-9]*" + t,
                    relevance: 0
                }, {
                    className: "number",
                    begin: e.C_NUMBER_RE,
                    relevance: 0,
                    starts: n
                }, {
                    className: "string",
                    begin: "'",
                    end: "'",
                    contains: [{
                        begin: "''"
                    }]
                }, {
                    begin: /\]|\}|\)/,
                    relevance: 0,
                    starts: n
                }, {
                    className: "string",
                    begin: '"',
                    end: '"',
                    contains: [{
                        begin: '""'
                    }],
                    starts: n
                }, e.COMMENT("^\\s*%\\{\\s*$", "^\\s*%\\}\\s*$"), e.COMMENT("%", "$")]
            }
        },
        nginx: function(e) {
            const t = e.regex
              , n = {
                className: "variable",
                variants: [{
                    begin: /\$\d+/
                }, {
                    begin: /\$\{\w+\}/
                }, {
                    begin: t.concat(/[$@]/, e.UNDERSCORE_IDENT_RE)
                }]
            }
              , r = {
                endsWithParent: !0,
                keywords: {
                    $pattern: /[a-z_]{2,}|\/dev\/poll/,
                    literal: ["on", "off", "yes", "no", "true", "false", "none", "blocked", "debug", "info", "notice", "warn", "error", "crit", "select", "break", "last", "permanent", "redirect", "kqueue", "rtsig", "epoll", "poll", "/dev/poll"]
                },
                relevance: 0,
                illegal: "=>",
                contains: [e.HASH_COMMENT_MODE, {
                    className: "string",
                    contains: [e.BACKSLASH_ESCAPE, n],
                    variants: [{
                        begin: /"/,
                        end: /"/
                    }, {
                        begin: /'/,
                        end: /'/
                    }]
                }, {
                    begin: "([a-z]+):/",
                    end: "\\s",
                    endsWithParent: !0,
                    excludeEnd: !0,
                    contains: [n]
                }, {
                    className: "regexp",
                    contains: [e.BACKSLASH_ESCAPE, n],
                    variants: [{
                        begin: "\\s\\^",
                        end: "\\s|\\{|;",
                        returnEnd: !0
                    }, {
                        begin: "~\\*?\\s+",
                        end: "\\s|\\{|;",
                        returnEnd: !0
                    }, {
                        begin: "\\*(\\.[a-z\\-]+)+"
                    }, {
                        begin: "([a-z\\-]+\\.)+\\*"
                    }]
                }, {
                    className: "number",
                    begin: "\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}(:\\d{1,5})?\\b"
                }, {
                    className: "number",
                    begin: "\\b\\d+[kKmMgGdshdwy]?\\b",
                    relevance: 0
                }, n]
            };
            return {
                name: "Nginx config",
                aliases: ["nginxconf"],
                contains: [e.HASH_COMMENT_MODE, {
                    beginKeywords: "upstream location",
                    end: /;|\{/,
                    contains: r.contains,
                    keywords: {
                        section: "upstream location"
                    }
                }, {
                    className: "section",
                    begin: t.concat(e.UNDERSCORE_IDENT_RE + t.lookahead(/\s+\{/)),
                    relevance: 0
                }, {
                    begin: t.lookahead(e.UNDERSCORE_IDENT_RE + "\\s"),
                    end: ";|\\{",
                    contains: [{
                        className: "attribute",
                        begin: e.UNDERSCORE_IDENT_RE,
                        starts: r
                    }],
                    relevance: 0
                }],
                illegal: "[^\\s\\}\\{]"
            }
        },
        objectivec: function(e) {
            const t = /[a-zA-Z@][a-zA-Z0-9_]*/
              , n = {
                $pattern: t,
                keyword: ["@interface", "@class", "@protocol", "@implementation"]
            };
            return {
                name: "Objective-C",
                aliases: ["mm", "objc", "obj-c", "obj-c++", "objective-c++"],
                keywords: {
                    "variable.language": ["this", "super"],
                    $pattern: t,
                    keyword: ["while", "export", "sizeof", "typedef", "const", "struct", "for", "union", "volatile", "static", "mutable", "if", "do", "return", "goto", "enum", "else", "break", "extern", "asm", "case", "default", "register", "explicit", "typename", "switch", "continue", "inline", "readonly", "assign", "readwrite", "self", "@synchronized", "id", "typeof", "nonatomic", "IBOutlet", "IBAction", "strong", "weak", "copy", "in", "out", "inout", "bycopy", "byref", "oneway", "__strong", "__weak", "__block", "__autoreleasing", "@private", "@protected", "@public", "@try", "@property", "@end", "@throw", "@catch", "@finally", "@autoreleasepool", "@synthesize", "@dynamic", "@selector", "@optional", "@required", "@encode", "@package", "@import", "@defs", "@compatibility_alias", "__bridge", "__bridge_transfer", "__bridge_retained", "__bridge_retain", "__covariant", "__contravariant", "__kindof", "_Nonnull", "_Nullable", "_Null_unspecified", "__FUNCTION__", "__PRETTY_FUNCTION__", "__attribute__", "getter", "setter", "retain", "unsafe_unretained", "nonnull", "nullable", "null_unspecified", "null_resettable", "class", "instancetype", "NS_DESIGNATED_INITIALIZER", "NS_UNAVAILABLE", "NS_REQUIRES_SUPER", "NS_RETURNS_INNER_POINTER", "NS_INLINE", "NS_AVAILABLE", "NS_DEPRECATED", "NS_ENUM", "NS_OPTIONS", "NS_SWIFT_UNAVAILABLE", "NS_ASSUME_NONNULL_BEGIN", "NS_ASSUME_NONNULL_END", "NS_REFINED_FOR_SWIFT", "NS_SWIFT_NAME", "NS_SWIFT_NOTHROW", "NS_DURING", "NS_HANDLER", "NS_ENDHANDLER", "NS_VALUERETURN", "NS_VOIDRETURN"],
                    literal: ["false", "true", "FALSE", "TRUE", "nil", "YES", "NO", "NULL"],
                    built_in: ["dispatch_once_t", "dispatch_queue_t", "dispatch_sync", "dispatch_async", "dispatch_once"],
                    type: ["int", "float", "char", "unsigned", "signed", "short", "long", "double", "wchar_t", "unichar", "void", "bool", "BOOL", "id|0", "_Bool"]
                },
                illegal: "</",
                contains: [{
                    className: "built_in",
                    begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
                }, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE, e.C_NUMBER_MODE, e.QUOTE_STRING_MODE, e.APOS_STRING_MODE, {
                    className: "string",
                    variants: [{
                        begin: '@"',
                        end: '"',
                        illegal: "\\n",
                        contains: [e.BACKSLASH_ESCAPE]
                    }]
                }, {
                    className: "meta",
                    begin: /#\s*[a-z]+\b/,
                    end: /$/,
                    keywords: {
                        keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include"
                    },
                    contains: [{
                        begin: /\\\n/,
                        relevance: 0
                    }, e.inherit(e.QUOTE_STRING_MODE, {
                        className: "string"
                    }), {
                        className: "string",
                        begin: /<.*?>/,
                        end: /$/,
                        illegal: "\\n"
                    }, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE]
                }, {
                    className: "class",
                    begin: "(" + n.keyword.join("|") + ")\\b",
                    end: /(\{|$)/,
                    excludeEnd: !0,
                    keywords: n,
                    contains: [e.UNDERSCORE_TITLE_MODE]
                }, {
                    begin: "\\." + e.UNDERSCORE_IDENT_RE,
                    relevance: 0
                }]
            }
        },
        ocaml: function(e) {
            return {
                name: "OCaml",
                aliases: ["ml"],
                keywords: {
                    $pattern: "[a-z_]\\w*!?",
                    keyword: "and as assert asr begin class constraint do done downto else end exception external for fun function functor if in include inherit! inherit initializer land lazy let lor lsl lsr lxor match method!|10 method mod module mutable new object of open! open or private rec sig struct then to try type val! val virtual when while with parser value",
                    built_in: "array bool bytes char exn|5 float int int32 int64 list lazy_t|5 nativeint|5 string unit in_channel out_channel ref",
                    literal: "true false"
                },
                illegal: /\/\/|>>/,
                contains: [{
                    className: "literal",
                    begin: "\\[(\\|\\|)?\\]|\\(\\)",
                    relevance: 0
                }, e.COMMENT("\\(\\*", "\\*\\)", {
                    contains: ["self"]
                }), {
                    className: "symbol",
                    begin: "'[A-Za-z_](?!')[\\w']*"
                }, {
                    className: "type",
                    begin: "`[A-Z][\\w']*"
                }, {
                    className: "type",
                    begin: "\\b[A-Z][\\w']*",
                    relevance: 0
                }, {
                    begin: "[a-z_]\\w*'[\\w']*",
                    relevance: 0
                }, e.inherit(e.APOS_STRING_MODE, {
                    className: "string",
                    relevance: 0
                }), e.inherit(e.QUOTE_STRING_MODE, {
                    illegal: null
                }), {
                    className: "number",
                    begin: "\\b(0[xX][a-fA-F0-9_]+[Lln]?|0[oO][0-7_]+[Lln]?|0[bB][01_]+[Lln]?|[0-9][0-9_]*([Lln]|(\\.[0-9_]*)?([eE][-+]?[0-9_]+)?)?)",
                    relevance: 0
                }, {
                    begin: /->/
                }]
            }
        },
        php: function(e) {
            const t = e.regex
              , n = /(?![A-Za-z0-9])(?![$])/
              , r = t.concat(/[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/, n)
              , o = t.concat(/(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/, n)
              , i = {
                scope: "variable",
                match: "\\$+" + r
            }
              , a = {
                scope: "subst",
                variants: [{
                    begin: /\$\w+/
                }, {
                    begin: /\{\$/,
                    end: /\}/
                }]
            }
              , s = e.inherit(e.APOS_STRING_MODE, {
                illegal: null
            })
              , l = "[ \t\n]"
              , c = {
                scope: "string",
                variants: [e.inherit(e.QUOTE_STRING_MODE, {
                    illegal: null,
                    contains: e.QUOTE_STRING_MODE.contains.concat(a)
                }), s, {
                    begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
                    end: /[ \t]*(\w+)\b/,
                    contains: e.QUOTE_STRING_MODE.contains.concat(a),
                    "on:begin": (e,t)=>{
                        t.data._beginMatch = e[1] || e[2]
                    }
                    ,
                    "on:end": (e,t)=>{
                        t.data._beginMatch !== e[1] && t.ignoreMatch()
                    }
                }, e.END_SAME_AS_BEGIN({
                    begin: /<<<[ \t]*'(\w+)'\n/,
                    end: /[ \t]*(\w+)\b/
                })]
            }
              , u = {
                scope: "number",
                variants: [{
                    begin: "\\b0[bB][01]+(?:_[01]+)*\\b"
                }, {
                    begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b"
                }, {
                    begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b"
                }, {
                    begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?"
                }],
                relevance: 0
            }
              , d = ["false", "null", "true"]
              , p = ["__CLASS__", "__DIR__", "__FILE__", "__FUNCTION__", "__COMPILER_HALT_OFFSET__", "__LINE__", "__METHOD__", "__NAMESPACE__", "__TRAIT__", "die", "echo", "exit", "include", "include_once", "print", "require", "require_once", "array", "abstract", "and", "as", "binary", "bool", "boolean", "break", "callable", "case", "catch", "class", "clone", "const", "continue", "declare", "default", "do", "double", "else", "elseif", "empty", "enddeclare", "endfor", "endforeach", "endif", "endswitch", "endwhile", "enum", "eval", "extends", "final", "finally", "float", "for", "foreach", "from", "global", "goto", "if", "implements", "instanceof", "insteadof", "int", "integer", "interface", "isset", "iterable", "list", "match|0", "mixed", "new", "never", "object", "or", "private", "protected", "public", "readonly", "real", "return", "string", "switch", "throw", "trait", "try", "unset", "use", "var", "void", "while", "xor", "yield"]
              , h = ["Error|0", "AppendIterator", "ArgumentCountError", "ArithmeticError", "ArrayIterator", "ArrayObject", "AssertionError", "BadFunctionCallException", "BadMethodCallException", "CachingIterator", "CallbackFilterIterator", "CompileError", "Countable", "DirectoryIterator", "DivisionByZeroError", "DomainException", "EmptyIterator", "ErrorException", "Exception", "FilesystemIterator", "FilterIterator", "GlobIterator", "InfiniteIterator", "InvalidArgumentException", "IteratorIterator", "LengthException", "LimitIterator", "LogicException", "MultipleIterator", "NoRewindIterator", "OutOfBoundsException", "OutOfRangeException", "OuterIterator", "OverflowException", "ParentIterator", "ParseError", "RangeException", "RecursiveArrayIterator", "RecursiveCachingIterator", "RecursiveCallbackFilterIterator", "RecursiveDirectoryIterator", "RecursiveFilterIterator", "RecursiveIterator", "RecursiveIteratorIterator", "RecursiveRegexIterator", "RecursiveTreeIterator", "RegexIterator", "RuntimeException", "SeekableIterator", "SplDoublyLinkedList", "SplFileInfo", "SplFileObject", "SplFixedArray", "SplHeap", "SplMaxHeap", "SplMinHeap", "SplObjectStorage", "SplObserver", "SplPriorityQueue", "SplQueue", "SplStack", "SplSubject", "SplTempFileObject", "TypeError", "UnderflowException", "UnexpectedValueException", "UnhandledMatchError", "ArrayAccess", "BackedEnum", "Closure", "Fiber", "Generator", "Iterator", "IteratorAggregate", "Serializable", "Stringable", "Throwable", "Traversable", "UnitEnum", "WeakReference", "WeakMap", "Directory", "__PHP_Incomplete_Class", "parent", "php_user_filter", "self", "static", "stdClass"]
              , f = {
                keyword: p,
                literal: (e=>{
                    const t = [];
                    return e.forEach((e=>{
                        t.push(e),
                        e.toLowerCase() === e ? t.push(e.toUpperCase()) : t.push(e.toLowerCase())
                    }
                    )),
                    t
                }
                )(d),
                built_in: h
            }
              , m = e=>e.map((e=>e.replace(/\|\d+$/, "")))
              , g = {
                variants: [{
                    match: [/new/, t.concat(l, "+"), t.concat("(?!", m(h).join("\\b|"), "\\b)"), o],
                    scope: {
                        1: "keyword",
                        4: "title.class"
                    }
                }]
            }
              , b = t.concat(r, "\\b(?!\\()")
              , O = {
                variants: [{
                    match: [t.concat(/::/, t.lookahead(/(?!class\b)/)), b],
                    scope: {
                        2: "variable.constant"
                    }
                }, {
                    match: [/::/, /class/],
                    scope: {
                        2: "variable.language"
                    }
                }, {
                    match: [o, t.concat(/::/, t.lookahead(/(?!class\b)/)), b],
                    scope: {
                        1: "title.class",
                        3: "variable.constant"
                    }
                }, {
                    match: [o, t.concat("::", t.lookahead(/(?!class\b)/))],
                    scope: {
                        1: "title.class"
                    }
                }, {
                    match: [o, /::/, /class/],
                    scope: {
                        1: "title.class",
                        3: "variable.language"
                    }
                }]
            }
              , v = {
                scope: "attr",
                match: t.concat(r, t.lookahead(":"), t.lookahead(/(?!::)/))
            }
              , y = {
                relevance: 0,
                begin: /\(/,
                end: /\)/,
                keywords: f,
                contains: [v, i, O, e.C_BLOCK_COMMENT_MODE, c, u, g]
            }
              , w = {
                relevance: 0,
                match: [/\b/, t.concat("(?!fn\\b|function\\b|", m(p).join("\\b|"), "|", m(h).join("\\b|"), "\\b)"), r, t.concat(l, "*"), t.lookahead(/(?=\()/)],
                scope: {
                    3: "title.function.invoke"
                },
                contains: [y]
            };
            y.contains.push(w);
            const _ = [v, O, e.C_BLOCK_COMMENT_MODE, c, u, g];
            return {
                case_insensitive: !1,
                keywords: f,
                contains: [{
                    begin: t.concat(/#\[\s*/, o),
                    beginScope: "meta",
                    end: /]/,
                    endScope: "meta",
                    keywords: {
                        literal: d,
                        keyword: ["new", "array"]
                    },
                    contains: [{
                        begin: /\[/,
                        end: /]/,
                        keywords: {
                            literal: d,
                            keyword: ["new", "array"]
                        },
                        contains: ["self", ..._]
                    }, ..._, {
                        scope: "meta",
                        match: o
                    }]
                }, e.HASH_COMMENT_MODE, e.COMMENT("//", "$"), e.COMMENT("/\\*", "\\*/", {
                    contains: [{
                        scope: "doctag",
                        match: "@[A-Za-z]+"
                    }]
                }), {
                    match: /__halt_compiler\(\);/,
                    keywords: "__halt_compiler",
                    starts: {
                        scope: "comment",
                        end: e.MATCH_NOTHING_RE,
                        contains: [{
                            match: /\?>/,
                            scope: "meta",
                            endsParent: !0
                        }]
                    }
                }, {
                    scope: "meta",
                    variants: [{
                        begin: /<\?php/,
                        relevance: 10
                    }, {
                        begin: /<\?=/
                    }, {
                        begin: /<\?/,
                        relevance: .1
                    }, {
                        begin: /\?>/
                    }]
                }, {
                    scope: "variable.language",
                    match: /\$this\b/
                }, i, w, O, {
                    match: [/const/, /\s/, r],
                    scope: {
                        1: "keyword",
                        3: "variable.constant"
                    }
                }, g, {
                    scope: "function",
                    relevance: 0,
                    beginKeywords: "fn function",
                    end: /[;{]/,
                    excludeEnd: !0,
                    illegal: "[$%\\[]",
                    contains: [{
                        beginKeywords: "use"
                    }, e.UNDERSCORE_TITLE_MODE, {
                        begin: "=>",
                        endsParent: !0
                    }, {
                        scope: "params",
                        begin: "\\(",
                        end: "\\)",
                        excludeBegin: !0,
                        excludeEnd: !0,
                        keywords: f,
                        contains: ["self", i, O, e.C_BLOCK_COMMENT_MODE, c, u]
                    }]
                }, {
                    scope: "class",
                    variants: [{
                        beginKeywords: "enum",
                        illegal: /[($"]/
                    }, {
                        beginKeywords: "class interface trait",
                        illegal: /[:($"]/
                    }],
                    relevance: 0,
                    end: /\{/,
                    excludeEnd: !0,
                    contains: [{
                        beginKeywords: "extends implements"
                    }, e.UNDERSCORE_TITLE_MODE]
                }, {
                    beginKeywords: "namespace",
                    relevance: 0,
                    end: ";",
                    illegal: /[.']/,
                    contains: [e.inherit(e.UNDERSCORE_TITLE_MODE, {
                        scope: "title.class"
                    })]
                }, {
                    beginKeywords: "use",
                    relevance: 0,
                    end: ";",
                    contains: [{
                        match: /\b(as|const|function)\b/,
                        scope: "keyword"
                    }, e.UNDERSCORE_TITLE_MODE]
                }, c, u]
            }
        },
        plaintext: function(e) {
            return {
                name: "Plain text",
                aliases: ["text", "txt"],
                disableAutodetect: !0
            }
        },
        powershell: function(e) {
            const t = {
                $pattern: /-?[A-z\.\-]+\b/,
                keyword: "if else foreach return do while until elseif begin for trap data dynamicparam end break throw param continue finally in switch exit filter try process catch hidden static parameter",
                built_in: "ac asnp cat cd CFS chdir clc clear clhy cli clp cls clv cnsn compare copy cp cpi cpp curl cvpa dbp del diff dir dnsn ebp echo|0 epal epcsv epsn erase etsn exsn fc fhx fl ft fw gal gbp gc gcb gci gcm gcs gdr gerr ghy gi gin gjb gl gm gmo gp gps gpv group gsn gsnp gsv gtz gu gv gwmi h history icm iex ihy ii ipal ipcsv ipmo ipsn irm ise iwmi iwr kill lp ls man md measure mi mount move mp mv nal ndr ni nmo npssc nsn nv ogv oh popd ps pushd pwd r rbp rcjb rcsn rd rdr ren ri rjb rm rmdir rmo rni rnp rp rsn rsnp rujb rv rvpa rwmi sajb sal saps sasv sbp sc scb select set shcm si sl sleep sls sort sp spjb spps spsv start stz sujb sv swmi tee trcm type wget where wjb write"
            }
              , n = {
                begin: "`[\\s\\S]",
                relevance: 0
            }
              , r = {
                className: "variable",
                variants: [{
                    begin: /\$\B/
                }, {
                    className: "keyword",
                    begin: /\$this/
                }, {
                    begin: /\$[\w\d][\w\d_:]*/
                }]
            }
              , o = {
                className: "string",
                variants: [{
                    begin: /"/,
                    end: /"/
                }, {
                    begin: /@"/,
                    end: /^"@/
                }],
                contains: [n, r, {
                    className: "variable",
                    begin: /\$[A-z]/,
                    end: /[^A-z]/
                }]
            }
              , i = {
                className: "string",
                variants: [{
                    begin: /'/,
                    end: /'/
                }, {
                    begin: /@'/,
                    end: /^'@/
                }]
            }
              , a = e.inherit(e.COMMENT(null, null), {
                variants: [{
                    begin: /#/,
                    end: /$/
                }, {
                    begin: /<#/,
                    end: /#>/
                }],
                contains: [{
                    className: "doctag",
                    variants: [{
                        begin: /\.(synopsis|description|example|inputs|outputs|notes|link|component|role|functionality)/
                    }, {
                        begin: /\.(parameter|forwardhelptargetname|forwardhelpcategory|remotehelprunspace|externalhelp)\s+\S+/
                    }]
                }]
            })
              , s = {
                className: "built_in",
                variants: [{
                    begin: "(".concat("Add|Clear|Close|Copy|Enter|Exit|Find|Format|Get|Hide|Join|Lock|Move|New|Open|Optimize|Pop|Push|Redo|Remove|Rename|Reset|Resize|Search|Select|Set|Show|Skip|Split|Step|Switch|Undo|Unlock|Watch|Backup|Checkpoint|Compare|Compress|Convert|ConvertFrom|ConvertTo|Dismount|Edit|Expand|Export|Group|Import|Initialize|Limit|Merge|Mount|Out|Publish|Restore|Save|Sync|Unpublish|Update|Approve|Assert|Build|Complete|Confirm|Deny|Deploy|Disable|Enable|Install|Invoke|Register|Request|Restart|Resume|Start|Stop|Submit|Suspend|Uninstall|Unregister|Wait|Debug|Measure|Ping|Repair|Resolve|Test|Trace|Connect|Disconnect|Read|Receive|Send|Write|Block|Grant|Protect|Revoke|Unblock|Unprotect|Use|ForEach|Sort|Tee|Where", ")+(-)[\\w\\d]+")
                }]
            }
              , l = {
                className: "class",
                beginKeywords: "class enum",
                end: /\s*[{]/,
                excludeEnd: !0,
                relevance: 0,
                contains: [e.TITLE_MODE]
            }
              , c = {
                className: "function",
                begin: /function\s+/,
                end: /\s*\{|$/,
                excludeEnd: !0,
                returnBegin: !0,
                relevance: 0,
                contains: [{
                    begin: "function",
                    relevance: 0,
                    className: "keyword"
                }, {
                    className: "title",
                    begin: /\w[\w\d]*((-)[\w\d]+)*/,
                    relevance: 0
                }, {
                    begin: /\(/,
                    end: /\)/,
                    className: "params",
                    relevance: 0,
                    contains: [r]
                }]
            }
              , u = {
                begin: /using\s/,
                end: /$/,
                returnBegin: !0,
                contains: [o, i, {
                    className: "keyword",
                    begin: /(using|assembly|command|module|namespace|type)/
                }]
            }
              , d = {
                variants: [{
                    className: "operator",
                    begin: "(".concat("-and|-as|-band|-bnot|-bor|-bxor|-casesensitive|-ccontains|-ceq|-cge|-cgt|-cle|-clike|-clt|-cmatch|-cne|-cnotcontains|-cnotlike|-cnotmatch|-contains|-creplace|-csplit|-eq|-exact|-f|-file|-ge|-gt|-icontains|-ieq|-ige|-igt|-ile|-ilike|-ilt|-imatch|-in|-ine|-inotcontains|-inotlike|-inotmatch|-ireplace|-is|-isnot|-isplit|-join|-le|-like|-lt|-match|-ne|-not|-notcontains|-notin|-notlike|-notmatch|-or|-regex|-replace|-shl|-shr|-split|-wildcard|-xor", ")\\b")
                }, {
                    className: "literal",
                    begin: /(-){1,2}[\w\d-]+/,
                    relevance: 0
                }]
            }
              , p = {
                className: "function",
                begin: /\[.*\]\s*[\w]+[ ]??\(/,
                end: /$/,
                returnBegin: !0,
                relevance: 0,
                contains: [{
                    className: "keyword",
                    begin: "(".concat(t.keyword.toString().replace(/\s/g, "|"), ")\\b"),
                    endsParent: !0,
                    relevance: 0
                }, e.inherit(e.TITLE_MODE, {
                    endsParent: !0
                })]
            }
              , h = [p, a, n, e.NUMBER_MODE, o, i, s, r, {
                className: "literal",
                begin: /\$(null|true|false)\b/
            }, {
                className: "selector-tag",
                begin: /@\B/,
                relevance: 0
            }]
              , f = {
                begin: /\[/,
                end: /\]/,
                excludeBegin: !0,
                excludeEnd: !0,
                relevance: 0,
                contains: [].concat("self", h, {
                    begin: "(" + ["string", "char", "byte", "int", "long", "bool", "decimal", "single", "double", "DateTime", "xml", "array", "hashtable", "void"].join("|") + ")",
                    className: "built_in",
                    relevance: 0
                }, {
                    className: "type",
                    begin: /[\.\w\d]+/,
                    relevance: 0
                })
            };
            return p.contains.unshift(f),
            {
                name: "PowerShell",
                aliases: ["pwsh", "ps", "ps1"],
                case_insensitive: !0,
                keywords: t,
                contains: h.concat(l, c, u, d, f)
            }
        },
        python: function(e) {
            const t = e.regex
              , n = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*","u")
              , r = ["and", "as", "assert", "async", "await", "break", "case", "class", "continue", "def", "del", "elif", "else", "except", "finally", "for", "from", "global", "if", "import", "in", "is", "lambda", "match", "nonlocal|10", "not", "or", "pass", "raise", "return", "try", "while", "with", "yield"]
              , o = {
                $pattern: /[A-Za-z]\w+|__\w+__/,
                keyword: r,
                built_in: ["__import__", "abs", "all", "any", "ascii", "bin", "bool", "breakpoint", "bytearray", "bytes", "callable", "chr", "classmethod", "compile", "complex", "delattr", "dict", "dir", "divmod", "enumerate", "eval", "exec", "filter", "float", "format", "frozenset", "getattr", "globals", "hasattr", "hash", "help", "hex", "id", "input", "int", "isinstance", "issubclass", "iter", "len", "list", "locals", "map", "max", "memoryview", "min", "next", "object", "oct", "open", "ord", "pow", "print", "property", "range", "repr", "reversed", "round", "set", "setattr", "slice", "sorted", "staticmethod", "str", "sum", "super", "tuple", "type", "vars", "zip"],
                literal: ["__debug__", "Ellipsis", "False", "None", "NotImplemented", "True"],
                type: ["Any", "Callable", "Coroutine", "Dict", "List", "Literal", "Generic", "Optional", "Sequence", "Set", "Tuple", "Type", "Union"]
            }
              , i = {
                className: "meta",
                begin: /^(>>>|\.\.\.) /
            }
              , a = {
                className: "subst",
                begin: /\{/,
                end: /\}/,
                keywords: o,
                illegal: /#/
            }
              , s = {
                begin: /\{\{/,
                relevance: 0
            }
              , l = {
                className: "string",
                contains: [e.BACKSLASH_ESCAPE],
                variants: [{
                    begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
                    end: /'''/,
                    contains: [e.BACKSLASH_ESCAPE, i],
                    relevance: 10
                }, {
                    begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
                    end: /"""/,
                    contains: [e.BACKSLASH_ESCAPE, i],
                    relevance: 10
                }, {
                    begin: /([fF][rR]|[rR][fF]|[fF])'''/,
                    end: /'''/,
                    contains: [e.BACKSLASH_ESCAPE, i, s, a]
                }, {
                    begin: /([fF][rR]|[rR][fF]|[fF])"""/,
                    end: /"""/,
                    contains: [e.BACKSLASH_ESCAPE, i, s, a]
                }, {
                    begin: /([uU]|[rR])'/,
                    end: /'/,
                    relevance: 10
                }, {
                    begin: /([uU]|[rR])"/,
                    end: /"/,
                    relevance: 10
                }, {
                    begin: /([bB]|[bB][rR]|[rR][bB])'/,
                    end: /'/
                }, {
                    begin: /([bB]|[bB][rR]|[rR][bB])"/,
                    end: /"/
                }, {
                    begin: /([fF][rR]|[rR][fF]|[fF])'/,
                    end: /'/,
                    contains: [e.BACKSLASH_ESCAPE, s, a]
                }, {
                    begin: /([fF][rR]|[rR][fF]|[fF])"/,
                    end: /"/,
                    contains: [e.BACKSLASH_ESCAPE, s, a]
                }, e.APOS_STRING_MODE, e.QUOTE_STRING_MODE]
            }
              , c = "[0-9](_?[0-9])*"
              , u = `(\\b(${c}))?\\.(${c})|\\b(${c})\\.`
              , d = `\\b|${r.join("|")}`
              , p = {
                className: "number",
                relevance: 0,
                variants: [{
                    begin: `(\\b(${c})|(${u}))[eE][+-]?(${c})[jJ]?(?=${d})`
                }, {
                    begin: `(${u})[jJ]?`
                }, {
                    begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${d})`
                }, {
                    begin: `\\b0[bB](_?[01])+[lL]?(?=${d})`
                }, {
                    begin: `\\b0[oO](_?[0-7])+[lL]?(?=${d})`
                }, {
                    begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${d})`
                }, {
                    begin: `\\b(${c})[jJ](?=${d})`
                }]
            }
              , h = {
                className: "comment",
                begin: t.lookahead(/# type:/),
                end: /$/,
                keywords: o,
                contains: [{
                    begin: /# type:/
                }, {
                    begin: /#/,
                    end: /\b\B/,
                    endsWithParent: !0
                }]
            }
              , f = {
                className: "params",
                variants: [{
                    className: "",
                    begin: /\(\s*\)/,
                    skip: !0
                }, {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: o,
                    contains: ["self", i, p, l, e.HASH_COMMENT_MODE]
                }]
            };
            return a.contains = [l, p, i],
            {
                name: "Python",
                aliases: ["py", "gyp", "ipython"],
                unicodeRegex: !0,
                keywords: o,
                illegal: /(<\/|\?)|=>/,
                contains: [i, p, {
                    begin: /\bself\b/
                }, {
                    beginKeywords: "if",
                    relevance: 0
                }, l, h, e.HASH_COMMENT_MODE, {
                    match: [/\bdef/, /\s+/, n],
                    scope: {
                        1: "keyword",
                        3: "title.function"
                    },
                    contains: [f]
                }, {
                    variants: [{
                        match: [/\bclass/, /\s+/, n, /\s*/, /\(\s*/, n, /\s*\)/]
                    }, {
                        match: [/\bclass/, /\s+/, n]
                    }],
                    scope: {
                        1: "keyword",
                        3: "title.class",
                        6: "title.class.inherited"
                    }
                }, {
                    className: "meta",
                    begin: /^[\t ]*@/,
                    end: /(?=#)|$/,
                    contains: [p, f, l]
                }]
            }
        },
        r: function(e) {
            const t = e.regex
              , n = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/
              , r = t.either(/0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/, /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/, /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/)
              , o = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/
              , i = t.either(/[()]/, /[{}]/, /\[\[/, /[[\]]/, /\\/, /,/);
            return {
                name: "R",
                keywords: {
                    $pattern: n,
                    keyword: "function if in break next repeat else for while",
                    literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
                    built_in: "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
                },
                contains: [e.COMMENT(/#'/, /$/, {
                    contains: [{
                        scope: "doctag",
                        match: /@examples/,
                        starts: {
                            end: t.lookahead(t.either(/\n^#'\s*(?=@[a-zA-Z]+)/, /\n^(?!#')/)),
                            endsParent: !0
                        }
                    }, {
                        scope: "doctag",
                        begin: "@param",
                        end: /$/,
                        contains: [{
                            scope: "variable",
                            variants: [{
                                match: n
                            }, {
                                match: /`(?:\\.|[^`\\])+`/
                            }],
                            endsParent: !0
                        }]
                    }, {
                        scope: "doctag",
                        match: /@[a-zA-Z]+/
                    }, {
                        scope: "keyword",
                        match: /\\[a-zA-Z]+/
                    }]
                }), e.HASH_COMMENT_MODE, {
                    scope: "string",
                    contains: [e.BACKSLASH_ESCAPE],
                    variants: [e.END_SAME_AS_BEGIN({
                        begin: /[rR]"(-*)\(/,
                        end: /\)(-*)"/
                    }), e.END_SAME_AS_BEGIN({
                        begin: /[rR]"(-*)\{/,
                        end: /\}(-*)"/
                    }), e.END_SAME_AS_BEGIN({
                        begin: /[rR]"(-*)\[/,
                        end: /\](-*)"/
                    }), e.END_SAME_AS_BEGIN({
                        begin: /[rR]'(-*)\(/,
                        end: /\)(-*)'/
                    }), e.END_SAME_AS_BEGIN({
                        begin: /[rR]'(-*)\{/,
                        end: /\}(-*)'/
                    }), e.END_SAME_AS_BEGIN({
                        begin: /[rR]'(-*)\[/,
                        end: /\](-*)'/
                    }), {
                        begin: '"',
                        end: '"',
                        relevance: 0
                    }, {
                        begin: "'",
                        end: "'",
                        relevance: 0
                    }]
                }, {
                    relevance: 0,
                    variants: [{
                        scope: {
                            1: "operator",
                            2: "number"
                        },
                        match: [o, r]
                    }, {
                        scope: {
                            1: "operator",
                            2: "number"
                        },
                        match: [/%[^%]*%/, r]
                    }, {
                        scope: {
                            1: "punctuation",
                            2: "number"
                        },
                        match: [i, r]
                    }, {
                        scope: {
                            2: "number"
                        },
                        match: [/[^a-zA-Z0-9._]|^/, r]
                    }]
                }, {
                    scope: {
                        3: "operator"
                    },
                    match: [n, /\s+/, /<-/, /\s+/]
                }, {
                    scope: "operator",
                    relevance: 0,
                    variants: [{
                        match: o
                    }, {
                        match: /%[^%]*%/
                    }]
                }, {
                    scope: "punctuation",
                    relevance: 0,
                    match: i
                }, {
                    begin: "`",
                    end: "`",
                    contains: [{
                        begin: /\\./
                    }]
                }]
            }
        },
        ruby: function(e) {
            const t = e.regex
              , n = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)"
              , r = t.either(/\b([A-Z]+[a-z0-9]+)+/, /\b([A-Z]+[a-z0-9]+)+[A-Z]+/)
              , o = t.concat(r, /(::\w+)*/)
              , i = {
                "variable.constant": ["__FILE__", "__LINE__", "__ENCODING__"],
                "variable.language": ["self", "super"],
                keyword: ["alias", "and", "begin", "BEGIN", "break", "case", "class", "defined", "do", "else", "elsif", "end", "END", "ensure", "for", "if", "in", "module", "next", "not", "or", "redo", "require", "rescue", "retry", "return", "then", "undef", "unless", "until", "when", "while", "yield", "include", "extend", "prepend", "public", "private", "protected", "raise", "throw"],
                built_in: ["proc", "lambda", "attr_accessor", "attr_reader", "attr_writer", "define_method", "private_constant", "module_function"],
                literal: ["true", "false", "nil"]
            }
              , a = {
                className: "doctag",
                begin: "@[A-Za-z]+"
            }
              , s = {
                begin: "#<",
                end: ">"
            }
              , l = [e.COMMENT("#", "$", {
                contains: [a]
            }), e.COMMENT("^=begin", "^=end", {
                contains: [a],
                relevance: 10
            }), e.COMMENT("^__END__", e.MATCH_NOTHING_RE)]
              , c = {
                className: "subst",
                begin: /#\{/,
                end: /\}/,
                keywords: i
            }
              , u = {
                className: "string",
                contains: [e.BACKSLASH_ESCAPE, c],
                variants: [{
                    begin: /'/,
                    end: /'/
                }, {
                    begin: /"/,
                    end: /"/
                }, {
                    begin: /`/,
                    end: /`/
                }, {
                    begin: /%[qQwWx]?\(/,
                    end: /\)/
                }, {
                    begin: /%[qQwWx]?\[/,
                    end: /\]/
                }, {
                    begin: /%[qQwWx]?\{/,
                    end: /\}/
                }, {
                    begin: /%[qQwWx]?</,
                    end: />/
                }, {
                    begin: /%[qQwWx]?\//,
                    end: /\//
                }, {
                    begin: /%[qQwWx]?%/,
                    end: /%/
                }, {
                    begin: /%[qQwWx]?-/,
                    end: /-/
                }, {
                    begin: /%[qQwWx]?\|/,
                    end: /\|/
                }, {
                    begin: /\B\?(\\\d{1,3})/
                }, {
                    begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/
                }, {
                    begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/
                }, {
                    begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/
                }, {
                    begin: /\B\?\\(c|C-)[\x20-\x7e]/
                }, {
                    begin: /\B\?\\?\S/
                }, {
                    begin: t.concat(/<<[-~]?'?/, t.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)),
                    contains: [e.END_SAME_AS_BEGIN({
                        begin: /(\w+)/,
                        end: /(\w+)/,
                        contains: [e.BACKSLASH_ESCAPE, c]
                    })]
                }]
            }
              , d = "[0-9](_?[0-9])*"
              , p = {
                className: "number",
                relevance: 0,
                variants: [{
                    begin: `\\b([1-9](_?[0-9])*|0)(\\.(${d}))?([eE][+-]?(${d})|r)?i?\\b`
                }, {
                    begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b"
                }, {
                    begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b"
                }, {
                    begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b"
                }, {
                    begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b"
                }, {
                    begin: "\\b0(_?[0-7])+r?i?\\b"
                }]
            }
              , h = {
                variants: [{
                    match: /\(\)/
                }, {
                    className: "params",
                    begin: /\(/,
                    end: /(?=\))/,
                    excludeBegin: !0,
                    endsParent: !0,
                    keywords: i
                }]
            }
              , f = [u, {
                variants: [{
                    match: [/class\s+/, o, /\s+<\s+/, o]
                }, {
                    match: [/\b(class|module)\s+/, o]
                }],
                scope: {
                    2: "title.class",
                    4: "title.class.inherited"
                },
                keywords: i
            }, {
                match: [/(include|extend)\s+/, o],
                scope: {
                    2: "title.class"
                },
                keywords: i
            }, {
                relevance: 0,
                match: [o, /\.new[. (]/],
                scope: {
                    1: "title.class"
                }
            }, {
                relevance: 0,
                match: /\b[A-Z][A-Z_0-9]+\b/,
                className: "variable.constant"
            }, {
                relevance: 0,
                match: r,
                scope: "title.class"
            }, {
                match: [/def/, /\s+/, n],
                scope: {
                    1: "keyword",
                    3: "title.function"
                },
                contains: [h]
            }, {
                begin: e.IDENT_RE + "::"
            }, {
                className: "symbol",
                begin: e.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
                relevance: 0
            }, {
                className: "symbol",
                begin: ":(?!\\s)",
                contains: [u, {
                    begin: n
                }],
                relevance: 0
            }, p, {
                className: "variable",
                begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
            }, {
                className: "params",
                begin: /\|/,
                end: /\|/,
                excludeBegin: !0,
                excludeEnd: !0,
                relevance: 0,
                keywords: i
            }, {
                begin: "(" + e.RE_STARTERS_RE + "|unless)\\s*",
                keywords: "unless",
                contains: [{
                    className: "regexp",
                    contains: [e.BACKSLASH_ESCAPE, c],
                    illegal: /\n/,
                    variants: [{
                        begin: "/",
                        end: "/[a-z]*"
                    }, {
                        begin: /%r\{/,
                        end: /\}[a-z]*/
                    }, {
                        begin: "%r\\(",
                        end: "\\)[a-z]*"
                    }, {
                        begin: "%r!",
                        end: "![a-z]*"
                    }, {
                        begin: "%r\\[",
                        end: "\\][a-z]*"
                    }]
                }].concat(s, l),
                relevance: 0
            }].concat(s, l);
            c.contains = f,
            h.contains = f;
            const m = [{
                begin: /^\s*=>/,
                starts: {
                    end: "$",
                    contains: f
                }
            }, {
                className: "meta.prompt",
                begin: "^([>?]>|[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]|(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>)(?=[ ])",
                starts: {
                    end: "$",
                    keywords: i,
                    contains: f
                }
            }];
            return l.unshift(s),
            {
                name: "Ruby",
                aliases: ["rb", "gemspec", "podspec", "thor", "irb"],
                keywords: i,
                illegal: /\/\*/,
                contains: [e.SHEBANG({
                    binary: "ruby"
                })].concat(m).concat(l).concat(f)
            }
        },
        rust: function(e) {
            const t = e.regex
              , n = {
                className: "title.function.invoke",
                relevance: 0,
                begin: t.concat(/\b/, /(?!let|for|while|if|else|match\b)/, e.IDENT_RE, t.lookahead(/\s*\(/))
            }
              , r = "([ui](8|16|32|64|128|size)|f(32|64))?"
              , o = ["drop ", "Copy", "Send", "Sized", "Sync", "Drop", "Fn", "FnMut", "FnOnce", "ToOwned", "Clone", "Debug", "PartialEq", "PartialOrd", "Eq", "Ord", "AsRef", "AsMut", "Into", "From", "Default", "Iterator", "Extend", "IntoIterator", "DoubleEndedIterator", "ExactSizeIterator", "SliceConcatExt", "ToString", "assert!", "assert_eq!", "bitflags!", "bytes!", "cfg!", "col!", "concat!", "concat_idents!", "debug_assert!", "debug_assert_eq!", "env!", "eprintln!", "panic!", "file!", "format!", "format_args!", "include_bytes!", "include_str!", "line!", "local_data_key!", "module_path!", "option_env!", "print!", "println!", "select!", "stringify!", "try!", "unimplemented!", "unreachable!", "vec!", "write!", "writeln!", "macro_rules!", "assert_ne!", "debug_assert_ne!"]
              , i = ["i8", "i16", "i32", "i64", "i128", "isize", "u8", "u16", "u32", "u64", "u128", "usize", "f32", "f64", "str", "char", "bool", "Box", "Option", "Result", "String", "Vec"];
            return {
                name: "Rust",
                aliases: ["rs"],
                keywords: {
                    $pattern: e.IDENT_RE + "!?",
                    type: i,
                    keyword: ["abstract", "as", "async", "await", "become", "box", "break", "const", "continue", "crate", "do", "dyn", "else", "enum", "extern", "false", "final", "fn", "for", "if", "impl", "in", "let", "loop", "macro", "match", "mod", "move", "mut", "override", "priv", "pub", "ref", "return", "self", "Self", "static", "struct", "super", "trait", "true", "try", "type", "typeof", "unsafe", "unsized", "use", "virtual", "where", "while", "yield"],
                    literal: ["true", "false", "Some", "None", "Ok", "Err"],
                    built_in: o
                },
                illegal: "</",
                contains: [e.C_LINE_COMMENT_MODE, e.COMMENT("/\\*", "\\*/", {
                    contains: ["self"]
                }), e.inherit(e.QUOTE_STRING_MODE, {
                    begin: /b?"/,
                    illegal: null
                }), {
                    className: "string",
                    variants: [{
                        begin: /b?r(#*)"(.|\n)*?"\1(?!#)/
                    }, {
                        begin: /b?'\\?(x\w{2}|u\w{4}|U\w{8}|.)'/
                    }]
                }, {
                    className: "symbol",
                    begin: /'[a-zA-Z_][a-zA-Z0-9_]*/
                }, {
                    className: "number",
                    variants: [{
                        begin: "\\b0b([01_]+)" + r
                    }, {
                        begin: "\\b0o([0-7_]+)" + r
                    }, {
                        begin: "\\b0x([A-Fa-f0-9_]+)" + r
                    }, {
                        begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + r
                    }],
                    relevance: 0
                }, {
                    begin: [/fn/, /\s+/, e.UNDERSCORE_IDENT_RE],
                    className: {
                        1: "keyword",
                        3: "title.function"
                    }
                }, {
                    className: "meta",
                    begin: "#!?\\[",
                    end: "\\]",
                    contains: [{
                        className: "string",
                        begin: /"/,
                        end: /"/
                    }]
                }, {
                    begin: [/let/, /\s+/, /(?:mut\s+)?/, e.UNDERSCORE_IDENT_RE],
                    className: {
                        1: "keyword",
                        3: "keyword",
                        4: "variable"
                    }
                }, {
                    begin: [/for/, /\s+/, e.UNDERSCORE_IDENT_RE, /\s+/, /in/],
                    className: {
                        1: "keyword",
                        3: "variable",
                        5: "keyword"
                    }
                }, {
                    begin: [/type/, /\s+/, e.UNDERSCORE_IDENT_RE],
                    className: {
                        1: "keyword",
                        3: "title.class"
                    }
                }, {
                    begin: [/(?:trait|enum|struct|union|impl|for)/, /\s+/, e.UNDERSCORE_IDENT_RE],
                    className: {
                        1: "keyword",
                        3: "title.class"
                    }
                }, {
                    begin: e.IDENT_RE + "::",
                    keywords: {
                        keyword: "Self",
                        built_in: o,
                        type: i
                    }
                }, {
                    className: "punctuation",
                    begin: "->"
                }, n]
            }
        },
        scss: function(e) {
            const t = (e=>({
                IMPORTANT: {
                    scope: "meta",
                    begin: "!important"
                },
                BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
                HEXCOLOR: {
                    scope: "number",
                    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
                },
                FUNCTION_DISPATCH: {
                    className: "built_in",
                    begin: /[\w-]+(?=\()/
                },
                ATTRIBUTE_SELECTOR_MODE: {
                    scope: "selector-attr",
                    begin: /\[/,
                    end: /\]/,
                    illegal: "$",
                    contains: [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE]
                },
                CSS_NUMBER_MODE: {
                    scope: "number",
                    begin: e.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
                    relevance: 0
                },
                CSS_VARIABLE: {
                    className: "attr",
                    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
                }
            }))(e)
              , n = ed
              , r = Ju
              , o = "@[a-z-]+"
              , i = {
                className: "variable",
                begin: "(\\$[a-zA-Z-][a-zA-Z0-9_-]*)\\b",
                relevance: 0
            };
            return {
                name: "SCSS",
                case_insensitive: !0,
                illegal: "[=/|']",
                contains: [e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE, t.CSS_NUMBER_MODE, {
                    className: "selector-id",
                    begin: "#[A-Za-z0-9_-]+",
                    relevance: 0
                }, {
                    className: "selector-class",
                    begin: "\\.[A-Za-z0-9_-]+",
                    relevance: 0
                }, t.ATTRIBUTE_SELECTOR_MODE, {
                    className: "selector-tag",
                    begin: "\\b(" + Yu.join("|") + ")\\b",
                    relevance: 0
                }, {
                    className: "selector-pseudo",
                    begin: ":(" + r.join("|") + ")"
                }, {
                    className: "selector-pseudo",
                    begin: ":(:)?(" + n.join("|") + ")"
                }, i, {
                    begin: /\(/,
                    end: /\)/,
                    contains: [t.CSS_NUMBER_MODE]
                }, t.CSS_VARIABLE, {
                    className: "attribute",
                    begin: "\\b(" + td.join("|") + ")\\b"
                }, {
                    begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b"
                }, {
                    begin: /:/,
                    end: /[;}{]/,
                    relevance: 0,
                    contains: [t.BLOCK_COMMENT, i, t.HEXCOLOR, t.CSS_NUMBER_MODE, e.QUOTE_STRING_MODE, e.APOS_STRING_MODE, t.IMPORTANT, t.FUNCTION_DISPATCH]
                }, {
                    begin: "@(page|font-face)",
                    keywords: {
                        $pattern: o,
                        keyword: "@page @font-face"
                    }
                }, {
                    begin: "@",
                    end: "[{;]",
                    returnBegin: !0,
                    keywords: {
                        $pattern: /[a-z-]+/,
                        keyword: "and or not only",
                        attribute: Ku.join(" ")
                    },
                    contains: [{
                        begin: o,
                        className: "keyword"
                    }, {
                        begin: /[a-z-]+(?=:)/,
                        className: "attribute"
                    }, i, e.QUOTE_STRING_MODE, e.APOS_STRING_MODE, t.HEXCOLOR, t.CSS_NUMBER_MODE]
                }, t.FUNCTION_DISPATCH]
            }
        },
        shell: function(e) {
            return {
                name: "Shell Session",
                aliases: ["console", "shellsession"],
                contains: [{
                    className: "meta.prompt",
                    begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
                    starts: {
                        end: /[^\\](?=\s*$)/,
                        subLanguage: "bash"
                    }
                }]
            }
        },
        sql: function(e) {
            const t = e.regex
              , n = e.COMMENT("--", "$")
              , r = ["true", "false", "unknown"]
              , o = ["bigint", "binary", "blob", "boolean", "char", "character", "clob", "date", "dec", "decfloat", "decimal", "float", "int", "integer", "interval", "nchar", "nclob", "national", "numeric", "real", "row", "smallint", "time", "timestamp", "varchar", "varying", "varbinary"]
              , i = ["abs", "acos", "array_agg", "asin", "atan", "avg", "cast", "ceil", "ceiling", "coalesce", "corr", "cos", "cosh", "count", "covar_pop", "covar_samp", "cume_dist", "dense_rank", "deref", "element", "exp", "extract", "first_value", "floor", "json_array", "json_arrayagg", "json_exists", "json_object", "json_objectagg", "json_query", "json_table", "json_table_primitive", "json_value", "lag", "last_value", "lead", "listagg", "ln", "log", "log10", "lower", "max", "min", "mod", "nth_value", "ntile", "nullif", "percent_rank", "percentile_cont", "percentile_disc", "position", "position_regex", "power", "rank", "regr_avgx", "regr_avgy", "regr_count", "regr_intercept", "regr_r2", "regr_slope", "regr_sxx", "regr_sxy", "regr_syy", "row_number", "sin", "sinh", "sqrt", "stddev_pop", "stddev_samp", "substring", "substring_regex", "sum", "tan", "tanh", "translate", "translate_regex", "treat", "trim", "trim_array", "unnest", "upper", "value_of", "var_pop", "var_samp", "width_bucket"]
              , a = ["create table", "insert into", "primary key", "foreign key", "not null", "alter table", "add constraint", "grouping sets", "on overflow", "character set", "respect nulls", "ignore nulls", "nulls first", "nulls last", "depth first", "breadth first"]
              , s = i
              , l = ["abs", "acos", "all", "allocate", "alter", "and", "any", "are", "array", "array_agg", "array_max_cardinality", "as", "asensitive", "asin", "asymmetric", "at", "atan", "atomic", "authorization", "avg", "begin", "begin_frame", "begin_partition", "between", "bigint", "binary", "blob", "boolean", "both", "by", "call", "called", "cardinality", "cascaded", "case", "cast", "ceil", "ceiling", "char", "char_length", "character", "character_length", "check", "classifier", "clob", "close", "coalesce", "collate", "collect", "column", "commit", "condition", "connect", "constraint", "contains", "convert", "copy", "corr", "corresponding", "cos", "cosh", "count", "covar_pop", "covar_samp", "create", "cross", "cube", "cume_dist", "current", "current_catalog", "current_date", "current_default_transform_group", "current_path", "current_role", "current_row", "current_schema", "current_time", "current_timestamp", "current_path", "current_role", "current_transform_group_for_type", "current_user", "cursor", "cycle", "date", "day", "deallocate", "dec", "decimal", "decfloat", "declare", "default", "define", "delete", "dense_rank", "deref", "describe", "deterministic", "disconnect", "distinct", "double", "drop", "dynamic", "each", "element", "else", "empty", "end", "end_frame", "end_partition", "end-exec", "equals", "escape", "every", "except", "exec", "execute", "exists", "exp", "external", "extract", "false", "fetch", "filter", "first_value", "float", "floor", "for", "foreign", "frame_row", "free", "from", "full", "function", "fusion", "get", "global", "grant", "group", "grouping", "groups", "having", "hold", "hour", "identity", "in", "indicator", "initial", "inner", "inout", "insensitive", "insert", "int", "integer", "intersect", "intersection", "interval", "into", "is", "join", "json_array", "json_arrayagg", "json_exists", "json_object", "json_objectagg", "json_query", "json_table", "json_table_primitive", "json_value", "lag", "language", "large", "last_value", "lateral", "lead", "leading", "left", "like", "like_regex", "listagg", "ln", "local", "localtime", "localtimestamp", "log", "log10", "lower", "match", "match_number", "match_recognize", "matches", "max", "member", "merge", "method", "min", "minute", "mod", "modifies", "module", "month", "multiset", "national", "natural", "nchar", "nclob", "new", "no", "none", "normalize", "not", "nth_value", "ntile", "null", "nullif", "numeric", "octet_length", "occurrences_regex", "of", "offset", "old", "omit", "on", "one", "only", "open", "or", "order", "out", "outer", "over", "overlaps", "overlay", "parameter", "partition", "pattern", "per", "percent", "percent_rank", "percentile_cont", "percentile_disc", "period", "portion", "position", "position_regex", "power", "precedes", "precision", "prepare", "primary", "procedure", "ptf", "range", "rank", "reads", "real", "recursive", "ref", "references", "referencing", "regr_avgx", "regr_avgy", "regr_count", "regr_intercept", "regr_r2", "regr_slope", "regr_sxx", "regr_sxy", "regr_syy", "release", "result", "return", "returns", "revoke", "right", "rollback", "rollup", "row", "row_number", "rows", "running", "savepoint", "scope", "scroll", "search", "second", "seek", "select", "sensitive", "session_user", "set", "show", "similar", "sin", "sinh", "skip", "smallint", "some", "specific", "specifictype", "sql", "sqlexception", "sqlstate", "sqlwarning", "sqrt", "start", "static", "stddev_pop", "stddev_samp", "submultiset", "subset", "substring", "substring_regex", "succeeds", "sum", "symmetric", "system", "system_time", "system_user", "table", "tablesample", "tan", "tanh", "then", "time", "timestamp", "timezone_hour", "timezone_minute", "to", "trailing", "translate", "translate_regex", "translation", "treat", "trigger", "trim", "trim_array", "true", "truncate", "uescape", "union", "unique", "unknown", "unnest", "update", "upper", "user", "using", "value", "values", "value_of", "var_pop", "var_samp", "varbinary", "varchar", "varying", "versioning", "when", "whenever", "where", "width_bucket", "window", "with", "within", "without", "year", "add", "asc", "collation", "desc", "final", "first", "last", "view"].filter((e=>!i.includes(e)))
              , c = {
                begin: t.concat(/\b/, t.either(...s), /\s*\(/),
                relevance: 0,
                keywords: {
                    built_in: s
                }
            };
            return {
                name: "SQL",
                case_insensitive: !0,
                illegal: /[{}]|<\//,
                keywords: {
                    $pattern: /\b[\w\.]+/,
                    keyword: function(e, {exceptions: t, when: n}={}) {
                        const r = n;
                        return t = t || [],
                        e.map((e=>e.match(/\|\d+$/) || t.includes(e) ? e : r(e) ? `${e}|0` : e))
                    }(l, {
                        when: e=>e.length < 3
                    }),
                    literal: r,
                    type: o,
                    built_in: ["current_catalog", "current_date", "current_default_transform_group", "current_path", "current_role", "current_schema", "current_transform_group_for_type", "current_user", "session_user", "system_time", "system_user", "current_time", "localtime", "current_timestamp", "localtimestamp"]
                },
                contains: [{
                    begin: t.either(...a),
                    relevance: 0,
                    keywords: {
                        $pattern: /[\w\.]+/,
                        keyword: l.concat(a),
                        literal: r,
                        type: o
                    }
                }, {
                    className: "type",
                    begin: t.either("double precision", "large object", "with timezone", "without timezone")
                }, c, {
                    className: "variable",
                    begin: /@[a-z0-9][a-z0-9_]*/
                }, {
                    className: "string",
                    variants: [{
                        begin: /'/,
                        end: /'/,
                        contains: [{
                            begin: /''/
                        }]
                    }]
                }, {
                    begin: /"/,
                    end: /"/,
                    contains: [{
                        begin: /""/
                    }]
                }, e.C_NUMBER_MODE, e.C_BLOCK_COMMENT_MODE, n, {
                    className: "operator",
                    begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
                    relevance: 0
                }]
            }
        },
        swift: function(e) {
            const t = {
                match: /\s+/,
                relevance: 0
            }
              , n = e.COMMENT("/\\*", "\\*/", {
                contains: ["self"]
            })
              , r = [e.C_LINE_COMMENT_MODE, n]
              , o = {
                match: [/\./, id(...sd, ...ld)],
                className: {
                    2: "keyword"
                }
            }
              , i = {
                match: od(/\./, id(...ud)),
                relevance: 0
            }
              , a = ud.filter((e=>"string" == typeof e)).concat(["_|0"])
              , s = {
                variants: [{
                    className: "keyword",
                    match: id(...ud.filter((e=>"string" != typeof e)).concat(cd).map(ad), ...ld)
                }]
            }
              , l = {
                $pattern: id(/\b\w+/, /#\w+/),
                keyword: a.concat(hd),
                literal: dd
            }
              , c = [o, i, s]
              , u = [{
                match: od(/\./, id(...fd)),
                relevance: 0
            }, {
                className: "built_in",
                match: od(/\b/, id(...fd), /(?=\()/)
            }]
              , d = {
                match: /->/,
                relevance: 0
            }
              , p = [d, {
                className: "operator",
                relevance: 0,
                variants: [{
                    match: bd
                }, {
                    match: `\\.(\\.|${gd})+`
                }]
            }]
              , h = "([0-9]_*)+"
              , f = "([0-9a-fA-F]_*)+"
              , m = {
                className: "number",
                relevance: 0,
                variants: [{
                    match: `\\b(${h})(\\.(${h}))?([eE][+-]?(${h}))?\\b`
                }, {
                    match: `\\b0x(${f})(\\.(${f}))?([pP][+-]?(${h}))?\\b`
                }, {
                    match: /\b0o([0-7]_*)+\b/
                }, {
                    match: /\b0b([01]_*)+\b/
                }]
            }
              , g = (e="")=>({
                className: "subst",
                variants: [{
                    match: od(/\\/, e, /[0\\tnr"']/)
                }, {
                    match: od(/\\/, e, /u\{[0-9a-fA-F]{1,8}\}/)
                }]
            })
              , b = (e="")=>({
                className: "subst",
                match: od(/\\/, e, /[\t ]*(?:[\r\n]|\r\n)/)
            })
              , O = (e="")=>({
                className: "subst",
                label: "interpol",
                begin: od(/\\/, e, /\(/),
                end: /\)/
            })
              , v = (e="")=>({
                begin: od(e, /"""/),
                end: od(/"""/, e),
                contains: [g(e), b(e), O(e)]
            })
              , y = (e="")=>({
                begin: od(e, /"/),
                end: od(/"/, e),
                contains: [g(e), O(e)]
            })
              , w = {
                className: "string",
                variants: [v(), v("#"), v("##"), v("###"), y(), y("#"), y("##"), y("###")]
            }
              , _ = [e.BACKSLASH_ESCAPE, {
                begin: /\[/,
                end: /\]/,
                relevance: 0,
                contains: [e.BACKSLASH_ESCAPE]
            }]
              , k = {
                begin: /\/[^\s](?=[^/\n]*\/)/,
                end: /\//,
                contains: _
            }
              , S = e=>{
                const t = od(e, /\//)
                  , n = od(/\//, e);
                return {
                    begin: t,
                    end: n,
                    contains: [..._, {
                        scope: "comment",
                        begin: `#(?!.*${n})`,
                        end: /$/
                    }]
                }
            }
              , E = {
                scope: "regexp",
                variants: [S("###"), S("##"), S("#"), k]
            }
              , x = {
                match: od(/`/, yd, /`/)
            }
              , T = [x, {
                className: "variable",
                match: /\$\d+/
            }, {
                className: "variable",
                match: `\\$${vd}+`
            }]
              , A = [{
                match: /(@|#(un)?)available/,
                scope: "keyword",
                starts: {
                    contains: [{
                        begin: /\(/,
                        end: /\)/,
                        keywords: kd,
                        contains: [...p, m, w]
                    }]
                }
            }, {
                scope: "keyword",
                match: od(/@/, id(..._d))
            }, {
                scope: "meta",
                match: od(/@/, yd)
            }]
              , C = {
                match: rd(/\b[A-Z]/),
                relevance: 0,
                contains: [{
                    className: "type",
                    match: od(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, vd, "+")
                }, {
                    className: "type",
                    match: wd,
                    relevance: 0
                }, {
                    match: /[?!]+/,
                    relevance: 0
                }, {
                    match: /\.\.\./,
                    relevance: 0
                }, {
                    match: od(/\s+&\s+/, rd(wd)),
                    relevance: 0
                }]
            }
              , P = {
                begin: /</,
                end: />/,
                keywords: l,
                contains: [...r, ...c, ...A, d, C]
            };
            C.contains.push(P);
            const D = {
                begin: /\(/,
                end: /\)/,
                relevance: 0,
                keywords: l,
                contains: ["self", {
                    match: od(yd, /\s*:/),
                    keywords: "_|0",
                    relevance: 0
                }, ...r, E, ...c, ...u, ...p, m, w, ...T, ...A, C]
            }
              , R = {
                begin: /</,
                end: />/,
                keywords: "repeat each",
                contains: [...r, C]
            }
              , N = {
                begin: /\(/,
                end: /\)/,
                keywords: l,
                contains: [{
                    begin: id(rd(od(yd, /\s*:/)), rd(od(yd, /\s+/, yd, /\s*:/))),
                    end: /:/,
                    relevance: 0,
                    contains: [{
                        className: "keyword",
                        match: /\b_\b/
                    }, {
                        className: "params",
                        match: yd
                    }]
                }, ...r, ...c, ...p, m, w, ...A, C, D],
                endsParent: !0,
                illegal: /["']/
            }
              , $ = {
                match: [/(func|macro)/, /\s+/, id(x.match, yd, bd)],
                className: {
                    1: "keyword",
                    3: "title.function"
                },
                contains: [R, N, t],
                illegal: [/\[/, /%/]
            }
              , I = {
                match: [/\b(?:subscript|init[?!]?)/, /\s*(?=[<(])/],
                className: {
                    1: "keyword"
                },
                contains: [R, N, t],
                illegal: /\[|%/
            }
              , M = {
                match: [/operator/, /\s+/, bd],
                className: {
                    1: "keyword",
                    3: "title"
                }
            }
              , L = {
                begin: [/precedencegroup/, /\s+/, wd],
                className: {
                    1: "keyword",
                    3: "title"
                },
                contains: [C],
                keywords: [...pd, ...dd],
                end: /}/
            };
            for (const Q of w.variants) {
                const e = Q.contains.find((e=>"interpol" === e.label));
                e.keywords = l;
                const t = [...c, ...u, ...p, m, w, ...T];
                e.contains = [...t, {
                    begin: /\(/,
                    end: /\)/,
                    contains: ["self", ...t]
                }]
            }
            return {
                name: "Swift",
                keywords: l,
                contains: [...r, $, I, {
                    beginKeywords: "struct protocol class extension enum actor",
                    end: "\\{",
                    excludeEnd: !0,
                    keywords: l,
                    contains: [e.inherit(e.TITLE_MODE, {
                        className: "title.class",
                        begin: /[A-Za-z$_][\u00C0-\u02B80-9A-Za-z$_]*/
                    }), ...c]
                }, M, L, {
                    beginKeywords: "import",
                    end: /$/,
                    contains: [...r],
                    relevance: 0
                }, E, ...c, ...u, ...p, m, w, ...T, ...A, C, D]
            }
        },
        typescript: function(e) {
            const t = function(e) {
                const t = e.regex
                  , n = Sd
                  , r = "<>"
                  , o = "</>"
                  , i = {
                    begin: /<[A-Za-z0-9\\._:-]+/,
                    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
                    isTrulyOpeningTag: (e,t)=>{
                        const n = e[0].length + e.index
                          , r = e.input[n];
                        if ("<" === r || "," === r)
                            return void t.ignoreMatch();
                        let o;
                        ">" === r && (((e,{after: t})=>{
                            const n = "</" + e[0].slice(1);
                            return -1 !== e.input.indexOf(n, t)
                        }
                        )(e, {
                            after: n
                        }) || t.ignoreMatch());
                        const i = e.input.substring(n);
                        ((o = i.match(/^\s*=/)) || (o = i.match(/^\s+extends\s+/)) && 0 === o.index) && t.ignoreMatch()
                    }
                }
                  , a = {
                    $pattern: Sd,
                    keyword: Ed,
                    literal: xd,
                    built_in: Dd,
                    "variable.language": Pd
                }
                  , s = "[0-9](_?[0-9])*"
                  , l = `\\.(${s})`
                  , c = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*"
                  , u = {
                    className: "number",
                    variants: [{
                        begin: `(\\b(${c})((${l})|\\.)?|(${l}))[eE][+-]?(${s})\\b`
                    }, {
                        begin: `\\b(${c})\\b((${l})\\b|\\.)?|(${l})\\b`
                    }, {
                        begin: "\\b(0|[1-9](_?[0-9])*)n\\b"
                    }, {
                        begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b"
                    }, {
                        begin: "\\b0[bB][0-1](_?[0-1])*n?\\b"
                    }, {
                        begin: "\\b0[oO][0-7](_?[0-7])*n?\\b"
                    }, {
                        begin: "\\b0[0-7]+n?\\b"
                    }],
                    relevance: 0
                }
                  , d = {
                    className: "subst",
                    begin: "\\$\\{",
                    end: "\\}",
                    keywords: a,
                    contains: []
                }
                  , p = {
                    begin: "html`",
                    end: "",
                    starts: {
                        end: "`",
                        returnEnd: !1,
                        contains: [e.BACKSLASH_ESCAPE, d],
                        subLanguage: "xml"
                    }
                }
                  , h = {
                    begin: "css`",
                    end: "",
                    starts: {
                        end: "`",
                        returnEnd: !1,
                        contains: [e.BACKSLASH_ESCAPE, d],
                        subLanguage: "css"
                    }
                }
                  , f = {
                    begin: "gql`",
                    end: "",
                    starts: {
                        end: "`",
                        returnEnd: !1,
                        contains: [e.BACKSLASH_ESCAPE, d],
                        subLanguage: "graphql"
                    }
                }
                  , m = {
                    className: "string",
                    begin: "`",
                    end: "`",
                    contains: [e.BACKSLASH_ESCAPE, d]
                }
                  , g = {
                    className: "comment",
                    variants: [e.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
                        relevance: 0,
                        contains: [{
                            begin: "(?=@[A-Za-z]+)",
                            relevance: 0,
                            contains: [{
                                className: "doctag",
                                begin: "@[A-Za-z]+"
                            }, {
                                className: "type",
                                begin: "\\{",
                                end: "\\}",
                                excludeEnd: !0,
                                excludeBegin: !0,
                                relevance: 0
                            }, {
                                className: "variable",
                                begin: n + "(?=\\s*(-)|$)",
                                endsParent: !0,
                                relevance: 0
                            }, {
                                begin: /(?=[^\n])\s/,
                                relevance: 0
                            }]
                        }]
                    }), e.C_BLOCK_COMMENT_MODE, e.C_LINE_COMMENT_MODE]
                }
                  , b = [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, p, h, f, m, {
                    match: /\$\d+/
                }, u];
                d.contains = b.concat({
                    begin: /\{/,
                    end: /\}/,
                    keywords: a,
                    contains: ["self"].concat(b)
                });
                const O = [].concat(g, d.contains)
                  , v = O.concat([{
                    begin: /\(/,
                    end: /\)/,
                    keywords: a,
                    contains: ["self"].concat(O)
                }])
                  , y = {
                    className: "params",
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: a,
                    contains: v
                }
                  , w = {
                    variants: [{
                        match: [/class/, /\s+/, n, /\s+/, /extends/, /\s+/, t.concat(n, "(", t.concat(/\./, n), ")*")],
                        scope: {
                            1: "keyword",
                            3: "title.class",
                            5: "keyword",
                            7: "title.class.inherited"
                        }
                    }, {
                        match: [/class/, /\s+/, n],
                        scope: {
                            1: "keyword",
                            3: "title.class"
                        }
                    }]
                }
                  , _ = {
                    relevance: 0,
                    match: t.either(/\bJSON/, /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/, /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/, /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/),
                    className: "title.class",
                    keywords: {
                        _: [...Td, ...Ad]
                    }
                }
                  , k = {
                    variants: [{
                        match: [/function/, /\s+/, n, /(?=\s*\()/]
                    }, {
                        match: [/function/, /\s*(?=\()/]
                    }],
                    className: {
                        1: "keyword",
                        3: "title.function"
                    },
                    label: "func.def",
                    contains: [y],
                    illegal: /%/
                }
                  , S = {
                    match: t.concat(/\b/, (E = [...Cd, "super", "import"],
                    t.concat("(?!", E.join("|"), ")")), n, t.lookahead(/\(/)),
                    className: "title.function",
                    relevance: 0
                };
                var E;
                const x = {
                    begin: t.concat(/\./, t.lookahead(t.concat(n, /(?![0-9A-Za-z$_(])/))),
                    end: n,
                    excludeBegin: !0,
                    keywords: "prototype",
                    className: "property",
                    relevance: 0
                }
                  , T = {
                    match: [/get|set/, /\s+/, n, /(?=\()/],
                    className: {
                        1: "keyword",
                        3: "title.function"
                    },
                    contains: [{
                        begin: /\(\)/
                    }, y]
                }
                  , A = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + e.UNDERSCORE_IDENT_RE + ")\\s*=>"
                  , C = {
                    match: [/const|var|let/, /\s+/, n, /\s*/, /=\s*/, /(async\s*)?/, t.lookahead(A)],
                    keywords: "async",
                    className: {
                        1: "keyword",
                        3: "title.function"
                    },
                    contains: [y]
                };
                return {
                    name: "JavaScript",
                    aliases: ["js", "jsx", "mjs", "cjs"],
                    keywords: a,
                    exports: {
                        PARAMS_CONTAINS: v,
                        CLASS_REFERENCE: _
                    },
                    illegal: /#(?![$_A-z])/,
                    contains: [e.SHEBANG({
                        label: "shebang",
                        binary: "node",
                        relevance: 5
                    }), {
                        label: "use_strict",
                        className: "meta",
                        relevance: 10,
                        begin: /^\s*['"]use (strict|asm)['"]/
                    }, e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, p, h, f, m, g, {
                        match: /\$\d+/
                    }, u, _, {
                        className: "attr",
                        begin: n + t.lookahead(":"),
                        relevance: 0
                    }, C, {
                        begin: "(" + e.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
                        keywords: "return throw case",
                        relevance: 0,
                        contains: [g, e.REGEXP_MODE, {
                            className: "function",
                            begin: A,
                            returnBegin: !0,
                            end: "\\s*=>",
                            contains: [{
                                className: "params",
                                variants: [{
                                    begin: e.UNDERSCORE_IDENT_RE,
                                    relevance: 0
                                }, {
                                    className: null,
                                    begin: /\(\s*\)/,
                                    skip: !0
                                }, {
                                    begin: /\(/,
                                    end: /\)/,
                                    excludeBegin: !0,
                                    excludeEnd: !0,
                                    keywords: a,
                                    contains: v
                                }]
                            }]
                        }, {
                            begin: /,/,
                            relevance: 0
                        }, {
                            match: /\s+/,
                            relevance: 0
                        }, {
                            variants: [{
                                begin: r,
                                end: o
                            }, {
                                match: /<[A-Za-z0-9\\._:-]+\s*\/>/
                            }, {
                                begin: i.begin,
                                "on:begin": i.isTrulyOpeningTag,
                                end: i.end
                            }],
                            subLanguage: "xml",
                            contains: [{
                                begin: i.begin,
                                end: i.end,
                                skip: !0,
                                contains: ["self"]
                            }]
                        }]
                    }, k, {
                        beginKeywords: "while if switch catch for"
                    }, {
                        begin: "\\b(?!function)" + e.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
                        returnBegin: !0,
                        label: "func.def",
                        contains: [y, e.inherit(e.TITLE_MODE, {
                            begin: n,
                            className: "title.function"
                        })]
                    }, {
                        match: /\.\.\./,
                        relevance: 0
                    }, x, {
                        match: "\\$" + n,
                        relevance: 0
                    }, {
                        match: [/\bconstructor(?=\s*\()/],
                        className: {
                            1: "title.function"
                        },
                        contains: [y]
                    }, S, {
                        relevance: 0,
                        match: /\b[A-Z][A-Z_0-9]+\b/,
                        className: "variable.constant"
                    }, w, T, {
                        match: /\$[(.]/
                    }]
                }
            }(e)
              , n = Sd
              , r = ["any", "void", "number", "boolean", "string", "object", "never", "symbol", "bigint", "unknown"]
              , o = {
                beginKeywords: "namespace",
                end: /\{/,
                excludeEnd: !0,
                contains: [t.exports.CLASS_REFERENCE]
            }
              , i = {
                beginKeywords: "interface",
                end: /\{/,
                excludeEnd: !0,
                keywords: {
                    keyword: "interface extends",
                    built_in: r
                },
                contains: [t.exports.CLASS_REFERENCE]
            }
              , a = {
                $pattern: Sd,
                keyword: Ed.concat(["type", "namespace", "interface", "public", "private", "protected", "implements", "declare", "abstract", "readonly", "enum", "override"]),
                literal: xd,
                built_in: Dd.concat(r),
                "variable.language": Pd
            }
              , s = {
                className: "meta",
                begin: "@" + n
            }
              , l = (e,t,n)=>{
                const r = e.contains.findIndex((e=>e.label === t));
                if (-1 === r)
                    throw new Error("can not find mode to replace");
                e.contains.splice(r, 1, n)
            }
            ;
            return Object.assign(t.keywords, a),
            t.exports.PARAMS_CONTAINS.push(s),
            t.contains = t.contains.concat([s, o, i]),
            l(t, "shebang", e.SHEBANG()),
            l(t, "use_strict", {
                className: "meta",
                relevance: 10,
                begin: /^\s*['"]use strict['"]/
            }),
            t.contains.find((e=>"func.def" === e.label)).relevance = 0,
            Object.assign(t, {
                name: "TypeScript",
                aliases: ["ts", "tsx", "mts", "cts"]
            }),
            t
        },
        xml: Rd,
        yaml: function(e) {
            const t = "true false yes no null"
              , n = "[\\w#;/?:@&=+$,.~*'()[\\]]+"
              , r = {
                className: "string",
                relevance: 0,
                variants: [{
                    begin: /'/,
                    end: /'/
                }, {
                    begin: /"/,
                    end: /"/
                }, {
                    begin: /\S+/
                }],
                contains: [e.BACKSLASH_ESCAPE, {
                    className: "template-variable",
                    variants: [{
                        begin: /\{\{/,
                        end: /\}\}/
                    }, {
                        begin: /%\{/,
                        end: /\}/
                    }]
                }]
            }
              , o = e.inherit(r, {
                variants: [{
                    begin: /'/,
                    end: /'/
                }, {
                    begin: /"/,
                    end: /"/
                }, {
                    begin: /[^\s,{}[\]]+/
                }]
            })
              , i = {
                className: "number",
                begin: "\\b[0-9]{4}(-[0-9][0-9]){0,2}([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?(\\.[0-9]*)?([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?\\b"
            }
              , a = {
                end: ",",
                endsWithParent: !0,
                excludeEnd: !0,
                keywords: t,
                relevance: 0
            }
              , s = {
                begin: /\{/,
                end: /\}/,
                contains: [a],
                illegal: "\\n",
                relevance: 0
            }
              , l = {
                begin: "\\[",
                end: "\\]",
                contains: [a],
                illegal: "\\n",
                relevance: 0
            }
              , c = [{
                className: "attr",
                variants: [{
                    begin: "\\w[\\w :\\/.-]*:(?=[ \t]|$)"
                }, {
                    begin: '"\\w[\\w :\\/.-]*":(?=[ \t]|$)'
                }, {
                    begin: "'\\w[\\w :\\/.-]*':(?=[ \t]|$)"
                }]
            }, {
                className: "meta",
                begin: "^---\\s*$",
                relevance: 10
            }, {
                className: "string",
                begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
            }, {
                begin: "<%[%=-]?",
                end: "[%-]?%>",
                subLanguage: "ruby",
                excludeBegin: !0,
                excludeEnd: !0,
                relevance: 0
            }, {
                className: "type",
                begin: "!\\w+!" + n
            }, {
                className: "type",
                begin: "!<" + n + ">"
            }, {
                className: "type",
                begin: "!" + n
            }, {
                className: "type",
                begin: "!!" + n
            }, {
                className: "meta",
                begin: "&" + e.UNDERSCORE_IDENT_RE + "$"
            }, {
                className: "meta",
                begin: "\\*" + e.UNDERSCORE_IDENT_RE + "$"
            }, {
                className: "bullet",
                begin: "-(?=[ ]|$)",
                relevance: 0
            }, e.HASH_COMMENT_MODE, {
                beginKeywords: t,
                keywords: {
                    literal: t
                }
            }, i, {
                className: "number",
                begin: e.C_NUMBER_RE + "\\b",
                relevance: 0
            }, s, l, r]
              , u = [...c];
            return u.pop(),
            u.push(o),
            a.contains = u,
            {
                name: "YAML",
                case_insensitive: !0,
                aliases: ["yml"],
                contains: c
            }
        }
    };
    const pS = {
        abandonedHeadElementChild: {
            reason: "Unexpected metadata element after head",
            description: "Unexpected element after head. Expected the element before `</head>`",
            url: !1
        },
        abruptClosingOfEmptyComment: {
            reason: "Unexpected abruptly closed empty comment",
            description: "Unexpected `>` or `->`. Expected `--\x3e` to close comments"
        },
        abruptDoctypePublicIdentifier: {
            reason: "Unexpected abruptly closed public identifier",
            description: "Unexpected `>`. Expected a closing `\"` or `'` after the public identifier"
        },
        abruptDoctypeSystemIdentifier: {
            reason: "Unexpected abruptly closed system identifier",
            description: "Unexpected `>`. Expected a closing `\"` or `'` after the identifier identifier"
        },
        absenceOfDigitsInNumericCharacterReference: {
            reason: "Unexpected non-digit at start of numeric character reference",
            description: "Unexpected `%c`. Expected `[0-9]` for decimal references or `[0-9a-fA-F]` for hexadecimal references"
        },
        cdataInHtmlContent: {
            reason: "Unexpected CDATA section in HTML",
            description: "Unexpected `<![CDATA[` in HTML. Remove it, use a comment, or encode special characters instead"
        },
        characterReferenceOutsideUnicodeRange: {
            reason: "Unexpected too big numeric character reference",
            description: "Unexpectedly high character reference. Expected character references to be at most hexadecimal 10ffff (or decimal 1114111)"
        },
        closingOfElementWithOpenChildElements: {
            reason: "Unexpected closing tag with open child elements",
            description: "Unexpectedly closing tag. Expected other tags to be closed first",
            url: !1
        },
        controlCharacterInInputStream: {
            reason: "Unexpected control character",
            description: "Unexpected control character `%x`. Expected a non-control code point, 0x00, or ASCII whitespace"
        },
        controlCharacterReference: {
            reason: "Unexpected control character reference",
            description: "Unexpectedly control character in reference. Expected a non-control code point, 0x00, or ASCII whitespace"
        },
        disallowedContentInNoscriptInHead: {
            reason: "Disallowed content inside `<noscript>` in `<head>`",
            description: "Unexpected text character `%c`. Only use text in `<noscript>`s in `<body>`",
            url: !1
        },
        duplicateAttribute: {
            reason: "Unexpected duplicate attribute",
            description: "Unexpectedly double attribute. Expected attributes to occur only once"
        },
        endTagWithAttributes: {
            reason: "Unexpected attribute on closing tag",
            description: "Unexpected attribute. Expected `>` instead"
        },
        endTagWithTrailingSolidus: {
            reason: "Unexpected slash at end of closing tag",
            description: "Unexpected `%c-1`. Expected `>` instead"
        },
        endTagWithoutMatchingOpenElement: {
            reason: "Unexpected unopened end tag",
            description: "Unexpected end tag. Expected no end tag or another end tag",
            url: !1
        },
        eofBeforeTagName: {
            reason: "Unexpected end of file",
            description: "Unexpected end of file. Expected tag name instead"
        },
        eofInCdata: {
            reason: "Unexpected end of file in CDATA",
            description: "Unexpected end of file. Expected `]]>` to close the CDATA"
        },
        eofInComment: {
            reason: "Unexpected end of file in comment",
            description: "Unexpected end of file. Expected `--\x3e` to close the comment"
        },
        eofInDoctype: {
            reason: "Unexpected end of file in doctype",
            description: "Unexpected end of file. Expected a valid doctype (such as `<!doctype html>`)"
        },
        eofInElementThatCanContainOnlyText: {
            reason: "Unexpected end of file in element that can only contain text",
            description: "Unexpected end of file. Expected text or a closing tag",
            url: !1
        },
        eofInScriptHtmlCommentLikeText: {
            reason: "Unexpected end of file in comment inside script",
            description: "Unexpected end of file. Expected `--\x3e` to close the comment"
        },
        eofInTag: {
            reason: "Unexpected end of file in tag",
            description: "Unexpected end of file. Expected `>` to close the tag"
        },
        incorrectlyClosedComment: {
            reason: "Incorrectly closed comment",
            description: "Unexpected `%c-1`. Expected `--\x3e` to close the comment"
        },
        incorrectlyOpenedComment: {
            reason: "Incorrectly opened comment",
            description: "Unexpected `%c`. Expected `\x3c!--` to open the comment"
        },
        invalidCharacterSequenceAfterDoctypeName: {
            reason: "Invalid sequence after doctype name",
            description: "Unexpected sequence at `%c`. Expected `public` or `system`"
        },
        invalidFirstCharacterOfTagName: {
            reason: "Invalid first character in tag name",
            description: "Unexpected `%c`. Expected an ASCII letter instead"
        },
        misplacedDoctype: {
            reason: "Misplaced doctype",
            description: "Unexpected doctype. Expected doctype before head",
            url: !1
        },
        misplacedStartTagForHeadElement: {
            reason: "Misplaced `<head>` start tag",
            description: "Unexpected start tag `<head>`. Expected `<head>` directly after doctype",
            url: !1
        },
        missingAttributeValue: {
            reason: "Missing attribute value",
            description: "Unexpected `%c-1`. Expected an attribute value or no `%c-1` instead"
        },
        missingDoctype: {
            reason: "Missing doctype before other content",
            description: "Expected a `<!doctype html>` before anything else",
            url: !1
        },
        missingDoctypeName: {
            reason: "Missing doctype name",
            description: "Unexpected doctype end at `%c`. Expected `html` instead"
        },
        missingDoctypePublicIdentifier: {
            reason: "Missing public identifier in doctype",
            description: "Unexpected `%c`. Expected identifier for `public` instead"
        },
        missingDoctypeSystemIdentifier: {
            reason: "Missing system identifier in doctype",
            description: 'Unexpected `%c`. Expected identifier for `system` instead (suggested: `"about:legacy-compat"`)'
        },
        missingEndTagName: {
            reason: "Missing name in end tag",
            description: "Unexpected `%c`. Expected an ASCII letter instead"
        },
        missingQuoteBeforeDoctypePublicIdentifier: {
            reason: "Missing quote before public identifier in doctype",
            description: "Unexpected `%c`. Expected `\"` or `'` instead"
        },
        missingQuoteBeforeDoctypeSystemIdentifier: {
            reason: "Missing quote before system identifier in doctype",
            description: "Unexpected `%c`. Expected `\"` or `'` instead"
        },
        missingSemicolonAfterCharacterReference: {
            reason: "Missing semicolon after character reference",
            description: "Unexpected `%c`. Expected `;` instead"
        },
        missingWhitespaceAfterDoctypePublicKeyword: {
            reason: "Missing whitespace after public identifier in doctype",
            description: "Unexpected `%c`. Expected ASCII whitespace instead"
        },
        missingWhitespaceAfterDoctypeSystemKeyword: {
            reason: "Missing whitespace after system identifier in doctype",
            description: "Unexpected `%c`. Expected ASCII whitespace instead"
        },
        missingWhitespaceBeforeDoctypeName: {
            reason: "Missing whitespace before doctype name",
            description: "Unexpected `%c`. Expected ASCII whitespace instead"
        },
        missingWhitespaceBetweenAttributes: {
            reason: "Missing whitespace between attributes",
            description: "Unexpected `%c`. Expected ASCII whitespace instead"
        },
        missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: {
            reason: "Missing whitespace between public and system identifiers in doctype",
            description: "Unexpected `%c`. Expected ASCII whitespace instead"
        },
        nestedComment: {
            reason: "Unexpected nested comment",
            description: "Unexpected `\x3c!--`. Expected `--\x3e`"
        },
        nestedNoscriptInHead: {
            reason: "Unexpected nested `<noscript>` in `<head>`",
            description: "Unexpected `<noscript>`. Expected a closing tag or a meta element",
            url: !1
        },
        nonConformingDoctype: {
            reason: "Unexpected non-conforming doctype declaration",
            description: 'Expected `<!doctype html>` or `<!doctype html system "about:legacy-compat">`',
            url: !1
        },
        nonVoidHtmlElementStartTagWithTrailingSolidus: {
            reason: "Unexpected trailing slash on start tag of non-void element",
            description: "Unexpected `/`. Expected `>` instead"
        },
        noncharacterCharacterReference: {
            reason: "Unexpected noncharacter code point referenced by character reference",
            description: "Unexpected code point. Do not use noncharacters in HTML"
        },
        noncharacterInInputStream: {
            reason: "Unexpected noncharacter character",
            description: "Unexpected code point `%x`. Do not use noncharacters in HTML"
        },
        nullCharacterReference: {
            reason: "Unexpected NULL character referenced by character reference",
            description: "Unexpected code point. Do not use NULL characters in HTML"
        },
        openElementsLeftAfterEof: {
            reason: "Unexpected end of file",
            description: "Unexpected end of file. Expected closing tag instead",
            url: !1
        },
        surrogateCharacterReference: {
            reason: "Unexpected surrogate character referenced by character reference",
            description: "Unexpected code point. Do not use lone surrogate characters in HTML"
        },
        surrogateInInputStream: {
            reason: "Unexpected surrogate character",
            description: "Unexpected code point `%x`. Do not use lone surrogate characters in HTML"
        },
        unexpectedCharacterAfterDoctypeSystemIdentifier: {
            reason: "Invalid character after system identifier in doctype",
            description: "Unexpected character at `%c`. Expected `>`"
        },
        unexpectedCharacterInAttributeName: {
            reason: "Unexpected character in attribute name",
            description: "Unexpected `%c`. Expected whitespace, `/`, `>`, `=`, or probably an ASCII letter"
        },
        unexpectedCharacterInUnquotedAttributeValue: {
            reason: "Unexpected character in unquoted attribute value",
            description: "Unexpected `%c`. Quote the attribute value to include it"
        },
        unexpectedEqualsSignBeforeAttributeName: {
            reason: "Unexpected equals sign before attribute name",
            description: "Unexpected `%c`. Add an attribute name before it"
        },
        unexpectedNullCharacter: {
            reason: "Unexpected NULL character",
            description: "Unexpected code point `%x`. Do not use NULL characters in HTML"
        },
        unexpectedQuestionMarkInsteadOfTagName: {
            reason: "Unexpected question mark instead of tag name",
            description: "Unexpected `%c`. Expected an ASCII letter instead"
        },
        unexpectedSolidusInTag: {
            reason: "Unexpected slash in tag",
            description: "Unexpected `%c-1`. Expected it followed by `>` or in a quoted attribute value"
        },
        unknownNamedCharacterReference: {
            reason: "Unexpected unknown named character reference",
            description: "Unexpected character reference. Expected known named character references"
        }
    }
      , hS = "https://html.spec.whatwg.org/multipage/parsing.html#parse-error-"
      , fS = /-[a-z]/g
      , mS = /%c(?:([-+])(\d+))?/g
      , gS = /%x/g
      , bS = {
        2: !0,
        1: !1,
        0: null
    }
      , OS = {};
    function vS(e, t) {
        const n = t || OS
          , r = n.onerror
          , o = e instanceof Yk ? e : new Yk(e)
          , i = n.fragment ? iO : oO
          , a = String(o)
          , s = i(a, {
            sourceCodeLocationInfo: !0,
            onParseError: n.onerror ? function(e) {
                const t = e.code
                  , i = function(e) {
                    return e.replace(fS, yS)
                }(t)
                  , s = n[i]
                  , l = null == s || s
                  , c = "number" == typeof l ? l : l ? 1 : 0;
                if (c) {
                    const n = pS[i]
                      , a = new qk(u(n.reason),{
                        place: {
                            start: {
                                line: e.startLine,
                                column: e.startCol,
                                offset: e.startOffset
                            },
                            end: {
                                line: e.endLine,
                                column: e.endCol,
                                offset: e.endOffset
                            }
                        },
                        ruleId: t,
                        source: "hast-util-from-html"
                    });
                    o.path && (a.file = o.path,
                    a.name = o.path + ":" + a.name),
                    a.fatal = bS[c],
                    a.note = u(n.description),
                    a.url = !1 === n.url ? void 0 : hS + t,
                    r(a)
                }
                function u(t) {
                    return t.replace(mS, (function(t, n, r) {
                        const o = (r ? Number.parseInt(r, 10) : 0) * ("-" === n ? -1 : 1);
                        return function(e) {
                            return "`" === e ? "` ` `" : e
                        }(a.charAt(e.startOffset + o))
                    }
                    )).replace(gS, (function() {
                        return t = a.charCodeAt(e.startOffset),
                        "0x" + t.toString(16).toUpperCase();
                        var t
                    }
                    ))
                }
            }
            : null,
            scriptingEnabled: !1
        });
        return Zf(s, {
            file: o,
            space: n.space,
            verbose: n.verbose
        })
    }
    function yS(e) {
        return e.charAt(1).toUpperCase()
    }
    function wS(e) {
        const {emitParseErrors: t, ...n} = {
            ...this.data("settings"),
            ...e
        };
        this.parser = function(e, r) {
            return vS(e, {
                ...n,
                onerror: t ? function(e) {
                    r.path && (e.name = r.path + ":" + e.name,
                    e.file = r.path),
                    r.messages.push(e)
                }
                : void 0
            })
        }
    }
    function _S(e) {
        return "text" === (null == e ? void 0 : e.type)
    }
    function kS(e) {
        return "element" === (null == e ? void 0 : e.type)
    }
    function SS(e) {
        return {
            type: "text",
            value: e
        }
    }
    function ES() {
        return e=>{
            eh(e, "element", ((e,t,n)=>{
                if ("element" === (null == n ? void 0 : n.type) && "pre" === n.tagName && "code" === e.tagName) {
                    let t = 0;
                    e.children = xS(e),
                    e.children.forEach((e=>{
                        if ("element" === e.type && "span" === e.tagName) {
                            const n = e.children[e.children.length - 1];
                            (!_S(n) || _S(n) && !AS(n)) && (e.children.push({
                                type: "text",
                                value: "\n"
                            }),
                            t++)
                        }
                    }
                    )),
                    e.properties.style = [`--line-count: ${t};`, `--line-digits: ${t.toString().length};`]
                }
            }
            ))
        }
    }
    function xS(e, t=[], n) {
        const r = ()=>t[t.length - 1] ?? (t.push(TS()) && t[t.length - 1]);
        return e.children.forEach((o=>{
            if (_S(o) && AS(o)) {
                const i = o.value.split(/\n/);
                i.forEach(((o,a)=>{
                    n ? r().children.push({
                        ...e,
                        children: [SS(o)]
                    }) : r().children.push(SS(o)),
                    a !== i.length - 1 && t.push(TS())
                }
                ))
            } else
                kS(o) && o.children.some(AS) ? xS(o, t, !0) : r().children.push(o)
        }
        )),
        t
    }
    function TS(...e) {
        return {
            type: "element",
            tagName: "span",
            properties: {
                class: ["line"]
            },
            children: e
        }
    }
    function AS(e) {
        return _S(e) && /\r?\n/.test(e.value) || kS(e) && e.children.some(AS)
    }
    function CS(e, t) {
        const n = ("string" == typeof (null == t ? void 0 : t.maskCredentials) ? [t.maskCredentials] : (null == t ? void 0 : t.maskCredentials) ?? []).filter((e=>!(e.length < 3) || (console.error(`Codeblock credentials must be at least 3 characters to mask. Will not mask "${e}"`),
        !1)))
          , r = `language-${eu[t.lang] ?? t.lang}`;
        var o;
        const i = oS().use(wS, {
            fragment: !0
        }).use((o = e,
        ()=>e=>{
            eh(e, "element", (e=>{
                "code" === e.tagName && e.children.push({
                    type: "text",
                    value: o
                })
            }
            ))
        }
        )).use(nh, {
            languages: t.languages
        }).use((null == t ? void 0 : t.lineNumbers) ? ES : ()=>{}
        ).use(Sv).processSync(`<pre><code class="${r}"></code></pre>`).toString();
        return n.length ? i.replace(new RegExp(n.join("|"),"g"), (e=>`<span class="credentials">${e}</span>`)) : i
    }
    const PS = e=>{
        let t = 0
          , n = 0
          , r = 0;
        if (!(null == e ? void 0 : e.length))
            return n;
        for (r = 0; r < e.length; r++)
            t = e.charCodeAt(r),
            n = (n << 5) - n + t,
            n |= 0;
        return n
    }
      , DS = Symbol.for("yaml.alias")
      , RS = Symbol.for("yaml.document")
      , NS = Symbol.for("yaml.map")
      , $S = Symbol.for("yaml.pair")
      , IS = Symbol.for("yaml.scalar")
      , MS = Symbol.for("yaml.seq")
      , LS = Symbol.for("yaml.node.type")
      , QS = e=>!!e && "object" == typeof e && e[LS] === DS
      , BS = e=>!!e && "object" == typeof e && e[LS] === RS
      , US = e=>!!e && "object" == typeof e && e[LS] === NS
      , FS = e=>!!e && "object" == typeof e && e[LS] === $S
      , jS = e=>!!e && "object" == typeof e && e[LS] === IS
      , zS = e=>!!e && "object" == typeof e && e[LS] === MS;
    function qS(e) {
        if (e && "object" == typeof e)
            switch (e[LS]) {
            case NS:
            case MS:
                return !0
            }
        return !1
    }
    function HS(e) {
        if (e && "object" == typeof e)
            switch (e[LS]) {
            case DS:
            case NS:
            case IS:
            case MS:
                return !0
            }
        return !1
    }
    const ZS = e=>(jS(e) || qS(e)) && !!e.anchor
      , WS = Symbol("break visit")
      , XS = Symbol("skip children")
      , VS = Symbol("remove node");
    function GS(e, t) {
        const n = function(e) {
            if ("object" == typeof e && (e.Collection || e.Node || e.Value))
                return Object.assign({
                    Alias: e.Node,
                    Map: e.Node,
                    Scalar: e.Node,
                    Seq: e.Node
                }, e.Value && {
                    Map: e.Value,
                    Scalar: e.Value,
                    Seq: e.Value
                }, e.Collection && {
                    Map: e.Collection,
                    Seq: e.Collection
                }, e);
            return e
        }(t);
        if (BS(e)) {
            YS(null, e.contents, n, Object.freeze([e])) === VS && (e.contents = null)
        } else
            YS(null, e, n, Object.freeze([]))
    }
    function YS(e, t, n, r) {
        const o = function(e, t, n, r) {
            var o, i, a, s, l;
            return "function" == typeof n ? n(e, t, r) : US(t) ? null == (o = n.Map) ? void 0 : o.call(n, e, t, r) : zS(t) ? null == (i = n.Seq) ? void 0 : i.call(n, e, t, r) : FS(t) ? null == (a = n.Pair) ? void 0 : a.call(n, e, t, r) : jS(t) ? null == (s = n.Scalar) ? void 0 : s.call(n, e, t, r) : QS(t) ? null == (l = n.Alias) ? void 0 : l.call(n, e, t, r) : void 0
        }(e, t, n, r);
        if (HS(o) || FS(o))
            return function(e, t, n) {
                const r = t[t.length - 1];
                if (qS(r))
                    r.items[e] = n;
                else if (FS(r))
                    "key" === e ? r.key = n : r.value = n;
                else {
                    if (!BS(r)) {
                        const e = QS(r) ? "alias" : "scalar";
                        throw new Error(`Cannot replace node with ${e} parent`)
                    }
                    r.contents = n
                }
            }(e, r, o),
            YS(e, o, n, r);
        if ("symbol" != typeof o)
            if (qS(t)) {
                r = Object.freeze(r.concat(t));
                for (let e = 0; e < t.items.length; ++e) {
                    const o = YS(e, t.items[e], n, r);
                    if ("number" == typeof o)
                        e = o - 1;
                    else {
                        if (o === WS)
                            return WS;
                        o === VS && (t.items.splice(e, 1),
                        e -= 1)
                    }
                }
            } else if (FS(t)) {
                r = Object.freeze(r.concat(t));
                const e = YS("key", t.key, n, r);
                if (e === WS)
                    return WS;
                e === VS && (t.key = null);
                const o = YS("value", t.value, n, r);
                if (o === WS)
                    return WS;
                o === VS && (t.value = null)
            }
        return o
    }
    GS.BREAK = WS,
    GS.SKIP = XS,
    GS.REMOVE = VS;
    const KS = {
        "!": "%21",
        ",": "%2C",
        "[": "%5B",
        "]": "%5D",
        "{": "%7B",
        "}": "%7D"
    };
    class JS {
        constructor(e, t) {
            this.docStart = null,
            this.docEnd = !1,
            this.yaml = Object.assign({}, JS.defaultYaml, e),
            this.tags = Object.assign({}, JS.defaultTags, t)
        }
        clone() {
            const e = new JS(this.yaml,this.tags);
            return e.docStart = this.docStart,
            e
        }
        atDocument() {
            const e = new JS(this.yaml,this.tags);
            switch (this.yaml.version) {
            case "1.1":
                this.atNextDocument = !0;
                break;
            case "1.2":
                this.atNextDocument = !1,
                this.yaml = {
                    explicit: JS.defaultYaml.explicit,
                    version: "1.2"
                },
                this.tags = Object.assign({}, JS.defaultTags)
            }
            return e
        }
        add(e, t) {
            this.atNextDocument && (this.yaml = {
                explicit: JS.defaultYaml.explicit,
                version: "1.1"
            },
            this.tags = Object.assign({}, JS.defaultTags),
            this.atNextDocument = !1);
            const n = e.trim().split(/[ \t]+/)
              , r = n.shift();
            switch (r) {
            case "%TAG":
                {
                    if (2 !== n.length && (t(0, "%TAG directive should contain exactly two parts"),
                    n.length < 2))
                        return !1;
                    const [e,r] = n;
                    return this.tags[e] = r,
                    !0
                }
            case "%YAML":
                {
                    if (this.yaml.explicit = !0,
                    1 !== n.length)
                        return t(0, "%YAML directive should contain exactly one part"),
                        !1;
                    const [e] = n;
                    if ("1.1" === e || "1.2" === e)
                        return this.yaml.version = e,
                        !0;
                    return t(6, `Unsupported YAML version ${e}`, /^\d+\.\d+$/.test(e)),
                    !1
                }
            default:
                return t(0, `Unknown directive ${r}`, !0),
                !1
            }
        }
        tagName(e, t) {
            if ("!" === e)
                return "!";
            if ("!" !== e[0])
                return t(`Not a valid tag: ${e}`),
                null;
            if ("<" === e[1]) {
                const n = e.slice(2, -1);
                return "!" === n || "!!" === n ? (t(`Verbatim tags aren't resolved, so ${e} is invalid.`),
                null) : (">" !== e[e.length - 1] && t("Verbatim tags must end with a >"),
                n)
            }
            const [,n,r] = e.match(/^(.*!)([^!]*)$/s);
            r || t(`The ${e} tag has no suffix`);
            const o = this.tags[n];
            if (o)
                try {
                    return o + decodeURIComponent(r)
                } catch (i) {
                    return t(String(i)),
                    null
                }
            return "!" === n ? e : (t(`Could not resolve tag: ${e}`),
            null)
        }
        tagString(e) {
            for (const [t,n] of Object.entries(this.tags))
                if (e.startsWith(n))
                    return t + e.substring(n.length).replace(/[!,[\]{}]/g, (e=>KS[e]));
            return "!" === e[0] ? e : `!<${e}>`
        }
        toString(e) {
            const t = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : []
              , n = Object.entries(this.tags);
            let r;
            if (e && n.length > 0 && HS(e.contents)) {
                const t = {};
                GS(e.contents, ((e,n)=>{
                    HS(n) && n.tag && (t[n.tag] = !0)
                }
                )),
                r = Object.keys(t)
            } else
                r = [];
            for (const [o,i] of n)
                "!!" === o && "tag:yaml.org,2002:" === i || e && !r.some((e=>e.startsWith(i))) || t.push(`%TAG ${o} ${i}`);
            return t.join("\n")
        }
    }
    function eE(e) {
        if (/[\x00-\x19\s,[\]{}]/.test(e)) {
            const t = JSON.stringify(e);
            throw new Error(`Anchor must not contain whitespace or control characters: ${t}`)
        }
        return !0
    }
    function tE(e) {
        const t = new Set;
        return GS(e, {
            Value(e, n) {
                n.anchor && t.add(n.anchor)
            }
        }),
        t
    }
    function nE(e, t) {
        for (let n = 1; ; ++n) {
            const r = `${e}${n}`;
            if (!t.has(r))
                return r
        }
    }
    function rE(e, t, n, r) {
        if (r && "object" == typeof r)
            if (Array.isArray(r))
                for (let o = 0, i = r.length; o < i; ++o) {
                    const t = r[o]
                      , n = rE(e, r, String(o), t);
                    void 0 === n ? delete r[o] : n !== t && (r[o] = n)
                }
            else if (r instanceof Map)
                for (const o of Array.from(r.keys())) {
                    const t = r.get(o)
                      , n = rE(e, r, o, t);
                    void 0 === n ? r.delete(o) : n !== t && r.set(o, n)
                }
            else if (r instanceof Set)
                for (const o of Array.from(r)) {
                    const t = rE(e, r, o, o);
                    void 0 === t ? r.delete(o) : t !== o && (r.delete(o),
                    r.add(t))
                }
            else
                for (const [o,i] of Object.entries(r)) {
                    const t = rE(e, r, o, i);
                    void 0 === t ? delete r[o] : t !== i && (r[o] = t)
                }
        return e.call(t, n, r)
    }
    function oE(e, t, n) {
        if (Array.isArray(e))
            return e.map(((e,t)=>oE(e, String(t), n)));
        if (e && "function" == typeof e.toJSON) {
            if (!n || !ZS(e))
                return e.toJSON(t, n);
            const r = {
                aliasCount: 0,
                count: 1,
                res: void 0
            };
            n.anchors.set(e, r),
            n.onCreate = e=>{
                r.res = e,
                delete n.onCreate
            }
            ;
            const o = e.toJSON(t, n);
            return n.onCreate && n.onCreate(o),
            o
        }
        return "bigint" != typeof e || (null == n ? void 0 : n.keep) ? e : Number(e)
    }
    JS.defaultYaml = {
        explicit: !1,
        version: "1.2"
    },
    JS.defaultTags = {
        "!!": "tag:yaml.org,2002:"
    };
    class iE {
        constructor(e) {
            Object.defineProperty(this, LS, {
                value: e
            })
        }
        clone() {
            const e = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
            return this.range && (e.range = this.range.slice()),
            e
        }
        toJS(e, {mapAsMap: t, maxAliasCount: n, onAnchor: r, reviver: o}={}) {
            if (!BS(e))
                throw new TypeError("A document argument is required");
            const i = {
                anchors: new Map,
                doc: e,
                keep: !0,
                mapAsMap: !0 === t,
                mapKeyWarned: !1,
                maxAliasCount: "number" == typeof n ? n : 100
            }
              , a = oE(this, "", i);
            if ("function" == typeof r)
                for (const {count: s, res: l} of i.anchors.values())
                    r(l, s);
            return "function" == typeof o ? rE(o, {
                "": a
            }, "", a) : a
        }
    }
    let aE = class extends iE {
        constructor(e) {
            super(DS),
            this.source = e,
            Object.defineProperty(this, "tag", {
                set() {
                    throw new Error("Alias nodes cannot have tags")
                }
            })
        }
        resolve(e) {
            let t;
            return GS(e, {
                Node: (e,n)=>{
                    if (n === this)
                        return GS.BREAK;
                    n.anchor === this.source && (t = n)
                }
            }),
            t
        }
        toJSON(e, t) {
            if (!t)
                return {
                    source: this.source
                };
            const {anchors: n, doc: r, maxAliasCount: o} = t
              , i = this.resolve(r);
            if (!i) {
                const e = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                throw new ReferenceError(e)
            }
            let a = n.get(i);
            if (a || (oE(i, null, t),
            a = n.get(i)),
            !a || void 0 === a.res) {
                throw new ReferenceError("This should not happen: Alias anchor was not resolved?")
            }
            if (o >= 0 && (a.count += 1,
            0 === a.aliasCount && (a.aliasCount = sE(r, i, n)),
            a.count * a.aliasCount > o)) {
                throw new ReferenceError("Excessive alias count indicates a resource exhaustion attack")
            }
            return a.res
        }
        toString(e, t, n) {
            const r = `*${this.source}`;
            if (e) {
                if (eE(this.source),
                e.options.verifyAliasOrder && !e.anchors.has(this.source)) {
                    const e = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                    throw new Error(e)
                }
                if (e.implicitKey)
                    return `${r} `
            }
            return r
        }
    }
    ;
    function sE(e, t, n) {
        if (QS(t)) {
            const r = t.resolve(e)
              , o = n && r && n.get(r);
            return o ? o.count * o.aliasCount : 0
        }
        if (qS(t)) {
            let r = 0;
            for (const o of t.items) {
                const t = sE(e, o, n);
                t > r && (r = t)
            }
            return r
        }
        if (FS(t)) {
            const r = sE(e, t.key, n)
              , o = sE(e, t.value, n);
            return Math.max(r, o)
        }
        return 1
    }
    const lE = e=>!e || "function" != typeof e && "object" != typeof e;
    class cE extends iE {
        constructor(e) {
            super(IS),
            this.value = e
        }
        toJSON(e, t) {
            return (null == t ? void 0 : t.keep) ? this.value : oE(this.value, e, t)
        }
        toString() {
            return String(this.value)
        }
    }
    cE.BLOCK_FOLDED = "BLOCK_FOLDED",
    cE.BLOCK_LITERAL = "BLOCK_LITERAL",
    cE.PLAIN = "PLAIN",
    cE.QUOTE_DOUBLE = "QUOTE_DOUBLE",
    cE.QUOTE_SINGLE = "QUOTE_SINGLE";
    const uE = "tag:yaml.org,2002:";
    function dE(e, t, n) {
        var r, o, i;
        if (BS(e) && (e = e.contents),
        HS(e))
            return e;
        if (FS(e)) {
            const t = null == (o = (r = n.schema[NS]).createNode) ? void 0 : o.call(r, n.schema, null, n);
            return t.items.push(e),
            t
        }
        (e instanceof String || e instanceof Number || e instanceof Boolean || "undefined" != typeof BigInt && e instanceof BigInt) && (e = e.valueOf());
        const {aliasDuplicateObjects: a, onAnchor: s, onTagObj: l, schema: c, sourceObjects: u} = n;
        let d;
        if (a && e && "object" == typeof e) {
            if (d = u.get(e),
            d)
                return d.anchor || (d.anchor = s(e)),
                new aE(d.anchor);
            d = {
                anchor: null,
                node: null
            },
            u.set(e, d)
        }
        (null == t ? void 0 : t.startsWith("!!")) && (t = uE + t.slice(2));
        let p = function(e, t, n) {
            if (t) {
                const e = n.filter((e=>e.tag === t))
                  , r = e.find((e=>!e.format)) ?? e[0];
                if (!r)
                    throw new Error(`Tag ${t} not found`);
                return r
            }
            return n.find((t=>{
                var n;
                return (null == (n = t.identify) ? void 0 : n.call(t, e)) && !t.format
            }
            ))
        }(e, t, c.tags);
        if (!p) {
            if (e && "function" == typeof e.toJSON && (e = e.toJSON()),
            !e || "object" != typeof e) {
                const t = new cE(e);
                return d && (d.node = t),
                t
            }
            p = e instanceof Map ? c[NS] : Symbol.iterator in Object(e) ? c[MS] : c[NS]
        }
        l && (l(p),
        delete n.onTagObj);
        const h = (null == p ? void 0 : p.createNode) ? p.createNode(n.schema, e, n) : "function" == typeof (null == (i = null == p ? void 0 : p.nodeClass) ? void 0 : i.from) ? p.nodeClass.from(n.schema, e, n) : new cE(e);
        return t ? h.tag = t : p.default || (h.tag = p.tag),
        d && (d.node = h),
        h
    }
    function pE(e, t, n) {
        let r = n;
        for (let o = t.length - 1; o >= 0; --o) {
            const e = t[o];
            if ("number" == typeof e && Number.isInteger(e) && e >= 0) {
                const t = [];
                t[e] = r,
                r = t
            } else
                r = new Map([[e, r]])
        }
        return dE(r, void 0, {
            aliasDuplicateObjects: !1,
            keepUndefined: !1,
            onAnchor: ()=>{
                throw new Error("This should not happen, please report a bug.")
            }
            ,
            schema: e,
            sourceObjects: new Map
        })
    }
    const hE = e=>null == e || "object" == typeof e && !!e[Symbol.iterator]().next().done;
    class fE extends iE {
        constructor(e, t) {
            super(e),
            Object.defineProperty(this, "schema", {
                value: t,
                configurable: !0,
                enumerable: !1,
                writable: !0
            })
        }
        clone(e) {
            const t = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
            return e && (t.schema = e),
            t.items = t.items.map((t=>HS(t) || FS(t) ? t.clone(e) : t)),
            this.range && (t.range = this.range.slice()),
            t
        }
        addIn(e, t) {
            if (hE(e))
                this.add(t);
            else {
                const [n,...r] = e
                  , o = this.get(n, !0);
                if (qS(o))
                    o.addIn(r, t);
                else {
                    if (void 0 !== o || !this.schema)
                        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${r}`);
                    this.set(n, pE(this.schema, r, t))
                }
            }
        }
        deleteIn(e) {
            const [t,...n] = e;
            if (0 === n.length)
                return this.delete(t);
            const r = this.get(t, !0);
            if (qS(r))
                return r.deleteIn(n);
            throw new Error(`Expected YAML collection at ${t}. Remaining path: ${n}`)
        }
        getIn(e, t) {
            const [n,...r] = e
              , o = this.get(n, !0);
            return 0 === r.length ? !t && jS(o) ? o.value : o : qS(o) ? o.getIn(r, t) : void 0
        }
        hasAllNullValues(e) {
            return this.items.every((t=>{
                if (!FS(t))
                    return !1;
                const n = t.value;
                return null == n || e && jS(n) && null == n.value && !n.commentBefore && !n.comment && !n.tag
            }
            ))
        }
        hasIn(e) {
            const [t,...n] = e;
            if (0 === n.length)
                return this.has(t);
            const r = this.get(t, !0);
            return !!qS(r) && r.hasIn(n)
        }
        setIn(e, t) {
            const [n,...r] = e;
            if (0 === r.length)
                this.set(n, t);
            else {
                const e = this.get(n, !0);
                if (qS(e))
                    e.setIn(r, t);
                else {
                    if (void 0 !== e || !this.schema)
                        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${r}`);
                    this.set(n, pE(this.schema, r, t))
                }
            }
        }
    }
    fE.maxFlowStringSingleLineLength = 60;
    const mE = e=>e.replace(/^(?!$)(?: $)?/gm, "#");
    function gE(e, t) {
        return /^\n+$/.test(e) ? e.substring(1) : t ? e.replace(/^(?! *$)/gm, t) : e
    }
    const bE = (e,t,n)=>e.endsWith("\n") ? gE(n, t) : n.includes("\n") ? "\n" + gE(n, t) : (e.endsWith(" ") ? "" : " ") + n
      , OE = "flow"
      , vE = "block"
      , yE = "quoted";
    function wE(e, t, n="flow", {indentAtStart: r, lineWidth: o=80, minContentWidth: i=20, onFold: a, onOverflow: s}={}) {
        if (!o || o < 0)
            return e;
        const l = Math.max(1 + i, 1 + o - t.length);
        if (e.length <= l)
            return e;
        const c = []
          , u = {};
        let d, p, h = o - t.length;
        "number" == typeof r && (r > o - Math.max(2, i) ? c.push(0) : h = o - r);
        let f = !1
          , m = -1
          , g = -1
          , b = -1;
        n === vE && (m = _E(e, m, t.length),
        -1 !== m && (h = m + l));
        for (let v; v = e[m += 1]; ) {
            if (n === yE && "\\" === v) {
                switch (g = m,
                e[m + 1]) {
                case "x":
                    m += 3;
                    break;
                case "u":
                    m += 5;
                    break;
                case "U":
                    m += 9;
                    break;
                default:
                    m += 1
                }
                b = m
            }
            if ("\n" === v)
                n === vE && (m = _E(e, m, t.length)),
                h = m + t.length + l,
                d = void 0;
            else {
                if (" " === v && p && " " !== p && "\n" !== p && "\t" !== p) {
                    const t = e[m + 1];
                    t && " " !== t && "\n" !== t && "\t" !== t && (d = m)
                }
                if (m >= h)
                    if (d)
                        c.push(d),
                        h = d + l,
                        d = void 0;
                    else if (n === yE) {
                        for (; " " === p || "\t" === p; )
                            p = v,
                            v = e[m += 1],
                            f = !0;
                        const t = m > b + 1 ? m - 2 : g - 1;
                        if (u[t])
                            return e;
                        c.push(t),
                        u[t] = !0,
                        h = t + l,
                        d = void 0
                    } else
                        f = !0
            }
            p = v
        }
        if (f && s && s(),
        0 === c.length)
            return e;
        a && a();
        let O = e.slice(0, c[0]);
        for (let v = 0; v < c.length; ++v) {
            const r = c[v]
              , o = c[v + 1] || e.length;
            0 === r ? O = `\n${t}${e.slice(0, o)}` : (n === yE && u[r] && (O += `${e[r]}\\`),
            O += `\n${t}${e.slice(r + 1, o)}`)
        }
        return O
    }
    function _E(e, t, n) {
        let r = t
          , o = t + 1
          , i = e[o];
        for (; " " === i || "\t" === i; )
            if (t < o + n)
                i = e[++t];
            else {
                do {
                    i = e[++t]
                } while (i && "\n" !== i);
                r = t,
                o = t + 1,
                i = e[o]
            }
        return r
    }
    const kE = (e,t)=>({
        indentAtStart: t ? e.indent.length : e.indentAtStart,
        lineWidth: e.options.lineWidth,
        minContentWidth: e.options.minContentWidth
    })
      , SE = e=>/^(%|---|\.\.\.)/m.test(e);
    function EE(e, t) {
        const n = JSON.stringify(e);
        if (t.options.doubleQuotedAsJSON)
            return n;
        const {implicitKey: r} = t
          , o = t.options.doubleQuotedMinMultiLineLength
          , i = t.indent || (SE(e) ? "  " : "");
        let a = ""
          , s = 0;
        for (let l = 0, c = n[l]; c; c = n[++l])
            if (" " === c && "\\" === n[l + 1] && "n" === n[l + 2] && (a += n.slice(s, l) + "\\ ",
            l += 1,
            s = l,
            c = "\\"),
            "\\" === c)
                switch (n[l + 1]) {
                case "u":
                    {
                        a += n.slice(s, l);
                        const e = n.substr(l + 2, 4);
                        switch (e) {
                        case "0000":
                            a += "\\0";
                            break;
                        case "0007":
                            a += "\\a";
                            break;
                        case "000b":
                            a += "\\v";
                            break;
                        case "001b":
                            a += "\\e";
                            break;
                        case "0085":
                            a += "\\N";
                            break;
                        case "00a0":
                            a += "\\_";
                            break;
                        case "2028":
                            a += "\\L";
                            break;
                        case "2029":
                            a += "\\P";
                            break;
                        default:
                            "00" === e.substr(0, 2) ? a += "\\x" + e.substr(2) : a += n.substr(l, 6)
                        }
                        l += 5,
                        s = l + 1
                    }
                    break;
                case "n":
                    if (r || '"' === n[l + 2] || n.length < o)
                        l += 1;
                    else {
                        for (a += n.slice(s, l) + "\n\n"; "\\" === n[l + 2] && "n" === n[l + 3] && '"' !== n[l + 4]; )
                            a += "\n",
                            l += 2;
                        a += i,
                        " " === n[l + 2] && (a += "\\"),
                        l += 1,
                        s = l + 1
                    }
                    break;
                default:
                    l += 1
                }
        return a = s ? a + n.slice(s) : n,
        r ? a : wE(a, i, yE, kE(t, !1))
    }
    function xE(e, t) {
        if (!1 === t.options.singleQuote || t.implicitKey && e.includes("\n") || /[ \t]\n|\n[ \t]/.test(e))
            return EE(e, t);
        const n = t.indent || (SE(e) ? "  " : "")
          , r = "'" + e.replace(/'/g, "''").replace(/\n+/g, `$&\n${n}`) + "'";
        return t.implicitKey ? r : wE(r, n, OE, kE(t, !1))
    }
    function TE(e, t) {
        const {singleQuote: n} = t.options;
        let r;
        if (!1 === n)
            r = EE;
        else {
            const t = e.includes('"')
              , o = e.includes("'");
            r = t && !o ? xE : o && !t ? EE : n ? xE : EE
        }
        return r(e, t)
    }
    let AE;
    try {
        AE = new RegExp("(^|(?<!\n))\n+(?!\n|$)","g")
    } catch {
        AE = /\n+(?!\n|$)/g
    }
    function CE({comment: e, type: t, value: n}, r, o, i) {
        const {blockQuote: a, commentString: s, lineWidth: l} = r.options;
        if (!a || /\n[\t ]+$/.test(n) || /^\s*$/.test(n))
            return TE(n, r);
        const c = r.indent || (r.forceBlockIndent || SE(n) ? "  " : "")
          , u = "literal" === a || "folded" !== a && t !== cE.BLOCK_FOLDED && (t === cE.BLOCK_LITERAL || !function(e, t, n) {
            if (!t || t < 0)
                return !1;
            const r = t - n
              , o = e.length;
            if (o <= r)
                return !1;
            for (let i = 0, a = 0; i < o; ++i)
                if ("\n" === e[i]) {
                    if (i - a > r)
                        return !0;
                    if (a = i + 1,
                    o - a <= r)
                        return !1
                }
            return !0
        }(n, l, c.length));
        if (!n)
            return u ? "|\n" : ">\n";
        let d, p;
        for (p = n.length; p > 0; --p) {
            const e = n[p - 1];
            if ("\n" !== e && "\t" !== e && " " !== e)
                break
        }
        let h = n.substring(p);
        const f = h.indexOf("\n");
        -1 === f ? d = "-" : n === h || f !== h.length - 1 ? (d = "+",
        i && i()) : d = "",
        h && (n = n.slice(0, -h.length),
        "\n" === h[h.length - 1] && (h = h.slice(0, -1)),
        h = h.replace(AE, `$&${c}`));
        let m, g = !1, b = -1;
        for (m = 0; m < n.length; ++m) {
            const e = n[m];
            if (" " === e)
                g = !0;
            else {
                if ("\n" !== e)
                    break;
                b = m
            }
        }
        let O = n.substring(0, b < m ? b + 1 : m);
        O && (n = n.substring(O.length),
        O = O.replace(/\n+/g, `$&${c}`));
        let v = (u ? "|" : ">") + (g ? c ? "2" : "1" : "") + d;
        if (e && (v += " " + s(e.replace(/ ?[\r\n]+/g, " ")),
        o && o()),
        u)
            return `${v}\n${c}${O}${n = n.replace(/\n+/g, `$&${c}`)}${h}`;
        return `${v}\n${c}${wE(`${O}${n = n.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${c}`)}${h}`, c, vE, kE(r, !0))}`
    }
    function PE(e, t, n, r) {
        const {implicitKey: o, inFlow: i} = t
          , a = "string" == typeof e.value ? e : Object.assign({}, e, {
            value: String(e.value)
        });
        let {type: s} = e;
        s !== cE.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(a.value) && (s = cE.QUOTE_DOUBLE);
        const l = e=>{
            switch (e) {
            case cE.BLOCK_FOLDED:
            case cE.BLOCK_LITERAL:
                return o || i ? TE(a.value, t) : CE(a, t, n, r);
            case cE.QUOTE_DOUBLE:
                return EE(a.value, t);
            case cE.QUOTE_SINGLE:
                return xE(a.value, t);
            case cE.PLAIN:
                return function(e, t, n, r) {
                    const {type: o, value: i} = e
                      , {actualString: a, implicitKey: s, indent: l, indentStep: c, inFlow: u} = t;
                    if (s && i.includes("\n") || u && /[[\]{},]/.test(i))
                        return TE(i, t);
                    if (!i || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(i))
                        return s || u || !i.includes("\n") ? TE(i, t) : CE(e, t, n, r);
                    if (!s && !u && o !== cE.PLAIN && i.includes("\n"))
                        return CE(e, t, n, r);
                    if (SE(i)) {
                        if ("" === l)
                            return t.forceBlockIndent = !0,
                            CE(e, t, n, r);
                        if (s && l === c)
                            return TE(i, t)
                    }
                    const d = i.replace(/\n+/g, `$&\n${l}`);
                    if (a) {
                        const e = e=>{
                            var t;
                            return e.default && "tag:yaml.org,2002:str" !== e.tag && (null == (t = e.test) ? void 0 : t.test(d))
                        }
                          , {compat: n, tags: r} = t.doc.schema;
                        if (r.some(e) || (null == n ? void 0 : n.some(e)))
                            return TE(i, t)
                    }
                    return s ? d : wE(d, l, OE, kE(t, !1))
                }(a, t, n, r);
            default:
                return null
            }
        }
        ;
        let c = l(s);
        if (null === c) {
            const {defaultKeyType: e, defaultStringType: n} = t.options
              , r = o && e || n;
            if (c = l(r),
            null === c)
                throw new Error(`Unsupported default string type ${r}`)
        }
        return c
    }
    function DE(e, t) {
        const n = Object.assign({
            blockQuote: !0,
            commentString: mE,
            defaultKeyType: null,
            defaultStringType: "PLAIN",
            directives: null,
            doubleQuotedAsJSON: !1,
            doubleQuotedMinMultiLineLength: 40,
            falseStr: "false",
            flowCollectionPadding: !0,
            indentSeq: !0,
            lineWidth: 80,
            minContentWidth: 20,
            nullStr: "null",
            simpleKeys: !1,
            singleQuote: null,
            trueStr: "true",
            verifyAliasOrder: !0
        }, e.schema.toStringOptions, t);
        let r;
        switch (n.collectionStyle) {
        case "block":
            r = !1;
            break;
        case "flow":
            r = !0;
            break;
        default:
            r = null
        }
        return {
            anchors: new Set,
            doc: e,
            flowCollectionPadding: n.flowCollectionPadding ? " " : "",
            indent: "",
            indentStep: "number" == typeof n.indent ? " ".repeat(n.indent) : "  ",
            inFlow: r,
            options: n
        }
    }
    function RE(e, t, n, r) {
        var o;
        if (FS(e))
            return e.toString(t, n, r);
        if (QS(e)) {
            if (t.doc.directives)
                return e.toString(t);
            if (null == (o = t.resolvedAliases) ? void 0 : o.has(e))
                throw new TypeError("Cannot stringify circular structure without alias nodes");
            t.resolvedAliases ? t.resolvedAliases.add(e) : t.resolvedAliases = new Set([e]),
            e = e.resolve(t.doc)
        }
        let i;
        const a = HS(e) ? e : t.doc.createNode(e, {
            onTagObj: e=>i = e
        });
        i || (i = function(e, t) {
            var n;
            if (t.tag) {
                const n = e.filter((e=>e.tag === t.tag));
                if (n.length > 0)
                    return n.find((e=>e.format === t.format)) ?? n[0]
            }
            let r, o;
            if (jS(t)) {
                o = t.value;
                const n = e.filter((e=>{
                    var t;
                    return null == (t = e.identify) ? void 0 : t.call(e, o)
                }
                ));
                r = n.find((e=>e.format === t.format)) ?? n.find((e=>!e.format))
            } else
                o = t,
                r = e.find((e=>e.nodeClass && o instanceof e.nodeClass));
            if (!r) {
                const e = (null == (n = null == o ? void 0 : o.constructor) ? void 0 : n.name) ?? typeof o;
                throw new Error(`Tag not resolved for ${e} value`)
            }
            return r
        }(t.doc.schema.tags, a));
        const s = function(e, t, {anchors: n, doc: r}) {
            if (!r.directives)
                return "";
            const o = []
              , i = (jS(e) || qS(e)) && e.anchor;
            i && eE(i) && (n.add(i),
            o.push(`&${i}`));
            const a = e.tag ? e.tag : t.default ? null : t.tag;
            return a && o.push(r.directives.tagString(a)),
            o.join(" ")
        }(a, i, t);
        s.length > 0 && (t.indentAtStart = (t.indentAtStart ?? 0) + s.length + 1);
        const l = "function" == typeof i.stringify ? i.stringify(a, t, n, r) : jS(a) ? PE(a, t, n, r) : a.toString(t, n, r);
        return s ? jS(a) || "{" === l[0] || "[" === l[0] ? `${s} ${l}` : `${s}\n${t.indent}${l}` : l
    }
    function NE(e, t) {
        "debug" !== e && "warn" !== e || ("undefined" != typeof process && process.emitWarning ? process.emitWarning(t) : console.warn(t))
    }
    function $E(e, t, {key: n, value: r}) {
        if ((null == e ? void 0 : e.doc.schema.merge) && IE(n))
            if (r = QS(r) ? r.resolve(e.doc) : r,
            zS(r))
                for (const o of r.items)
                    ME(e, t, o);
            else if (Array.isArray(r))
                for (const o of r)
                    ME(e, t, o);
            else
                ME(e, t, r);
        else {
            const o = oE(n, "", e);
            if (t instanceof Map)
                t.set(o, oE(r, o, e));
            else if (t instanceof Set)
                t.add(o);
            else {
                const i = function(e, t, n) {
                    if (null === t)
                        return "";
                    if ("object" != typeof t)
                        return String(t);
                    if (HS(e) && (null == n ? void 0 : n.doc)) {
                        const t = DE(n.doc, {});
                        t.anchors = new Set;
                        for (const e of n.anchors.keys())
                            t.anchors.add(e.anchor);
                        t.inFlow = !0,
                        t.inStringifyKey = !0;
                        const r = e.toString(t);
                        if (!n.mapKeyWarned) {
                            let e = JSON.stringify(r);
                            e.length > 40 && (e = e.substring(0, 36) + '..."'),
                            NE(n.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${e}. Set mapAsMap: true to use object keys.`),
                            n.mapKeyWarned = !0
                        }
                        return r
                    }
                    return JSON.stringify(t)
                }(n, o, e)
                  , a = oE(r, i, e);
                i in t ? Object.defineProperty(t, i, {
                    value: a,
                    writable: !0,
                    enumerable: !0,
                    configurable: !0
                }) : t[i] = a
            }
        }
        return t
    }
    const IE = e=>"<<" === e || jS(e) && "<<" === e.value && (!e.type || e.type === cE.PLAIN);
    function ME(e, t, n) {
        const r = e && QS(n) ? n.resolve(e.doc) : n;
        if (!US(r))
            throw new Error("Merge sources must be maps or map aliases");
        const o = r.toJSON(null, e, Map);
        for (const [i,a] of o)
            t instanceof Map ? t.has(i) || t.set(i, a) : t instanceof Set ? t.add(i) : Object.prototype.hasOwnProperty.call(t, i) || Object.defineProperty(t, i, {
                value: a,
                writable: !0,
                enumerable: !0,
                configurable: !0
            });
        return t
    }
    function LE(e, t, n) {
        const r = dE(e, void 0, n)
          , o = dE(t, void 0, n);
        return new QE(r,o)
    }
    class QE {
        constructor(e, t=null) {
            Object.defineProperty(this, LS, {
                value: $S
            }),
            this.key = e,
            this.value = t
        }
        clone(e) {
            let {key: t, value: n} = this;
            return HS(t) && (t = t.clone(e)),
            HS(n) && (n = n.clone(e)),
            new QE(t,n)
        }
        toJSON(e, t) {
            return $E(t, (null == t ? void 0 : t.mapAsMap) ? new Map : {}, this)
        }
        toString(e, t, n) {
            return (null == e ? void 0 : e.doc) ? function({key: e, value: t}, n, r, o) {
                const {allNullValues: i, doc: a, indent: s, indentStep: l, options: {commentString: c, indentSeq: u, simpleKeys: d}} = n;
                let p = HS(e) && e.comment || null;
                if (d) {
                    if (p)
                        throw new Error("With simple keys, key nodes cannot have comments");
                    if (qS(e) || !HS(e) && "object" == typeof e)
                        throw new Error("With simple keys, collection cannot be used as a key value")
                }
                let h = !d && (!e || p && null == t && !n.inFlow || qS(e) || (jS(e) ? e.type === cE.BLOCK_FOLDED || e.type === cE.BLOCK_LITERAL : "object" == typeof e));
                n = Object.assign({}, n, {
                    allNullValues: !1,
                    implicitKey: !h && (d || !i),
                    indent: s + l
                });
                let f, m, g, b = !1, O = !1, v = RE(e, n, (()=>b = !0), (()=>O = !0));
                if (!h && !n.inFlow && v.length > 1024) {
                    if (d)
                        throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
                    h = !0
                }
                if (n.inFlow) {
                    if (i || null == t)
                        return b && r && r(),
                        "" === v ? "?" : h ? `? ${v}` : v
                } else if (i && !d || null == t && h)
                    return v = `? ${v}`,
                    p && !b ? v += bE(v, n.indent, c(p)) : O && o && o(),
                    v;
                b && (p = null),
                h ? (p && (v += bE(v, n.indent, c(p))),
                v = `? ${v}\n${s}:`) : (v = `${v}:`,
                p && (v += bE(v, n.indent, c(p)))),
                HS(t) ? (f = !!t.spaceBefore,
                m = t.commentBefore,
                g = t.comment) : (f = !1,
                m = null,
                g = null,
                t && "object" == typeof t && (t = a.createNode(t))),
                n.implicitKey = !1,
                h || p || !jS(t) || (n.indentAtStart = v.length + 1),
                O = !1,
                u || !(l.length >= 2) || n.inFlow || h || !zS(t) || t.flow || t.tag || t.anchor || (n.indent = n.indent.substring(2));
                let y = !1;
                const w = RE(t, n, (()=>y = !0), (()=>O = !0));
                let _ = " ";
                if (p || f || m)
                    _ = f ? "\n" : "",
                    m && (_ += `\n${gE(c(m), n.indent)}`),
                    "" !== w || n.inFlow ? _ += `\n${n.indent}` : "\n" === _ && (_ = "\n\n");
                else if (!h && qS(t)) {
                    const e = w[0]
                      , r = w.indexOf("\n")
                      , o = -1 !== r
                      , i = n.inFlow ?? t.flow ?? 0 === t.items.length;
                    if (o || !i) {
                        let t = !1;
                        if (o && ("&" === e || "!" === e)) {
                            let n = w.indexOf(" ");
                            "&" === e && -1 !== n && n < r && "!" === w[n + 1] && (n = w.indexOf(" ", n + 1)),
                            (-1 === n || r < n) && (t = !0)
                        }
                        t || (_ = `\n${n.indent}`)
                    }
                } else
                    "" !== w && "\n" !== w[0] || (_ = "");
                return v += _ + w,
                n.inFlow ? y && r && r() : g && !y ? v += bE(v, n.indent, c(g)) : O && o && o(),
                v
            }(this, e, t, n) : JSON.stringify(this)
        }
    }
    function BE(e, t, n) {
        return (t.inFlow ?? e.flow ? FE : UE)(e, t, n)
    }
    function UE({comment: e, items: t}, n, {blockItemPrefix: r, flowChars: o, itemIndent: i, onChompKeep: a, onComment: s}) {
        const {indent: l, options: {commentString: c}} = n
          , u = Object.assign({}, n, {
            indent: i,
            type: null
        });
        let d = !1;
        const p = [];
        for (let f = 0; f < t.length; ++f) {
            const e = t[f];
            let o = null;
            if (HS(e))
                !d && e.spaceBefore && p.push(""),
                jE(n, p, e.commentBefore, d),
                e.comment && (o = e.comment);
            else if (FS(e)) {
                const t = HS(e.key) ? e.key : null;
                t && (!d && t.spaceBefore && p.push(""),
                jE(n, p, t.commentBefore, d))
            }
            d = !1;
            let a = RE(e, u, (()=>o = null), (()=>d = !0));
            o && (a += bE(a, i, c(o))),
            d && o && (d = !1),
            p.push(r + a)
        }
        let h;
        if (0 === p.length)
            h = o.start + o.end;
        else {
            h = p[0];
            for (let e = 1; e < p.length; ++e) {
                const t = p[e];
                h += t ? `\n${l}${t}` : "\n"
            }
        }
        return e ? (h += "\n" + gE(c(e), l),
        s && s()) : d && a && a(),
        h
    }
    function FE({items: e}, t, {flowChars: n, itemIndent: r}) {
        const {indent: o, indentStep: i, flowCollectionPadding: a, options: {commentString: s}} = t;
        r += i;
        const l = Object.assign({}, t, {
            indent: r,
            inFlow: !0,
            type: null
        });
        let c = !1
          , u = 0;
        const d = [];
        for (let f = 0; f < e.length; ++f) {
            const n = e[f];
            let o = null;
            if (HS(n))
                n.spaceBefore && d.push(""),
                jE(t, d, n.commentBefore, !1),
                n.comment && (o = n.comment);
            else if (FS(n)) {
                const e = HS(n.key) ? n.key : null;
                e && (e.spaceBefore && d.push(""),
                jE(t, d, e.commentBefore, !1),
                e.comment && (c = !0));
                const r = HS(n.value) ? n.value : null;
                r ? (r.comment && (o = r.comment),
                r.commentBefore && (c = !0)) : null == n.value && (null == e ? void 0 : e.comment) && (o = e.comment)
            }
            o && (c = !0);
            let i = RE(n, l, (()=>o = null));
            f < e.length - 1 && (i += ","),
            o && (i += bE(i, r, s(o))),
            !c && (d.length > u || i.includes("\n")) && (c = !0),
            d.push(i),
            u = d.length
        }
        const {start: p, end: h} = n;
        if (0 === d.length)
            return p + h;
        if (!c) {
            const e = d.reduce(((e,t)=>e + t.length + 2), 2);
            c = t.options.lineWidth > 0 && e > t.options.lineWidth
        }
        if (c) {
            let e = p;
            for (const t of d)
                e += t ? `\n${i}${o}${t}` : "\n";
            return `${e}\n${o}${h}`
        }
        return `${p}${a}${d.join(" ")}${a}${h}`
    }
    function jE({indent: e, options: {commentString: t}}, n, r, o) {
        if (r && o && (r = r.replace(/^\n+/, "")),
        r) {
            const o = gE(t(r), e);
            n.push(o.trimStart())
        }
    }
    function zE(e, t) {
        const n = jS(t) ? t.value : t;
        for (const r of e)
            if (FS(r)) {
                if (r.key === t || r.key === n)
                    return r;
                if (jS(r.key) && r.key.value === n)
                    return r
            }
    }
    class qE extends fE {
        static get tagName() {
            return "tag:yaml.org,2002:map"
        }
        constructor(e) {
            super(NS, e),
            this.items = []
        }
        static from(e, t, n) {
            const {keepUndefined: r, replacer: o} = n
              , i = new this(e)
              , a = (e,a)=>{
                if ("function" == typeof o)
                    a = o.call(t, e, a);
                else if (Array.isArray(o) && !o.includes(e))
                    return;
                (void 0 !== a || r) && i.items.push(LE(e, a, n))
            }
            ;
            if (t instanceof Map)
                for (const [s,l] of t)
                    a(s, l);
            else if (t && "object" == typeof t)
                for (const s of Object.keys(t))
                    a(s, t[s]);
            return "function" == typeof e.sortMapEntries && i.items.sort(e.sortMapEntries),
            i
        }
        add(e, t) {
            var n;
            let r;
            r = FS(e) ? e : e && "object" == typeof e && "key"in e ? new QE(e.key,e.value) : new QE(e,null == e ? void 0 : e.value);
            const o = zE(this.items, r.key)
              , i = null == (n = this.schema) ? void 0 : n.sortMapEntries;
            if (o) {
                if (!t)
                    throw new Error(`Key ${r.key} already set`);
                jS(o.value) && lE(r.value) ? o.value.value = r.value : o.value = r.value
            } else if (i) {
                const e = this.items.findIndex((e=>i(r, e) < 0));
                -1 === e ? this.items.push(r) : this.items.splice(e, 0, r)
            } else
                this.items.push(r)
        }
        delete(e) {
            const t = zE(this.items, e);
            if (!t)
                return !1;
            return this.items.splice(this.items.indexOf(t), 1).length > 0
        }
        get(e, t) {
            const n = zE(this.items, e)
              , r = null == n ? void 0 : n.value;
            return (!t && jS(r) ? r.value : r) ?? void 0
        }
        has(e) {
            return !!zE(this.items, e)
        }
        set(e, t) {
            this.add(new QE(e,t), !0)
        }
        toJSON(e, t, n) {
            const r = n ? new n : (null == t ? void 0 : t.mapAsMap) ? new Map : {};
            (null == t ? void 0 : t.onCreate) && t.onCreate(r);
            for (const o of this.items)
                $E(t, r, o);
            return r
        }
        toString(e, t, n) {
            if (!e)
                return JSON.stringify(this);
            for (const r of this.items)
                if (!FS(r))
                    throw new Error(`Map items must all be pairs; found ${JSON.stringify(r)} instead`);
            return !e.allNullValues && this.hasAllNullValues(!1) && (e = Object.assign({}, e, {
                allNullValues: !0
            })),
            BE(this, e, {
                blockItemPrefix: "",
                flowChars: {
                    start: "{",
                    end: "}"
                },
                itemIndent: e.indent || "",
                onChompKeep: n,
                onComment: t
            })
        }
    }
    const HE = {
        collection: "map",
        default: !0,
        nodeClass: qE,
        tag: "tag:yaml.org,2002:map",
        resolve: (e,t)=>(US(e) || t("Expected a mapping for this tag"),
        e),
        createNode: (e,t,n)=>qE.from(e, t, n)
    };
    class ZE extends fE {
        static get tagName() {
            return "tag:yaml.org,2002:seq"
        }
        constructor(e) {
            super(MS, e),
            this.items = []
        }
        add(e) {
            this.items.push(e)
        }
        delete(e) {
            const t = WE(e);
            if ("number" != typeof t)
                return !1;
            return this.items.splice(t, 1).length > 0
        }
        get(e, t) {
            const n = WE(e);
            if ("number" != typeof n)
                return;
            const r = this.items[n];
            return !t && jS(r) ? r.value : r
        }
        has(e) {
            const t = WE(e);
            return "number" == typeof t && t < this.items.length
        }
        set(e, t) {
            const n = WE(e);
            if ("number" != typeof n)
                throw new Error(`Expected a valid index, not ${e}.`);
            const r = this.items[n];
            jS(r) && lE(t) ? r.value = t : this.items[n] = t
        }
        toJSON(e, t) {
            const n = [];
            (null == t ? void 0 : t.onCreate) && t.onCreate(n);
            let r = 0;
            for (const o of this.items)
                n.push(oE(o, String(r++), t));
            return n
        }
        toString(e, t, n) {
            return e ? BE(this, e, {
                blockItemPrefix: "- ",
                flowChars: {
                    start: "[",
                    end: "]"
                },
                itemIndent: (e.indent || "") + "  ",
                onChompKeep: n,
                onComment: t
            }) : JSON.stringify(this)
        }
        static from(e, t, n) {
            const {replacer: r} = n
              , o = new this(e);
            if (t && Symbol.iterator in Object(t)) {
                let e = 0;
                for (let i of t) {
                    if ("function" == typeof r) {
                        const n = t instanceof Set ? i : String(e++);
                        i = r.call(t, n, i)
                    }
                    o.items.push(dE(i, void 0, n))
                }
            }
            return o
        }
    }
    function WE(e) {
        let t = jS(e) ? e.value : e;
        return t && "string" == typeof t && (t = Number(t)),
        "number" == typeof t && Number.isInteger(t) && t >= 0 ? t : null
    }
    const XE = {
        collection: "seq",
        default: !0,
        nodeClass: ZE,
        tag: "tag:yaml.org,2002:seq",
        resolve: (e,t)=>(zS(e) || t("Expected a sequence for this tag"),
        e),
        createNode: (e,t,n)=>ZE.from(e, t, n)
    }
      , VE = {
        identify: e=>"string" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:str",
        resolve: e=>e,
        stringify: (e,t,n,r)=>PE(e, t = Object.assign({
            actualString: !0
        }, t), n, r)
    }
      , GE = {
        identify: e=>null == e,
        createNode: ()=>new cE(null),
        default: !0,
        tag: "tag:yaml.org,2002:null",
        test: /^(?:~|[Nn]ull|NULL)?$/,
        resolve: ()=>new cE(null),
        stringify: ({source: e},t)=>"string" == typeof e && GE.test.test(e) ? e : t.options.nullStr
    }
      , YE = {
        identify: e=>"boolean" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:bool",
        test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
        resolve: e=>new cE("t" === e[0] || "T" === e[0]),
        stringify({source: e, value: t}, n) {
            if (e && YE.test.test(e)) {
                if (t === ("t" === e[0] || "T" === e[0]))
                    return e
            }
            return t ? n.options.trueStr : n.options.falseStr
        }
    };
    function KE({format: e, minFractionDigits: t, tag: n, value: r}) {
        if ("bigint" == typeof r)
            return String(r);
        const o = "number" == typeof r ? r : Number(r);
        if (!isFinite(o))
            return isNaN(o) ? ".nan" : o < 0 ? "-.inf" : ".inf";
        let i = JSON.stringify(r);
        if (!e && t && (!n || "tag:yaml.org,2002:float" === n) && /^\d/.test(i)) {
            let e = i.indexOf(".");
            e < 0 && (e = i.length,
            i += ".");
            let n = t - (i.length - e - 1);
            for (; n-- > 0; )
                i += "0"
        }
        return i
    }
    const JE = {
        identify: e=>"number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
        resolve: e=>"nan" === e.slice(-3).toLowerCase() ? NaN : "-" === e[0] ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
        stringify: KE
    }
      , ex = {
        identify: e=>"number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        format: "EXP",
        test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
        resolve: e=>parseFloat(e),
        stringify(e) {
            const t = Number(e.value);
            return isFinite(t) ? t.toExponential() : KE(e)
        }
    }
      , tx = {
        identify: e=>"number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
        resolve(e) {
            const t = new cE(parseFloat(e))
              , n = e.indexOf(".");
            return -1 !== n && "0" === e[e.length - 1] && (t.minFractionDigits = e.length - n - 1),
            t
        },
        stringify: KE
    }
      , nx = e=>"bigint" == typeof e || Number.isInteger(e)
      , rx = (e,t,n,{intAsBigInt: r})=>r ? BigInt(e) : parseInt(e.substring(t), n);
    function ox(e, t, n) {
        const {value: r} = e;
        return nx(r) && r >= 0 ? n + r.toString(t) : KE(e)
    }
    const ix = {
        identify: e=>nx(e) && e >= 0,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "OCT",
        test: /^0o[0-7]+$/,
        resolve: (e,t,n)=>rx(e, 2, 8, n),
        stringify: e=>ox(e, 8, "0o")
    }
      , ax = {
        identify: nx,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        test: /^[-+]?[0-9]+$/,
        resolve: (e,t,n)=>rx(e, 0, 10, n),
        stringify: KE
    }
      , sx = {
        identify: e=>nx(e) && e >= 0,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "HEX",
        test: /^0x[0-9a-fA-F]+$/,
        resolve: (e,t,n)=>rx(e, 2, 16, n),
        stringify: e=>ox(e, 16, "0x")
    }
      , lx = [HE, XE, VE, GE, YE, ix, ax, sx, JE, ex, tx];
    function cx(e) {
        return "bigint" == typeof e || Number.isInteger(e)
    }
    const ux = ({value: e})=>JSON.stringify(e)
      , dx = [HE, XE].concat([{
        identify: e=>"string" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:str",
        resolve: e=>e,
        stringify: ux
    }, {
        identify: e=>null == e,
        createNode: ()=>new cE(null),
        default: !0,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: ()=>null,
        stringify: ux
    }, {
        identify: e=>"boolean" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: e=>"true" === e,
        stringify: ux
    }, {
        identify: cx,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (e,t,{intAsBigInt: n})=>n ? BigInt(e) : parseInt(e, 10),
        stringify: ({value: e})=>cx(e) ? e.toString() : JSON.stringify(e)
    }, {
        identify: e=>"number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: e=>parseFloat(e),
        stringify: ux
    }], {
        default: !0,
        tag: "",
        test: /^/,
        resolve: (e,t)=>(t(`Unresolved plain scalar ${JSON.stringify(e)}`),
        e)
    })
      , px = {
        identify: e=>e instanceof Uint8Array,
        default: !1,
        tag: "tag:yaml.org,2002:binary",
        resolve(e, t) {
            if ("function" == typeof Buffer)
                return Buffer.from(e, "base64");
            if ("function" == typeof atob) {
                const t = atob(e.replace(/[\n\r]/g, ""))
                  , n = new Uint8Array(t.length);
                for (let e = 0; e < t.length; ++e)
                    n[e] = t.charCodeAt(e);
                return n
            }
            return t("This environment does not support reading binary tags; either Buffer or atob is required"),
            e
        },
        stringify({comment: e, type: t, value: n}, r, o, i) {
            const a = n;
            let s;
            if ("function" == typeof Buffer)
                s = a instanceof Buffer ? a.toString("base64") : Buffer.from(a.buffer).toString("base64");
            else {
                if ("function" != typeof btoa)
                    throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
                {
                    let e = "";
                    for (let t = 0; t < a.length; ++t)
                        e += String.fromCharCode(a[t]);
                    s = btoa(e)
                }
            }
            if (t || (t = cE.BLOCK_LITERAL),
            t !== cE.QUOTE_DOUBLE) {
                const e = Math.max(r.options.lineWidth - r.indent.length, r.options.minContentWidth)
                  , n = Math.ceil(s.length / e)
                  , o = new Array(n);
                for (let t = 0, r = 0; t < n; ++t,
                r += e)
                    o[t] = s.substr(r, e);
                s = o.join(t === cE.BLOCK_LITERAL ? "\n" : " ")
            }
            return PE({
                comment: e,
                type: t,
                value: s
            }, r, o, i)
        }
    };
    function hx(e, t) {
        if (zS(e))
            for (let n = 0; n < e.items.length; ++n) {
                let r = e.items[n];
                if (!FS(r)) {
                    if (US(r)) {
                        r.items.length > 1 && t("Each pair must have its own sequence indicator");
                        const e = r.items[0] || new QE(new cE(null));
                        if (r.commentBefore && (e.key.commentBefore = e.key.commentBefore ? `${r.commentBefore}\n${e.key.commentBefore}` : r.commentBefore),
                        r.comment) {
                            const t = e.value ?? e.key;
                            t.comment = t.comment ? `${r.comment}\n${t.comment}` : r.comment
                        }
                        r = e
                    }
                    e.items[n] = FS(r) ? r : new QE(r)
                }
            }
        else
            t("Expected a sequence for this tag");
        return e
    }
    function fx(e, t, n) {
        const {replacer: r} = n
          , o = new ZE(e);
        o.tag = "tag:yaml.org,2002:pairs";
        let i = 0;
        if (t && Symbol.iterator in Object(t))
            for (let a of t) {
                let e, s;
                if ("function" == typeof r && (a = r.call(t, String(i++), a)),
                Array.isArray(a)) {
                    if (2 !== a.length)
                        throw new TypeError(`Expected [key, value] tuple: ${a}`);
                    e = a[0],
                    s = a[1]
                } else if (a && a instanceof Object) {
                    const t = Object.keys(a);
                    if (1 !== t.length)
                        throw new TypeError(`Expected tuple with one key, not ${t.length} keys`);
                    e = t[0],
                    s = a[e]
                } else
                    e = a;
                o.items.push(LE(e, s, n))
            }
        return o
    }
    const mx = {
        collection: "seq",
        default: !1,
        tag: "tag:yaml.org,2002:pairs",
        resolve: hx,
        createNode: fx
    };
    class gx extends ZE {
        constructor() {
            super(),
            this.add = qE.prototype.add.bind(this),
            this.delete = qE.prototype.delete.bind(this),
            this.get = qE.prototype.get.bind(this),
            this.has = qE.prototype.has.bind(this),
            this.set = qE.prototype.set.bind(this),
            this.tag = gx.tag
        }
        toJSON(e, t) {
            if (!t)
                return super.toJSON(e);
            const n = new Map;
            (null == t ? void 0 : t.onCreate) && t.onCreate(n);
            for (const r of this.items) {
                let e, o;
                if (FS(r) ? (e = oE(r.key, "", t),
                o = oE(r.value, e, t)) : e = oE(r, "", t),
                n.has(e))
                    throw new Error("Ordered maps must not include duplicate keys");
                n.set(e, o)
            }
            return n
        }
        static from(e, t, n) {
            const r = fx(e, t, n)
              , o = new this;
            return o.items = r.items,
            o
        }
    }
    gx.tag = "tag:yaml.org,2002:omap";
    const bx = {
        collection: "seq",
        identify: e=>e instanceof Map,
        nodeClass: gx,
        default: !1,
        tag: "tag:yaml.org,2002:omap",
        resolve(e, t) {
            const n = hx(e, t)
              , r = [];
            for (const {key: o} of n.items)
                jS(o) && (r.includes(o.value) ? t(`Ordered maps must not include duplicate keys: ${o.value}`) : r.push(o.value));
            return Object.assign(new gx, n)
        },
        createNode: (e,t,n)=>gx.from(e, t, n)
    };
    function Ox({value: e, source: t}, n) {
        return t && (e ? vx : yx).test.test(t) ? t : e ? n.options.trueStr : n.options.falseStr
    }
    const vx = {
        identify: e=>!0 === e,
        default: !0,
        tag: "tag:yaml.org,2002:bool",
        test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
        resolve: ()=>new cE(!0),
        stringify: Ox
    }
      , yx = {
        identify: e=>!1 === e,
        default: !0,
        tag: "tag:yaml.org,2002:bool",
        test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
        resolve: ()=>new cE(!1),
        stringify: Ox
    }
      , wx = {
        identify: e=>"number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
        resolve: e=>"nan" === e.slice(-3).toLowerCase() ? NaN : "-" === e[0] ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
        stringify: KE
    }
      , _x = {
        identify: e=>"number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        format: "EXP",
        test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
        resolve: e=>parseFloat(e.replace(/_/g, "")),
        stringify(e) {
            const t = Number(e.value);
            return isFinite(t) ? t.toExponential() : KE(e)
        }
    }
      , kx = {
        identify: e=>"number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
        resolve(e) {
            const t = new cE(parseFloat(e.replace(/_/g, "")))
              , n = e.indexOf(".");
            if (-1 !== n) {
                const r = e.substring(n + 1).replace(/_/g, "");
                "0" === r[r.length - 1] && (t.minFractionDigits = r.length)
            }
            return t
        },
        stringify: KE
    }
      , Sx = e=>"bigint" == typeof e || Number.isInteger(e);
    function Ex(e, t, n, {intAsBigInt: r}) {
        const o = e[0];
        if ("-" !== o && "+" !== o || (t += 1),
        e = e.substring(t).replace(/_/g, ""),
        r) {
            switch (n) {
            case 2:
                e = `0b${e}`;
                break;
            case 8:
                e = `0o${e}`;
                break;
            case 16:
                e = `0x${e}`
            }
            const t = BigInt(e);
            return "-" === o ? BigInt(-1) * t : t
        }
        const i = parseInt(e, n);
        return "-" === o ? -1 * i : i
    }
    function xx(e, t, n) {
        const {value: r} = e;
        if (Sx(r)) {
            const e = r.toString(t);
            return r < 0 ? "-" + n + e.substr(1) : n + e
        }
        return KE(e)
    }
    const Tx = {
        identify: Sx,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "BIN",
        test: /^[-+]?0b[0-1_]+$/,
        resolve: (e,t,n)=>Ex(e, 2, 2, n),
        stringify: e=>xx(e, 2, "0b")
    }
      , Ax = {
        identify: Sx,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "OCT",
        test: /^[-+]?0[0-7_]+$/,
        resolve: (e,t,n)=>Ex(e, 1, 8, n),
        stringify: e=>xx(e, 8, "0")
    }
      , Cx = {
        identify: Sx,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        test: /^[-+]?[0-9][0-9_]*$/,
        resolve: (e,t,n)=>Ex(e, 0, 10, n),
        stringify: KE
    }
      , Px = {
        identify: Sx,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "HEX",
        test: /^[-+]?0x[0-9a-fA-F_]+$/,
        resolve: (e,t,n)=>Ex(e, 2, 16, n),
        stringify: e=>xx(e, 16, "0x")
    };
    class Dx extends qE {
        constructor(e) {
            super(e),
            this.tag = Dx.tag
        }
        add(e) {
            let t;
            t = FS(e) ? e : e && "object" == typeof e && "key"in e && "value"in e && null === e.value ? new QE(e.key,null) : new QE(e,null);
            zE(this.items, t.key) || this.items.push(t)
        }
        get(e, t) {
            const n = zE(this.items, e);
            return !t && FS(n) ? jS(n.key) ? n.key.value : n.key : n
        }
        set(e, t) {
            if ("boolean" != typeof t)
                throw new Error("Expected boolean value for set(key, value) in a YAML set, not " + typeof t);
            const n = zE(this.items, e);
            n && !t ? this.items.splice(this.items.indexOf(n), 1) : !n && t && this.items.push(new QE(e))
        }
        toJSON(e, t) {
            return super.toJSON(e, t, Set)
        }
        toString(e, t, n) {
            if (!e)
                return JSON.stringify(this);
            if (this.hasAllNullValues(!0))
                return super.toString(Object.assign({}, e, {
                    allNullValues: !0
                }), t, n);
            throw new Error("Set items must all have null values")
        }
        static from(e, t, n) {
            const {replacer: r} = n
              , o = new this(e);
            if (t && Symbol.iterator in Object(t))
                for (let i of t)
                    "function" == typeof r && (i = r.call(t, i, i)),
                    o.items.push(LE(i, null, n));
            return o
        }
    }
    Dx.tag = "tag:yaml.org,2002:set";
    const Rx = {
        collection: "map",
        identify: e=>e instanceof Set,
        nodeClass: Dx,
        default: !1,
        tag: "tag:yaml.org,2002:set",
        createNode: (e,t,n)=>Dx.from(e, t, n),
        resolve(e, t) {
            if (US(e)) {
                if (e.hasAllNullValues(!0))
                    return Object.assign(new Dx, e);
                t("Set items must all have null values")
            } else
                t("Expected a mapping for this tag");
            return e
        }
    };
    function Nx(e, t) {
        const n = e[0]
          , r = "-" === n || "+" === n ? e.substring(1) : e
          , o = e=>t ? BigInt(e) : Number(e)
          , i = r.replace(/_/g, "").split(":").reduce(((e,t)=>e * o(60) + o(t)), o(0));
        return "-" === n ? o(-1) * i : i
    }
    function $x(e) {
        let {value: t} = e
          , n = e=>e;
        if ("bigint" == typeof t)
            n = e=>BigInt(e);
        else if (isNaN(t) || !isFinite(t))
            return KE(e);
        let r = "";
        t < 0 && (r = "-",
        t *= n(-1));
        const o = n(60)
          , i = [t % o];
        return t < 60 ? i.unshift(0) : (t = (t - i[0]) / o,
        i.unshift(t % o),
        t >= 60 && (t = (t - i[0]) / o,
        i.unshift(t))),
        r + i.map((e=>String(e).padStart(2, "0"))).join(":").replace(/000000\d*$/, "")
    }
    const Ix = {
        identify: e=>"bigint" == typeof e || Number.isInteger(e),
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "TIME",
        test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
        resolve: (e,t,{intAsBigInt: n})=>Nx(e, n),
        stringify: $x
    }
      , Mx = {
        identify: e=>"number" == typeof e,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        format: "TIME",
        test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
        resolve: e=>Nx(e, !1),
        stringify: $x
    }
      , Lx = {
        identify: e=>e instanceof Date,
        default: !0,
        tag: "tag:yaml.org,2002:timestamp",
        test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
        resolve(e) {
            const t = e.match(Lx.test);
            if (!t)
                throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
            const [,n,r,o,i,a,s] = t.map(Number)
              , l = t[7] ? Number((t[7] + "00").substr(1, 3)) : 0;
            let c = Date.UTC(n, r - 1, o, i || 0, a || 0, s || 0, l);
            const u = t[8];
            if (u && "Z" !== u) {
                let e = Nx(u, !1);
                Math.abs(e) < 30 && (e *= 60),
                c -= 6e4 * e
            }
            return new Date(c)
        },
        stringify: ({value: e})=>e.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    }
      , Qx = [HE, XE, VE, GE, vx, yx, Tx, Ax, Cx, Px, wx, _x, kx, px, bx, mx, Rx, Ix, Mx, Lx]
      , Bx = new Map([["core", lx], ["failsafe", [HE, XE, VE]], ["json", dx], ["yaml11", Qx], ["yaml-1.1", Qx]])
      , Ux = {
        binary: px,
        bool: YE,
        float: tx,
        floatExp: ex,
        floatNaN: JE,
        floatTime: Mx,
        int: ax,
        intHex: sx,
        intOct: ix,
        intTime: Ix,
        map: HE,
        null: GE,
        omap: bx,
        pairs: mx,
        seq: XE,
        set: Rx,
        timestamp: Lx
    }
      , Fx = {
        "tag:yaml.org,2002:binary": px,
        "tag:yaml.org,2002:omap": bx,
        "tag:yaml.org,2002:pairs": mx,
        "tag:yaml.org,2002:set": Rx,
        "tag:yaml.org,2002:timestamp": Lx
    };
    function jx(e, t) {
        let n = Bx.get(t);
        if (!n) {
            if (!Array.isArray(e)) {
                const e = Array.from(Bx.keys()).filter((e=>"yaml11" !== e)).map((e=>JSON.stringify(e))).join(", ");
                throw new Error(`Unknown schema "${t}"; use one of ${e} or define customTags array`)
            }
            n = []
        }
        if (Array.isArray(e))
            for (const r of e)
                n = n.concat(r);
        else
            "function" == typeof e && (n = e(n.slice()));
        return n.map((e=>{
            if ("string" != typeof e)
                return e;
            const t = Ux[e];
            if (t)
                return t;
            const n = Object.keys(Ux).map((e=>JSON.stringify(e))).join(", ");
            throw new Error(`Unknown custom tag "${e}"; use one of ${n}`)
        }
        ))
    }
    const zx = (e,t)=>e.key < t.key ? -1 : e.key > t.key ? 1 : 0;
    let qx = class e {
        constructor({compat: e, customTags: t, merge: n, resolveKnownTags: r, schema: o, sortMapEntries: i, toStringDefaults: a}) {
            this.compat = Array.isArray(e) ? jx(e, "compat") : e ? jx(null, e) : null,
            this.merge = !!n,
            this.name = "string" == typeof o && o || "core",
            this.knownTags = r ? Fx : {},
            this.tags = jx(t, this.name),
            this.toStringOptions = a ?? null,
            Object.defineProperty(this, NS, {
                value: HE
            }),
            Object.defineProperty(this, IS, {
                value: VE
            }),
            Object.defineProperty(this, MS, {
                value: XE
            }),
            this.sortMapEntries = "function" == typeof i ? i : !0 === i ? zx : null
        }
        clone() {
            const t = Object.create(e.prototype, Object.getOwnPropertyDescriptors(this));
            return t.tags = this.tags.slice(),
            t
        }
    }
    ;
    class Hx {
        constructor(e, t, n) {
            this.commentBefore = null,
            this.comment = null,
            this.errors = [],
            this.warnings = [],
            Object.defineProperty(this, LS, {
                value: RS
            });
            let r = null;
            "function" == typeof t || Array.isArray(t) ? r = t : void 0 === n && t && (n = t,
            t = void 0);
            const o = Object.assign({
                intAsBigInt: !1,
                keepSourceTokens: !1,
                logLevel: "warn",
                prettyErrors: !0,
                strict: !0,
                uniqueKeys: !0,
                version: "1.2"
            }, n);
            this.options = o;
            let {version: i} = o;
            (null == n ? void 0 : n._directives) ? (this.directives = n._directives.atDocument(),
            this.directives.yaml.explicit && (i = this.directives.yaml.version)) : this.directives = new JS({
                version: i
            }),
            this.setSchema(i, n),
            this.contents = void 0 === e ? null : this.createNode(e, r, n)
        }
        clone() {
            const e = Object.create(Hx.prototype, {
                [LS]: {
                    value: RS
                }
            });
            return e.commentBefore = this.commentBefore,
            e.comment = this.comment,
            e.errors = this.errors.slice(),
            e.warnings = this.warnings.slice(),
            e.options = Object.assign({}, this.options),
            this.directives && (e.directives = this.directives.clone()),
            e.schema = this.schema.clone(),
            e.contents = HS(this.contents) ? this.contents.clone(e.schema) : this.contents,
            this.range && (e.range = this.range.slice()),
            e
        }
        add(e) {
            Zx(this.contents) && this.contents.add(e)
        }
        addIn(e, t) {
            Zx(this.contents) && this.contents.addIn(e, t)
        }
        createAlias(e, t) {
            if (!e.anchor) {
                const n = tE(this);
                e.anchor = !t || n.has(t) ? nE(t || "a", n) : t
            }
            return new aE(e.anchor)
        }
        createNode(e, t, n) {
            let r;
            if ("function" == typeof t)
                e = t.call({
                    "": e
                }, "", e),
                r = t;
            else if (Array.isArray(t)) {
                const e = e=>"number" == typeof e || e instanceof String || e instanceof Number
                  , n = t.filter(e).map(String);
                n.length > 0 && (t = t.concat(n)),
                r = t
            } else
                void 0 === n && t && (n = t,
                t = void 0);
            const {aliasDuplicateObjects: o, anchorPrefix: i, flow: a, keepUndefined: s, onTagObj: l, tag: c} = n ?? {}
              , {onAnchor: u, setAnchors: d, sourceObjects: p} = function(e, t) {
                const n = []
                  , r = new Map;
                let o = null;
                return {
                    onAnchor: r=>{
                        n.push(r),
                        o || (o = tE(e));
                        const i = nE(t, o);
                        return o.add(i),
                        i
                    }
                    ,
                    setAnchors: ()=>{
                        for (const e of n) {
                            const t = r.get(e);
                            if ("object" != typeof t || !t.anchor || !jS(t.node) && !qS(t.node)) {
                                const t = new Error("Failed to resolve repeated object (this should not happen)");
                                throw t.source = e,
                                t
                            }
                            t.node.anchor = t.anchor
                        }
                    }
                    ,
                    sourceObjects: r
                }
            }(this, i || "a")
              , h = dE(e, c, {
                aliasDuplicateObjects: o ?? !0,
                keepUndefined: s ?? !1,
                onAnchor: u,
                onTagObj: l,
                replacer: r,
                schema: this.schema,
                sourceObjects: p
            });
            return a && qS(h) && (h.flow = !0),
            d(),
            h
        }
        createPair(e, t, n={}) {
            const r = this.createNode(e, null, n)
              , o = this.createNode(t, null, n);
            return new QE(r,o)
        }
        delete(e) {
            return !!Zx(this.contents) && this.contents.delete(e)
        }
        deleteIn(e) {
            return hE(e) ? null != this.contents && (this.contents = null,
            !0) : !!Zx(this.contents) && this.contents.deleteIn(e)
        }
        get(e, t) {
            return qS(this.contents) ? this.contents.get(e, t) : void 0
        }
        getIn(e, t) {
            return hE(e) ? !t && jS(this.contents) ? this.contents.value : this.contents : qS(this.contents) ? this.contents.getIn(e, t) : void 0
        }
        has(e) {
            return !!qS(this.contents) && this.contents.has(e)
        }
        hasIn(e) {
            return hE(e) ? void 0 !== this.contents : !!qS(this.contents) && this.contents.hasIn(e)
        }
        set(e, t) {
            null == this.contents ? this.contents = pE(this.schema, [e], t) : Zx(this.contents) && this.contents.set(e, t)
        }
        setIn(e, t) {
            hE(e) ? this.contents = t : null == this.contents ? this.contents = pE(this.schema, Array.from(e), t) : Zx(this.contents) && this.contents.setIn(e, t)
        }
        setSchema(e, t={}) {
            let n;
            switch ("number" == typeof e && (e = String(e)),
            e) {
            case "1.1":
                this.directives ? this.directives.yaml.version = "1.1" : this.directives = new JS({
                    version: "1.1"
                }),
                n = {
                    merge: !0,
                    resolveKnownTags: !1,
                    schema: "yaml-1.1"
                };
                break;
            case "1.2":
            case "next":
                this.directives ? this.directives.yaml.version = e : this.directives = new JS({
                    version: e
                }),
                n = {
                    merge: !1,
                    resolveKnownTags: !0,
                    schema: "core"
                };
                break;
            case null:
                this.directives && delete this.directives,
                n = null;
                break;
            default:
                {
                    const t = JSON.stringify(e);
                    throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${t}`)
                }
            }
            if (t.schema instanceof Object)
                this.schema = t.schema;
            else {
                if (!n)
                    throw new Error("With a null YAML version, the { schema: Schema } option is required");
                this.schema = new qx(Object.assign(n, t))
            }
        }
        toJS({json: e, jsonArg: t, mapAsMap: n, maxAliasCount: r, onAnchor: o, reviver: i}={}) {
            const a = {
                anchors: new Map,
                doc: this,
                keep: !e,
                mapAsMap: !0 === n,
                mapKeyWarned: !1,
                maxAliasCount: "number" == typeof r ? r : 100
            }
              , s = oE(this.contents, t ?? "", a);
            if ("function" == typeof o)
                for (const {count: l, res: c} of a.anchors.values())
                    o(c, l);
            return "function" == typeof i ? rE(i, {
                "": s
            }, "", s) : s
        }
        toJSON(e, t) {
            return this.toJS({
                json: !0,
                jsonArg: e,
                mapAsMap: !1,
                onAnchor: t
            })
        }
        toString(e={}) {
            if (this.errors.length > 0)
                throw new Error("Document with errors cannot be stringified");
            if ("indent"in e && (!Number.isInteger(e.indent) || Number(e.indent) <= 0)) {
                const t = JSON.stringify(e.indent);
                throw new Error(`"indent" option must be a positive integer, not ${t}`)
            }
            return function(e, t) {
                var n;
                const r = [];
                let o = !0 === t.directives;
                if (!1 !== t.directives && e.directives) {
                    const t = e.directives.toString(e);
                    t ? (r.push(t),
                    o = !0) : e.directives.docStart && (o = !0)
                }
                o && r.push("---");
                const i = DE(e, t)
                  , {commentString: a} = i.options;
                if (e.commentBefore) {
                    1 !== r.length && r.unshift("");
                    const t = a(e.commentBefore);
                    r.unshift(gE(t, ""))
                }
                let s = !1
                  , l = null;
                if (e.contents) {
                    if (HS(e.contents)) {
                        if (e.contents.spaceBefore && o && r.push(""),
                        e.contents.commentBefore) {
                            const t = a(e.contents.commentBefore);
                            r.push(gE(t, ""))
                        }
                        i.forceBlockIndent = !!e.comment,
                        l = e.contents.comment
                    }
                    const t = l ? void 0 : ()=>s = !0;
                    let n = RE(e.contents, i, (()=>l = null), t);
                    l && (n += bE(n, "", a(l))),
                    "|" !== n[0] && ">" !== n[0] || "---" !== r[r.length - 1] ? r.push(n) : r[r.length - 1] = `--- ${n}`
                } else
                    r.push(RE(e.contents, i));
                if (null == (n = e.directives) ? void 0 : n.docEnd)
                    if (e.comment) {
                        const t = a(e.comment);
                        t.includes("\n") ? (r.push("..."),
                        r.push(gE(t, ""))) : r.push(`... ${t}`)
                    } else
                        r.push("...");
                else {
                    let t = e.comment;
                    t && s && (t = t.replace(/^\n+/, "")),
                    t && (s && !l || "" === r[r.length - 1] || r.push(""),
                    r.push(gE(a(t), "")))
                }
                return r.join("\n") + "\n"
            }(this, e)
        }
    }
    function Zx(e) {
        if (qS(e))
            return !0;
        throw new Error("Expected a YAML collection as document contents")
    }
    class Wx extends Error {
        constructor(e, t, n, r) {
            super(),
            this.name = e,
            this.code = n,
            this.message = r,
            this.pos = t
        }
    }
    class Xx extends Wx {
        constructor(e, t, n) {
            super("YAMLParseError", e, t, n)
        }
    }
    class Vx extends Wx {
        constructor(e, t, n) {
            super("YAMLWarning", e, t, n)
        }
    }
    const Gx = (e,t)=>n=>{
        if (-1 === n.pos[0])
            return;
        n.linePos = n.pos.map((e=>t.linePos(e)));
        const {line: r, col: o} = n.linePos[0];
        n.message += ` at line ${r}, column ${o}`;
        let i = o - 1
          , a = e.substring(t.lineStarts[r - 1], t.lineStarts[r]).replace(/[\n\r]+$/, "");
        if (i >= 60 && a.length > 80) {
            const e = Math.min(i - 39, a.length - 79);
            a = "…" + a.substring(e),
            i -= e - 1
        }
        if (a.length > 80 && (a = a.substring(0, 79) + "…"),
        r > 1 && /^ *$/.test(a.substring(0, i))) {
            let n = e.substring(t.lineStarts[r - 2], t.lineStarts[r - 1]);
            n.length > 80 && (n = n.substring(0, 79) + "…\n"),
            a = n + a
        }
        if (/[^ ]/.test(a)) {
            let e = 1;
            const t = n.linePos[1];
            t && t.line === r && t.col > o && (e = Math.max(1, Math.min(t.col - o, 80 - i)));
            const s = " ".repeat(i) + "^".repeat(e);
            n.message += `:\n\n${a}\n${s}\n`
        }
    }
    ;
    function Yx(e, {flow: t, indicator: n, next: r, offset: o, onError: i, parentIndent: a, startOnNewline: s}) {
        let l = !1
          , c = s
          , u = s
          , d = ""
          , p = ""
          , h = !1
          , f = !1
          , m = !1
          , g = null
          , b = null
          , O = null
          , v = null
          , y = null
          , w = null;
        for (const S of e)
            switch (m && ("space" !== S.type && "newline" !== S.type && "comma" !== S.type && i(S.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"),
            m = !1),
            g && (c && "comment" !== S.type && "newline" !== S.type && i(g, "TAB_AS_INDENT", "Tabs are not allowed as indentation"),
            g = null),
            S.type) {
            case "space":
                t || "doc-start" === n && "flow-collection" === (null == r ? void 0 : r.type) || !S.source.includes("\t") || (g = S),
                u = !0;
                break;
            case "comment":
                {
                    u || i(S, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
                    const e = S.source.substring(1) || " ";
                    d ? d += p + e : d = e,
                    p = "",
                    c = !1;
                    break
                }
            case "newline":
                c ? d ? d += S.source : l = !0 : p += S.source,
                c = !0,
                h = !0,
                (b || O) && (f = !0),
                u = !0;
                break;
            case "anchor":
                b && i(S, "MULTIPLE_ANCHORS", "A node can have at most one anchor"),
                S.source.endsWith(":") && i(S.offset + S.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", !0),
                b = S,
                null === w && (w = S.offset),
                c = !1,
                u = !1,
                m = !0;
                break;
            case "tag":
                O && i(S, "MULTIPLE_TAGS", "A node can have at most one tag"),
                O = S,
                null === w && (w = S.offset),
                c = !1,
                u = !1,
                m = !0;
                break;
            case n:
                (b || O) && i(S, "BAD_PROP_ORDER", `Anchors and tags must be after the ${S.source} indicator`),
                y && i(S, "UNEXPECTED_TOKEN", `Unexpected ${S.source} in ${t ?? "collection"}`),
                y = S,
                c = "seq-item-ind" === n || "explicit-key-ind" === n,
                u = !1;
                break;
            case "comma":
                if (t) {
                    v && i(S, "UNEXPECTED_TOKEN", `Unexpected , in ${t}`),
                    v = S,
                    c = !1,
                    u = !1;
                    break
                }
            default:
                i(S, "UNEXPECTED_TOKEN", `Unexpected ${S.type} token`),
                c = !1,
                u = !1
            }
        const _ = e[e.length - 1]
          , k = _ ? _.offset + _.source.length : o;
        return m && r && "space" !== r.type && "newline" !== r.type && "comma" !== r.type && ("scalar" !== r.type || "" !== r.source) && i(r.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"),
        g && (c && g.indent <= a || "block-map" === (null == r ? void 0 : r.type) || "block-seq" === (null == r ? void 0 : r.type)) && i(g, "TAB_AS_INDENT", "Tabs are not allowed as indentation"),
        {
            comma: v,
            found: y,
            spaceBefore: l,
            comment: d,
            hasNewline: h,
            hasNewlineAfterProp: f,
            anchor: b,
            tag: O,
            end: k,
            start: w ?? k
        }
    }
    function Kx(e) {
        if (!e)
            return null;
        switch (e.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
            if (e.source.includes("\n"))
                return !0;
            if (e.end)
                for (const t of e.end)
                    if ("newline" === t.type)
                        return !0;
            return !1;
        case "flow-collection":
            for (const t of e.items) {
                for (const e of t.start)
                    if ("newline" === e.type)
                        return !0;
                if (t.sep)
                    for (const e of t.sep)
                        if ("newline" === e.type)
                            return !0;
                if (Kx(t.key) || Kx(t.value))
                    return !0
            }
            return !1;
        default:
            return !0
        }
    }
    function Jx(e, t, n) {
        if ("flow-collection" === (null == t ? void 0 : t.type)) {
            const r = t.end[0];
            if (r.indent === e && ("]" === r.source || "}" === r.source) && Kx(t)) {
                n(r, "BAD_INDENT", "Flow end indicator should be more indented than parent", !0)
            }
        }
    }
    function eT(e, t, n) {
        const {uniqueKeys: r} = e.options;
        if (!1 === r)
            return !1;
        const o = "function" == typeof r ? r : (t,n)=>t === n || jS(t) && jS(n) && t.value === n.value && !("<<" === t.value && e.schema.merge);
        return t.some((e=>o(e.key, n)))
    }
    const tT = "All mapping items must start at the same column";
    function nT(e, t, n, r) {
        let o = "";
        if (e) {
            let i = !1
              , a = "";
            for (const s of e) {
                const {source: e, type: l} = s;
                switch (l) {
                case "space":
                    i = !0;
                    break;
                case "comment":
                    {
                        n && !i && r(s, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
                        const t = e.substring(1) || " ";
                        o ? o += a + t : o = t,
                        a = "";
                        break
                    }
                case "newline":
                    o && (a += e),
                    i = !0;
                    break;
                default:
                    r(s, "UNEXPECTED_TOKEN", `Unexpected ${l} at node end`)
                }
                t += e.length
            }
        }
        return {
            comment: o,
            offset: t
        }
    }
    const rT = "Block collections are not allowed within flow collections"
      , oT = e=>e && ("block-map" === e.type || "block-seq" === e.type);
    function iT(e, t, n, r, o, i) {
        const a = "block-map" === n.type ? function({composeNode: e, composeEmptyNode: t}, n, r, o, i) {
            var a;
            const s = new ((null == i ? void 0 : i.nodeClass) ?? qE)(n.schema);
            n.atRoot && (n.atRoot = !1);
            let l = r.offset
              , c = null;
            for (const u of r.items) {
                const {start: i, key: d, sep: p, value: h} = u
                  , f = Yx(i, {
                    indicator: "explicit-key-ind",
                    next: d ?? (null == p ? void 0 : p[0]),
                    offset: l,
                    onError: o,
                    parentIndent: r.indent,
                    startOnNewline: !0
                })
                  , m = !f.found;
                if (m) {
                    if (d && ("block-seq" === d.type ? o(l, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent"in d && d.indent !== r.indent && o(l, "BAD_INDENT", tT)),
                    !f.anchor && !f.tag && !p) {
                        c = f.end,
                        f.comment && (s.comment ? s.comment += "\n" + f.comment : s.comment = f.comment);
                        continue
                    }
                    (f.hasNewlineAfterProp || Kx(d)) && o(d ?? i[i.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line")
                } else
                    (null == (a = f.found) ? void 0 : a.indent) !== r.indent && o(l, "BAD_INDENT", tT);
                const g = f.end
                  , b = d ? e(n, d, f, o) : t(n, g, i, null, f, o);
                n.schema.compat && Jx(r.indent, d, o),
                eT(n, s.items, b) && o(g, "DUPLICATE_KEY", "Map keys must be unique");
                const O = Yx(p ?? [], {
                    indicator: "map-value-ind",
                    next: h,
                    offset: b.range[2],
                    onError: o,
                    parentIndent: r.indent,
                    startOnNewline: !d || "block-scalar" === d.type
                });
                if (l = O.end,
                O.found) {
                    m && ("block-map" !== (null == h ? void 0 : h.type) || O.hasNewline || o(l, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"),
                    n.options.strict && f.start < O.found.offset - 1024 && o(b.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
                    const i = h ? e(n, h, O, o) : t(n, l, p, null, O, o);
                    n.schema.compat && Jx(r.indent, h, o),
                    l = i.range[2];
                    const a = new QE(b,i);
                    n.options.keepSourceTokens && (a.srcToken = u),
                    s.items.push(a)
                } else {
                    m && o(b.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"),
                    O.comment && (b.comment ? b.comment += "\n" + O.comment : b.comment = O.comment);
                    const e = new QE(b);
                    n.options.keepSourceTokens && (e.srcToken = u),
                    s.items.push(e)
                }
            }
            return c && c < l && o(c, "IMPOSSIBLE", "Map comment with trailing content"),
            s.range = [r.offset, l, c ?? l],
            s
        }(e, t, n, r, i) : "block-seq" === n.type ? function({composeNode: e, composeEmptyNode: t}, n, r, o, i) {
            const a = new ((null == i ? void 0 : i.nodeClass) ?? ZE)(n.schema);
            n.atRoot && (n.atRoot = !1);
            let s = r.offset
              , l = null;
            for (const {start: c, value: u} of r.items) {
                const i = Yx(c, {
                    indicator: "seq-item-ind",
                    next: u,
                    offset: s,
                    onError: o,
                    parentIndent: r.indent,
                    startOnNewline: !0
                });
                if (!i.found) {
                    if (!(i.anchor || i.tag || u)) {
                        l = i.end,
                        i.comment && (a.comment = i.comment);
                        continue
                    }
                    u && "block-seq" === u.type ? o(i.end, "BAD_INDENT", "All sequence items must start at the same column") : o(s, "MISSING_CHAR", "Sequence item without - indicator")
                }
                const d = u ? e(n, u, i, o) : t(n, i.end, c, null, i, o);
                n.schema.compat && Jx(r.indent, u, o),
                s = d.range[2],
                a.items.push(d)
            }
            return a.range = [r.offset, s, l ?? s],
            a
        }(e, t, n, r, i) : function({composeNode: e, composeEmptyNode: t}, n, r, o, i) {
            const a = "{" === r.start.source
              , s = a ? "flow map" : "flow sequence"
              , l = new ((null == i ? void 0 : i.nodeClass) ?? (a ? qE : ZE))(n.schema);
            l.flow = !0;
            const c = n.atRoot;
            c && (n.atRoot = !1);
            let u = r.offset + r.start.source.length;
            for (let m = 0; m < r.items.length; ++m) {
                const i = r.items[m]
                  , {start: c, key: d, sep: p, value: h} = i
                  , f = Yx(c, {
                    flow: s,
                    indicator: "explicit-key-ind",
                    next: d ?? (null == p ? void 0 : p[0]),
                    offset: u,
                    onError: o,
                    parentIndent: r.indent,
                    startOnNewline: !1
                });
                if (!f.found) {
                    if (!(f.anchor || f.tag || p || h)) {
                        0 === m && f.comma ? o(f.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${s}`) : m < r.items.length - 1 && o(f.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${s}`),
                        f.comment && (l.comment ? l.comment += "\n" + f.comment : l.comment = f.comment),
                        u = f.end;
                        continue
                    }
                    !a && n.options.strict && Kx(d) && o(d, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line")
                }
                if (0 === m)
                    f.comma && o(f.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${s}`);
                else if (f.comma || o(f.start, "MISSING_CHAR", `Missing , between ${s} items`),
                f.comment) {
                    let e = "";
                    e: for (const t of c)
                        switch (t.type) {
                        case "comma":
                        case "space":
                            break;
                        case "comment":
                            e = t.source.substring(1);
                            break e;
                        default:
                            break e
                        }
                    if (e) {
                        let t = l.items[l.items.length - 1];
                        FS(t) && (t = t.value ?? t.key),
                        t.comment ? t.comment += "\n" + e : t.comment = e,
                        f.comment = f.comment.substring(e.length + 1)
                    }
                }
                if (a || p || f.found) {
                    const m = f.end
                      , g = d ? e(n, d, f, o) : t(n, m, c, null, f, o);
                    oT(d) && o(g.range, "BLOCK_IN_FLOW", rT);
                    const b = Yx(p ?? [], {
                        flow: s,
                        indicator: "map-value-ind",
                        next: h,
                        offset: g.range[2],
                        onError: o,
                        parentIndent: r.indent,
                        startOnNewline: !1
                    });
                    if (b.found) {
                        if (!a && !f.found && n.options.strict) {
                            if (p)
                                for (const e of p) {
                                    if (e === b.found)
                                        break;
                                    if ("newline" === e.type) {
                                        o(e, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                                        break
                                    }
                                }
                            f.start < b.found.offset - 1024 && o(b.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key")
                        }
                    } else
                        h && ("source"in h && h.source && ":" === h.source[0] ? o(h, "MISSING_CHAR", `Missing space after : in ${s}`) : o(b.start, "MISSING_CHAR", `Missing , or : between ${s} items`));
                    const O = h ? e(n, h, b, o) : b.found ? t(n, b.end, p, null, b, o) : null;
                    O ? oT(h) && o(O.range, "BLOCK_IN_FLOW", rT) : b.comment && (g.comment ? g.comment += "\n" + b.comment : g.comment = b.comment);
                    const v = new QE(g,O);
                    if (n.options.keepSourceTokens && (v.srcToken = i),
                    a) {
                        const e = l;
                        eT(n, e.items, g) && o(m, "DUPLICATE_KEY", "Map keys must be unique"),
                        e.items.push(v)
                    } else {
                        const e = new qE(n.schema);
                        e.flow = !0,
                        e.items.push(v),
                        l.items.push(e)
                    }
                    u = O ? O.range[2] : b.end
                } else {
                    const r = h ? e(n, h, f, o) : t(n, f.end, p, null, f, o);
                    l.items.push(r),
                    u = r.range[2],
                    oT(h) && o(r.range, "BLOCK_IN_FLOW", rT)
                }
            }
            const d = a ? "}" : "]"
              , [p,...h] = r.end;
            let f = u;
            if (p && p.source === d)
                f = p.offset + p.source.length;
            else {
                const e = s[0].toUpperCase() + s.substring(1);
                o(u, c ? "MISSING_CHAR" : "BAD_INDENT", c ? `${e} must end with a ${d}` : `${e} in block collection must be sufficiently indented and end with a ${d}`),
                p && 1 !== p.source.length && h.unshift(p)
            }
            if (h.length > 0) {
                const e = nT(h, f, n.options.strict, o);
                e.comment && (l.comment ? l.comment += "\n" + e.comment : l.comment = e.comment),
                l.range = [r.offset, f, e.offset]
            } else
                l.range = [r.offset, f, f];
            return l
        }(e, t, n, r, i)
          , s = a.constructor;
        return "!" === o || o === s.tagName ? (a.tag = s.tagName,
        a) : (o && (a.tag = o),
        a)
    }
    function aT(e, t, n) {
        const r = t.offset
          , o = function({offset: e, props: t}, n, r) {
            if ("block-scalar-header" !== t[0].type)
                return r(t[0], "IMPOSSIBLE", "Block scalar header not found"),
                null;
            const {source: o} = t[0]
              , i = o[0];
            let a = 0
              , s = ""
              , l = -1;
            for (let p = 1; p < o.length; ++p) {
                const t = o[p];
                if (s || "-" !== t && "+" !== t) {
                    const n = Number(t);
                    !a && n ? a = n : -1 === l && (l = e + p)
                } else
                    s = t
            }
            -1 !== l && r(l, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${o}`);
            let c = !1
              , u = ""
              , d = o.length;
            for (let p = 1; p < t.length; ++p) {
                const e = t[p];
                switch (e.type) {
                case "space":
                    c = !0;
                case "newline":
                    d += e.source.length;
                    break;
                case "comment":
                    if (n && !c) {
                        r(e, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters")
                    }
                    d += e.source.length,
                    u = e.source.substring(1);
                    break;
                case "error":
                    r(e, "UNEXPECTED_TOKEN", e.message),
                    d += e.source.length;
                    break;
                default:
                    {
                        r(e, "UNEXPECTED_TOKEN", `Unexpected token in block scalar header: ${e.type}`);
                        const t = e.source;
                        t && "string" == typeof t && (d += t.length)
                    }
                }
            }
            return {
                mode: i,
                indent: a,
                chomp: s,
                comment: u,
                length: d
            }
        }(t, e.options.strict, n);
        if (!o)
            return {
                value: "",
                type: null,
                comment: "",
                range: [r, r, r]
            };
        const i = ">" === o.mode ? cE.BLOCK_FOLDED : cE.BLOCK_LITERAL
          , a = t.source ? function(e) {
            const t = e.split(/\n( *)/)
              , n = t[0]
              , r = n.match(/^( *)/)
              , o = [(null == r ? void 0 : r[1]) ? [r[1], n.slice(r[1].length)] : ["", n]];
            for (let i = 1; i < t.length; i += 2)
                o.push([t[i], t[i + 1]]);
            return o
        }(t.source) : [];
        let s = a.length;
        for (let m = a.length - 1; m >= 0; --m) {
            const e = a[m][1];
            if ("" !== e && "\r" !== e)
                break;
            s = m
        }
        if (0 === s) {
            const e = "+" === o.chomp && a.length > 0 ? "\n".repeat(Math.max(1, a.length - 1)) : "";
            let n = r + o.length;
            return t.source && (n += t.source.length),
            {
                value: e,
                type: i,
                comment: o.comment,
                range: [r, n, n]
            }
        }
        let l = t.indent + o.indent
          , c = t.offset + o.length
          , u = 0;
        for (let m = 0; m < s; ++m) {
            const [t,r] = a[m];
            if ("" !== r && "\r" !== r) {
                if (t.length < l) {
                    const e = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                    n(c + t.length, "MISSING_CHAR", e)
                }
                if (0 === o.indent && (l = t.length),
                u = m,
                0 === l && !e.atRoot) {
                    n(c, "BAD_INDENT", "Block scalar values in collections must be indented")
                }
                break
            }
            0 === o.indent && t.length > l && (l = t.length),
            c += t.length + r.length + 1
        }
        for (let m = a.length - 1; m >= s; --m)
            a[m][0].length > l && (s = m + 1);
        let d = ""
          , p = ""
          , h = !1;
        for (let m = 0; m < u; ++m)
            d += a[m][0].slice(l) + "\n";
        for (let m = u; m < s; ++m) {
            let[e,t] = a[m];
            c += e.length + t.length + 1;
            const r = "\r" === t[t.length - 1];
            if (r && (t = t.slice(0, -1)),
            t && e.length < l) {
                const i = `Block scalar lines must not be less indented than their ${o.indent ? "explicit indentation indicator" : "first line"}`;
                n(c - t.length - (r ? 2 : 1), "BAD_INDENT", i),
                e = ""
            }
            i === cE.BLOCK_LITERAL ? (d += p + e.slice(l) + t,
            p = "\n") : e.length > l || "\t" === t[0] ? (" " === p ? p = "\n" : h || "\n" !== p || (p = "\n\n"),
            d += p + e.slice(l) + t,
            p = "\n",
            h = !0) : "" === t ? "\n" === p ? d += "\n" : p = "\n" : (d += p + t,
            p = " ",
            h = !1)
        }
        switch (o.chomp) {
        case "-":
            break;
        case "+":
            for (let e = s; e < a.length; ++e)
                d += "\n" + a[e][0].slice(l);
            "\n" !== d[d.length - 1] && (d += "\n");
            break;
        default:
            d += "\n"
        }
        const f = r + o.length + t.source.length;
        return {
            value: d,
            type: i,
            comment: o.comment,
            range: [r, f, f]
        }
    }
    function sT(e, t, n) {
        const {offset: r, type: o, source: i, end: a} = e;
        let s, l;
        const c = (e,t,o)=>n(r + e, t, o);
        switch (o) {
        case "scalar":
            s = cE.PLAIN,
            l = function(e, t) {
                let n = "";
                switch (e[0]) {
                case "\t":
                    n = "a tab character";
                    break;
                case ",":
                    n = "flow indicator character ,";
                    break;
                case "%":
                    n = "directive indicator character %";
                    break;
                case "|":
                case ">":
                    n = `block scalar indicator ${e[0]}`;
                    break;
                case "@":
                case "`":
                    n = `reserved character ${e[0]}`
                }
                n && t(0, "BAD_SCALAR_START", `Plain value cannot start with ${n}`);
                return lT(e)
            }(i, c);
            break;
        case "single-quoted-scalar":
            s = cE.QUOTE_SINGLE,
            l = function(e, t) {
                "'" === e[e.length - 1] && 1 !== e.length || t(e.length, "MISSING_CHAR", "Missing closing 'quote");
                return lT(e.slice(1, -1)).replace(/''/g, "'")
            }(i, c);
            break;
        case "double-quoted-scalar":
            s = cE.QUOTE_DOUBLE,
            l = function(e, t) {
                let n = "";
                for (let r = 1; r < e.length - 1; ++r) {
                    const o = e[r];
                    if ("\r" !== o || "\n" !== e[r + 1])
                        if ("\n" === o) {
                            const {fold: t, offset: o} = cT(e, r);
                            n += t,
                            r = o
                        } else if ("\\" === o) {
                            let o = e[++r];
                            const i = uT[o];
                            if (i)
                                n += i;
                            else if ("\n" === o)
                                for (o = e[r + 1]; " " === o || "\t" === o; )
                                    o = e[1 + ++r];
                            else if ("\r" === o && "\n" === e[r + 1])
                                for (o = e[1 + ++r]; " " === o || "\t" === o; )
                                    o = e[1 + ++r];
                            else if ("x" === o || "u" === o || "U" === o) {
                                const i = {
                                    x: 2,
                                    u: 4,
                                    U: 8
                                }[o];
                                n += dT(e, r + 1, i, t),
                                r += i
                            } else {
                                const o = e.substr(r - 1, 2);
                                t(r - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${o}`),
                                n += o
                            }
                        } else if (" " === o || "\t" === o) {
                            const t = r;
                            let i = e[r + 1];
                            for (; " " === i || "\t" === i; )
                                i = e[1 + ++r];
                            "\n" === i || "\r" === i && "\n" === e[r + 2] || (n += r > t ? e.slice(t, r + 1) : o)
                        } else
                            n += o
                }
                '"' === e[e.length - 1] && 1 !== e.length || t(e.length, "MISSING_CHAR", 'Missing closing "quote');
                return n
            }(i, c);
            break;
        default:
            return n(e, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${o}`),
            {
                value: "",
                type: null,
                comment: "",
                range: [r, r + i.length, r + i.length]
            }
        }
        const u = r + i.length
          , d = nT(a, u, t, n);
        return {
            value: l,
            type: s,
            comment: d.comment,
            range: [r, u, d.offset]
        }
    }
    function lT(e) {
        let t, n;
        try {
            t = new RegExp("(.*?)(?<![ \t])[ \t]*\r?\n","sy"),
            n = new RegExp("[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n","sy")
        } catch (l) {
            t = /(.*?)[ \t]*\r?\n/sy,
            n = /[ \t]*(.*?)[ \t]*\r?\n/sy
        }
        let r = t.exec(e);
        if (!r)
            return e;
        let o = r[1]
          , i = " "
          , a = t.lastIndex;
        for (n.lastIndex = a; r = n.exec(e); )
            "" === r[1] ? "\n" === i ? o += i : i = "\n" : (o += i + r[1],
            i = " "),
            a = n.lastIndex;
        const s = /[ \t]*(.*)/sy;
        return s.lastIndex = a,
        r = s.exec(e),
        o + i + ((null == r ? void 0 : r[1]) ?? "")
    }
    function cT(e, t) {
        let n = ""
          , r = e[t + 1];
        for (; !(" " !== r && "\t" !== r && "\n" !== r && "\r" !== r || "\r" === r && "\n" !== e[t + 2]); )
            "\n" === r && (n += "\n"),
            r = e[(t += 1) + 1];
        return n || (n = " "),
        {
            fold: n,
            offset: t
        }
    }
    const uT = {
        0: "\0",
        a: "",
        b: "\b",
        e: "",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "\t",
        v: "\v",
        N: "",
        _: " ",
        L: "\u2028",
        P: "\u2029",
        " ": " ",
        '"': '"',
        "/": "/",
        "\\": "\\",
        "\t": "\t"
    };
    function dT(e, t, n, r) {
        const o = e.substr(t, n)
          , i = o.length === n && /^[0-9a-fA-F]+$/.test(o) ? parseInt(o, 16) : NaN;
        if (isNaN(i)) {
            const o = e.substr(t - 2, n + 2);
            return r(t - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${o}`),
            o
        }
        return String.fromCodePoint(i)
    }
    function pT(e, t, n, r) {
        const {value: o, type: i, comment: a, range: s} = "block-scalar" === t.type ? aT(e, t, r) : sT(t, e.options.strict, r)
          , l = n ? e.directives.tagName(n.source, (e=>r(n, "TAG_RESOLVE_FAILED", e))) : null
          , c = n && l ? function(e, t, n, r, o) {
            var i;
            if ("!" === n)
                return e[IS];
            const a = [];
            for (const l of e.tags)
                if (!l.collection && l.tag === n) {
                    if (!l.default || !l.test)
                        return l;
                    a.push(l)
                }
            for (const l of a)
                if (null == (i = l.test) ? void 0 : i.test(t))
                    return l;
            const s = e.knownTags[n];
            if (s && !s.collection)
                return e.tags.push(Object.assign({}, s, {
                    default: !1,
                    test: void 0
                })),
                s;
            return o(r, "TAG_RESOLVE_FAILED", `Unresolved tag: ${n}`, "tag:yaml.org,2002:str" !== n),
            e[IS]
        }(e.schema, o, l, n, r) : "scalar" === t.type ? function({directives: e, schema: t}, n, r, o) {
            const i = t.tags.find((e=>{
                var t;
                return e.default && (null == (t = e.test) ? void 0 : t.test(n))
            }
            )) || t[IS];
            if (t.compat) {
                const a = t.compat.find((e=>{
                    var t;
                    return e.default && (null == (t = e.test) ? void 0 : t.test(n))
                }
                )) ?? t[IS];
                if (i.tag !== a.tag) {
                    o(r, "TAG_RESOLVE_FAILED", `Value may be parsed as either ${e.tagString(i.tag)} or ${e.tagString(a.tag)}`, !0)
                }
            }
            return i
        }(e, o, t, r) : e.schema[IS];
        let u;
        try {
            const i = c.resolve(o, (e=>r(n ?? t, "TAG_RESOLVE_FAILED", e)), e.options);
            u = jS(i) ? i : new cE(i)
        } catch (d) {
            const e = d instanceof Error ? d.message : String(d);
            r(n ?? t, "TAG_RESOLVE_FAILED", e),
            u = new cE(o)
        }
        return u.range = s,
        u.source = o,
        i && (u.type = i),
        l && (u.tag = l),
        c.format && (u.format = c.format),
        a && (u.comment = a),
        u
    }
    function hT(e, t, n) {
        if (t) {
            null === n && (n = t.length);
            for (let r = n - 1; r >= 0; --r) {
                let n = t[r];
                switch (n.type) {
                case "space":
                case "comment":
                case "newline":
                    e -= n.source.length;
                    continue
                }
                for (n = t[++r]; "space" === (null == n ? void 0 : n.type); )
                    e += n.source.length,
                    n = t[++r];
                break
            }
        }
        return e
    }
    const fT = {
        composeNode: mT,
        composeEmptyNode: gT
    };
    function mT(e, t, n, r) {
        const {spaceBefore: o, comment: i, anchor: a, tag: s} = n;
        let l, c = !0;
        switch (t.type) {
        case "alias":
            l = function({options: e}, {offset: t, source: n, end: r}, o) {
                const i = new aE(n.substring(1));
                "" === i.source && o(t, "BAD_ALIAS", "Alias cannot be an empty string");
                i.source.endsWith(":") && o(t + n.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", !0);
                const a = t + n.length
                  , s = nT(r, a, e.strict, o);
                i.range = [t, a, s.offset],
                s.comment && (i.comment = s.comment);
                return i
            }(e, t, r),
            (a || s) && r(t, "ALIAS_PROPS", "An alias node must not specify any properties");
            break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
            l = pT(e, t, s, r),
            a && (l.anchor = a.source.substring(1));
            break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
            l = function(e, t, n, r, o) {
                var i;
                const a = r ? t.directives.tagName(r.source, (e=>o(r, "TAG_RESOLVE_FAILED", e))) : null
                  , s = "block-map" === n.type ? "map" : "block-seq" === n.type ? "seq" : "{" === n.start.source ? "map" : "seq";
                if (!r || !a || "!" === a || a === qE.tagName && "map" === s || a === ZE.tagName && "seq" === s || !s)
                    return iT(e, t, n, o, a);
                let l = t.schema.tags.find((e=>e.tag === a && e.collection === s));
                if (!l) {
                    const i = t.schema.knownTags[a];
                    if (!i || i.collection !== s)
                        return (null == i ? void 0 : i.collection) ? o(r, "BAD_COLLECTION_TYPE", `${i.tag} used for ${s} collection, but expects ${i.collection}`, !0) : o(r, "TAG_RESOLVE_FAILED", `Unresolved tag: ${a}`, !0),
                        iT(e, t, n, o, a);
                    t.schema.tags.push(Object.assign({}, i, {
                        default: !1
                    })),
                    l = i
                }
                const c = iT(e, t, n, o, a, l)
                  , u = (null == (i = l.resolve) ? void 0 : i.call(l, c, (e=>o(r, "TAG_RESOLVE_FAILED", e)), t.options)) ?? c
                  , d = HS(u) ? u : new cE(u);
                return d.range = c.range,
                d.tag = a,
                (null == l ? void 0 : l.format) && (d.format = l.format),
                d
            }(fT, e, t, s, r),
            a && (l.anchor = a.source.substring(1));
            break;
        default:
            r(t, "UNEXPECTED_TOKEN", "error" === t.type ? t.message : `Unsupported token (type: ${t.type})`),
            l = gT(e, t.offset, void 0, null, n, r),
            c = !1
        }
        return a && "" === l.anchor && r(a, "BAD_ALIAS", "Anchor cannot be an empty string"),
        o && (l.spaceBefore = !0),
        i && ("scalar" === t.type && "" === t.source ? l.comment = i : l.commentBefore = i),
        e.options.keepSourceTokens && c && (l.srcToken = t),
        l
    }
    function gT(e, t, n, r, {spaceBefore: o, comment: i, anchor: a, tag: s, end: l}, c) {
        const u = pT(e, {
            type: "scalar",
            offset: hT(t, n, r),
            indent: -1,
            source: ""
        }, s, c);
        return a && (u.anchor = a.source.substring(1),
        "" === u.anchor && c(a, "BAD_ALIAS", "Anchor cannot be an empty string")),
        o && (u.spaceBefore = !0),
        i && (u.comment = i,
        u.range[2] = l),
        u
    }
    function bT(e) {
        if ("number" == typeof e)
            return [e, e + 1];
        if (Array.isArray(e))
            return 2 === e.length ? e : [e[0], e[1]];
        const {offset: t, source: n} = e;
        return [t, t + ("string" == typeof n ? n.length : 1)]
    }
    function OT(e) {
        var t;
        let n = ""
          , r = !1
          , o = !1;
        for (let i = 0; i < e.length; ++i) {
            const a = e[i];
            switch (a[0]) {
            case "#":
                n += ("" === n ? "" : o ? "\n\n" : "\n") + (a.substring(1) || " "),
                r = !0,
                o = !1;
                break;
            case "%":
                "#" !== (null == (t = e[i + 1]) ? void 0 : t[0]) && (i += 1),
                r = !1;
                break;
            default:
                r || (o = !0),
                r = !1
            }
        }
        return {
            comment: n,
            afterEmptyLine: o
        }
    }
    class vT {
        constructor(e={}) {
            this.doc = null,
            this.atDirectives = !1,
            this.prelude = [],
            this.errors = [],
            this.warnings = [],
            this.onError = (e,t,n,r)=>{
                const o = bT(e);
                r ? this.warnings.push(new Vx(o,t,n)) : this.errors.push(new Xx(o,t,n))
            }
            ,
            this.directives = new JS({
                version: e.version || "1.2"
            }),
            this.options = e
        }
        decorate(e, t) {
            const {comment: n, afterEmptyLine: r} = OT(this.prelude);
            if (n) {
                const o = e.contents;
                if (t)
                    e.comment = e.comment ? `${e.comment}\n${n}` : n;
                else if (r || e.directives.docStart || !o)
                    e.commentBefore = n;
                else if (qS(o) && !o.flow && o.items.length > 0) {
                    let e = o.items[0];
                    FS(e) && (e = e.key);
                    const t = e.commentBefore;
                    e.commentBefore = t ? `${n}\n${t}` : n
                } else {
                    const e = o.commentBefore;
                    o.commentBefore = e ? `${n}\n${e}` : n
                }
            }
            t ? (Array.prototype.push.apply(e.errors, this.errors),
            Array.prototype.push.apply(e.warnings, this.warnings)) : (e.errors = this.errors,
            e.warnings = this.warnings),
            this.prelude = [],
            this.errors = [],
            this.warnings = []
        }
        streamInfo() {
            return {
                comment: OT(this.prelude).comment,
                directives: this.directives,
                errors: this.errors,
                warnings: this.warnings
            }
        }
        *compose(e, t=!1, n=-1) {
            for (const r of e)
                yield*this.next(r);
            yield*this.end(t, n)
        }
        *next(e) {
            switch (e.type) {
            case "directive":
                this.directives.add(e.source, ((t,n,r)=>{
                    const o = bT(e);
                    o[0] += t,
                    this.onError(o, "BAD_DIRECTIVE", n, r)
                }
                )),
                this.prelude.push(e.source),
                this.atDirectives = !0;
                break;
            case "document":
                {
                    const t = function(e, t, {offset: n, start: r, value: o, end: i}, a) {
                        const s = Object.assign({
                            _directives: t
                        }, e)
                          , l = new Hx(void 0,s)
                          , c = {
                            atRoot: !0,
                            directives: l.directives,
                            options: l.options,
                            schema: l.schema
                        }
                          , u = Yx(r, {
                            indicator: "doc-start",
                            next: o ?? (null == i ? void 0 : i[0]),
                            offset: n,
                            onError: a,
                            parentIndent: 0,
                            startOnNewline: !0
                        });
                        u.found && (l.directives.docStart = !0,
                        !o || "block-map" !== o.type && "block-seq" !== o.type || u.hasNewline || a(u.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")),
                        l.contents = o ? mT(c, o, u, a) : gT(c, u.end, r, null, u, a);
                        const d = l.contents.range[2]
                          , p = nT(i, d, !1, a);
                        return p.comment && (l.comment = p.comment),
                        l.range = [n, d, p.offset],
                        l
                    }(this.options, this.directives, e, this.onError);
                    this.atDirectives && !t.directives.docStart && this.onError(e, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"),
                    this.decorate(t, !1),
                    this.doc && (yield this.doc),
                    this.doc = t,
                    this.atDirectives = !1;
                    break
                }
            case "byte-order-mark":
            case "space":
                break;
            case "comment":
            case "newline":
                this.prelude.push(e.source);
                break;
            case "error":
                {
                    const t = e.source ? `${e.message}: ${JSON.stringify(e.source)}` : e.message
                      , n = new Xx(bT(e),"UNEXPECTED_TOKEN",t);
                    this.atDirectives || !this.doc ? this.errors.push(n) : this.doc.errors.push(n);
                    break
                }
            case "doc-end":
                {
                    if (!this.doc) {
                        const t = "Unexpected doc-end without preceding document";
                        this.errors.push(new Xx(bT(e),"UNEXPECTED_TOKEN",t));
                        break
                    }
                    this.doc.directives.docEnd = !0;
                    const t = nT(e.end, e.offset + e.source.length, this.doc.options.strict, this.onError);
                    if (this.decorate(this.doc, !0),
                    t.comment) {
                        const e = this.doc.comment;
                        this.doc.comment = e ? `${e}\n${t.comment}` : t.comment
                    }
                    this.doc.range[2] = t.offset;
                    break
                }
            default:
                this.errors.push(new Xx(bT(e),"UNEXPECTED_TOKEN",`Unsupported token ${e.type}`))
            }
        }
        *end(e=!1, t=-1) {
            if (this.doc)
                this.decorate(this.doc, !0),
                yield this.doc,
                this.doc = null;
            else if (e) {
                const e = Object.assign({
                    _directives: this.directives
                }, this.options)
                  , n = new Hx(void 0,e);
                this.atDirectives && this.onError(t, "MISSING_CHAR", "Missing directives-end indicator line"),
                n.range = [0, t, t],
                this.decorate(n, !1),
                yield n
            }
        }
    }
    function yT(e) {
        switch (e) {
        case void 0:
        case " ":
        case "\n":
        case "\r":
        case "\t":
            return !0;
        default:
            return !1
        }
    }
    const wT = new Set("0123456789ABCDEFabcdef")
      , _T = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()")
      , kT = new Set(",[]{}")
      , ST = new Set(" ,[]{}\n\r\t")
      , ET = e=>!e || ST.has(e);
    class xT {
        constructor() {
            this.atEnd = !1,
            this.blockScalarIndent = -1,
            this.blockScalarKeep = !1,
            this.buffer = "",
            this.flowKey = !1,
            this.flowLevel = 0,
            this.indentNext = 0,
            this.indentValue = 0,
            this.lineEndPos = null,
            this.next = null,
            this.pos = 0
        }
        *lex(e, t=!1) {
            if (e) {
                if ("string" != typeof e)
                    throw TypeError("source is not a string");
                this.buffer = this.buffer ? this.buffer + e : e,
                this.lineEndPos = null
            }
            this.atEnd = !t;
            let n = this.next ?? "stream";
            for (; n && (t || this.hasChars(1)); )
                n = yield*this.parseNext(n)
        }
        atLineEnd() {
            let e = this.pos
              , t = this.buffer[e];
            for (; " " === t || "\t" === t; )
                t = this.buffer[++e];
            return !t || "#" === t || "\n" === t || "\r" === t && "\n" === this.buffer[e + 1]
        }
        charAt(e) {
            return this.buffer[this.pos + e]
        }
        continueScalar(e) {
            let t = this.buffer[e];
            if (this.indentNext > 0) {
                let n = 0;
                for (; " " === t; )
                    t = this.buffer[++n + e];
                if ("\r" === t) {
                    const t = this.buffer[n + e + 1];
                    if ("\n" === t || !t && !this.atEnd)
                        return e + n + 1
                }
                return "\n" === t || n >= this.indentNext || !t && !this.atEnd ? e + n : -1
            }
            if ("-" === t || "." === t) {
                const t = this.buffer.substr(e, 3);
                if (("---" === t || "..." === t) && yT(this.buffer[e + 3]))
                    return -1
            }
            return e
        }
        getLine() {
            let e = this.lineEndPos;
            return ("number" != typeof e || -1 !== e && e < this.pos) && (e = this.buffer.indexOf("\n", this.pos),
            this.lineEndPos = e),
            -1 === e ? this.atEnd ? this.buffer.substring(this.pos) : null : ("\r" === this.buffer[e - 1] && (e -= 1),
            this.buffer.substring(this.pos, e))
        }
        hasChars(e) {
            return this.pos + e <= this.buffer.length
        }
        setNext(e) {
            return this.buffer = this.buffer.substring(this.pos),
            this.pos = 0,
            this.lineEndPos = null,
            this.next = e,
            null
        }
        peek(e) {
            return this.buffer.substr(this.pos, e)
        }
        *parseNext(e) {
            switch (e) {
            case "stream":
                return yield*this.parseStream();
            case "line-start":
                return yield*this.parseLineStart();
            case "block-start":
                return yield*this.parseBlockStart();
            case "doc":
                return yield*this.parseDocument();
            case "flow":
                return yield*this.parseFlowCollection();
            case "quoted-scalar":
                return yield*this.parseQuotedScalar();
            case "block-scalar":
                return yield*this.parseBlockScalar();
            case "plain-scalar":
                return yield*this.parsePlainScalar()
            }
        }
        *parseStream() {
            let e = this.getLine();
            if (null === e)
                return this.setNext("stream");
            if ("\ufeff" === e[0] && (yield*this.pushCount(1),
            e = e.substring(1)),
            "%" === e[0]) {
                let t = e.length
                  , n = e.indexOf("#");
                for (; -1 !== n; ) {
                    const r = e[n - 1];
                    if (" " === r || "\t" === r) {
                        t = n - 1;
                        break
                    }
                    n = e.indexOf("#", n + 1)
                }
                for (; ; ) {
                    const n = e[t - 1];
                    if (" " !== n && "\t" !== n)
                        break;
                    t -= 1
                }
                const r = (yield*this.pushCount(t)) + (yield*this.pushSpaces(!0));
                return yield*this.pushCount(e.length - r),
                this.pushNewline(),
                "stream"
            }
            if (this.atLineEnd()) {
                const t = yield*this.pushSpaces(!0);
                return yield*this.pushCount(e.length - t),
                yield*this.pushNewline(),
                "stream"
            }
            return yield"",
            yield*this.parseLineStart()
        }
        *parseLineStart() {
            const e = this.charAt(0);
            if (!e && !this.atEnd)
                return this.setNext("line-start");
            if ("-" === e || "." === e) {
                if (!this.atEnd && !this.hasChars(4))
                    return this.setNext("line-start");
                const e = this.peek(3);
                if ("---" === e && yT(this.charAt(3)))
                    return yield*this.pushCount(3),
                    this.indentValue = 0,
                    this.indentNext = 0,
                    "doc";
                if ("..." === e && yT(this.charAt(3)))
                    return yield*this.pushCount(3),
                    "stream"
            }
            return this.indentValue = yield*this.pushSpaces(!1),
            this.indentNext > this.indentValue && !yT(this.charAt(1)) && (this.indentNext = this.indentValue),
            yield*this.parseBlockStart()
        }
        *parseBlockStart() {
            const [e,t] = this.peek(2);
            if (!t && !this.atEnd)
                return this.setNext("block-start");
            if (("-" === e || "?" === e || ":" === e) && yT(t)) {
                const e = (yield*this.pushCount(1)) + (yield*this.pushSpaces(!0));
                return this.indentNext = this.indentValue + 1,
                this.indentValue += e,
                yield*this.parseBlockStart()
            }
            return "doc"
        }
        *parseDocument() {
            yield*this.pushSpaces(!0);
            const e = this.getLine();
            if (null === e)
                return this.setNext("doc");
            let t = yield*this.pushIndicators();
            switch (e[t]) {
            case "#":
                yield*this.pushCount(e.length - t);
            case void 0:
                return yield*this.pushNewline(),
                yield*this.parseLineStart();
            case "{":
            case "[":
                return yield*this.pushCount(1),
                this.flowKey = !1,
                this.flowLevel = 1,
                "flow";
            case "}":
            case "]":
                return yield*this.pushCount(1),
                "doc";
            case "*":
                return yield*this.pushUntil(ET),
                "doc";
            case '"':
            case "'":
                return yield*this.parseQuotedScalar();
            case "|":
            case ">":
                return t += (yield*this.parseBlockScalarHeader()),
                t += (yield*this.pushSpaces(!0)),
                yield*this.pushCount(e.length - t),
                yield*this.pushNewline(),
                yield*this.parseBlockScalar();
            default:
                return yield*this.parsePlainScalar()
            }
        }
        *parseFlowCollection() {
            let e, t, n = -1;
            do {
                e = yield*this.pushNewline(),
                e > 0 ? (t = yield*this.pushSpaces(!1),
                this.indentValue = n = t) : t = 0,
                t += (yield*this.pushSpaces(!0))
            } while (e + t > 0);
            const r = this.getLine();
            if (null === r)
                return this.setNext("flow");
            if (-1 !== n && n < this.indentNext && "#" !== r[0] || 0 === n && (r.startsWith("---") || r.startsWith("...")) && yT(r[3])) {
                if (!(n === this.indentNext - 1 && 1 === this.flowLevel && ("]" === r[0] || "}" === r[0])))
                    return this.flowLevel = 0,
                    yield"",
                    yield*this.parseLineStart()
            }
            let o = 0;
            for (; "," === r[o]; )
                o += (yield*this.pushCount(1)),
                o += (yield*this.pushSpaces(!0)),
                this.flowKey = !1;
            switch (o += (yield*this.pushIndicators()),
            r[o]) {
            case void 0:
                return "flow";
            case "#":
                return yield*this.pushCount(r.length - o),
                "flow";
            case "{":
            case "[":
                return yield*this.pushCount(1),
                this.flowKey = !1,
                this.flowLevel += 1,
                "flow";
            case "}":
            case "]":
                return yield*this.pushCount(1),
                this.flowKey = !0,
                this.flowLevel -= 1,
                this.flowLevel ? "flow" : "doc";
            case "*":
                return yield*this.pushUntil(ET),
                "flow";
            case '"':
            case "'":
                return this.flowKey = !0,
                yield*this.parseQuotedScalar();
            case ":":
                {
                    const e = this.charAt(1);
                    if (this.flowKey || yT(e) || "," === e)
                        return this.flowKey = !1,
                        yield*this.pushCount(1),
                        yield*this.pushSpaces(!0),
                        "flow"
                }
            default:
                return this.flowKey = !1,
                yield*this.parsePlainScalar()
            }
        }
        *parseQuotedScalar() {
            const e = this.charAt(0);
            let t = this.buffer.indexOf(e, this.pos + 1);
            if ("'" === e)
                for (; -1 !== t && "'" === this.buffer[t + 1]; )
                    t = this.buffer.indexOf("'", t + 2);
            else
                for (; -1 !== t; ) {
                    let e = 0;
                    for (; "\\" === this.buffer[t - 1 - e]; )
                        e += 1;
                    if (e % 2 == 0)
                        break;
                    t = this.buffer.indexOf('"', t + 1)
                }
            const n = this.buffer.substring(0, t);
            let r = n.indexOf("\n", this.pos);
            if (-1 !== r) {
                for (; -1 !== r; ) {
                    const e = this.continueScalar(r + 1);
                    if (-1 === e)
                        break;
                    r = n.indexOf("\n", e)
                }
                -1 !== r && (t = r - ("\r" === n[r - 1] ? 2 : 1))
            }
            if (-1 === t) {
                if (!this.atEnd)
                    return this.setNext("quoted-scalar");
                t = this.buffer.length
            }
            return yield*this.pushToIndex(t + 1, !1),
            this.flowLevel ? "flow" : "doc"
        }
        *parseBlockScalarHeader() {
            this.blockScalarIndent = -1,
            this.blockScalarKeep = !1;
            let e = this.pos;
            for (; ; ) {
                const t = this.buffer[++e];
                if ("+" === t)
                    this.blockScalarKeep = !0;
                else if (t > "0" && t <= "9")
                    this.blockScalarIndent = Number(t) - 1;
                else if ("-" !== t)
                    break
            }
            return yield*this.pushUntil((e=>yT(e) || "#" === e))
        }
        *parseBlockScalar() {
            let e, t = this.pos - 1, n = 0;
            e: for (let o = this.pos; e = this.buffer[o]; ++o)
                switch (e) {
                case " ":
                    n += 1;
                    break;
                case "\n":
                    t = o,
                    n = 0;
                    break;
                case "\r":
                    {
                        const e = this.buffer[o + 1];
                        if (!e && !this.atEnd)
                            return this.setNext("block-scalar");
                        if ("\n" === e)
                            break
                    }
                default:
                    break e
                }
            if (!e && !this.atEnd)
                return this.setNext("block-scalar");
            if (n >= this.indentNext) {
                -1 === this.blockScalarIndent ? this.indentNext = n : this.indentNext = this.blockScalarIndent + (0 === this.indentNext ? 1 : this.indentNext);
                do {
                    const e = this.continueScalar(t + 1);
                    if (-1 === e)
                        break;
                    t = this.buffer.indexOf("\n", e)
                } while (-1 !== t);
                if (-1 === t) {
                    if (!this.atEnd)
                        return this.setNext("block-scalar");
                    t = this.buffer.length
                }
            }
            let r = t + 1;
            for (e = this.buffer[r]; " " === e; )
                e = this.buffer[++r];
            if ("\t" === e) {
                for (; "\t" === e || " " === e || "\r" === e || "\n" === e; )
                    e = this.buffer[++r];
                t = r - 1
            } else if (!this.blockScalarKeep)
                for (; ; ) {
                    let e = t - 1
                      , r = this.buffer[e];
                    "\r" === r && (r = this.buffer[--e]);
                    const o = e;
                    for (; " " === r; )
                        r = this.buffer[--e];
                    if (!("\n" === r && e >= this.pos && e + 1 + n > o))
                        break;
                    t = e
                }
            return yield"",
            yield*this.pushToIndex(t + 1, !0),
            yield*this.parseLineStart()
        }
        *parsePlainScalar() {
            const e = this.flowLevel > 0;
            let t, n = this.pos - 1, r = this.pos - 1;
            for (; t = this.buffer[++r]; )
                if (":" === t) {
                    const t = this.buffer[r + 1];
                    if (yT(t) || e && kT.has(t))
                        break;
                    n = r
                } else if (yT(t)) {
                    let o = this.buffer[r + 1];
                    if ("\r" === t && ("\n" === o ? (r += 1,
                    t = "\n",
                    o = this.buffer[r + 1]) : n = r),
                    "#" === o || e && kT.has(o))
                        break;
                    if ("\n" === t) {
                        const e = this.continueScalar(r + 1);
                        if (-1 === e)
                            break;
                        r = Math.max(r, e - 2)
                    }
                } else {
                    if (e && kT.has(t))
                        break;
                    n = r
                }
            return t || this.atEnd ? (yield"",
            yield*this.pushToIndex(n + 1, !0),
            e ? "flow" : "doc") : this.setNext("plain-scalar")
        }
        *pushCount(e) {
            return e > 0 ? (yield this.buffer.substr(this.pos, e),
            this.pos += e,
            e) : 0
        }
        *pushToIndex(e, t) {
            const n = this.buffer.slice(this.pos, e);
            return n ? (yield n,
            this.pos += n.length,
            n.length) : (t && (yield""),
            0)
        }
        *pushIndicators() {
            switch (this.charAt(0)) {
            case "!":
                return (yield*this.pushTag()) + (yield*this.pushSpaces(!0)) + (yield*this.pushIndicators());
            case "&":
                return (yield*this.pushUntil(ET)) + (yield*this.pushSpaces(!0)) + (yield*this.pushIndicators());
            case "-":
            case "?":
            case ":":
                {
                    const e = this.flowLevel > 0
                      , t = this.charAt(1);
                    if (yT(t) || e && kT.has(t))
                        return e ? this.flowKey && (this.flowKey = !1) : this.indentNext = this.indentValue + 1,
                        (yield*this.pushCount(1)) + (yield*this.pushSpaces(!0)) + (yield*this.pushIndicators())
                }
            }
            return 0
        }
        *pushTag() {
            if ("<" === this.charAt(1)) {
                let e = this.pos + 2
                  , t = this.buffer[e];
                for (; !yT(t) && ">" !== t; )
                    t = this.buffer[++e];
                return yield*this.pushToIndex(">" === t ? e + 1 : e, !1)
            }
            {
                let e = this.pos + 1
                  , t = this.buffer[e];
                for (; t; )
                    if (_T.has(t))
                        t = this.buffer[++e];
                    else {
                        if ("%" !== t || !wT.has(this.buffer[e + 1]) || !wT.has(this.buffer[e + 2]))
                            break;
                        t = this.buffer[e += 3]
                    }
                return yield*this.pushToIndex(e, !1)
            }
        }
        *pushNewline() {
            const e = this.buffer[this.pos];
            return "\n" === e ? yield*this.pushCount(1) : "\r" === e && "\n" === this.charAt(1) ? yield*this.pushCount(2) : 0
        }
        *pushSpaces(e) {
            let t, n = this.pos - 1;
            do {
                t = this.buffer[++n]
            } while (" " === t || e && "\t" === t);
            const r = n - this.pos;
            return r > 0 && (yield this.buffer.substr(this.pos, r),
            this.pos = n),
            r
        }
        *pushUntil(e) {
            let t = this.pos
              , n = this.buffer[t];
            for (; !e(n); )
                n = this.buffer[++t];
            return yield*this.pushToIndex(t, !1)
        }
    }
    class TT {
        constructor() {
            this.lineStarts = [],
            this.addNewLine = e=>this.lineStarts.push(e),
            this.linePos = e=>{
                let t = 0
                  , n = this.lineStarts.length;
                for (; t < n; ) {
                    const r = t + n >> 1;
                    this.lineStarts[r] < e ? t = r + 1 : n = r
                }
                if (this.lineStarts[t] === e)
                    return {
                        line: t + 1,
                        col: 1
                    };
                if (0 === t)
                    return {
                        line: 0,
                        col: e
                    };
                return {
                    line: t,
                    col: e - this.lineStarts[t - 1] + 1
                }
            }
        }
    }
    function AT(e, t) {
        for (let n = 0; n < e.length; ++n)
            if (e[n].type === t)
                return !0;
        return !1
    }
    function CT(e) {
        for (let t = 0; t < e.length; ++t)
            switch (e[t].type) {
            case "space":
            case "comment":
            case "newline":
                break;
            default:
                return t
            }
        return -1
    }
    function PT(e) {
        switch (null == e ? void 0 : e.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
            return !0;
        default:
            return !1
        }
    }
    function DT(e) {
        switch (e.type) {
        case "document":
            return e.start;
        case "block-map":
            {
                const t = e.items[e.items.length - 1];
                return t.sep ?? t.start
            }
        case "block-seq":
            return e.items[e.items.length - 1].start;
        default:
            return []
        }
    }
    function RT(e) {
        var t;
        if (0 === e.length)
            return [];
        let n = e.length;
        e: for (; --n >= 0; )
            switch (e[n].type) {
            case "doc-start":
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
            case "newline":
                break e
            }
        for (; "space" === (null == (t = e[++n]) ? void 0 : t.type); )
            ;
        return e.splice(n, e.length)
    }
    function NT(e) {
        if ("flow-seq-start" === e.start.type)
            for (const t of e.items)
                !t.sep || t.value || AT(t.start, "explicit-key-ind") || AT(t.sep, "map-value-ind") || (t.key && (t.value = t.key),
                delete t.key,
                PT(t.value) ? t.value.end ? Array.prototype.push.apply(t.value.end, t.sep) : t.value.end = t.sep : Array.prototype.push.apply(t.start, t.sep),
                delete t.sep)
    }
    let $T = class {
        constructor(e) {
            this.atNewLine = !0,
            this.atScalar = !1,
            this.indent = 0,
            this.offset = 0,
            this.onKeyLine = !1,
            this.stack = [],
            this.source = "",
            this.type = "",
            this.lexer = new xT,
            this.onNewLine = e
        }
        *parse(e, t=!1) {
            this.onNewLine && 0 === this.offset && this.onNewLine(0);
            for (const n of this.lexer.lex(e, t))
                yield*this.next(n);
            t || (yield*this.end())
        }
        *next(e) {
            if (this.source = e,
            this.atScalar)
                return this.atScalar = !1,
                yield*this.step(),
                void (this.offset += e.length);
            const t = function(e) {
                switch (e) {
                case "\ufeff":
                    return "byte-order-mark";
                case "":
                    return "doc-mode";
                case "":
                    return "flow-error-end";
                case "":
                    return "scalar";
                case "---":
                    return "doc-start";
                case "...":
                    return "doc-end";
                case "":
                case "\n":
                case "\r\n":
                    return "newline";
                case "-":
                    return "seq-item-ind";
                case "?":
                    return "explicit-key-ind";
                case ":":
                    return "map-value-ind";
                case "{":
                    return "flow-map-start";
                case "}":
                    return "flow-map-end";
                case "[":
                    return "flow-seq-start";
                case "]":
                    return "flow-seq-end";
                case ",":
                    return "comma"
                }
                switch (e[0]) {
                case " ":
                case "\t":
                    return "space";
                case "#":
                    return "comment";
                case "%":
                    return "directive-line";
                case "*":
                    return "alias";
                case "&":
                    return "anchor";
                case "!":
                    return "tag";
                case "'":
                    return "single-quoted-scalar";
                case '"':
                    return "double-quoted-scalar";
                case "|":
                case ">":
                    return "block-scalar-header"
                }
                return null
            }(e);
            if (t)
                if ("scalar" === t)
                    this.atNewLine = !1,
                    this.atScalar = !0,
                    this.type = "scalar";
                else {
                    switch (this.type = t,
                    yield*this.step(),
                    t) {
                    case "newline":
                        this.atNewLine = !0,
                        this.indent = 0,
                        this.onNewLine && this.onNewLine(this.offset + e.length);
                        break;
                    case "space":
                        this.atNewLine && " " === e[0] && (this.indent += e.length);
                        break;
                    case "explicit-key-ind":
                    case "map-value-ind":
                    case "seq-item-ind":
                        this.atNewLine && (this.indent += e.length);
                        break;
                    case "doc-mode":
                    case "flow-error-end":
                        return;
                    default:
                        this.atNewLine = !1
                    }
                    this.offset += e.length
                }
            else {
                const t = `Not a YAML token: ${e}`;
                yield*this.pop({
                    type: "error",
                    offset: this.offset,
                    message: t,
                    source: e
                }),
                this.offset += e.length
            }
        }
        *end() {
            for (; this.stack.length > 0; )
                yield*this.pop()
        }
        get sourceToken() {
            return {
                type: this.type,
                offset: this.offset,
                indent: this.indent,
                source: this.source
            }
        }
        *step() {
            const e = this.peek(1);
            if ("doc-end" !== this.type || e && "doc-end" === e.type) {
                if (!e)
                    return yield*this.stream();
                switch (e.type) {
                case "document":
                    return yield*this.document(e);
                case "alias":
                case "scalar":
                case "single-quoted-scalar":
                case "double-quoted-scalar":
                    return yield*this.scalar(e);
                case "block-scalar":
                    return yield*this.blockScalar(e);
                case "block-map":
                    return yield*this.blockMap(e);
                case "block-seq":
                    return yield*this.blockSequence(e);
                case "flow-collection":
                    return yield*this.flowCollection(e);
                case "doc-end":
                    return yield*this.documentEnd(e)
                }
                yield*this.pop()
            } else {
                for (; this.stack.length > 0; )
                    yield*this.pop();
                this.stack.push({
                    type: "doc-end",
                    offset: this.offset,
                    source: this.source
                })
            }
        }
        peek(e) {
            return this.stack[this.stack.length - e]
        }
        *pop(e) {
            const t = e ?? this.stack.pop();
            if (t)
                if (0 === this.stack.length)
                    yield t;
                else {
                    const e = this.peek(1);
                    switch ("block-scalar" === t.type ? t.indent = "indent"in e ? e.indent : 0 : "flow-collection" === t.type && "document" === e.type && (t.indent = 0),
                    "flow-collection" === t.type && NT(t),
                    e.type) {
                    case "document":
                        e.value = t;
                        break;
                    case "block-scalar":
                        e.props.push(t);
                        break;
                    case "block-map":
                        {
                            const n = e.items[e.items.length - 1];
                            if (n.value)
                                return e.items.push({
                                    start: [],
                                    key: t,
                                    sep: []
                                }),
                                void (this.onKeyLine = !0);
                            if (!n.sep)
                                return Object.assign(n, {
                                    key: t,
                                    sep: []
                                }),
                                void (this.onKeyLine = !n.explicitKey);
                            n.value = t;
                            break
                        }
                    case "block-seq":
                        {
                            const n = e.items[e.items.length - 1];
                            n.value ? e.items.push({
                                start: [],
                                value: t
                            }) : n.value = t;
                            break
                        }
                    case "flow-collection":
                        {
                            const n = e.items[e.items.length - 1];
                            return void (!n || n.value ? e.items.push({
                                start: [],
                                key: t,
                                sep: []
                            }) : n.sep ? n.value = t : Object.assign(n, {
                                key: t,
                                sep: []
                            }))
                        }
                    default:
                        yield*this.pop(),
                        yield*this.pop(t)
                    }
                    if (!("document" !== e.type && "block-map" !== e.type && "block-seq" !== e.type || "block-map" !== t.type && "block-seq" !== t.type)) {
                        const n = t.items[t.items.length - 1];
                        n && !n.sep && !n.value && n.start.length > 0 && -1 === CT(n.start) && (0 === t.indent || n.start.every((e=>"comment" !== e.type || e.indent < t.indent))) && ("document" === e.type ? e.end = n.start : e.items.push({
                            start: n.start
                        }),
                        t.items.splice(-1, 1))
                    }
                }
            else {
                const e = "Tried to pop an empty stack";
                yield{
                    type: "error",
                    offset: this.offset,
                    source: "",
                    message: e
                }
            }
        }
        *stream() {
            switch (this.type) {
            case "directive-line":
                return void (yield{
                    type: "directive",
                    offset: this.offset,
                    source: this.source
                });
            case "byte-order-mark":
            case "space":
            case "comment":
            case "newline":
                return void (yield this.sourceToken);
            case "doc-mode":
            case "doc-start":
                {
                    const e = {
                        type: "document",
                        offset: this.offset,
                        start: []
                    };
                    return "doc-start" === this.type && e.start.push(this.sourceToken),
                    void this.stack.push(e)
                }
            }
            yield{
                type: "error",
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML stream`,
                source: this.source
            }
        }
        *document(e) {
            if (e.value)
                return yield*this.lineEnd(e);
            switch (this.type) {
            case "doc-start":
                return void (-1 !== CT(e.start) ? (yield*this.pop(),
                yield*this.step()) : e.start.push(this.sourceToken));
            case "anchor":
            case "tag":
            case "space":
            case "comment":
            case "newline":
                return void e.start.push(this.sourceToken)
            }
            const t = this.startBlockValue(e);
            t ? this.stack.push(t) : yield{
                type: "error",
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
            }
        }
        *scalar(e) {
            if ("map-value-ind" === this.type) {
                const t = RT(DT(this.peek(2)));
                let n;
                e.end ? (n = e.end,
                n.push(this.sourceToken),
                delete e.end) : n = [this.sourceToken];
                const r = {
                    type: "block-map",
                    offset: e.offset,
                    indent: e.indent,
                    items: [{
                        start: t,
                        key: e,
                        sep: n
                    }]
                };
                this.onKeyLine = !0,
                this.stack[this.stack.length - 1] = r
            } else
                yield*this.lineEnd(e)
        }
        *blockScalar(e) {
            switch (this.type) {
            case "space":
            case "comment":
            case "newline":
                return void e.props.push(this.sourceToken);
            case "scalar":
                if (e.source = this.source,
                this.atNewLine = !0,
                this.indent = 0,
                this.onNewLine) {
                    let e = this.source.indexOf("\n") + 1;
                    for (; 0 !== e; )
                        this.onNewLine(this.offset + e),
                        e = this.source.indexOf("\n", e) + 1
                }
                yield*this.pop();
                break;
            default:
                yield*this.pop(),
                yield*this.step()
            }
        }
        *blockMap(e) {
            var t;
            const n = e.items[e.items.length - 1];
            switch (this.type) {
            case "newline":
                if (this.onKeyLine = !1,
                n.value) {
                    const t = "end"in n.value ? n.value.end : void 0
                      , r = Array.isArray(t) ? t[t.length - 1] : void 0;
                    "comment" === (null == r ? void 0 : r.type) ? null == t || t.push(this.sourceToken) : e.items.push({
                        start: [this.sourceToken]
                    })
                } else
                    n.sep ? n.sep.push(this.sourceToken) : n.start.push(this.sourceToken);
                return;
            case "space":
            case "comment":
                if (n.value)
                    e.items.push({
                        start: [this.sourceToken]
                    });
                else if (n.sep)
                    n.sep.push(this.sourceToken);
                else {
                    if (this.atIndentedComment(n.start, e.indent)) {
                        const r = e.items[e.items.length - 2]
                          , o = null == (t = null == r ? void 0 : r.value) ? void 0 : t.end;
                        if (Array.isArray(o))
                            return Array.prototype.push.apply(o, n.start),
                            o.push(this.sourceToken),
                            void e.items.pop()
                    }
                    n.start.push(this.sourceToken)
                }
                return
            }
            if (this.indent >= e.indent) {
                const t = !this.onKeyLine && this.indent === e.indent
                  , r = t && (n.sep || n.explicitKey) && "seq-item-ind" !== this.type;
                let o = [];
                if (r && n.sep && !n.value) {
                    const t = [];
                    for (let r = 0; r < n.sep.length; ++r) {
                        const o = n.sep[r];
                        switch (o.type) {
                        case "newline":
                            t.push(r);
                            break;
                        case "space":
                            break;
                        case "comment":
                            o.indent > e.indent && (t.length = 0);
                            break;
                        default:
                            t.length = 0
                        }
                    }
                    t.length >= 2 && (o = n.sep.splice(t[1]))
                }
                switch (this.type) {
                case "anchor":
                case "tag":
                    return void (r || n.value ? (o.push(this.sourceToken),
                    e.items.push({
                        start: o
                    }),
                    this.onKeyLine = !0) : n.sep ? n.sep.push(this.sourceToken) : n.start.push(this.sourceToken));
                case "explicit-key-ind":
                    return n.sep || n.explicitKey ? r || n.value ? (o.push(this.sourceToken),
                    e.items.push({
                        start: o,
                        explicitKey: !0
                    })) : this.stack.push({
                        type: "block-map",
                        offset: this.offset,
                        indent: this.indent,
                        items: [{
                            start: [this.sourceToken],
                            explicitKey: !0
                        }]
                    }) : (n.start.push(this.sourceToken),
                    n.explicitKey = !0),
                    void (this.onKeyLine = !0);
                case "map-value-ind":
                    if (n.explicitKey)
                        if (n.sep)
                            if (n.value)
                                e.items.push({
                                    start: [],
                                    key: null,
                                    sep: [this.sourceToken]
                                });
                            else if (AT(n.sep, "map-value-ind"))
                                this.stack.push({
                                    type: "block-map",
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [{
                                        start: o,
                                        key: null,
                                        sep: [this.sourceToken]
                                    }]
                                });
                            else if (PT(n.key) && !AT(n.sep, "newline")) {
                                const e = RT(n.start)
                                  , t = n.key
                                  , r = n.sep;
                                r.push(this.sourceToken),
                                delete n.key,
                                delete n.sep,
                                this.stack.push({
                                    type: "block-map",
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [{
                                        start: e,
                                        key: t,
                                        sep: r
                                    }]
                                })
                            } else
                                o.length > 0 ? n.sep = n.sep.concat(o, this.sourceToken) : n.sep.push(this.sourceToken);
                        else if (AT(n.start, "newline"))
                            Object.assign(n, {
                                key: null,
                                sep: [this.sourceToken]
                            });
                        else {
                            const e = RT(n.start);
                            this.stack.push({
                                type: "block-map",
                                offset: this.offset,
                                indent: this.indent,
                                items: [{
                                    start: e,
                                    key: null,
                                    sep: [this.sourceToken]
                                }]
                            })
                        }
                    else
                        n.sep ? n.value || r ? e.items.push({
                            start: o,
                            key: null,
                            sep: [this.sourceToken]
                        }) : AT(n.sep, "map-value-ind") ? this.stack.push({
                            type: "block-map",
                            offset: this.offset,
                            indent: this.indent,
                            items: [{
                                start: [],
                                key: null,
                                sep: [this.sourceToken]
                            }]
                        }) : n.sep.push(this.sourceToken) : Object.assign(n, {
                            key: null,
                            sep: [this.sourceToken]
                        });
                    return void (this.onKeyLine = !0);
                case "alias":
                case "scalar":
                case "single-quoted-scalar":
                case "double-quoted-scalar":
                    {
                        const t = this.flowScalar(this.type);
                        return void (r || n.value ? (e.items.push({
                            start: o,
                            key: t,
                            sep: []
                        }),
                        this.onKeyLine = !0) : n.sep ? this.stack.push(t) : (Object.assign(n, {
                            key: t,
                            sep: []
                        }),
                        this.onKeyLine = !0))
                    }
                default:
                    {
                        const n = this.startBlockValue(e);
                        if (n)
                            return t && "block-seq" !== n.type && e.items.push({
                                start: o
                            }),
                            void this.stack.push(n)
                    }
                }
            }
            yield*this.pop(),
            yield*this.step()
        }
        *blockSequence(e) {
            var t;
            const n = e.items[e.items.length - 1];
            switch (this.type) {
            case "newline":
                if (n.value) {
                    const t = "end"in n.value ? n.value.end : void 0
                      , r = Array.isArray(t) ? t[t.length - 1] : void 0;
                    "comment" === (null == r ? void 0 : r.type) ? null == t || t.push(this.sourceToken) : e.items.push({
                        start: [this.sourceToken]
                    })
                } else
                    n.start.push(this.sourceToken);
                return;
            case "space":
            case "comment":
                if (n.value)
                    e.items.push({
                        start: [this.sourceToken]
                    });
                else {
                    if (this.atIndentedComment(n.start, e.indent)) {
                        const r = e.items[e.items.length - 2]
                          , o = null == (t = null == r ? void 0 : r.value) ? void 0 : t.end;
                        if (Array.isArray(o))
                            return Array.prototype.push.apply(o, n.start),
                            o.push(this.sourceToken),
                            void e.items.pop()
                    }
                    n.start.push(this.sourceToken)
                }
                return;
            case "anchor":
            case "tag":
                if (n.value || this.indent <= e.indent)
                    break;
                return void n.start.push(this.sourceToken);
            case "seq-item-ind":
                if (this.indent !== e.indent)
                    break;
                return void (n.value || AT(n.start, "seq-item-ind") ? e.items.push({
                    start: [this.sourceToken]
                }) : n.start.push(this.sourceToken))
            }
            if (this.indent > e.indent) {
                const t = this.startBlockValue(e);
                if (t)
                    return void this.stack.push(t)
            }
            yield*this.pop(),
            yield*this.step()
        }
        *flowCollection(e) {
            const t = e.items[e.items.length - 1];
            if ("flow-error-end" === this.type) {
                let e;
                do {
                    yield*this.pop(),
                    e = this.peek(1)
                } while (e && "flow-collection" === e.type)
            } else if (0 === e.end.length) {
                switch (this.type) {
                case "comma":
                case "explicit-key-ind":
                    return void (!t || t.sep ? e.items.push({
                        start: [this.sourceToken]
                    }) : t.start.push(this.sourceToken));
                case "map-value-ind":
                    return void (!t || t.value ? e.items.push({
                        start: [],
                        key: null,
                        sep: [this.sourceToken]
                    }) : t.sep ? t.sep.push(this.sourceToken) : Object.assign(t, {
                        key: null,
                        sep: [this.sourceToken]
                    }));
                case "space":
                case "comment":
                case "newline":
                case "anchor":
                case "tag":
                    return void (!t || t.value ? e.items.push({
                        start: [this.sourceToken]
                    }) : t.sep ? t.sep.push(this.sourceToken) : t.start.push(this.sourceToken));
                case "alias":
                case "scalar":
                case "single-quoted-scalar":
                case "double-quoted-scalar":
                    {
                        const n = this.flowScalar(this.type);
                        return void (!t || t.value ? e.items.push({
                            start: [],
                            key: n,
                            sep: []
                        }) : t.sep ? this.stack.push(n) : Object.assign(t, {
                            key: n,
                            sep: []
                        }))
                    }
                case "flow-map-end":
                case "flow-seq-end":
                    return void e.end.push(this.sourceToken)
                }
                const n = this.startBlockValue(e);
                n ? this.stack.push(n) : (yield*this.pop(),
                yield*this.step())
            } else {
                const t = this.peek(2);
                if ("block-map" === t.type && ("map-value-ind" === this.type && t.indent === e.indent || "newline" === this.type && !t.items[t.items.length - 1].sep))
                    yield*this.pop(),
                    yield*this.step();
                else if ("map-value-ind" === this.type && "flow-collection" !== t.type) {
                    const n = RT(DT(t));
                    NT(e);
                    const r = e.end.splice(1, e.end.length);
                    r.push(this.sourceToken);
                    const o = {
                        type: "block-map",
                        offset: e.offset,
                        indent: e.indent,
                        items: [{
                            start: n,
                            key: e,
                            sep: r
                        }]
                    };
                    this.onKeyLine = !0,
                    this.stack[this.stack.length - 1] = o
                } else
                    yield*this.lineEnd(e)
            }
        }
        flowScalar(e) {
            if (this.onNewLine) {
                let e = this.source.indexOf("\n") + 1;
                for (; 0 !== e; )
                    this.onNewLine(this.offset + e),
                    e = this.source.indexOf("\n", e) + 1
            }
            return {
                type: e,
                offset: this.offset,
                indent: this.indent,
                source: this.source
            }
        }
        startBlockValue(e) {
            switch (this.type) {
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar":
                return this.flowScalar(this.type);
            case "block-scalar-header":
                return {
                    type: "block-scalar",
                    offset: this.offset,
                    indent: this.indent,
                    props: [this.sourceToken],
                    source: ""
                };
            case "flow-map-start":
            case "flow-seq-start":
                return {
                    type: "flow-collection",
                    offset: this.offset,
                    indent: this.indent,
                    start: this.sourceToken,
                    items: [],
                    end: []
                };
            case "seq-item-ind":
                return {
                    type: "block-seq",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{
                        start: [this.sourceToken]
                    }]
                };
            case "explicit-key-ind":
                {
                    this.onKeyLine = !0;
                    const t = RT(DT(e));
                    return t.push(this.sourceToken),
                    {
                        type: "block-map",
                        offset: this.offset,
                        indent: this.indent,
                        items: [{
                            start: t,
                            explicitKey: !0
                        }]
                    }
                }
            case "map-value-ind":
                {
                    this.onKeyLine = !0;
                    const t = RT(DT(e));
                    return {
                        type: "block-map",
                        offset: this.offset,
                        indent: this.indent,
                        items: [{
                            start: t,
                            key: null,
                            sep: [this.sourceToken]
                        }]
                    }
                }
            }
            return null
        }
        atIndentedComment(e, t) {
            return "comment" === this.type && (!(this.indent <= t) && e.every((e=>"newline" === e.type || "space" === e.type)))
        }
        *documentEnd(e) {
            "doc-mode" !== this.type && (e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken],
            "newline" === this.type && (yield*this.pop()))
        }
        *lineEnd(e) {
            switch (this.type) {
            case "comma":
            case "doc-start":
            case "doc-end":
            case "flow-seq-end":
            case "flow-map-end":
            case "map-value-ind":
                yield*this.pop(),
                yield*this.step();
                break;
            case "newline":
                this.onKeyLine = !1;
            default:
                e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken],
                "newline" === this.type && (yield*this.pop())
            }
        }
    }
    ;
    function IT(e, t={}) {
        const {lineCounter: n, prettyErrors: r} = function(e) {
            const t = !1 !== e.prettyErrors;
            return {
                lineCounter: e.lineCounter || t && new TT || null,
                prettyErrors: t
            }
        }(t)
          , o = new $T(null == n ? void 0 : n.addNewLine)
          , i = new vT(t);
        let a = null;
        for (const s of i.compose(o.parse(e), !0, e.length))
            if (a) {
                if ("silent" !== a.options.logLevel) {
                    a.errors.push(new Xx(s.range.slice(0, 2),"MULTIPLE_DOCS","Source contains multiple documents; please use YAML.parseAllDocuments()"));
                    break
                }
            } else
                a = s;
        return r && n && (a.errors.forEach(Gx(e, n)),
        a.warnings.forEach(Gx(e, n))),
        a
    }
    const MT = {
        parse: e=>{
            const t = JSON.parse(e);
            if ("object" != typeof t)
                throw Error("Invalid JSON object");
            return t
        }
        ,
        parseSafe(e, t) {
            try {
                return MT.parse(e)
            } catch (n) {
                return "function" == typeof t ? t(n) : t
            }
        },
        stringify: e=>JSON.stringify(e)
    }
      , LT = e=>"string" == typeof e && !!MT.parseSafe(e, !1);
    async function QT(e, t) {
        "https://api.scalar.com/request-proxy" === t && (t = "https://proxy.scalar.com");
        const n = await fetch(t ? function(e, t) {
            return `${e}?scalar_url=${encodeURI(t)}`
        }(t, e) : e);
        return 200 !== n.status && (console.error(`[fetchSpecFromUrl] Failed to fetch the specification at ${e} (Status: ${n.status})`),
        t || console.warn(`[fetchSpecFromUrl] Tried to fetch the specification (url: ${e}) without a proxy. Are the CORS headers configured to allow cross-domain requests? https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS`)),
        function(e) {
            if ("{" !== e.trim()[0])
                return e;
            try {
                return JSON.stringify(JSON.parse(e), null, 2)
            } catch {
                return e
            }
        }(await n.text())
    }
    const BT = {
        100: {
            name: "Continue",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/100"
        },
        101: {
            name: "Switching Protocols",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101"
        },
        102: {
            name: "Processing",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/102"
        },
        103: {
            name: "Early Hints",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103"
        },
        200: {
            name: "OK",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200"
        },
        201: {
            name: "Created",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/201"
        },
        202: {
            name: "Accepted",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/202"
        },
        203: {
            name: "Non-Authoritative Information",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/203"
        },
        204: {
            name: "No Content",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/204"
        },
        205: {
            name: "Reset Content",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/205"
        },
        206: {
            name: "Partial Content",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206"
        },
        207: {
            name: "Multi-Status",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/207"
        },
        208: {
            name: "Already Reported",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/208"
        },
        226: {
            name: "IM Used",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/226"
        },
        300: {
            name: "Multiple Choices",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/300"
        },
        301: {
            name: "Moved Permanently",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301"
        },
        302: {
            name: "Found",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/302"
        },
        303: {
            name: "See Other",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/303"
        },
        304: {
            name: "Not Modified",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/304"
        },
        305: {
            name: "Use Proxy",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/305"
        },
        306: {
            name: "(Unused)",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/306"
        },
        307: {
            name: "Temporary Redirect",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/307"
        },
        308: {
            name: "Permanent Redirect",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/308"
        },
        400: {
            name: "Bad Request",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/400"
        },
        401: {
            name: "Unauthorized",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401"
        },
        402: {
            name: "Payment Required",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/402"
        },
        403: {
            name: "Forbidden",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/403"
        },
        404: {
            name: "Not Found",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404"
        },
        405: {
            name: "Method Not Allowed",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405"
        },
        406: {
            name: "Not Acceptable",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/406"
        },
        407: {
            name: "Proxy Authentication Required",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/407"
        },
        408: {
            name: "Request Timeout",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408"
        },
        409: {
            name: "Conflict",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409"
        },
        410: {
            name: "Gone",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/410"
        },
        411: {
            name: "Length Required",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/411"
        },
        412: {
            name: "Precondition Failed",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/412"
        },
        413: {
            name: "Content Too Large",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"
        },
        414: {
            name: "URI Too Long",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/414"
        },
        415: {
            name: "Unsupported Media Type",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/415"
        },
        416: {
            name: "Range Not Satisfiable",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/416"
        },
        417: {
            name: "Expectation Failed",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/417"
        },
        421: {
            name: "Misdirected Request",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/421"
        },
        422: {
            name: "Unprocessable Content",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/422"
        },
        423: {
            name: "Locked",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/423"
        },
        424: {
            name: "Failed Dependency",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/424"
        },
        425: {
            name: "Too Early",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/425"
        },
        426: {
            name: "Upgrade Required",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/426"
        },
        428: {
            name: "Precondition Required",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/428"
        },
        429: {
            name: "Too Many Requests",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"
        },
        431: {
            name: "Request Header Fields Too Large",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431"
        },
        451: {
            name: "Unavailable For Legal Reasons",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/451"
        },
        500: {
            name: "Internal Server Error",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500"
        },
        501: {
            name: "Not Implemented",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/501"
        },
        502: {
            name: "Bad Gateway",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502"
        },
        503: {
            name: "Service Unavailable",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"
        },
        504: {
            name: "Gateway Timeout",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504"
        },
        505: {
            name: "HTTP Version Not Supported",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/505"
        },
        506: {
            name: "Variant Also Negotiates",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/506"
        },
        507: {
            name: "Insufficient Storage",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/507"
        },
        508: {
            name: "Loop Detected",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/508"
        },
        510: {
            name: "Not Extended",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/510"
        },
        511: {
            name: "Network Authentication Required",
            url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/511"
        }
    };
    function UT(e) {
        if ("string" == typeof e)
            return e.replace(/;.*$/, "").replace(/\/.+\+/, "/").trim()
    }
    function FT(e) {
        if (!e)
            return e;
        const t = {
            ...e
        };
        return Object.keys(t).forEach((e=>{
            const n = UT(e);
            void 0 !== n && (t[n] = t[e],
            e !== n && delete t[e])
        }
        )),
        t
    }
    function jT(e, t) {
        return Object.keys(e).forEach((n=>{
            Object.hasOwn(t, n) || delete e[n]
        }
        )),
        Object.assign(e, t),
        e
    }
    const zT = e=>{
        if ("string" == typeof e)
            return LT(e) ? JSON.stringify(JSON.parse(e), null, 2) : e;
        if ("object" == typeof e)
            try {
                return JSON.stringify(e, null, 2)
            } catch {
                return function(e) {
                    const t = new Set;
                    return JSON.stringify(e, ((e,n)=>{
                        if ("object" == typeof n && null !== n) {
                            if (t.has(n))
                                return "[Circular]";
                            t.add(n)
                        }
                        return n
                    }
                    ), 2)
                }(e)
            }
        return e.toString()
    }
    ;
    const qT = "undefined" != typeof window ? window.__SCALAR__ ?? {} : {}
      , HT = ["innerHTML"]
      , ZT = Ln({
        __name: "ScalarCodeBlock",
        props: {
            content: {},
            lang: {
                default: "plaintext"
            },
            lineNumbers: {
                type: Boolean,
                default: !1
            },
            hideCredentials: {}
        },
        setup(e) {
            const t = e
              , n = ei((()=>CS(zT(t.content), {
                lang: t.lang.trim(),
                languages: dS,
                lineNumbers: t.lineNumbers,
                maskCredentials: t.hideCredentials
            }).slice(5, -6)));
            return (e,t)=>(mo(),
            vo("pre", {
                class: "scalar-component scalar-codeblock-pre",
                innerHTML: n.value
            }, null, 8, HT))
        }
    })
      , WT = ["innerHTML"]
      , XT = Ln({
        __name: "ScalarMarkdown",
        props: {
            value: {},
            withImages: {
                type: Boolean,
                default: !1
            }
        },
        setup(e) {
            const t = e
              , n = ei((()=>function(e, t) {
                const n = (null == t ? void 0 : t.removeTags) ?? []
                  , r = [...TO.tagNames ?? [], ...(null == t ? void 0 : t.allowTags) ?? []].filter((e=>!n.includes(e)));
                return oS().use(dk).use($_).use(Pk, {
                    allowDangerousHtml: !0
                }).use(EO).use(IO, {
                    ...TO,
                    tagNames: r,
                    attributes: {
                        ...TO.attributes,
                        abbr: ["title"]
                    }
                }).use(nh, {
                    languages: dS,
                    detect: !0
                }).use(vh, {
                    target: "_blank"
                }).use(Wh).use(Sv).processSync(e).toString()
            }(t.value ?? "", {
                removeTags: t.withImages ? [] : ["img", "picture"]
            })));
            return Cn((async()=>await (e=>new Promise((t=>setTimeout(t, e))))(1))),
            (e,t)=>(mo(),
            vo("div", {
                class: "markdown",
                innerHTML: n.value
            }, null, 8, WT))
        }
    })
      , VT = Math.min
      , GT = Math.max
      , YT = Math.round
      , KT = Math.floor
      , JT = e=>({
        x: e,
        y: e
    })
      , eA = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
    }
      , tA = {
        start: "end",
        end: "start"
    };
    function nA(e, t, n) {
        return GT(e, VT(t, n))
    }
    function rA(e, t) {
        return "function" == typeof e ? e(t) : e
    }
    function oA(e) {
        return e.split("-")[0]
    }
    function iA(e) {
        return e.split("-")[1]
    }
    function aA(e) {
        return "x" === e ? "y" : "x"
    }
    function sA(e) {
        return "y" === e ? "height" : "width"
    }
    function lA(e) {
        return ["top", "bottom"].includes(oA(e)) ? "y" : "x"
    }
    function cA(e) {
        return aA(lA(e))
    }
    function uA(e) {
        return e.replace(/start|end/g, (e=>tA[e]))
    }
    function dA(e) {
        return e.replace(/left|right|bottom|top/g, (e=>eA[e]))
    }
    function pA(e) {
        const {x: t, y: n, width: r, height: o} = e;
        return {
            width: r,
            height: o,
            top: n,
            left: t,
            right: t + r,
            bottom: n + o,
            x: t,
            y: n
        }
    }
    function hA(e, t, n) {
        let {reference: r, floating: o} = e;
        const i = lA(t)
          , a = cA(t)
          , s = sA(a)
          , l = oA(t)
          , c = "y" === i
          , u = r.x + r.width / 2 - o.width / 2
          , d = r.y + r.height / 2 - o.height / 2
          , p = r[s] / 2 - o[s] / 2;
        let h;
        switch (l) {
        case "top":
            h = {
                x: u,
                y: r.y - o.height
            };
            break;
        case "bottom":
            h = {
                x: u,
                y: r.y + r.height
            };
            break;
        case "right":
            h = {
                x: r.x + r.width,
                y: d
            };
            break;
        case "left":
            h = {
                x: r.x - o.width,
                y: d
            };
            break;
        default:
            h = {
                x: r.x,
                y: r.y
            }
        }
        switch (iA(t)) {
        case "start":
            h[a] -= p * (n && c ? -1 : 1);
            break;
        case "end":
            h[a] += p * (n && c ? -1 : 1)
        }
        return h
    }
    async function fA(e, t) {
        var n;
        void 0 === t && (t = {});
        const {x: r, y: o, platform: i, rects: a, elements: s, strategy: l} = e
          , {boundary: c="clippingAncestors", rootBoundary: u="viewport", elementContext: d="floating", altBoundary: p=!1, padding: h=0} = rA(t, e)
          , f = function(e) {
            return "number" != typeof e ? function(e) {
                return {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0,
                    ...e
                }
            }(e) : {
                top: e,
                right: e,
                bottom: e,
                left: e
            }
        }(h)
          , m = s[p ? "floating" === d ? "reference" : "floating" : d]
          , g = pA(await i.getClippingRect({
            element: null == (n = await (null == i.isElement ? void 0 : i.isElement(m))) || n ? m : m.contextElement || await (null == i.getDocumentElement ? void 0 : i.getDocumentElement(s.floating)),
            boundary: c,
            rootBoundary: u,
            strategy: l
        }))
          , b = "floating" === d ? {
            x: r,
            y: o,
            width: a.floating.width,
            height: a.floating.height
        } : a.reference
          , O = await (null == i.getOffsetParent ? void 0 : i.getOffsetParent(s.floating))
          , v = await (null == i.isElement ? void 0 : i.isElement(O)) && await (null == i.getScale ? void 0 : i.getScale(O)) || {
            x: 1,
            y: 1
        }
          , y = pA(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
            elements: s,
            rect: b,
            offsetParent: O,
            strategy: l
        }) : b);
        return {
            top: (g.top - y.top + f.top) / v.y,
            bottom: (y.bottom - g.bottom + f.bottom) / v.y,
            left: (g.left - y.left + f.left) / v.x,
            right: (y.right - g.right + f.right) / v.x
        }
    }
    function mA(e) {
        return OA(e) ? (e.nodeName || "").toLowerCase() : "#document"
    }
    function gA(e) {
        var t;
        return (null == e || null == (t = e.ownerDocument) ? void 0 : t.defaultView) || window
    }
    function bA(e) {
        var t;
        return null == (t = (OA(e) ? e.ownerDocument : e.document) || window.document) ? void 0 : t.documentElement
    }
    function OA(e) {
        return e instanceof Node || e instanceof gA(e).Node
    }
    function vA(e) {
        return e instanceof Element || e instanceof gA(e).Element
    }
    function yA(e) {
        return e instanceof HTMLElement || e instanceof gA(e).HTMLElement
    }
    function wA(e) {
        return "undefined" != typeof ShadowRoot && (e instanceof ShadowRoot || e instanceof gA(e).ShadowRoot)
    }
    function _A(e) {
        const {overflow: t, overflowX: n, overflowY: r, display: o} = TA(e);
        return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(o)
    }
    function kA(e) {
        return ["table", "td", "th"].includes(mA(e))
    }
    function SA(e) {
        const t = EA()
          , n = TA(e);
        return "none" !== n.transform || "none" !== n.perspective || !!n.containerType && "normal" !== n.containerType || !t && !!n.backdropFilter && "none" !== n.backdropFilter || !t && !!n.filter && "none" !== n.filter || ["transform", "perspective", "filter"].some((e=>(n.willChange || "").includes(e))) || ["paint", "layout", "strict", "content"].some((e=>(n.contain || "").includes(e)))
    }
    function EA() {
        return !("undefined" == typeof CSS || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none")
    }
    function xA(e) {
        return ["html", "body", "#document"].includes(mA(e))
    }
    function TA(e) {
        return gA(e).getComputedStyle(e)
    }
    function AA(e) {
        return vA(e) ? {
            scrollLeft: e.scrollLeft,
            scrollTop: e.scrollTop
        } : {
            scrollLeft: e.pageXOffset,
            scrollTop: e.pageYOffset
        }
    }
    function CA(e) {
        if ("html" === mA(e))
            return e;
        const t = e.assignedSlot || e.parentNode || wA(e) && e.host || bA(e);
        return wA(t) ? t.host : t
    }
    function PA(e) {
        const t = CA(e);
        return xA(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : yA(t) && _A(t) ? t : PA(t)
    }
    function DA(e, t, n) {
        var r;
        void 0 === t && (t = []),
        void 0 === n && (n = !0);
        const o = PA(e)
          , i = o === (null == (r = e.ownerDocument) ? void 0 : r.body)
          , a = gA(o);
        return i ? t.concat(a, a.visualViewport || [], _A(o) ? o : [], a.frameElement && n ? DA(a.frameElement) : []) : t.concat(o, DA(o, [], n))
    }
    function RA(e) {
        const t = TA(e);
        let n = parseFloat(t.width) || 0
          , r = parseFloat(t.height) || 0;
        const o = yA(e)
          , i = o ? e.offsetWidth : n
          , a = o ? e.offsetHeight : r
          , s = YT(n) !== i || YT(r) !== a;
        return s && (n = i,
        r = a),
        {
            width: n,
            height: r,
            $: s
        }
    }
    function NA(e) {
        return vA(e) ? e : e.contextElement
    }
    function $A(e) {
        const t = NA(e);
        if (!yA(t))
            return JT(1);
        const n = t.getBoundingClientRect()
          , {width: r, height: o, $: i} = RA(t);
        let a = (i ? YT(n.width) : n.width) / r
          , s = (i ? YT(n.height) : n.height) / o;
        return a && Number.isFinite(a) || (a = 1),
        s && Number.isFinite(s) || (s = 1),
        {
            x: a,
            y: s
        }
    }
    const IA = JT(0);
    function MA(e) {
        const t = gA(e);
        return EA() && t.visualViewport ? {
            x: t.visualViewport.offsetLeft,
            y: t.visualViewport.offsetTop
        } : IA
    }
    function LA(e, t, n, r) {
        void 0 === t && (t = !1),
        void 0 === n && (n = !1);
        const o = e.getBoundingClientRect()
          , i = NA(e);
        let a = JT(1);
        t && (r ? vA(r) && (a = $A(r)) : a = $A(e));
        const s = function(e, t, n) {
            return void 0 === t && (t = !1),
            !(!n || t && n !== gA(e)) && t
        }(i, n, r) ? MA(i) : JT(0);
        let l = (o.left + s.x) / a.x
          , c = (o.top + s.y) / a.y
          , u = o.width / a.x
          , d = o.height / a.y;
        if (i) {
            const e = gA(i)
              , t = r && vA(r) ? gA(r) : r;
            let n = e
              , o = n.frameElement;
            for (; o && r && t !== n; ) {
                const e = $A(o)
                  , t = o.getBoundingClientRect()
                  , r = TA(o)
                  , i = t.left + (o.clientLeft + parseFloat(r.paddingLeft)) * e.x
                  , a = t.top + (o.clientTop + parseFloat(r.paddingTop)) * e.y;
                l *= e.x,
                c *= e.y,
                u *= e.x,
                d *= e.y,
                l += i,
                c += a,
                n = gA(o),
                o = n.frameElement
            }
        }
        return pA({
            width: u,
            height: d,
            x: l,
            y: c
        })
    }
    const QA = [":popover-open", ":modal"];
    function BA(e) {
        return QA.some((t=>{
            try {
                return e.matches(t)
            } catch (Aa) {
                return !1
            }
        }
        ))
    }
    function UA(e) {
        return LA(bA(e)).left + AA(e).scrollLeft
    }
    function FA(e, t, n) {
        let r;
        if ("viewport" === t)
            r = function(e, t) {
                const n = gA(e)
                  , r = bA(e)
                  , o = n.visualViewport;
                let i = r.clientWidth
                  , a = r.clientHeight
                  , s = 0
                  , l = 0;
                if (o) {
                    i = o.width,
                    a = o.height;
                    const e = EA();
                    (!e || e && "fixed" === t) && (s = o.offsetLeft,
                    l = o.offsetTop)
                }
                return {
                    width: i,
                    height: a,
                    x: s,
                    y: l
                }
            }(e, n);
        else if ("document" === t)
            r = function(e) {
                const t = bA(e)
                  , n = AA(e)
                  , r = e.ownerDocument.body
                  , o = GT(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth)
                  , i = GT(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
                let a = -n.scrollLeft + UA(e);
                const s = -n.scrollTop;
                return "rtl" === TA(r).direction && (a += GT(t.clientWidth, r.clientWidth) - o),
                {
                    width: o,
                    height: i,
                    x: a,
                    y: s
                }
            }(bA(e));
        else if (vA(t))
            r = function(e, t) {
                const n = LA(e, !0, "fixed" === t)
                  , r = n.top + e.clientTop
                  , o = n.left + e.clientLeft
                  , i = yA(e) ? $A(e) : JT(1);
                return {
                    width: e.clientWidth * i.x,
                    height: e.clientHeight * i.y,
                    x: o * i.x,
                    y: r * i.y
                }
            }(t, n);
        else {
            const n = MA(e);
            r = {
                ...t,
                x: t.x - n.x,
                y: t.y - n.y
            }
        }
        return pA(r)
    }
    function jA(e, t) {
        const n = CA(e);
        return !(n === t || !vA(n) || xA(n)) && ("fixed" === TA(n).position || jA(n, t))
    }
    function zA(e, t, n) {
        const r = yA(t)
          , o = bA(t)
          , i = "fixed" === n
          , a = LA(e, !0, i, t);
        let s = {
            scrollLeft: 0,
            scrollTop: 0
        };
        const l = JT(0);
        if (r || !r && !i)
            if (("body" !== mA(t) || _A(o)) && (s = AA(t)),
            r) {
                const e = LA(t, !0, i, t);
                l.x = e.x + t.clientLeft,
                l.y = e.y + t.clientTop
            } else
                o && (l.x = UA(o));
        return {
            x: a.left + s.scrollLeft - l.x,
            y: a.top + s.scrollTop - l.y,
            width: a.width,
            height: a.height
        }
    }
    function qA(e) {
        return "static" === TA(e).position
    }
    function HA(e, t) {
        return yA(e) && "fixed" !== TA(e).position ? t ? t(e) : e.offsetParent : null
    }
    function ZA(e, t) {
        const n = gA(e);
        if (BA(e))
            return n;
        if (!yA(e)) {
            let t = CA(e);
            for (; t && !xA(t); ) {
                if (vA(t) && !qA(t))
                    return t;
                t = CA(t)
            }
            return n
        }
        let r = HA(e, t);
        for (; r && kA(r) && qA(r); )
            r = HA(r, t);
        return r && xA(r) && qA(r) && !SA(r) ? n : r || function(e) {
            let t = CA(e);
            for (; yA(t) && !xA(t); ) {
                if (SA(t))
                    return t;
                t = CA(t)
            }
            return null
        }(e) || n
    }
    const WA = {
        convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
            let {elements: t, rect: n, offsetParent: r, strategy: o} = e;
            const i = "fixed" === o
              , a = bA(r)
              , s = !!t && BA(t.floating);
            if (r === a || s && i)
                return n;
            let l = {
                scrollLeft: 0,
                scrollTop: 0
            }
              , c = JT(1);
            const u = JT(0)
              , d = yA(r);
            if ((d || !d && !i) && (("body" !== mA(r) || _A(a)) && (l = AA(r)),
            yA(r))) {
                const e = LA(r);
                c = $A(r),
                u.x = e.x + r.clientLeft,
                u.y = e.y + r.clientTop
            }
            return {
                width: n.width * c.x,
                height: n.height * c.y,
                x: n.x * c.x - l.scrollLeft * c.x + u.x,
                y: n.y * c.y - l.scrollTop * c.y + u.y
            }
        },
        getDocumentElement: bA,
        getClippingRect: function(e) {
            let {element: t, boundary: n, rootBoundary: r, strategy: o} = e;
            const i = [..."clippingAncestors" === n ? BA(t) ? [] : function(e, t) {
                const n = t.get(e);
                if (n)
                    return n;
                let r = DA(e, [], !1).filter((e=>vA(e) && "body" !== mA(e)))
                  , o = null;
                const i = "fixed" === TA(e).position;
                let a = i ? CA(e) : e;
                for (; vA(a) && !xA(a); ) {
                    const t = TA(a)
                      , n = SA(a);
                    n || "fixed" !== t.position || (o = null),
                    (i ? !n && !o : !n && "static" === t.position && o && ["absolute", "fixed"].includes(o.position) || _A(a) && !n && jA(e, a)) ? r = r.filter((e=>e !== a)) : o = t,
                    a = CA(a)
                }
                return t.set(e, r),
                r
            }(t, this._c) : [].concat(n), r]
              , a = i[0]
              , s = i.reduce(((e,n)=>{
                const r = FA(t, n, o);
                return e.top = GT(r.top, e.top),
                e.right = VT(r.right, e.right),
                e.bottom = VT(r.bottom, e.bottom),
                e.left = GT(r.left, e.left),
                e
            }
            ), FA(t, a, o));
            return {
                width: s.right - s.left,
                height: s.bottom - s.top,
                x: s.left,
                y: s.top
            }
        },
        getOffsetParent: ZA,
        getElementRects: async function(e) {
            const t = this.getOffsetParent || ZA
              , n = this.getDimensions
              , r = await n(e.floating);
            return {
                reference: zA(e.reference, await t(e.floating), e.strategy),
                floating: {
                    x: 0,
                    y: 0,
                    width: r.width,
                    height: r.height
                }
            }
        },
        getClientRects: function(e) {
            return Array.from(e.getClientRects())
        },
        getDimensions: function(e) {
            const {width: t, height: n} = RA(e);
            return {
                width: t,
                height: n
            }
        },
        getScale: $A,
        isElement: vA,
        isRTL: function(e) {
            return "rtl" === TA(e).direction
        }
    };
    function XA(e, t, n, r) {
        void 0 === r && (r = {});
        const {ancestorScroll: o=!0, ancestorResize: i=!0, elementResize: a="function" == typeof ResizeObserver, layoutShift: s="function" == typeof IntersectionObserver, animationFrame: l=!1} = r
          , c = NA(e)
          , u = o || i ? [...c ? DA(c) : [], ...DA(t)] : [];
        u.forEach((e=>{
            o && e.addEventListener("scroll", n, {
                passive: !0
            }),
            i && e.addEventListener("resize", n)
        }
        ));
        const d = c && s ? function(e, t) {
            let n, r = null;
            const o = bA(e);
            function i() {
                var e;
                clearTimeout(n),
                null == (e = r) || e.disconnect(),
                r = null
            }
            return function a(s, l) {
                void 0 === s && (s = !1),
                void 0 === l && (l = 1),
                i();
                const {left: c, top: u, width: d, height: p} = e.getBoundingClientRect();
                if (s || t(),
                !d || !p)
                    return;
                const h = {
                    rootMargin: -KT(u) + "px " + -KT(o.clientWidth - (c + d)) + "px " + -KT(o.clientHeight - (u + p)) + "px " + -KT(c) + "px",
                    threshold: GT(0, VT(1, l)) || 1
                };
                let f = !0;
                function m(e) {
                    const t = e[0].intersectionRatio;
                    if (t !== l) {
                        if (!f)
                            return a();
                        t ? a(!1, t) : n = setTimeout((()=>{
                            a(!1, 1e-7)
                        }
                        ), 1e3)
                    }
                    f = !1
                }
                try {
                    r = new IntersectionObserver(m,{
                        ...h,
                        root: o.ownerDocument
                    })
                } catch (Aa) {
                    r = new IntersectionObserver(m,h)
                }
                r.observe(e)
            }(!0),
            i
        }(c, n) : null;
        let p, h = -1, f = null;
        a && (f = new ResizeObserver((e=>{
            let[r] = e;
            r && r.target === c && f && (f.unobserve(t),
            cancelAnimationFrame(h),
            h = requestAnimationFrame((()=>{
                var e;
                null == (e = f) || e.observe(t)
            }
            ))),
            n()
        }
        )),
        c && !l && f.observe(c),
        f.observe(t));
        let m = l ? LA(e) : null;
        return l && function t() {
            const r = LA(e);
            !m || r.x === m.x && r.y === m.y && r.width === m.width && r.height === m.height || n();
            m = r,
            p = requestAnimationFrame(t)
        }(),
        n(),
        ()=>{
            var e;
            u.forEach((e=>{
                o && e.removeEventListener("scroll", n),
                i && e.removeEventListener("resize", n)
            }
            )),
            null == d || d(),
            null == (e = f) || e.disconnect(),
            f = null,
            l && cancelAnimationFrame(p)
        }
    }
    const VA = function(e) {
        return void 0 === e && (e = 0),
        {
            name: "offset",
            options: e,
            async fn(t) {
                var n, r;
                const {x: o, y: i, placement: a, middlewareData: s} = t
                  , l = await async function(e, t) {
                    const {placement: n, platform: r, elements: o} = e
                      , i = await (null == r.isRTL ? void 0 : r.isRTL(o.floating))
                      , a = oA(n)
                      , s = iA(n)
                      , l = "y" === lA(n)
                      , c = ["left", "top"].includes(a) ? -1 : 1
                      , u = i && l ? -1 : 1
                      , d = rA(t, e);
                    let {mainAxis: p, crossAxis: h, alignmentAxis: f} = "number" == typeof d ? {
                        mainAxis: d,
                        crossAxis: 0,
                        alignmentAxis: null
                    } : {
                        mainAxis: 0,
                        crossAxis: 0,
                        alignmentAxis: null,
                        ...d
                    };
                    return s && "number" == typeof f && (h = "end" === s ? -1 * f : f),
                    l ? {
                        x: h * u,
                        y: p * c
                    } : {
                        x: p * c,
                        y: h * u
                    }
                }(t, e);
                return a === (null == (n = s.offset) ? void 0 : n.placement) && null != (r = s.arrow) && r.alignmentOffset ? {} : {
                    x: o + l.x,
                    y: i + l.y,
                    data: {
                        ...l,
                        placement: a
                    }
                }
            }
        }
    }
      , GA = function(e) {
        return void 0 === e && (e = {}),
        {
            name: "shift",
            options: e,
            async fn(t) {
                const {x: n, y: r, placement: o} = t
                  , {mainAxis: i=!0, crossAxis: a=!1, limiter: s={
                    fn: e=>{
                        let {x: t, y: n} = e;
                        return {
                            x: t,
                            y: n
                        }
                    }
                }, ...l} = rA(e, t)
                  , c = {
                    x: n,
                    y: r
                }
                  , u = await fA(t, l)
                  , d = lA(oA(o))
                  , p = aA(d);
                let h = c[p]
                  , f = c[d];
                if (i) {
                    const e = "y" === p ? "bottom" : "right";
                    h = nA(h + u["y" === p ? "top" : "left"], h, h - u[e])
                }
                if (a) {
                    const e = "y" === d ? "bottom" : "right";
                    f = nA(f + u["y" === d ? "top" : "left"], f, f - u[e])
                }
                const m = s.fn({
                    ...t,
                    [p]: h,
                    [d]: f
                });
                return {
                    ...m,
                    data: {
                        x: m.x - n,
                        y: m.y - r
                    }
                }
            }
        }
    }
      , YA = function(e) {
        return void 0 === e && (e = {}),
        {
            name: "flip",
            options: e,
            async fn(t) {
                var n, r;
                const {placement: o, middlewareData: i, rects: a, initialPlacement: s, platform: l, elements: c} = t
                  , {mainAxis: u=!0, crossAxis: d=!0, fallbackPlacements: p, fallbackStrategy: h="bestFit", fallbackAxisSideDirection: f="none", flipAlignment: m=!0, ...g} = rA(e, t);
                if (null != (n = i.arrow) && n.alignmentOffset)
                    return {};
                const b = oA(o)
                  , O = oA(s) === s
                  , v = await (null == l.isRTL ? void 0 : l.isRTL(c.floating))
                  , y = p || (O || !m ? [dA(s)] : function(e) {
                    const t = dA(e);
                    return [uA(e), t, uA(t)]
                }(s));
                p || "none" === f || y.push(...function(e, t, n, r) {
                    const o = iA(e);
                    let i = function(e, t, n) {
                        const r = ["left", "right"]
                          , o = ["right", "left"]
                          , i = ["top", "bottom"]
                          , a = ["bottom", "top"];
                        switch (e) {
                        case "top":
                        case "bottom":
                            return n ? t ? o : r : t ? r : o;
                        case "left":
                        case "right":
                            return t ? i : a;
                        default:
                            return []
                        }
                    }(oA(e), "start" === n, r);
                    return o && (i = i.map((e=>e + "-" + o)),
                    t && (i = i.concat(i.map(uA)))),
                    i
                }(s, m, f, v));
                const w = [s, ...y]
                  , _ = await fA(t, g)
                  , k = [];
                let S = (null == (r = i.flip) ? void 0 : r.overflows) || [];
                if (u && k.push(_[b]),
                d) {
                    const e = function(e, t, n) {
                        void 0 === n && (n = !1);
                        const r = iA(e)
                          , o = cA(e)
                          , i = sA(o);
                        let a = "x" === o ? r === (n ? "end" : "start") ? "right" : "left" : "start" === r ? "bottom" : "top";
                        return t.reference[i] > t.floating[i] && (a = dA(a)),
                        [a, dA(a)]
                    }(o, a, v);
                    k.push(_[e[0]], _[e[1]])
                }
                if (S = [...S, {
                    placement: o,
                    overflows: k
                }],
                !k.every((e=>e <= 0))) {
                    var E, x;
                    const e = ((null == (E = i.flip) ? void 0 : E.index) || 0) + 1
                      , t = w[e];
                    if (t)
                        return {
                            data: {
                                index: e,
                                overflows: S
                            },
                            reset: {
                                placement: t
                            }
                        };
                    let n = null == (x = S.filter((e=>e.overflows[0] <= 0)).sort(((e,t)=>e.overflows[1] - t.overflows[1]))[0]) ? void 0 : x.placement;
                    if (!n)
                        switch (h) {
                        case "bestFit":
                            {
                                var T;
                                const e = null == (T = S.map((e=>[e.placement, e.overflows.filter((e=>e > 0)).reduce(((e,t)=>e + t), 0)])).sort(((e,t)=>e[1] - t[1]))[0]) ? void 0 : T[0];
                                e && (n = e);
                                break
                            }
                        case "initialPlacement":
                            n = s
                        }
                    if (o !== n)
                        return {
                            reset: {
                                placement: n
                            }
                        }
                }
                return {}
            }
        }
    }
      , KA = (e,t,n)=>{
        const r = new Map
          , o = {
            platform: WA,
            ...n
        }
          , i = {
            ...o.platform,
            _c: r
        };
        return (async(e,t,n)=>{
            const {placement: r="bottom", strategy: o="absolute", middleware: i=[], platform: a} = n
              , s = i.filter(Boolean)
              , l = await (null == a.isRTL ? void 0 : a.isRTL(t));
            let c = await a.getElementRects({
                reference: e,
                floating: t,
                strategy: o
            })
              , {x: u, y: d} = hA(c, r, l)
              , p = r
              , h = {}
              , f = 0;
            for (let m = 0; m < s.length; m++) {
                const {name: n, fn: i} = s[m]
                  , {x: g, y: b, data: O, reset: v} = await i({
                    x: u,
                    y: d,
                    initialPlacement: r,
                    placement: p,
                    strategy: o,
                    middlewareData: h,
                    rects: c,
                    platform: a,
                    elements: {
                        reference: e,
                        floating: t
                    }
                });
                u = null != g ? g : u,
                d = null != b ? b : d,
                h = {
                    ...h,
                    [n]: {
                        ...h[n],
                        ...O
                    }
                },
                v && f <= 50 && (f++,
                "object" == typeof v && (v.placement && (p = v.placement),
                v.rects && (c = !0 === v.rects ? await a.getElementRects({
                    reference: e,
                    floating: t,
                    strategy: o
                }) : v.rects),
                ({x: u, y: d} = hA(c, p, l))),
                m = -1)
            }
            return {
                x: u,
                y: d,
                placement: p,
                strategy: o,
                middlewareData: h
            }
        }
        )(e, t, {
            ...o,
            platform: i
        })
    }
    ;
    function JA(e) {
        if (function(e) {
            return null != e && "object" == typeof e && "$el"in e
        }(e)) {
            const t = e.$el;
            return OA(t) && "#comment" === mA(t) ? null : t
        }
        return e
    }
    function eC(e) {
        if ("undefined" == typeof window)
            return 1;
        return (e.ownerDocument.defaultView || window).devicePixelRatio || 1
    }
    function tC(e, t) {
        const n = eC(e);
        return Math.round(t * n) / n
    }
    const nC = Object.assign({
        "./Add.svg": ()=>Promise.resolve().then((()=>B8)),
        "./ArrowLeft.svg": ()=>Promise.resolve().then((()=>q8)),
        "./ArrowRight.svg": ()=>Promise.resolve().then((()=>V8)),
        "./Background.svg": ()=>Promise.resolve().then((()=>e7)),
        "./Brackets.svg": ()=>Promise.resolve().then((()=>i7)),
        "./Branch.svg": ()=>Promise.resolve().then((()=>u7)),
        "./CallToAction.svg": ()=>Promise.resolve().then((()=>m7)),
        "./Checkmark.svg": ()=>Promise.resolve().then((()=>y7)),
        "./ChevronDown.svg": ()=>Promise.resolve().then((()=>E7)),
        "./ChevronLeft.svg": ()=>Promise.resolve().then((()=>P7)),
        "./ChevronRight.svg": ()=>Promise.resolve().then((()=>I7)),
        "./ChevronUp.svg": ()=>Promise.resolve().then((()=>U7)),
        "./Clipboard.svg": ()=>Promise.resolve().then((()=>H7)),
        "./Close.svg": ()=>Promise.resolve().then((()=>G7)),
        "./CodeFolder.svg": ()=>Promise.resolve().then((()=>t6)),
        "./Cookie.svg": ()=>Promise.resolve().then((()=>a6)),
        "./DarkMode.svg": ()=>Promise.resolve().then((()=>d6)),
        "./Delete.svg": ()=>Promise.resolve().then((()=>g6)),
        "./Discord.svg": ()=>Promise.resolve().then((()=>w6)),
        "./DocsPage.svg": ()=>Promise.resolve().then((()=>x6)),
        "./Duplicate.svg": ()=>Promise.resolve().then((()=>D6)),
        "./Edit.svg": ()=>Promise.resolve().then((()=>M6)),
        "./Ellipses.svg": ()=>Promise.resolve().then((()=>F6)),
        "./Error.svg": ()=>Promise.resolve().then((()=>Z6)),
        "./ExternalLink.svg": ()=>Promise.resolve().then((()=>Y6)),
        "./FilterList.svg": ()=>Promise.resolve().then((()=>n9)),
        "./Folder.svg": ()=>Promise.resolve().then((()=>s9)),
        "./GitHub.svg": ()=>Promise.resolve().then((()=>p9)),
        "./Hide.svg": ()=>Promise.resolve().then((()=>b9)),
        "./History.svg": ()=>Promise.resolve().then((()=>_9)),
        "./Info.svg": ()=>Promise.resolve().then((()=>T9)),
        "./JsonObject.svg": ()=>Promise.resolve().then((()=>R9)),
        "./Key.svg": ()=>Promise.resolve().then((()=>L9)),
        "./Leave.svg": ()=>Promise.resolve().then((()=>j9)),
        "./LightDarkModeToggle.svg": ()=>Promise.resolve().then((()=>W9)),
        "./LightMode.svg": ()=>Promise.resolve().then((()=>K9)),
        "./Link.svg": ()=>Promise.resolve().then((()=>ree)),
        "./Lock.svg": ()=>Promise.resolve().then((()=>lee)),
        "./Logo.svg": ()=>Promise.resolve().then((()=>hee)),
        "./LogoAPI.svg": ()=>Promise.resolve().then((()=>Oee)),
        "./LogoClient.svg": ()=>Promise.resolve().then((()=>kee)),
        "./LogoMarket.svg": ()=>Promise.resolve().then((()=>Aee)),
        "./LogoSwagger.svg": ()=>Promise.resolve().then((()=>Nee)),
        "./Magic.svg": ()=>Promise.resolve().then((()=>Qee)),
        "./Menu.svg": ()=>Promise.resolve().then((()=>zee)),
        "./Page.svg": ()=>Promise.resolve().then((()=>Xee)),
        "./PaperAirplane.svg": ()=>Promise.resolve().then((()=>Jee)),
        "./Payment.svg": ()=>Promise.resolve().then((()=>ote)),
        "./Play.svg": ()=>Promise.resolve().then((()=>cte)),
        "./Refresh.svg": ()=>Promise.resolve().then((()=>fte)),
        "./Response.svg": ()=>Promise.resolve().then((()=>vte)),
        "./Search.svg": ()=>Promise.resolve().then((()=>Ste)),
        "./Show.svg": ()=>Promise.resolve().then((()=>Cte)),
        "./SideBarClosed.svg": ()=>Promise.resolve().then((()=>$te)),
        "./SideBarOpen.svg": ()=>Promise.resolve().then((()=>Bte)),
        "./Sort.svg": ()=>Promise.resolve().then((()=>qte)),
        "./Terminal.svg": ()=>Promise.resolve().then((()=>Vte)),
        "./ThumbsDown.svg": ()=>Promise.resolve().then((()=>ene)),
        "./ThumbsUp.svg": ()=>Promise.resolve().then((()=>ine)),
        "./Trash.svg": ()=>Promise.resolve().then((()=>une)),
        "./Unlock.svg": ()=>Promise.resolve().then((()=>mne)),
        "./Upload.svg": ()=>Promise.resolve().then((()=>yne)),
        "./User.svg": ()=>Promise.resolve().then((()=>Ene)),
        "./programming-framework-angular.svg": ()=>Promise.resolve().then((()=>Pne)),
        "./programming-framework-astro.svg": ()=>Promise.resolve().then((()=>Ine)),
        "./programming-framework-laravel.svg": ()=>Promise.resolve().then((()=>Une)),
        "./programming-framework-nextdotjs.svg": ()=>Promise.resolve().then((()=>Hne)),
        "./programming-framework-react.svg": ()=>Promise.resolve().then((()=>Gne)),
        "./programming-framework-vuedotjs.svg": ()=>Promise.resolve().then((()=>tre)),
        "./programming-language-c.svg": ()=>Promise.resolve().then((()=>are)),
        "./programming-language-clojure.svg": ()=>Promise.resolve().then((()=>dre)),
        "./programming-language-csharp.svg": ()=>Promise.resolve().then((()=>gre)),
        "./programming-language-css3.svg": ()=>Promise.resolve().then((()=>wre)),
        "./programming-language-go.svg": ()=>Promise.resolve().then((()=>xre)),
        "./programming-language-html5.svg": ()=>Promise.resolve().then((()=>Dre)),
        "./programming-language-http.svg": ()=>Promise.resolve().then((()=>Mre)),
        "./programming-language-java.svg": ()=>Promise.resolve().then((()=>Fre)),
        "./programming-language-javascript.svg": ()=>Promise.resolve().then((()=>Zre)),
        "./programming-language-json.svg": ()=>Promise.resolve().then((()=>Yre)),
        "./programming-language-kotlin.svg": ()=>Promise.resolve().then((()=>noe)),
        "./programming-language-node.svg": ()=>Promise.resolve().then((()=>soe)),
        "./programming-language-objc.svg": ()=>Promise.resolve().then((()=>poe)),
        "./programming-language-ocaml.svg": ()=>Promise.resolve().then((()=>boe)),
        "./programming-language-php.svg": ()=>Promise.resolve().then((()=>_oe)),
        "./programming-language-powershell.svg": ()=>Promise.resolve().then((()=>Toe)),
        "./programming-language-python.svg": ()=>Promise.resolve().then((()=>Roe)),
        "./programming-language-r.svg": ()=>Promise.resolve().then((()=>Loe)),
        "./programming-language-ruby.svg": ()=>Promise.resolve().then((()=>joe)),
        "./programming-language-scala.svg": ()=>Promise.resolve().then((()=>Woe)),
        "./programming-language-shell.svg": ()=>Promise.resolve().then((()=>Koe)),
        "./programming-language-swift.svg": ()=>Promise.resolve().then((()=>rie)),
        "./programming-language-typescript.svg": ()=>Promise.resolve().then((()=>lie)),
        "./programming-script-code.svg": ()=>Promise.resolve().then((()=>hie)),
        "./programming-tool-git.svg": ()=>Promise.resolve().then((()=>Oie)),
        "./programming-tool-tailwindcss.svg": ()=>Promise.resolve().then((()=>kie))
    });
    const rC = Ln({
        __name: "ScalarIcon",
        props: {
            icon: {},
            size: {}
        },
        setup(e) {
            const t = e
              , n = Qc({
                variants: {
                    size: {
                        xs: "size-3 stroke-[1.4]",
                        sm: "size-3.5 stroke-[1.2]",
                        md: "size-4 stroke-[1.1]",
                        lg: "size-5",
                        xl: "size-6 stroke-[0.96]",
                        "2xl": "size-8 stroke-[0.92]",
                        "3xl": "size-10 stroke-[0.9]",
                        full: "size-full"
                    }
                },
                defaultVariants: {
                    size: "full"
                }
            })
              , r = Et(null)
              , o = Et(!0);
            return zr((()=>t.icon), (async e=>{
                o.value = !0,
                r.value = await async function(e) {
                    const t = `./${e}.svg`;
                    return nC[t] ? Bn(nC[t]) : (console.warn(`Could not find icon: ${e}`),
                    null)
                }(e),
                o.value = !1
            }
            ), {
                immediate: !0
            }),
            (e,t)=>o.value ? (mo(),
            vo("div", {
                key: 0,
                class: Z(Ct(n)({
                    size: e.size ? e.size : "xs"
                }))
            }, null, 2)) : (mo(),
            yo(On(r.value), {
                key: 1,
                class: Z(Ct(Bc)("scalar-icon", Ct(n)({
                    size: e.size
                })))
            }, null, 8, ["class"]))
        }
    })
      , oC = ["ariaDisabled"]
      , iC = {
        class: "sr-only"
    }
      , aC = Ln({
        __name: "ScalarIconButton",
        props: {
            label: {},
            icon: {},
            disabled: {
                type: Boolean
            },
            variant: {
                default: "ghost"
            },
            size: {
                default: "md"
            }
        },
        setup(e) {
            const t = Qc({
                base: "scalar-icon-button grid aspect-square cursor-pointer rounded",
                variants: {
                    size: {
                        xxs: "size-3.5 p-0.5",
                        xs: "size-5 p-1",
                        sm: "size-6 p-1",
                        md: "size-10 p-3",
                        full: "h-full w-full"
                    },
                    disabled: {
                        true: "cursor-not-allowed shadow-none"
                    },
                    variant: Hc
                }
            })
              , n = ei((()=>{
                const {class: e, ...t} = Wn();
                return {
                    class: e || "",
                    rest: t
                }
            }
            ));
            return (e,r)=>(mo(),
            vo("button", Io(n.value.rest, {
                ariaDisabled: e.disabled || void 0,
                class: Ct(Bc)(Ct(t)({
                    size: e.size,
                    variant: e.variant,
                    disabled: e.disabled
                }), n.value.class),
                type: "button"
            }), [xo(Ct(rC), {
                icon: e.icon
            }, null, 8, ["icon"]), Eo("span", iC, K(e.label), 1)], 16, oC))
        }
    })
      , sC = {
        class: "sr-only"
    }
      , lC = ["value"]
      , cC = Ln({
        inheritAttrs: !1,
        __name: "ScalarSearchInput",
        props: {
            loading: {},
            modelValue: {}
        },
        emits: ["update:modelValue"],
        setup(e, {emit: t}) {
            const n = t;
            function r(e) {
                n("update:modelValue", e.target.value)
            }
            const o = ei((()=>{
                const {class: e, ...t} = Wn();
                return {
                    className: e || "",
                    rest: t
                }
            }
            ));
            return (e,t)=>(mo(),
            vo("label", Io(o.value.rest, {
                class: Ct(Bc)("flex rounded border bg-b-1 text-sm font-medium focus-within:border-c-1", o.value.className)
            }), [Eo("span", sC, [Fn(e.$slots, "label", {}, (()=>[Co("Enter search")]))]), Eo("input", {
                autocapitalize: "off",
                autocomplete: "off",
                autocorrect: "off",
                class: "flex-1 rounded border-none bg-transparent p-3 outline-none",
                placeholder: "Search...",
                spellcheck: "false",
                type: "text",
                value: e.modelValue,
                onInput: r
            }, null, 40, lC), e.loading && e.loading.isLoading ? (mo(),
            yo(Ct(Vc), {
                key: 0,
                class: "mr-3 self-center",
                loadingState: e.loading,
                size: "20px"
            }, null, 8, ["loadingState"])) : e.modelValue ? (mo(),
            yo(Ct(aC), {
                key: 1,
                class: "self-center",
                icon: "Close",
                label: "Clear Search",
                size: "md",
                onClick: t[0] || (t[0] = e=>n("update:modelValue", ""))
            })) : Do("", !0)], 16))
        }
    })
      , uC = {
        class: "contents"
    }
      , dC = {
        class: "text-c-3 group-hover:text-c-1"
    }
      , pC = {
        class: "flex min-w-0 flex-1 flex-col gap-0.75"
    }
      , hC = {
        class: "flex items-center gap-1"
    }
      , fC = {
        class: "flex-1 truncate text-sm font-medium"
    }
      , mC = {
        key: 0,
        class: "text-xs text-c-2"
    }
      , gC = {
        class: "truncate text-xs text-c-2"
    }
      , bC = Ln({
        inheritAttrs: !1,
        __name: "ScalarSearchResultItem",
        props: {
            icon: {},
            active: {
                type: Boolean
            }
        },
        setup(e) {
            const t = ei((()=>{
                const {class: e, ...t} = Wn();
                return {
                    className: e || "",
                    rest: t
                }
            }
            ));
            return (e,n)=>(mo(),
            vo("li", uC, [Eo("a", Io(t.value.rest, {
                class: Ct(Bc)("group flex cursor-pointer gap-3 rounded px-3 py-1.5 no-underline hover:bg-b-2", {
                    "bg-b-2": e.active
                }, t.value.className)
            }), [Eo("div", dC, [Fn(e.$slots, "icon", {}, (()=>[e.icon ? (mo(),
            yo(Ct(rC), {
                key: 0,
                icon: e.icon,
                size: "sm"
            }, null, 8, ["icon"])) : Do("", !0)]))]), Eo("div", pC, [Eo("div", hC, [Eo("div", fC, [Fn(e.$slots, "default")]), e.$slots.addon ? (mo(),
            vo("div", mC, [Fn(e.$slots, "addon")])) : Do("", !0)]), Eo("div", gC, [Fn(e.$slots, "description")])])], 16)]))
        }
    })
      , OC = Eo("div", {
        class: "flex flex-col items-center gap-2 px-3 py-4"
    }, [Eo("div", {
        class: "rotate-90 text-lg font-bold"
    }, ":("), Eo("div", {
        class: "text-sm font-medium text-c-2"
    }, "No results found")], -1)
      , vC = Ln({
        inheritAttrs: !1,
        __name: "ScalarSearchResultList",
        props: {
            noResults: {
                type: Boolean
            }
        },
        setup(e) {
            const t = ei((()=>{
                const {class: e, ...t} = Wn();
                return {
                    className: e || "",
                    rest: t
                }
            }
            ));
            return (e,n)=>(mo(),
            vo("ul", Io(t.value.rest, {
                class: Ct(Bc)("flex flex-col", t.value.className)
            }), [e.noResults ? Fn(e.$slots, "noResults", {
                key: 0
            }, (()=>[OC])) : Do("", !0), Fn(e.$slots, "default")], 16))
        }
    });
    let yC = (e=21)=>{
        let t = ""
          , n = crypto.getRandomValues(new Uint8Array(e));
        for (; e--; )
            t += "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict"[63 & n[e]];
        return t
    }
    ;
    class wC {
        lineAt(e) {
            if (e < 0 || e > this.length)
                throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
            return this.lineInner(e, !1, 1, 0)
        }
        line(e) {
            if (e < 1 || e > this.lines)
                throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
            return this.lineInner(e, !0, 1, 0)
        }
        replace(e, t, n) {
            [e,t] = PC(this, e, t);
            let r = [];
            return this.decompose(0, e, r, 2),
            n.length && n.decompose(0, n.length, r, 3),
            this.decompose(t, this.length, r, 1),
            kC.from(r, this.length - (t - e) + n.length)
        }
        append(e) {
            return this.replace(this.length, this.length, e)
        }
        slice(e, t=this.length) {
            [e,t] = PC(this, e, t);
            let n = [];
            return this.decompose(e, t, n, 0),
            kC.from(n, t - e)
        }
        eq(e) {
            if (e == this)
                return !0;
            if (e.length != this.length || e.lines != this.lines)
                return !1;
            let t = this.scanIdentical(e, 1)
              , n = this.length - this.scanIdentical(e, -1)
              , r = new xC(this)
              , o = new xC(e);
            for (let i = t, a = t; ; ) {
                if (r.next(i),
                o.next(i),
                i = 0,
                r.lineBreak != o.lineBreak || r.done != o.done || r.value != o.value)
                    return !1;
                if (a += r.value.length,
                r.done || a >= n)
                    return !0
            }
        }
        iter(e=1) {
            return new xC(this,e)
        }
        iterRange(e, t=this.length) {
            return new TC(this,e,t)
        }
        iterLines(e, t) {
            let n;
            if (null == e)
                n = this.iter();
            else {
                null == t && (t = this.lines + 1);
                let r = this.line(e).from;
                n = this.iterRange(r, Math.max(r, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to))
            }
            return new AC(n)
        }
        toString() {
            return this.sliceString(0)
        }
        toJSON() {
            let e = [];
            return this.flatten(e),
            e
        }
        constructor() {}
        static of(e) {
            if (0 == e.length)
                throw new RangeError("A document must have at least one line");
            return 1 != e.length || e[0] ? e.length <= 32 ? new _C(e) : kC.from(_C.split(e, [])) : wC.empty
        }
    }
    class _C extends wC {
        constructor(e, t=function(e) {
            let t = -1;
            for (let n of e)
                t += n.length + 1;
            return t
        }(e)) {
            super(),
            this.text = e,
            this.length = t
        }
        get lines() {
            return this.text.length
        }
        get children() {
            return null
        }
        lineInner(e, t, n, r) {
            for (let o = 0; ; o++) {
                let i = this.text[o]
                  , a = r + i.length;
                if ((t ? n : a) >= e)
                    return new CC(r,a,n,i);
                r = a + 1,
                n++
            }
        }
        decompose(e, t, n, r) {
            let o = e <= 0 && t >= this.length ? this : new _C(EC(this.text, e, t),Math.min(t, this.length) - Math.max(0, e));
            if (1 & r) {
                let e = n.pop()
                  , t = SC(o.text, e.text.slice(), 0, o.length);
                if (t.length <= 32)
                    n.push(new _C(t,e.length + o.length));
                else {
                    let e = t.length >> 1;
                    n.push(new _C(t.slice(0, e)), new _C(t.slice(e)))
                }
            } else
                n.push(o)
        }
        replace(e, t, n) {
            if (!(n instanceof _C))
                return super.replace(e, t, n);
            [e,t] = PC(this, e, t);
            let r = SC(this.text, SC(n.text, EC(this.text, 0, e)), t)
              , o = this.length + n.length - (t - e);
            return r.length <= 32 ? new _C(r,o) : kC.from(_C.split(r, []), o)
        }
        sliceString(e, t=this.length, n="\n") {
            [e,t] = PC(this, e, t);
            let r = "";
            for (let o = 0, i = 0; o <= t && i < this.text.length; i++) {
                let a = this.text[i]
                  , s = o + a.length;
                o > e && i && (r += n),
                e < s && t > o && (r += a.slice(Math.max(0, e - o), t - o)),
                o = s + 1
            }
            return r
        }
        flatten(e) {
            for (let t of this.text)
                e.push(t)
        }
        scanIdentical() {
            return 0
        }
        static split(e, t) {
            let n = []
              , r = -1;
            for (let o of e)
                n.push(o),
                r += o.length + 1,
                32 == n.length && (t.push(new _C(n,r)),
                n = [],
                r = -1);
            return r > -1 && t.push(new _C(n,r)),
            t
        }
    }
    class kC extends wC {
        constructor(e, t) {
            super(),
            this.children = e,
            this.length = t,
            this.lines = 0;
            for (let n of e)
                this.lines += n.lines
        }
        lineInner(e, t, n, r) {
            for (let o = 0; ; o++) {
                let i = this.children[o]
                  , a = r + i.length
                  , s = n + i.lines - 1;
                if ((t ? s : a) >= e)
                    return i.lineInner(e, t, n, r);
                r = a + 1,
                n = s + 1
            }
        }
        decompose(e, t, n, r) {
            for (let o = 0, i = 0; i <= t && o < this.children.length; o++) {
                let a = this.children[o]
                  , s = i + a.length;
                if (e <= s && t >= i) {
                    let o = r & ((i <= e ? 1 : 0) | (s >= t ? 2 : 0));
                    i >= e && s <= t && !o ? n.push(a) : a.decompose(e - i, t - i, n, o)
                }
                i = s + 1
            }
        }
        replace(e, t, n) {
            if ([e,t] = PC(this, e, t),
            n.lines < this.lines)
                for (let r = 0, o = 0; r < this.children.length; r++) {
                    let i = this.children[r]
                      , a = o + i.length;
                    if (e >= o && t <= a) {
                        let s = i.replace(e - o, t - o, n)
                          , l = this.lines - i.lines + s.lines;
                        if (s.lines < l >> 4 && s.lines > l >> 6) {
                            let o = this.children.slice();
                            return o[r] = s,
                            new kC(o,this.length - (t - e) + n.length)
                        }
                        return super.replace(o, a, s)
                    }
                    o = a + 1
                }
            return super.replace(e, t, n)
        }
        sliceString(e, t=this.length, n="\n") {
            [e,t] = PC(this, e, t);
            let r = "";
            for (let o = 0, i = 0; o < this.children.length && i <= t; o++) {
                let a = this.children[o]
                  , s = i + a.length;
                i > e && o && (r += n),
                e < s && t > i && (r += a.sliceString(e - i, t - i, n)),
                i = s + 1
            }
            return r
        }
        flatten(e) {
            for (let t of this.children)
                t.flatten(e)
        }
        scanIdentical(e, t) {
            if (!(e instanceof kC))
                return 0;
            let n = 0
              , [r,o,i,a] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
            for (; ; r += t,
            o += t) {
                if (r == i || o == a)
                    return n;
                let s = this.children[r]
                  , l = e.children[o];
                if (s != l)
                    return n + s.scanIdentical(l, t);
                n += s.length + 1
            }
        }
        static from(e, t=e.reduce(((e,t)=>e + t.length + 1), -1)) {
            let n = 0;
            for (let p of e)
                n += p.lines;
            if (n < 32) {
                let n = [];
                for (let t of e)
                    t.flatten(n);
                return new _C(n,t)
            }
            let r = Math.max(32, n >> 5)
              , o = r << 1
              , i = r >> 1
              , a = []
              , s = 0
              , l = -1
              , c = [];
            function u(e) {
                let t;
                if (e.lines > o && e instanceof kC)
                    for (let n of e.children)
                        u(n);
                else
                    e.lines > i && (s > i || !s) ? (d(),
                    a.push(e)) : e instanceof _C && s && (t = c[c.length - 1])instanceof _C && e.lines + t.lines <= 32 ? (s += e.lines,
                    l += e.length + 1,
                    c[c.length - 1] = new _C(t.text.concat(e.text),t.length + 1 + e.length)) : (s + e.lines > r && d(),
                    s += e.lines,
                    l += e.length + 1,
                    c.push(e))
            }
            function d() {
                0 != s && (a.push(1 == c.length ? c[0] : kC.from(c, l)),
                l = -1,
                s = c.length = 0)
            }
            for (let p of e)
                u(p);
            return d(),
            1 == a.length ? a[0] : new kC(a,t)
        }
    }
    function SC(e, t, n=0, r=1e9) {
        for (let o = 0, i = 0, a = !0; i < e.length && o <= r; i++) {
            let s = e[i]
              , l = o + s.length;
            l >= n && (l > r && (s = s.slice(0, r - o)),
            o < n && (s = s.slice(n - o)),
            a ? (t[t.length - 1] += s,
            a = !1) : t.push(s)),
            o = l + 1
        }
        return t
    }
    function EC(e, t, n) {
        return SC(e, [""], t, n)
    }
    wC.empty = new _C([""],0);
    class xC {
        constructor(e, t=1) {
            this.dir = t,
            this.done = !1,
            this.lineBreak = !1,
            this.value = "",
            this.nodes = [e],
            this.offsets = [t > 0 ? 1 : (e instanceof _C ? e.text.length : e.children.length) << 1]
        }
        nextInner(e, t) {
            for (this.done = this.lineBreak = !1; ; ) {
                let n = this.nodes.length - 1
                  , r = this.nodes[n]
                  , o = this.offsets[n]
                  , i = o >> 1
                  , a = r instanceof _C ? r.text.length : r.children.length;
                if (i == (t > 0 ? a : 0)) {
                    if (0 == n)
                        return this.done = !0,
                        this.value = "",
                        this;
                    t > 0 && this.offsets[n - 1]++,
                    this.nodes.pop(),
                    this.offsets.pop()
                } else if ((1 & o) == (t > 0 ? 0 : 1)) {
                    if (this.offsets[n] += t,
                    0 == e)
                        return this.lineBreak = !0,
                        this.value = "\n",
                        this;
                    e--
                } else if (r instanceof _C) {
                    let o = r.text[i + (t < 0 ? -1 : 0)];
                    if (this.offsets[n] += t,
                    o.length > Math.max(0, e))
                        return this.value = 0 == e ? o : t > 0 ? o.slice(e) : o.slice(0, o.length - e),
                        this;
                    e -= o.length
                } else {
                    let o = r.children[i + (t < 0 ? -1 : 0)];
                    e > o.length ? (e -= o.length,
                    this.offsets[n] += t) : (t < 0 && this.offsets[n]--,
                    this.nodes.push(o),
                    this.offsets.push(t > 0 ? 1 : (o instanceof _C ? o.text.length : o.children.length) << 1))
                }
            }
        }
        next(e=0) {
            return e < 0 && (this.nextInner(-e, -this.dir),
            e = this.value.length),
            this.nextInner(e, this.dir)
        }
    }
    class TC {
        constructor(e, t, n) {
            this.value = "",
            this.done = !1,
            this.cursor = new xC(e,t > n ? -1 : 1),
            this.pos = t > n ? e.length : 0,
            this.from = Math.min(t, n),
            this.to = Math.max(t, n)
        }
        nextInner(e, t) {
            if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
                return this.value = "",
                this.done = !0,
                this;
            e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
            let n = t < 0 ? this.pos - this.from : this.to - this.pos;
            e > n && (e = n),
            n -= e;
            let {value: r} = this.cursor.next(e);
            return this.pos += (r.length + e) * t,
            this.value = r.length <= n ? r : t < 0 ? r.slice(r.length - n) : r.slice(0, n),
            this.done = !this.value,
            this
        }
        next(e=0) {
            return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)),
            this.nextInner(e, this.cursor.dir)
        }
        get lineBreak() {
            return this.cursor.lineBreak && "" != this.value
        }
    }
    class AC {
        constructor(e) {
            this.inner = e,
            this.afterBreak = !0,
            this.value = "",
            this.done = !1
        }
        next(e=0) {
            let {done: t, lineBreak: n, value: r} = this.inner.next(e);
            return t && this.afterBreak ? (this.value = "",
            this.afterBreak = !1) : t ? (this.done = !0,
            this.value = "") : n ? this.afterBreak ? this.value = "" : (this.afterBreak = !0,
            this.next()) : (this.value = r,
            this.afterBreak = !1),
            this
        }
        get lineBreak() {
            return !1
        }
    }
    "undefined" != typeof Symbol && (wC.prototype[Symbol.iterator] = function() {
        return this.iter()
    }
    ,
    xC.prototype[Symbol.iterator] = TC.prototype[Symbol.iterator] = AC.prototype[Symbol.iterator] = function() {
        return this
    }
    );
    class CC {
        constructor(e, t, n, r) {
            this.from = e,
            this.to = t,
            this.number = n,
            this.text = r
        }
        get length() {
            return this.to - this.from
        }
    }
    function PC(e, t, n) {
        return [t = Math.max(0, Math.min(e.length, t)), Math.max(t, Math.min(e.length, n))]
    }
    let DC = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e=>e ? parseInt(e, 36) : 1));
    for (let Rie = 1; Rie < DC.length; Rie++)
        DC[Rie] += DC[Rie - 1];
    function RC(e) {
        for (let t = 1; t < DC.length; t += 2)
            if (DC[t] > e)
                return DC[t - 1] <= e;
        return !1
    }
    function NC(e) {
        return e >= 127462 && e <= 127487
    }
    const $C = 8205;
    function IC(e, t, n=!0, r=!0) {
        return (n ? MC : LC)(e, t, r)
    }
    function MC(e, t, n) {
        if (t == e.length)
            return t;
        t && QC(e.charCodeAt(t)) && BC(e.charCodeAt(t - 1)) && t--;
        let r = UC(e, t);
        for (t += jC(r); t < e.length; ) {
            let o = UC(e, t);
            if (r == $C || o == $C || n && RC(o))
                t += jC(o),
                r = o;
            else {
                if (!NC(o))
                    break;
                {
                    let n = 0
                      , r = t - 2;
                    for (; r >= 0 && NC(UC(e, r)); )
                        n++,
                        r -= 2;
                    if (n % 2 == 0)
                        break;
                    t += 2
                }
            }
        }
        return t
    }
    function LC(e, t, n) {
        for (; t > 0; ) {
            let r = MC(e, t - 2, n);
            if (r < t)
                return r;
            t--
        }
        return 0
    }
    function QC(e) {
        return e >= 56320 && e < 57344
    }
    function BC(e) {
        return e >= 55296 && e < 56320
    }
    function UC(e, t) {
        let n = e.charCodeAt(t);
        if (!BC(n) || t + 1 == e.length)
            return n;
        let r = e.charCodeAt(t + 1);
        return QC(r) ? r - 56320 + (n - 55296 << 10) + 65536 : n
    }
    function FC(e) {
        return e <= 65535 ? String.fromCharCode(e) : (e -= 65536,
        String.fromCharCode(55296 + (e >> 10), 56320 + (1023 & e)))
    }
    function jC(e) {
        return e < 65536 ? 1 : 2
    }
    const zC = /\r\n?|\n/;
    var qC = function(e) {
        return e[e.Simple = 0] = "Simple",
        e[e.TrackDel = 1] = "TrackDel",
        e[e.TrackBefore = 2] = "TrackBefore",
        e[e.TrackAfter = 3] = "TrackAfter",
        e
    }(qC || (qC = {}));
    class HC {
        constructor(e) {
            this.sections = e
        }
        get length() {
            let e = 0;
            for (let t = 0; t < this.sections.length; t += 2)
                e += this.sections[t];
            return e
        }
        get newLength() {
            let e = 0;
            for (let t = 0; t < this.sections.length; t += 2) {
                let n = this.sections[t + 1];
                e += n < 0 ? this.sections[t] : n
            }
            return e
        }
        get empty() {
            return 0 == this.sections.length || 2 == this.sections.length && this.sections[1] < 0
        }
        iterGaps(e) {
            for (let t = 0, n = 0, r = 0; t < this.sections.length; ) {
                let o = this.sections[t++]
                  , i = this.sections[t++];
                i < 0 ? (e(n, r, o),
                r += o) : r += i,
                n += o
            }
        }
        iterChangedRanges(e, t=!1) {
            VC(this, e, t)
        }
        get invertedDesc() {
            let e = [];
            for (let t = 0; t < this.sections.length; ) {
                let n = this.sections[t++]
                  , r = this.sections[t++];
                r < 0 ? e.push(n, r) : e.push(r, n)
            }
            return new HC(e)
        }
        composeDesc(e) {
            return this.empty ? e : e.empty ? this : YC(this, e)
        }
        mapDesc(e, t=!1) {
            return e.empty ? this : GC(this, e, t)
        }
        mapPos(e, t=-1, n=qC.Simple) {
            let r = 0
              , o = 0;
            for (let i = 0; i < this.sections.length; ) {
                let a = this.sections[i++]
                  , s = this.sections[i++]
                  , l = r + a;
                if (s < 0) {
                    if (l > e)
                        return o + (e - r);
                    o += a
                } else {
                    if (n != qC.Simple && l >= e && (n == qC.TrackDel && r < e && l > e || n == qC.TrackBefore && r < e || n == qC.TrackAfter && l > e))
                        return null;
                    if (l > e || l == e && t < 0 && !a)
                        return e == r || t < 0 ? o : o + s;
                    o += s
                }
                r = l
            }
            if (e > r)
                throw new RangeError(`Position ${e} is out of range for changeset of length ${r}`);
            return o
        }
        touchesRange(e, t=e) {
            for (let n = 0, r = 0; n < this.sections.length && r <= t; ) {
                let o = r + this.sections[n++];
                if (this.sections[n++] >= 0 && r <= t && o >= e)
                    return !(r < e && o > t) || "cover";
                r = o
            }
            return !1
        }
        toString() {
            let e = "";
            for (let t = 0; t < this.sections.length; ) {
                let n = this.sections[t++]
                  , r = this.sections[t++];
                e += (e ? " " : "") + n + (r >= 0 ? ":" + r : "")
            }
            return e
        }
        toJSON() {
            return this.sections
        }
        static fromJSON(e) {
            if (!Array.isArray(e) || e.length % 2 || e.some((e=>"number" != typeof e)))
                throw new RangeError("Invalid JSON representation of ChangeDesc");
            return new HC(e)
        }
        static create(e) {
            return new HC(e)
        }
    }
    class ZC extends HC {
        constructor(e, t) {
            super(e),
            this.inserted = t
        }
        apply(e) {
            if (this.length != e.length)
                throw new RangeError("Applying change set to a document with the wrong length");
            return VC(this, ((t,n,r,o,i)=>e = e.replace(r, r + (n - t), i)), !1),
            e
        }
        mapDesc(e, t=!1) {
            return GC(this, e, t, !0)
        }
        invert(e) {
            let t = this.sections.slice()
              , n = [];
            for (let r = 0, o = 0; r < t.length; r += 2) {
                let i = t[r]
                  , a = t[r + 1];
                if (a >= 0) {
                    t[r] = a,
                    t[r + 1] = i;
                    let s = r >> 1;
                    for (; n.length < s; )
                        n.push(wC.empty);
                    n.push(i ? e.slice(o, o + i) : wC.empty)
                }
                o += i
            }
            return new ZC(t,n)
        }
        compose(e) {
            return this.empty ? e : e.empty ? this : YC(this, e, !0)
        }
        map(e, t=!1) {
            return e.empty ? this : GC(this, e, t, !0)
        }
        iterChanges(e, t=!1) {
            VC(this, e, t)
        }
        get desc() {
            return HC.create(this.sections)
        }
        filter(e) {
            let t = []
              , n = []
              , r = []
              , o = new KC(this);
            e: for (let i = 0, a = 0; ; ) {
                let s = i == e.length ? 1e9 : e[i++];
                for (; a < s || a == s && 0 == o.len; ) {
                    if (o.done)
                        break e;
                    let e = Math.min(o.len, s - a);
                    WC(r, e, -1);
                    let i = -1 == o.ins ? -1 : 0 == o.off ? o.ins : 0;
                    WC(t, e, i),
                    i > 0 && XC(n, t, o.text),
                    o.forward(e),
                    a += e
                }
                let l = e[i++];
                for (; a < l; ) {
                    if (o.done)
                        break e;
                    let e = Math.min(o.len, l - a);
                    WC(t, e, -1),
                    WC(r, e, -1 == o.ins ? -1 : 0 == o.off ? o.ins : 0),
                    o.forward(e),
                    a += e
                }
            }
            return {
                changes: new ZC(t,n),
                filtered: HC.create(r)
            }
        }
        toJSON() {
            let e = [];
            for (let t = 0; t < this.sections.length; t += 2) {
                let n = this.sections[t]
                  , r = this.sections[t + 1];
                r < 0 ? e.push(n) : 0 == r ? e.push([n]) : e.push([n].concat(this.inserted[t >> 1].toJSON()))
            }
            return e
        }
        static of(e, t, n) {
            let r = []
              , o = []
              , i = 0
              , a = null;
            function s(e=!1) {
                if (!e && !r.length)
                    return;
                i < t && WC(r, t - i, -1);
                let n = new ZC(r,o);
                a = a ? a.compose(n.map(a)) : n,
                r = [],
                o = [],
                i = 0
            }
            return function e(l) {
                if (Array.isArray(l))
                    for (let t of l)
                        e(t);
                else if (l instanceof ZC) {
                    if (l.length != t)
                        throw new RangeError(`Mismatched change set length (got ${l.length}, expected ${t})`);
                    s(),
                    a = a ? a.compose(l.map(a)) : l
                } else {
                    let {from: e, to: a=e, insert: c} = l;
                    if (e > a || e < 0 || a > t)
                        throw new RangeError(`Invalid change range ${e} to ${a} (in doc of length ${t})`);
                    let u = c ? "string" == typeof c ? wC.of(c.split(n || zC)) : c : wC.empty
                      , d = u.length;
                    if (e == a && 0 == d)
                        return;
                    e < i && s(),
                    e > i && WC(r, e - i, -1),
                    WC(r, a - e, d),
                    XC(o, r, u),
                    i = a
                }
            }(e),
            s(!a),
            a
        }
        static empty(e) {
            return new ZC(e ? [e, -1] : [],[])
        }
        static fromJSON(e) {
            if (!Array.isArray(e))
                throw new RangeError("Invalid JSON representation of ChangeSet");
            let t = []
              , n = [];
            for (let r = 0; r < e.length; r++) {
                let o = e[r];
                if ("number" == typeof o)
                    t.push(o, -1);
                else {
                    if (!Array.isArray(o) || "number" != typeof o[0] || o.some(((e,t)=>t && "string" != typeof e)))
                        throw new RangeError("Invalid JSON representation of ChangeSet");
                    if (1 == o.length)
                        t.push(o[0], 0);
                    else {
                        for (; n.length < r; )
                            n.push(wC.empty);
                        n[r] = wC.of(o.slice(1)),
                        t.push(o[0], n[r].length)
                    }
                }
            }
            return new ZC(t,n)
        }
        static createSet(e, t) {
            return new ZC(e,t)
        }
    }
    function WC(e, t, n, r=!1) {
        if (0 == t && n <= 0)
            return;
        let o = e.length - 2;
        o >= 0 && n <= 0 && n == e[o + 1] ? e[o] += t : 0 == t && 0 == e[o] ? e[o + 1] += n : r ? (e[o] += t,
        e[o + 1] += n) : e.push(t, n)
    }
    function XC(e, t, n) {
        if (0 == n.length)
            return;
        let r = t.length - 2 >> 1;
        if (r < e.length)
            e[e.length - 1] = e[e.length - 1].append(n);
        else {
            for (; e.length < r; )
                e.push(wC.empty);
            e.push(n)
        }
    }
    function VC(e, t, n) {
        let r = e.inserted;
        for (let o = 0, i = 0, a = 0; a < e.sections.length; ) {
            let s = e.sections[a++]
              , l = e.sections[a++];
            if (l < 0)
                o += s,
                i += s;
            else {
                let c = o
                  , u = i
                  , d = wC.empty;
                for (; c += s,
                u += l,
                l && r && (d = d.append(r[a - 2 >> 1])),
                !(n || a == e.sections.length || e.sections[a + 1] < 0); )
                    s = e.sections[a++],
                    l = e.sections[a++];
                t(o, c, i, u, d),
                o = c,
                i = u
            }
        }
    }
    function GC(e, t, n, r=!1) {
        let o = []
          , i = r ? [] : null
          , a = new KC(e)
          , s = new KC(t);
        for (let l = -1; ; )
            if (-1 == a.ins && -1 == s.ins) {
                let e = Math.min(a.len, s.len);
                WC(o, e, -1),
                a.forward(e),
                s.forward(e)
            } else if (s.ins >= 0 && (a.ins < 0 || l == a.i || 0 == a.off && (s.len < a.len || s.len == a.len && !n))) {
                let e = s.len;
                for (WC(o, s.ins, -1); e; ) {
                    let t = Math.min(a.len, e);
                    a.ins >= 0 && l < a.i && a.len <= t && (WC(o, 0, a.ins),
                    i && XC(i, o, a.text),
                    l = a.i),
                    a.forward(t),
                    e -= t
                }
                s.next()
            } else {
                if (!(a.ins >= 0)) {
                    if (a.done && s.done)
                        return i ? ZC.createSet(o, i) : HC.create(o);
                    throw new Error("Mismatched change set lengths")
                }
                {
                    let e = 0
                      , t = a.len;
                    for (; t; )
                        if (-1 == s.ins) {
                            let n = Math.min(t, s.len);
                            e += n,
                            t -= n,
                            s.forward(n)
                        } else {
                            if (!(0 == s.ins && s.len < t))
                                break;
                            t -= s.len,
                            s.next()
                        }
                    WC(o, e, l < a.i ? a.ins : 0),
                    i && l < a.i && XC(i, o, a.text),
                    l = a.i,
                    a.forward(a.len - t)
                }
            }
    }
    function YC(e, t, n=!1) {
        let r = []
          , o = n ? [] : null
          , i = new KC(e)
          , a = new KC(t);
        for (let s = !1; ; ) {
            if (i.done && a.done)
                return o ? ZC.createSet(r, o) : HC.create(r);
            if (0 == i.ins)
                WC(r, i.len, 0, s),
                i.next();
            else if (0 != a.len || a.done) {
                if (i.done || a.done)
                    throw new Error("Mismatched change set lengths");
                {
                    let e = Math.min(i.len2, a.len)
                      , t = r.length;
                    if (-1 == i.ins) {
                        let t = -1 == a.ins ? -1 : a.off ? 0 : a.ins;
                        WC(r, e, t, s),
                        o && t && XC(o, r, a.text)
                    } else
                        -1 == a.ins ? (WC(r, i.off ? 0 : i.len, e, s),
                        o && XC(o, r, i.textBit(e))) : (WC(r, i.off ? 0 : i.len, a.off ? 0 : a.ins, s),
                        o && !a.off && XC(o, r, a.text));
                    s = (i.ins > e || a.ins >= 0 && a.len > e) && (s || r.length > t),
                    i.forward2(e),
                    a.forward(e)
                }
            } else
                WC(r, 0, a.ins, s),
                o && XC(o, r, a.text),
                a.next()
        }
    }
    class KC {
        constructor(e) {
            this.set = e,
            this.i = 0,
            this.next()
        }
        next() {
            let {sections: e} = this.set;
            this.i < e.length ? (this.len = e[this.i++],
            this.ins = e[this.i++]) : (this.len = 0,
            this.ins = -2),
            this.off = 0
        }
        get done() {
            return -2 == this.ins
        }
        get len2() {
            return this.ins < 0 ? this.len : this.ins
        }
        get text() {
            let {inserted: e} = this.set
              , t = this.i - 2 >> 1;
            return t >= e.length ? wC.empty : e[t]
        }
        textBit(e) {
            let {inserted: t} = this.set
              , n = this.i - 2 >> 1;
            return n >= t.length && !e ? wC.empty : t[n].slice(this.off, null == e ? void 0 : this.off + e)
        }
        forward(e) {
            e == this.len ? this.next() : (this.len -= e,
            this.off += e)
        }
        forward2(e) {
            -1 == this.ins ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e,
            this.off += e)
        }
    }
    class JC {
        constructor(e, t, n) {
            this.from = e,
            this.to = t,
            this.flags = n
        }
        get anchor() {
            return 32 & this.flags ? this.to : this.from
        }
        get head() {
            return 32 & this.flags ? this.from : this.to
        }
        get empty() {
            return this.from == this.to
        }
        get assoc() {
            return 8 & this.flags ? -1 : 16 & this.flags ? 1 : 0
        }
        get bidiLevel() {
            let e = 7 & this.flags;
            return 7 == e ? null : e
        }
        get goalColumn() {
            let e = this.flags >> 6;
            return 16777215 == e ? void 0 : e
        }
        map(e, t=-1) {
            let n, r;
            return this.empty ? n = r = e.mapPos(this.from, t) : (n = e.mapPos(this.from, 1),
            r = e.mapPos(this.to, -1)),
            n == this.from && r == this.to ? this : new JC(n,r,this.flags)
        }
        extend(e, t=e) {
            if (e <= this.anchor && t >= this.anchor)
                return eP.range(e, t);
            let n = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
            return eP.range(this.anchor, n)
        }
        eq(e, t=!1) {
            return !(this.anchor != e.anchor || this.head != e.head || t && this.empty && this.assoc != e.assoc)
        }
        toJSON() {
            return {
                anchor: this.anchor,
                head: this.head
            }
        }
        static fromJSON(e) {
            if (!e || "number" != typeof e.anchor || "number" != typeof e.head)
                throw new RangeError("Invalid JSON representation for SelectionRange");
            return eP.range(e.anchor, e.head)
        }
        static create(e, t, n) {
            return new JC(e,t,n)
        }
    }
    class eP {
        constructor(e, t) {
            this.ranges = e,
            this.mainIndex = t
        }
        map(e, t=-1) {
            return e.empty ? this : eP.create(this.ranges.map((n=>n.map(e, t))), this.mainIndex)
        }
        eq(e, t=!1) {
            if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
                return !1;
            for (let n = 0; n < this.ranges.length; n++)
                if (!this.ranges[n].eq(e.ranges[n], t))
                    return !1;
            return !0
        }
        get main() {
            return this.ranges[this.mainIndex]
        }
        asSingle() {
            return 1 == this.ranges.length ? this : new eP([this.main],0)
        }
        addRange(e, t=!0) {
            return eP.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1)
        }
        replaceRange(e, t=this.mainIndex) {
            let n = this.ranges.slice();
            return n[t] = e,
            eP.create(n, this.mainIndex)
        }
        toJSON() {
            return {
                ranges: this.ranges.map((e=>e.toJSON())),
                main: this.mainIndex
            }
        }
        static fromJSON(e) {
            if (!e || !Array.isArray(e.ranges) || "number" != typeof e.main || e.main >= e.ranges.length)
                throw new RangeError("Invalid JSON representation for EditorSelection");
            return new eP(e.ranges.map((e=>JC.fromJSON(e))),e.main)
        }
        static single(e, t=e) {
            return new eP([eP.range(e, t)],0)
        }
        static create(e, t=0) {
            if (0 == e.length)
                throw new RangeError("A selection needs at least one range");
            for (let n = 0, r = 0; r < e.length; r++) {
                let o = e[r];
                if (o.empty ? o.from <= n : o.from < n)
                    return eP.normalized(e.slice(), t);
                n = o.to
            }
            return new eP(e,t)
        }
        static cursor(e, t=0, n, r) {
            return JC.create(e, e, (0 == t ? 0 : t < 0 ? 8 : 16) | (null == n ? 7 : Math.min(6, n)) | (null != r ? r : 16777215) << 6)
        }
        static range(e, t, n, r) {
            let o = (null != n ? n : 16777215) << 6 | (null == r ? 7 : Math.min(6, r));
            return t < e ? JC.create(t, e, 48 | o) : JC.create(e, t, (t > e ? 8 : 0) | o)
        }
        static normalized(e, t=0) {
            let n = e[t];
            e.sort(((e,t)=>e.from - t.from)),
            t = e.indexOf(n);
            for (let r = 1; r < e.length; r++) {
                let n = e[r]
                  , o = e[r - 1];
                if (n.empty ? n.from <= o.to : n.from < o.to) {
                    let i = o.from
                      , a = Math.max(n.to, o.to);
                    r <= t && t--,
                    e.splice(--r, 2, n.anchor > n.head ? eP.range(a, i) : eP.range(i, a))
                }
            }
            return new eP(e,t)
        }
    }
    function tP(e, t) {
        for (let n of e.ranges)
            if (n.to > t)
                throw new RangeError("Selection points outside of document")
    }
    let nP = 0;
    class rP {
        constructor(e, t, n, r, o) {
            this.combine = e,
            this.compareInput = t,
            this.compare = n,
            this.isStatic = r,
            this.id = nP++,
            this.default = e([]),
            this.extensions = "function" == typeof o ? o(this) : o
        }
        get reader() {
            return this
        }
        static define(e={}) {
            return new rP(e.combine || (e=>e),e.compareInput || ((e,t)=>e === t),e.compare || (e.combine ? (e,t)=>e === t : oP),!!e.static,e.enables)
        }
        of(e) {
            return new iP([],this,0,e)
        }
        compute(e, t) {
            if (this.isStatic)
                throw new Error("Can't compute a static facet");
            return new iP(e,this,1,t)
        }
        computeN(e, t) {
            if (this.isStatic)
                throw new Error("Can't compute a static facet");
            return new iP(e,this,2,t)
        }
        from(e, t) {
            return t || (t = e=>e),
            this.compute([e], (n=>t(n.field(e))))
        }
    }
    function oP(e, t) {
        return e == t || e.length == t.length && e.every(((e,n)=>e === t[n]))
    }
    class iP {
        constructor(e, t, n, r) {
            this.dependencies = e,
            this.facet = t,
            this.type = n,
            this.value = r,
            this.id = nP++
        }
        dynamicSlot(e) {
            var t;
            let n = this.value
              , r = this.facet.compareInput
              , o = this.id
              , i = e[o] >> 1
              , a = 2 == this.type
              , s = !1
              , l = !1
              , c = [];
            for (let u of this.dependencies)
                "doc" == u ? s = !0 : "selection" == u ? l = !0 : 1 & (null !== (t = e[u.id]) && void 0 !== t ? t : 1) || c.push(e[u.id]);
            return {
                create: e=>(e.values[i] = n(e),
                1),
                update(e, t) {
                    if (s && t.docChanged || l && (t.docChanged || t.selection) || sP(e, c)) {
                        let t = n(e);
                        if (a ? !aP(t, e.values[i], r) : !r(t, e.values[i]))
                            return e.values[i] = t,
                            1
                    }
                    return 0
                },
                reconfigure: (e,t)=>{
                    let s, l = t.config.address[o];
                    if (null != l) {
                        let o = _P(t, l);
                        if (this.dependencies.every((n=>n instanceof rP ? t.facet(n) === e.facet(n) : !(n instanceof uP) || t.field(n, !1) == e.field(n, !1))) || (a ? aP(s = n(e), o, r) : r(s = n(e), o)))
                            return e.values[i] = o,
                            0
                    } else
                        s = n(e);
                    return e.values[i] = s,
                    1
                }
            }
        }
    }
    function aP(e, t, n) {
        if (e.length != t.length)
            return !1;
        for (let r = 0; r < e.length; r++)
            if (!n(e[r], t[r]))
                return !1;
        return !0
    }
    function sP(e, t) {
        let n = !1;
        for (let r of t)
            1 & wP(e, r) && (n = !0);
        return n
    }
    function lP(e, t, n) {
        let r = n.map((t=>e[t.id]))
          , o = n.map((e=>e.type))
          , i = r.filter((e=>!(1 & e)))
          , a = e[t.id] >> 1;
        function s(e) {
            let n = [];
            for (let t = 0; t < r.length; t++) {
                let i = _P(e, r[t]);
                if (2 == o[t])
                    for (let e of i)
                        n.push(e);
                else
                    n.push(i)
            }
            return t.combine(n)
        }
        return {
            create(e) {
                for (let t of r)
                    wP(e, t);
                return e.values[a] = s(e),
                1
            },
            update(e, n) {
                if (!sP(e, i))
                    return 0;
                let r = s(e);
                return t.compare(r, e.values[a]) ? 0 : (e.values[a] = r,
                1)
            },
            reconfigure(e, o) {
                let i = sP(e, r)
                  , l = o.config.facets[t.id]
                  , c = o.facet(t);
                if (l && !i && oP(n, l))
                    return e.values[a] = c,
                    0;
                let u = s(e);
                return t.compare(u, c) ? (e.values[a] = c,
                0) : (e.values[a] = u,
                1)
            }
        }
    }
    const cP = rP.define({
        static: !0
    });
    class uP {
        constructor(e, t, n, r, o) {
            this.id = e,
            this.createF = t,
            this.updateF = n,
            this.compareF = r,
            this.spec = o,
            this.provides = void 0
        }
        static define(e) {
            let t = new uP(nP++,e.create,e.update,e.compare || ((e,t)=>e === t),e);
            return e.provide && (t.provides = e.provide(t)),
            t
        }
        create(e) {
            let t = e.facet(cP).find((e=>e.field == this));
            return ((null == t ? void 0 : t.create) || this.createF)(e)
        }
        slot(e) {
            let t = e[this.id] >> 1;
            return {
                create: e=>(e.values[t] = this.create(e),
                1),
                update: (e,n)=>{
                    let r = e.values[t]
                      , o = this.updateF(r, n);
                    return this.compareF(r, o) ? 0 : (e.values[t] = o,
                    1)
                }
                ,
                reconfigure: (e,n)=>null != n.config.address[this.id] ? (e.values[t] = n.field(this),
                0) : (e.values[t] = this.create(e),
                1)
            }
        }
        init(e) {
            return [this, cP.of({
                field: this,
                create: e
            })]
        }
        get extension() {
            return this
        }
    }
    const dP = 4
      , pP = 3
      , hP = 2
      , fP = 1;
    function mP(e) {
        return t=>new bP(t,e)
    }
    const gP = {
        highest: mP(0),
        high: mP(fP),
        default: mP(hP),
        low: mP(pP),
        lowest: mP(dP)
    };
    class bP {
        constructor(e, t) {
            this.inner = e,
            this.prec = t
        }
    }
    class OP {
        of(e) {
            return new vP(this,e)
        }
        reconfigure(e) {
            return OP.reconfigure.of({
                compartment: this,
                extension: e
            })
        }
        get(e) {
            return e.config.compartments.get(this)
        }
    }
    class vP {
        constructor(e, t) {
            this.compartment = e,
            this.inner = t
        }
    }
    class yP {
        constructor(e, t, n, r, o, i) {
            for (this.base = e,
            this.compartments = t,
            this.dynamicSlots = n,
            this.address = r,
            this.staticValues = o,
            this.facets = i,
            this.statusTemplate = []; this.statusTemplate.length < n.length; )
                this.statusTemplate.push(0)
        }
        staticFacet(e) {
            let t = this.address[e.id];
            return null == t ? e.default : this.staticValues[t >> 1]
        }
        static resolve(e, t, n) {
            let r = []
              , o = Object.create(null)
              , i = new Map;
            for (let d of function(e, t, n) {
                let r = [[], [], [], [], []]
                  , o = new Map;
                function i(e, a) {
                    let s = o.get(e);
                    if (null != s) {
                        if (s <= a)
                            return;
                        let t = r[s].indexOf(e);
                        t > -1 && r[s].splice(t, 1),
                        e instanceof vP && n.delete(e.compartment)
                    }
                    if (o.set(e, a),
                    Array.isArray(e))
                        for (let t of e)
                            i(t, a);
                    else if (e instanceof vP) {
                        if (n.has(e.compartment))
                            throw new RangeError("Duplicate use of compartment in extensions");
                        let r = t.get(e.compartment) || e.inner;
                        n.set(e.compartment, r),
                        i(r, a)
                    } else if (e instanceof bP)
                        i(e.inner, e.prec);
                    else if (e instanceof uP)
                        r[a].push(e),
                        e.provides && i(e.provides, a);
                    else if (e instanceof iP)
                        r[a].push(e),
                        e.facet.extensions && i(e.facet.extensions, hP);
                    else {
                        let t = e.extension;
                        if (!t)
                            throw new Error(`Unrecognized extension value in extension set (${e}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
                        i(t, a)
                    }
                }
                return i(e, hP),
                r.reduce(((e,t)=>e.concat(t)))
            }(e, t, i))
                d instanceof uP ? r.push(d) : (o[d.facet.id] || (o[d.facet.id] = [])).push(d);
            let a = Object.create(null)
              , s = []
              , l = [];
            for (let d of r)
                a[d.id] = l.length << 1,
                l.push((e=>d.slot(e)));
            let c = null == n ? void 0 : n.config.facets;
            for (let d in o) {
                let e = o[d]
                  , t = e[0].facet
                  , r = c && c[d] || [];
                if (e.every((e=>0 == e.type)))
                    if (a[t.id] = s.length << 1 | 1,
                    oP(r, e))
                        s.push(n.facet(t));
                    else {
                        let r = t.combine(e.map((e=>e.value)));
                        s.push(n && t.compare(r, n.facet(t)) ? n.facet(t) : r)
                    }
                else {
                    for (let t of e)
                        0 == t.type ? (a[t.id] = s.length << 1 | 1,
                        s.push(t.value)) : (a[t.id] = l.length << 1,
                        l.push((e=>t.dynamicSlot(e))));
                    a[t.id] = l.length << 1,
                    l.push((n=>lP(n, t, e)))
                }
            }
            let u = l.map((e=>e(a)));
            return new yP(e,i,u,a,s,o)
        }
    }
    function wP(e, t) {
        if (1 & t)
            return 2;
        let n = t >> 1
          , r = e.status[n];
        if (4 == r)
            throw new Error("Cyclic dependency between fields and/or facets");
        if (2 & r)
            return r;
        e.status[n] = 4;
        let o = e.computeSlot(e, e.config.dynamicSlots[n]);
        return e.status[n] = 2 | o
    }
    function _P(e, t) {
        return 1 & t ? e.config.staticValues[t >> 1] : e.values[t >> 1]
    }
    const kP = rP.define()
      , SP = rP.define({
        combine: e=>e.some((e=>e)),
        static: !0
    })
      , EP = rP.define({
        combine: e=>e.length ? e[0] : void 0,
        static: !0
    })
      , xP = rP.define()
      , TP = rP.define()
      , AP = rP.define()
      , CP = rP.define({
        combine: e=>!!e.length && e[0]
    });
    class PP {
        constructor(e, t) {
            this.type = e,
            this.value = t
        }
        static define() {
            return new DP
        }
    }
    class DP {
        of(e) {
            return new PP(this,e)
        }
    }
    class RP {
        constructor(e) {
            this.map = e
        }
        of(e) {
            return new NP(this,e)
        }
    }
    class NP {
        constructor(e, t) {
            this.type = e,
            this.value = t
        }
        map(e) {
            let t = this.type.map(this.value, e);
            return void 0 === t ? void 0 : t == this.value ? this : new NP(this.type,t)
        }
        is(e) {
            return this.type == e
        }
        static define(e={}) {
            return new RP(e.map || (e=>e))
        }
        static mapEffects(e, t) {
            if (!e.length)
                return e;
            let n = [];
            for (let r of e) {
                let e = r.map(t);
                e && n.push(e)
            }
            return n
        }
    }
    NP.reconfigure = NP.define(),
    NP.appendConfig = NP.define();
    class $P {
        constructor(e, t, n, r, o, i) {
            this.startState = e,
            this.changes = t,
            this.selection = n,
            this.effects = r,
            this.annotations = o,
            this.scrollIntoView = i,
            this._doc = null,
            this._state = null,
            n && tP(n, t.newLength),
            o.some((e=>e.type == $P.time)) || (this.annotations = o.concat($P.time.of(Date.now())))
        }
        static create(e, t, n, r, o, i) {
            return new $P(e,t,n,r,o,i)
        }
        get newDoc() {
            return this._doc || (this._doc = this.changes.apply(this.startState.doc))
        }
        get newSelection() {
            return this.selection || this.startState.selection.map(this.changes)
        }
        get state() {
            return this._state || this.startState.applyTransaction(this),
            this._state
        }
        annotation(e) {
            for (let t of this.annotations)
                if (t.type == e)
                    return t.value
        }
        get docChanged() {
            return !this.changes.empty
        }
        get reconfigured() {
            return this.startState.config != this.state.config
        }
        isUserEvent(e) {
            let t = this.annotation($P.userEvent);
            return !(!t || !(t == e || t.length > e.length && t.slice(0, e.length) == e && "." == t[e.length]))
        }
    }
    function IP(e, t) {
        let n = [];
        for (let r = 0, o = 0; ; ) {
            let i, a;
            if (r < e.length && (o == t.length || t[o] >= e[r]))
                i = e[r++],
                a = e[r++];
            else {
                if (!(o < t.length))
                    return n;
                i = t[o++],
                a = t[o++]
            }
            !n.length || n[n.length - 1] < i ? n.push(i, a) : n[n.length - 1] < a && (n[n.length - 1] = a)
        }
    }
    function MP(e, t, n) {
        var r;
        let o, i, a;
        return n ? (o = t.changes,
        i = ZC.empty(t.changes.length),
        a = e.changes.compose(t.changes)) : (o = t.changes.map(e.changes),
        i = e.changes.mapDesc(t.changes, !0),
        a = e.changes.compose(o)),
        {
            changes: a,
            selection: t.selection ? t.selection.map(i) : null === (r = e.selection) || void 0 === r ? void 0 : r.map(o),
            effects: NP.mapEffects(e.effects, o).concat(NP.mapEffects(t.effects, i)),
            annotations: e.annotations.length ? e.annotations.concat(t.annotations) : t.annotations,
            scrollIntoView: e.scrollIntoView || t.scrollIntoView
        }
    }
    function LP(e, t, n) {
        let r = t.selection
          , o = UP(t.annotations);
        return t.userEvent && (o = o.concat($P.userEvent.of(t.userEvent))),
        {
            changes: t.changes instanceof ZC ? t.changes : ZC.of(t.changes || [], n, e.facet(EP)),
            selection: r && (r instanceof eP ? r : eP.single(r.anchor, r.head)),
            effects: UP(t.effects),
            annotations: o,
            scrollIntoView: !!t.scrollIntoView
        }
    }
    function QP(e, t, n) {
        let r = LP(e, t.length ? t[0] : {}, e.doc.length);
        t.length && !1 === t[0].filter && (n = !1);
        for (let i = 1; i < t.length; i++) {
            !1 === t[i].filter && (n = !1);
            let o = !!t[i].sequential;
            r = MP(r, LP(e, t[i], o ? r.changes.newLength : e.doc.length), o)
        }
        let o = $P.create(e, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
        return function(e) {
            let t = e.startState
              , n = t.facet(AP)
              , r = e;
            for (let o = n.length - 1; o >= 0; o--) {
                let i = n[o](e);
                i && Object.keys(i).length && (r = MP(r, LP(t, i, e.changes.newLength), !0))
            }
            return r == e ? e : $P.create(t, e.changes, e.selection, r.effects, r.annotations, r.scrollIntoView)
        }(n ? function(e) {
            let t = e.startState
              , n = !0;
            for (let o of t.facet(xP)) {
                let t = o(e);
                if (!1 === t) {
                    n = !1;
                    break
                }
                Array.isArray(t) && (n = !0 === n ? t : IP(n, t))
            }
            if (!0 !== n) {
                let r, o;
                if (!1 === n)
                    o = e.changes.invertedDesc,
                    r = ZC.empty(t.doc.length);
                else {
                    let t = e.changes.filter(n);
                    r = t.changes,
                    o = t.filtered.mapDesc(t.changes).invertedDesc
                }
                e = $P.create(t, r, e.selection && e.selection.map(o), NP.mapEffects(e.effects, o), e.annotations, e.scrollIntoView)
            }
            let r = t.facet(TP);
            for (let o = r.length - 1; o >= 0; o--) {
                let n = r[o](e);
                e = n instanceof $P ? n : Array.isArray(n) && 1 == n.length && n[0]instanceof $P ? n[0] : QP(t, UP(n), !1)
            }
            return e
        }(o) : o)
    }
    $P.time = PP.define(),
    $P.userEvent = PP.define(),
    $P.addToHistory = PP.define(),
    $P.remote = PP.define();
    const BP = [];
    function UP(e) {
        return null == e ? BP : Array.isArray(e) ? e : [e]
    }
    var FP = function(e) {
        return e[e.Word = 0] = "Word",
        e[e.Space = 1] = "Space",
        e[e.Other = 2] = "Other",
        e
    }(FP || (FP = {}));
    const jP = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
    let zP;
    try {
        zP = new RegExp("[\\p{Alphabetic}\\p{Number}_]","u")
    } catch (Die) {}
    function qP(e) {
        return t=>{
            if (!/\S/.test(t))
                return FP.Space;
            if (function(e) {
                if (zP)
                    return zP.test(e);
                for (let t = 0; t < e.length; t++) {
                    let n = e[t];
                    if (/\w/.test(n) || n > "" && (n.toUpperCase() != n.toLowerCase() || jP.test(n)))
                        return !0
                }
                return !1
            }(t))
                return FP.Word;
            for (let n = 0; n < e.length; n++)
                if (t.indexOf(e[n]) > -1)
                    return FP.Word;
            return FP.Other
        }
    }
    class HP {
        constructor(e, t, n, r, o, i) {
            this.config = e,
            this.doc = t,
            this.selection = n,
            this.values = r,
            this.status = e.statusTemplate.slice(),
            this.computeSlot = o,
            i && (i._state = this);
            for (let a = 0; a < this.config.dynamicSlots.length; a++)
                wP(this, a << 1);
            this.computeSlot = null
        }
        field(e, t=!0) {
            let n = this.config.address[e.id];
            if (null != n)
                return wP(this, n),
                _P(this, n);
            if (t)
                throw new RangeError("Field is not present in this state")
        }
        update(...e) {
            return QP(this, e, !0)
        }
        applyTransaction(e) {
            let t, n = this.config, {base: r, compartments: o} = n;
            for (let a of e.effects)
                a.is(OP.reconfigure) ? (n && (o = new Map,
                n.compartments.forEach(((e,t)=>o.set(t, e))),
                n = null),
                o.set(a.value.compartment, a.value.extension)) : a.is(NP.reconfigure) ? (n = null,
                r = a.value) : a.is(NP.appendConfig) && (n = null,
                r = UP(r).concat(a.value));
            if (n)
                t = e.startState.values.slice();
            else {
                n = yP.resolve(r, o, this),
                t = new HP(n,this.doc,this.selection,n.dynamicSlots.map((()=>null)),((e,t)=>t.reconfigure(e, this)),null).values
            }
            let i = e.startState.facet(SP) ? e.newSelection : e.newSelection.asSingle();
            new HP(n,e.newDoc,i,t,((t,n)=>n.update(t, e)),e)
        }
        replaceSelection(e) {
            return "string" == typeof e && (e = this.toText(e)),
            this.changeByRange((t=>({
                changes: {
                    from: t.from,
                    to: t.to,
                    insert: e
                },
                range: eP.cursor(t.from + e.length)
            })))
        }
        changeByRange(e) {
            let t = this.selection
              , n = e(t.ranges[0])
              , r = this.changes(n.changes)
              , o = [n.range]
              , i = UP(n.effects);
            for (let a = 1; a < t.ranges.length; a++) {
                let n = e(t.ranges[a])
                  , s = this.changes(n.changes)
                  , l = s.map(r);
                for (let e = 0; e < a; e++)
                    o[e] = o[e].map(l);
                let c = r.mapDesc(s, !0);
                o.push(n.range.map(c)),
                r = r.compose(l),
                i = NP.mapEffects(i, l).concat(NP.mapEffects(UP(n.effects), c))
            }
            return {
                changes: r,
                selection: eP.create(o, t.mainIndex),
                effects: i
            }
        }
        changes(e=[]) {
            return e instanceof ZC ? e : ZC.of(e, this.doc.length, this.facet(HP.lineSeparator))
        }
        toText(e) {
            return wC.of(e.split(this.facet(HP.lineSeparator) || zC))
        }
        sliceDoc(e=0, t=this.doc.length) {
            return this.doc.sliceString(e, t, this.lineBreak)
        }
        facet(e) {
            let t = this.config.address[e.id];
            return null == t ? e.default : (wP(this, t),
            _P(this, t))
        }
        toJSON(e) {
            let t = {
                doc: this.sliceDoc(),
                selection: this.selection.toJSON()
            };
            if (e)
                for (let n in e) {
                    let r = e[n];
                    r instanceof uP && null != this.config.address[r.id] && (t[n] = r.spec.toJSON(this.field(e[n]), this))
                }
            return t
        }
        static fromJSON(e, t={}, n) {
            if (!e || "string" != typeof e.doc)
                throw new RangeError("Invalid JSON representation for EditorState");
            let r = [];
            if (n)
                for (let o in n)
                    if (Object.prototype.hasOwnProperty.call(e, o)) {
                        let t = n[o]
                          , i = e[o];
                        r.push(t.init((e=>t.spec.fromJSON(i, e))))
                    }
            return HP.create({
                doc: e.doc,
                selection: eP.fromJSON(e.selection),
                extensions: t.extensions ? r.concat([t.extensions]) : r
            })
        }
        static create(e={}) {
            let t = yP.resolve(e.extensions || [], new Map)
              , n = e.doc instanceof wC ? e.doc : wC.of((e.doc || "").split(t.staticFacet(HP.lineSeparator) || zC))
              , r = e.selection ? e.selection instanceof eP ? e.selection : eP.single(e.selection.anchor, e.selection.head) : eP.single(0);
            return tP(r, n.length),
            t.staticFacet(SP) || (r = r.asSingle()),
            new HP(t,n,r,t.dynamicSlots.map((()=>null)),((e,t)=>t.create(e)),null)
        }
        get tabSize() {
            return this.facet(HP.tabSize)
        }
        get lineBreak() {
            return this.facet(HP.lineSeparator) || "\n"
        }
        get readOnly() {
            return this.facet(CP)
        }
        phrase(e, ...t) {
            for (let n of this.facet(HP.phrases))
                if (Object.prototype.hasOwnProperty.call(n, e)) {
                    e = n[e];
                    break
                }
            return t.length && (e = e.replace(/\$(\$|\d*)/g, ((e,n)=>{
                if ("$" == n)
                    return "$";
                let r = +(n || 1);
                return !r || r > t.length ? e : t[r - 1]
            }
            ))),
            e
        }
        languageDataAt(e, t, n=-1) {
            let r = [];
            for (let o of this.facet(kP))
                for (let i of o(this, t, n))
                    Object.prototype.hasOwnProperty.call(i, e) && r.push(i[e]);
            return r
        }
        charCategorizer(e) {
            return qP(this.languageDataAt("wordChars", e).join(""))
        }
        wordAt(e) {
            let {text: t, from: n, length: r} = this.doc.lineAt(e)
              , o = this.charCategorizer(e)
              , i = e - n
              , a = e - n;
            for (; i > 0; ) {
                let e = IC(t, i, !1);
                if (o(t.slice(e, i)) != FP.Word)
                    break;
                i = e
            }
            for (; a < r; ) {
                let e = IC(t, a);
                if (o(t.slice(a, e)) != FP.Word)
                    break;
                a = e
            }
            return i == a ? null : eP.range(i + n, a + n)
        }
    }
    function ZP(e, t, n={}) {
        let r = {};
        for (let o of e)
            for (let e of Object.keys(o)) {
                let t = o[e]
                  , i = r[e];
                if (void 0 === i)
                    r[e] = t;
                else if (i === t || void 0 === t)
                    ;
                else {
                    if (!Object.hasOwnProperty.call(n, e))
                        throw new Error("Config merge conflict for field " + e);
                    r[e] = n[e](i, t)
                }
            }
        for (let o in t)
            void 0 === r[o] && (r[o] = t[o]);
        return r
    }
    HP.allowMultipleSelections = SP,
    HP.tabSize = rP.define({
        combine: e=>e.length ? e[0] : 4
    }),
    HP.lineSeparator = EP,
    HP.readOnly = CP,
    HP.phrases = rP.define({
        compare(e, t) {
            let n = Object.keys(e)
              , r = Object.keys(t);
            return n.length == r.length && n.every((n=>e[n] == t[n]))
        }
    }),
    HP.languageData = kP,
    HP.changeFilter = xP,
    HP.transactionFilter = TP,
    HP.transactionExtender = AP,
    OP.reconfigure = NP.define();
    class WP {
        eq(e) {
            return this == e
        }
        range(e, t=e) {
            return XP.create(e, t, this)
        }
    }
    WP.prototype.startSide = WP.prototype.endSide = 0,
    WP.prototype.point = !1,
    WP.prototype.mapMode = qC.TrackDel;
    let XP = class e {
        constructor(e, t, n) {
            this.from = e,
            this.to = t,
            this.value = n
        }
        static create(t, n, r) {
            return new e(t,n,r)
        }
    }
    ;
    function VP(e, t) {
        return e.from - t.from || e.value.startSide - t.value.startSide
    }
    class GP {
        constructor(e, t, n, r) {
            this.from = e,
            this.to = t,
            this.value = n,
            this.maxPoint = r
        }
        get length() {
            return this.to[this.to.length - 1]
        }
        findIndex(e, t, n, r=0) {
            let o = n ? this.to : this.from;
            for (let i = r, a = o.length; ; ) {
                if (i == a)
                    return i;
                let r = i + a >> 1
                  , s = o[r] - e || (n ? this.value[r].endSide : this.value[r].startSide) - t;
                if (r == i)
                    return s >= 0 ? i : a;
                s >= 0 ? a = r : i = r + 1
            }
        }
        between(e, t, n, r) {
            for (let o = this.findIndex(t, -1e9, !0), i = this.findIndex(n, 1e9, !1, o); o < i; o++)
                if (!1 === r(this.from[o] + e, this.to[o] + e, this.value[o]))
                    return !1
        }
        map(e, t) {
            let n = []
              , r = []
              , o = []
              , i = -1
              , a = -1;
            for (let s = 0; s < this.value.length; s++) {
                let l, c, u = this.value[s], d = this.from[s] + e, p = this.to[s] + e;
                if (d == p) {
                    let e = t.mapPos(d, u.startSide, u.mapMode);
                    if (null == e)
                        continue;
                    if (l = c = e,
                    u.startSide != u.endSide && (c = t.mapPos(d, u.endSide),
                    c < l))
                        continue
                } else if (l = t.mapPos(d, u.startSide),
                c = t.mapPos(p, u.endSide),
                l > c || l == c && u.startSide > 0 && u.endSide <= 0)
                    continue;
                (c - l || u.endSide - u.startSide) < 0 || (i < 0 && (i = l),
                u.point && (a = Math.max(a, c - l)),
                n.push(u),
                r.push(l - i),
                o.push(c - i))
            }
            return {
                mapped: n.length ? new GP(r,o,n,a) : null,
                pos: i
            }
        }
    }
    class YP {
        constructor(e, t, n, r) {
            this.chunkPos = e,
            this.chunk = t,
            this.nextLayer = n,
            this.maxPoint = r
        }
        static create(e, t, n, r) {
            return new YP(e,t,n,r)
        }
        get length() {
            let e = this.chunk.length - 1;
            return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length)
        }
        get size() {
            if (this.isEmpty)
                return 0;
            let e = this.nextLayer.size;
            for (let t of this.chunk)
                e += t.value.length;
            return e
        }
        chunkEnd(e) {
            return this.chunkPos[e] + this.chunk[e].length
        }
        update(e) {
            let {add: t=[], sort: n=!1, filterFrom: r=0, filterTo: o=this.length} = e
              , i = e.filter;
            if (0 == t.length && !i)
                return this;
            if (n && (t = t.slice().sort(VP)),
            this.isEmpty)
                return t.length ? YP.of(t) : this;
            let a = new eD(this,null,-1).goto(0)
              , s = 0
              , l = []
              , c = new KP;
            for (; a.value || s < t.length; )
                if (s < t.length && (a.from - t[s].from || a.startSide - t[s].value.startSide) >= 0) {
                    let e = t[s++];
                    c.addInner(e.from, e.to, e.value) || l.push(e)
                } else
                    1 == a.rangeIndex && a.chunkIndex < this.chunk.length && (s == t.length || this.chunkEnd(a.chunkIndex) < t[s].from) && (!i || r > this.chunkEnd(a.chunkIndex) || o < this.chunkPos[a.chunkIndex]) && c.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!i || r > a.to || o < a.from || i(a.from, a.to, a.value)) && (c.addInner(a.from, a.to, a.value) || l.push(XP.create(a.from, a.to, a.value))),
                    a.next());
            return c.finishInner(this.nextLayer.isEmpty && !l.length ? YP.empty : this.nextLayer.update({
                add: l,
                filter: i,
                filterFrom: r,
                filterTo: o
            }))
        }
        map(e) {
            if (e.empty || this.isEmpty)
                return this;
            let t = []
              , n = []
              , r = -1;
            for (let i = 0; i < this.chunk.length; i++) {
                let o = this.chunkPos[i]
                  , a = this.chunk[i]
                  , s = e.touchesRange(o, o + a.length);
                if (!1 === s)
                    r = Math.max(r, a.maxPoint),
                    t.push(a),
                    n.push(e.mapPos(o));
                else if (!0 === s) {
                    let {mapped: i, pos: s} = a.map(o, e);
                    i && (r = Math.max(r, i.maxPoint),
                    t.push(i),
                    n.push(s))
                }
            }
            let o = this.nextLayer.map(e);
            return 0 == t.length ? o : new YP(n,t,o || YP.empty,r)
        }
        between(e, t, n) {
            if (!this.isEmpty) {
                for (let r = 0; r < this.chunk.length; r++) {
                    let o = this.chunkPos[r]
                      , i = this.chunk[r];
                    if (t >= o && e <= o + i.length && !1 === i.between(o, e - o, t - o, n))
                        return
                }
                this.nextLayer.between(e, t, n)
            }
        }
        iter(e=0) {
            return tD.from([this]).goto(e)
        }
        get isEmpty() {
            return this.nextLayer == this
        }
        static iter(e, t=0) {
            return tD.from(e).goto(t)
        }
        static compare(e, t, n, r, o=-1) {
            let i = e.filter((e=>e.maxPoint > 0 || !e.isEmpty && e.maxPoint >= o))
              , a = t.filter((e=>e.maxPoint > 0 || !e.isEmpty && e.maxPoint >= o))
              , s = JP(i, a, n)
              , l = new rD(i,s,o)
              , c = new rD(a,s,o);
            n.iterGaps(((e,t,n)=>oD(l, e, c, t, n, r))),
            n.empty && 0 == n.length && oD(l, 0, c, 0, 0, r)
        }
        static eq(e, t, n=0, r) {
            null == r && (r = 999999999);
            let o = e.filter((e=>!e.isEmpty && t.indexOf(e) < 0))
              , i = t.filter((t=>!t.isEmpty && e.indexOf(t) < 0));
            if (o.length != i.length)
                return !1;
            if (!o.length)
                return !0;
            let a = JP(o, i)
              , s = new rD(o,a,0).goto(n)
              , l = new rD(i,a,0).goto(n);
            for (; ; ) {
                if (s.to != l.to || !iD(s.active, l.active) || s.point && (!l.point || !s.point.eq(l.point)))
                    return !1;
                if (s.to > r)
                    return !0;
                s.next(),
                l.next()
            }
        }
        static spans(e, t, n, r, o=-1) {
            let i = new rD(e,null,o).goto(t)
              , a = t
              , s = i.openStart;
            for (; ; ) {
                let e = Math.min(i.to, n);
                if (i.point) {
                    let n = i.activeForPoint(i.to)
                      , o = i.pointFrom < t ? n.length + 1 : i.point.startSide < 0 ? n.length : Math.min(n.length, s);
                    r.point(a, e, i.point, n, o, i.pointRank),
                    s = Math.min(i.openEnd(e), n.length)
                } else
                    e > a && (r.span(a, e, i.active, s),
                    s = i.openEnd(e));
                if (i.to > n)
                    return s + (i.point && i.to > n ? 1 : 0);
                a = i.to,
                i.next()
            }
        }
        static of(e, t=!1) {
            let n = new KP;
            for (let r of e instanceof XP ? [e] : t ? function(e) {
                if (e.length > 1)
                    for (let t = e[0], n = 1; n < e.length; n++) {
                        let r = e[n];
                        if (VP(t, r) > 0)
                            return e.slice().sort(VP);
                        t = r
                    }
                return e
            }(e) : e)
                n.add(r.from, r.to, r.value);
            return n.finish()
        }
        static join(e) {
            if (!e.length)
                return YP.empty;
            let t = e[e.length - 1];
            for (let n = e.length - 2; n >= 0; n--)
                for (let r = e[n]; r != YP.empty; r = r.nextLayer)
                    t = new YP(r.chunkPos,r.chunk,t,Math.max(r.maxPoint, t.maxPoint));
            return t
        }
    }
    YP.empty = new YP([],[],null,-1),
    YP.empty.nextLayer = YP.empty;
    class KP {
        finishChunk(e) {
            this.chunks.push(new GP(this.from,this.to,this.value,this.maxPoint)),
            this.chunkPos.push(this.chunkStart),
            this.chunkStart = -1,
            this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint),
            this.maxPoint = -1,
            e && (this.from = [],
            this.to = [],
            this.value = [])
        }
        constructor() {
            this.chunks = [],
            this.chunkPos = [],
            this.chunkStart = -1,
            this.last = null,
            this.lastFrom = -1e9,
            this.lastTo = -1e9,
            this.from = [],
            this.to = [],
            this.value = [],
            this.maxPoint = -1,
            this.setMaxPoint = -1,
            this.nextLayer = null
        }
        add(e, t, n) {
            this.addInner(e, t, n) || (this.nextLayer || (this.nextLayer = new KP)).add(e, t, n)
        }
        addInner(e, t, n) {
            let r = e - this.lastTo || n.startSide - this.last.endSide;
            if (r <= 0 && (e - this.lastFrom || n.startSide - this.last.startSide) < 0)
                throw new Error("Ranges must be added sorted by `from` position and `startSide`");
            return !(r < 0) && (250 == this.from.length && this.finishChunk(!0),
            this.chunkStart < 0 && (this.chunkStart = e),
            this.from.push(e - this.chunkStart),
            this.to.push(t - this.chunkStart),
            this.last = n,
            this.lastFrom = e,
            this.lastTo = t,
            this.value.push(n),
            n.point && (this.maxPoint = Math.max(this.maxPoint, t - e)),
            !0)
        }
        addChunk(e, t) {
            if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
                return !1;
            this.from.length && this.finishChunk(!0),
            this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint),
            this.chunks.push(t),
            this.chunkPos.push(e);
            let n = t.value.length - 1;
            return this.last = t.value[n],
            this.lastFrom = t.from[n] + e,
            this.lastTo = t.to[n] + e,
            !0
        }
        finish() {
            return this.finishInner(YP.empty)
        }
        finishInner(e) {
            if (this.from.length && this.finishChunk(!1),
            0 == this.chunks.length)
                return e;
            let t = YP.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
            return this.from = null,
            t
        }
    }
    function JP(e, t, n) {
        let r = new Map;
        for (let i of e)
            for (let e = 0; e < i.chunk.length; e++)
                i.chunk[e].maxPoint <= 0 && r.set(i.chunk[e], i.chunkPos[e]);
        let o = new Set;
        for (let i of t)
            for (let e = 0; e < i.chunk.length; e++) {
                let t = r.get(i.chunk[e]);
                null == t || (n ? n.mapPos(t) : t) != i.chunkPos[e] || (null == n ? void 0 : n.touchesRange(t, t + i.chunk[e].length)) || o.add(i.chunk[e])
            }
        return o
    }
    class eD {
        constructor(e, t, n, r=0) {
            this.layer = e,
            this.skip = t,
            this.minPoint = n,
            this.rank = r
        }
        get startSide() {
            return this.value ? this.value.startSide : 0
        }
        get endSide() {
            return this.value ? this.value.endSide : 0
        }
        goto(e, t=-1e9) {
            return this.chunkIndex = this.rangeIndex = 0,
            this.gotoInner(e, t, !1),
            this
        }
        gotoInner(e, t, n) {
            for (; this.chunkIndex < this.layer.chunk.length; ) {
                let t = this.layer.chunk[this.chunkIndex];
                if (!(this.skip && this.skip.has(t) || this.layer.chunkEnd(this.chunkIndex) < e || t.maxPoint < this.minPoint))
                    break;
                this.chunkIndex++,
                n = !1
            }
            if (this.chunkIndex < this.layer.chunk.length) {
                let r = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
                (!n || this.rangeIndex < r) && this.setRangeIndex(r)
            }
            this.next()
        }
        forward(e, t) {
            (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0)
        }
        next() {
            for (; ; ) {
                if (this.chunkIndex == this.layer.chunk.length) {
                    this.from = this.to = 1e9,
                    this.value = null;
                    break
                }
                {
                    let e = this.layer.chunkPos[this.chunkIndex]
                      , t = this.layer.chunk[this.chunkIndex]
                      , n = e + t.from[this.rangeIndex];
                    if (this.from = n,
                    this.to = e + t.to[this.rangeIndex],
                    this.value = t.value[this.rangeIndex],
                    this.setRangeIndex(this.rangeIndex + 1),
                    this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
                        break
                }
            }
        }
        setRangeIndex(e) {
            if (e == this.layer.chunk[this.chunkIndex].value.length) {
                if (this.chunkIndex++,
                this.skip)
                    for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
                        this.chunkIndex++;
                this.rangeIndex = 0
            } else
                this.rangeIndex = e
        }
        nextChunk() {
            this.chunkIndex++,
            this.rangeIndex = 0,
            this.next()
        }
        compare(e) {
            return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide
        }
    }
    class tD {
        constructor(e) {
            this.heap = e
        }
        static from(e, t=null, n=-1) {
            let r = [];
            for (let o = 0; o < e.length; o++)
                for (let i = e[o]; !i.isEmpty; i = i.nextLayer)
                    i.maxPoint >= n && r.push(new eD(i,t,n,o));
            return 1 == r.length ? r[0] : new tD(r)
        }
        get startSide() {
            return this.value ? this.value.startSide : 0
        }
        goto(e, t=-1e9) {
            for (let n of this.heap)
                n.goto(e, t);
            for (let n = this.heap.length >> 1; n >= 0; n--)
                nD(this.heap, n);
            return this.next(),
            this
        }
        forward(e, t) {
            for (let n of this.heap)
                n.forward(e, t);
            for (let n = this.heap.length >> 1; n >= 0; n--)
                nD(this.heap, n);
            (this.to - e || this.value.endSide - t) < 0 && this.next()
        }
        next() {
            if (0 == this.heap.length)
                this.from = this.to = 1e9,
                this.value = null,
                this.rank = -1;
            else {
                let e = this.heap[0];
                this.from = e.from,
                this.to = e.to,
                this.value = e.value,
                this.rank = e.rank,
                e.value && e.next(),
                nD(this.heap, 0)
            }
        }
    }
    function nD(e, t) {
        for (let n = e[t]; ; ) {
            let r = 1 + (t << 1);
            if (r >= e.length)
                break;
            let o = e[r];
            if (r + 1 < e.length && o.compare(e[r + 1]) >= 0 && (o = e[r + 1],
            r++),
            n.compare(o) < 0)
                break;
            e[r] = n,
            e[t] = o,
            t = r
        }
    }
    class rD {
        constructor(e, t, n) {
            this.minPoint = n,
            this.active = [],
            this.activeTo = [],
            this.activeRank = [],
            this.minActive = -1,
            this.point = null,
            this.pointFrom = 0,
            this.pointRank = 0,
            this.to = -1e9,
            this.endSide = 0,
            this.openStart = -1,
            this.cursor = tD.from(e, t, n)
        }
        goto(e, t=-1e9) {
            return this.cursor.goto(e, t),
            this.active.length = this.activeTo.length = this.activeRank.length = 0,
            this.minActive = -1,
            this.to = e,
            this.endSide = t,
            this.openStart = -1,
            this.next(),
            this
        }
        forward(e, t) {
            for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
                this.removeActive(this.minActive);
            this.cursor.forward(e, t)
        }
        removeActive(e) {
            aD(this.active, e),
            aD(this.activeTo, e),
            aD(this.activeRank, e),
            this.minActive = lD(this.active, this.activeTo)
        }
        addActive(e) {
            let t = 0
              , {value: n, to: r, rank: o} = this.cursor;
            for (; t < this.activeRank.length && (o - this.activeRank[t] || r - this.activeTo[t]) > 0; )
                t++;
            sD(this.active, t, n),
            sD(this.activeTo, t, r),
            sD(this.activeRank, t, o),
            e && sD(e, t, this.cursor.from),
            this.minActive = lD(this.active, this.activeTo)
        }
        next() {
            let e = this.to
              , t = this.point;
            this.point = null;
            let n = this.openStart < 0 ? [] : null;
            for (; ; ) {
                let r = this.minActive;
                if (r > -1 && (this.activeTo[r] - this.cursor.from || this.active[r].endSide - this.cursor.startSide) < 0) {
                    if (this.activeTo[r] > e) {
                        this.to = this.activeTo[r],
                        this.endSide = this.active[r].endSide;
                        break
                    }
                    this.removeActive(r),
                    n && aD(n, r)
                } else {
                    if (!this.cursor.value) {
                        this.to = this.endSide = 1e9;
                        break
                    }
                    if (this.cursor.from > e) {
                        this.to = this.cursor.from,
                        this.endSide = this.cursor.startSide;
                        break
                    }
                    {
                        let e = this.cursor.value;
                        if (e.point) {
                            if (!(t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)) {
                                this.point = e,
                                this.pointFrom = this.cursor.from,
                                this.pointRank = this.cursor.rank,
                                this.to = this.cursor.to,
                                this.endSide = e.endSide,
                                this.cursor.next(),
                                this.forward(this.to, this.endSide);
                                break
                            }
                            this.cursor.next()
                        } else
                            this.addActive(n),
                            this.cursor.next()
                    }
                }
            }
            if (n) {
                this.openStart = 0;
                for (let t = n.length - 1; t >= 0 && n[t] < e; t--)
                    this.openStart++
            }
        }
        activeForPoint(e) {
            if (!this.active.length)
                return this.active;
            let t = [];
            for (let n = this.active.length - 1; n >= 0 && !(this.activeRank[n] < this.pointRank); n--)
                (this.activeTo[n] > e || this.activeTo[n] == e && this.active[n].endSide >= this.point.endSide) && t.push(this.active[n]);
            return t.reverse()
        }
        openEnd(e) {
            let t = 0;
            for (let n = this.activeTo.length - 1; n >= 0 && this.activeTo[n] > e; n--)
                t++;
            return t
        }
    }
    function oD(e, t, n, r, o, i) {
        e.goto(t),
        n.goto(r);
        let a = r + o
          , s = r
          , l = r - t;
        for (; ; ) {
            let t = e.to + l - n.to || e.endSide - n.endSide
              , r = t < 0 ? e.to + l : n.to
              , o = Math.min(r, a);
            if (e.point || n.point ? e.point && n.point && (e.point == n.point || e.point.eq(n.point)) && iD(e.activeForPoint(e.to), n.activeForPoint(n.to)) || i.comparePoint(s, o, e.point, n.point) : o > s && !iD(e.active, n.active) && i.compareRange(s, o, e.active, n.active),
            r > a)
                break;
            s = r,
            t <= 0 && e.next(),
            t >= 0 && n.next()
        }
    }
    function iD(e, t) {
        if (e.length != t.length)
            return !1;
        for (let n = 0; n < e.length; n++)
            if (e[n] != t[n] && !e[n].eq(t[n]))
                return !1;
        return !0
    }
    function aD(e, t) {
        for (let n = t, r = e.length - 1; n < r; n++)
            e[n] = e[n + 1];
        e.pop()
    }
    function sD(e, t, n) {
        for (let r = e.length - 1; r >= t; r--)
            e[r + 1] = e[r];
        e[t] = n
    }
    function lD(e, t) {
        let n = -1
          , r = 1e9;
        for (let o = 0; o < t.length; o++)
            (t[o] - r || e[o].endSide - e[n].endSide) < 0 && (n = o,
            r = t[o]);
        return n
    }
    function cD(e, t, n=e.length) {
        let r = 0;
        for (let o = 0; o < n; )
            9 == e.charCodeAt(o) ? (r += t - r % t,
            o++) : (r++,
            o = IC(e, o));
        return r
    }
    const uD = "undefined" == typeof Symbol ? "__ͼ" : Symbol.for("ͼ")
      , dD = "undefined" == typeof Symbol ? "__styleSet" + Math.floor(1e8 * Math.random()) : Symbol("styleSet")
      , pD = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : {};
    class hD {
        constructor(e, t) {
            this.rules = [];
            let {finish: n} = t || {};
            function r(e) {
                return /^@/.test(e) ? [e] : e.split(/,\s*/)
            }
            function o(e, t, i, a) {
                let s = []
                  , l = /^@(\w+)\b/.exec(e[0])
                  , c = l && "keyframes" == l[1];
                if (l && null == t)
                    return i.push(e[0] + ";");
                for (let n in t) {
                    let a = t[n];
                    if (/&/.test(n))
                        o(n.split(/,\s*/).map((t=>e.map((e=>t.replace(/&/, e))))).reduce(((e,t)=>e.concat(t))), a, i);
                    else if (a && "object" == typeof a) {
                        if (!l)
                            throw new RangeError("The value of a property (" + n + ") should be a primitive value.");
                        o(r(n), a, s, c)
                    } else
                        null != a && s.push(n.replace(/_.*/, "").replace(/[A-Z]/g, (e=>"-" + e.toLowerCase())) + ": " + a + ";")
                }
                (s.length || c) && i.push((!n || l || a ? e : e.map(n)).join(", ") + " {" + s.join(" ") + "}")
            }
            for (let i in e)
                o(r(i), e[i], this.rules)
        }
        getRules() {
            return this.rules.join("\n")
        }
        static newName() {
            let e = pD[uD] || 1;
            return pD[uD] = e + 1,
            "ͼ" + e.toString(36)
        }
        static mount(e, t, n) {
            let r = e[dD]
              , o = n && n.nonce;
            r ? o && r.setNonce(o) : r = new mD(e,o),
            r.mount(Array.isArray(t) ? t : [t], e)
        }
    }
    let fD = new Map;
    class mD {
        constructor(e, t) {
            let n = e.ownerDocument || e
              , r = n.defaultView;
            if (!e.head && e.adoptedStyleSheets && r.CSSStyleSheet) {
                let t = fD.get(n);
                if (t)
                    return e[dD] = t;
                this.sheet = new r.CSSStyleSheet,
                fD.set(n, this)
            } else
                this.styleTag = n.createElement("style"),
                t && this.styleTag.setAttribute("nonce", t);
            this.modules = [],
            e[dD] = this
        }
        mount(e, t) {
            let n = this.sheet
              , r = 0
              , o = 0;
            for (let i = 0; i < e.length; i++) {
                let t = e[i]
                  , a = this.modules.indexOf(t);
                if (a < o && a > -1 && (this.modules.splice(a, 1),
                o--,
                a = -1),
                -1 == a) {
                    if (this.modules.splice(o++, 0, t),
                    n)
                        for (let e = 0; e < t.rules.length; e++)
                            n.insertRule(t.rules[e], r++)
                } else {
                    for (; o < a; )
                        r += this.modules[o++].rules.length;
                    r += t.rules.length,
                    o++
                }
            }
            if (n)
                t.adoptedStyleSheets.indexOf(this.sheet) < 0 && (t.adoptedStyleSheets = [this.sheet, ...t.adoptedStyleSheets]);
            else {
                let e = "";
                for (let t = 0; t < this.modules.length; t++)
                    e += this.modules[t].getRules() + "\n";
                this.styleTag.textContent = e;
                let n = t.head || t;
                this.styleTag.parentNode != n && n.insertBefore(this.styleTag, n.firstChild)
            }
        }
        setNonce(e) {
            this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e)
        }
    }
    for (var gD = {
        8: "Backspace",
        9: "Tab",
        10: "Enter",
        12: "NumLock",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        44: "PrintScreen",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Meta",
        92: "Meta",
        106: "*",
        107: "+",
        108: ",",
        109: "-",
        110: ".",
        111: "/",
        144: "NumLock",
        145: "ScrollLock",
        160: "Shift",
        161: "Shift",
        162: "Control",
        163: "Control",
        164: "Alt",
        165: "Alt",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'"
    }, bD = {
        48: ")",
        49: "!",
        50: "@",
        51: "#",
        52: "$",
        53: "%",
        54: "^",
        55: "&",
        56: "*",
        57: "(",
        59: ":",
        61: "+",
        173: "_",
        186: ":",
        187: "+",
        188: "<",
        189: "_",
        190: ">",
        191: "?",
        192: "~",
        219: "{",
        220: "|",
        221: "}",
        222: '"'
    }, OD = "undefined" != typeof navigator && /Mac/.test(navigator.platform), vD = "undefined" != typeof navigator && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), yD = 0; yD < 10; yD++)
        gD[48 + yD] = gD[96 + yD] = String(yD);
    for (yD = 1; yD <= 24; yD++)
        gD[yD + 111] = "F" + yD;
    for (yD = 65; yD <= 90; yD++)
        gD[yD] = String.fromCharCode(yD + 32),
        bD[yD] = String.fromCharCode(yD);
    for (var wD in gD)
        bD.hasOwnProperty(wD) || (bD[wD] = gD[wD]);
    function _D(e) {
        let t;
        return t = 11 == e.nodeType ? e.getSelection ? e : e.ownerDocument : e,
        t.getSelection()
    }
    function kD(e, t) {
        return !!t && (e == t || e.contains(1 != t.nodeType ? t.parentNode : t))
    }
    function SD(e, t) {
        if (!t.anchorNode)
            return !1;
        try {
            return kD(e, t.anchorNode)
        } catch (Die) {
            return !1
        }
    }
    function ED(e) {
        return 3 == e.nodeType ? QD(e, 0, e.nodeValue.length).getClientRects() : 1 == e.nodeType ? e.getClientRects() : []
    }
    function xD(e, t, n, r) {
        return !!n && (CD(e, t, n, r, -1) || CD(e, t, n, r, 1))
    }
    function TD(e) {
        for (var t = 0; ; t++)
            if (!(e = e.previousSibling))
                return t
    }
    function AD(e) {
        return 1 == e.nodeType && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(e.nodeName)
    }
    function CD(e, t, n, r, o) {
        for (; ; ) {
            if (e == n && t == r)
                return !0;
            if (t == (o < 0 ? 0 : PD(e))) {
                if ("DIV" == e.nodeName)
                    return !1;
                let n = e.parentNode;
                if (!n || 1 != n.nodeType)
                    return !1;
                t = TD(e) + (o < 0 ? 0 : 1),
                e = n
            } else {
                if (1 != e.nodeType)
                    return !1;
                if (1 == (e = e.childNodes[t + (o < 0 ? -1 : 0)]).nodeType && "false" == e.contentEditable)
                    return !1;
                t = o < 0 ? PD(e) : 0
            }
        }
    }
    function PD(e) {
        return 3 == e.nodeType ? e.nodeValue.length : e.childNodes.length
    }
    function DD(e, t) {
        let n = t ? e.left : e.right;
        return {
            left: n,
            right: n,
            top: e.top,
            bottom: e.bottom
        }
    }
    function RD(e) {
        let t = e.visualViewport;
        return t ? {
            left: 0,
            right: t.width,
            top: 0,
            bottom: t.height
        } : {
            left: 0,
            right: e.innerWidth,
            top: 0,
            bottom: e.innerHeight
        }
    }
    function ND(e, t) {
        let n = t.width / e.offsetWidth
          , r = t.height / e.offsetHeight;
        return (n > .995 && n < 1.005 || !isFinite(n) || Math.abs(t.width - e.offsetWidth) < 1) && (n = 1),
        (r > .995 && r < 1.005 || !isFinite(r) || Math.abs(t.height - e.offsetHeight) < 1) && (r = 1),
        {
            scaleX: n,
            scaleY: r
        }
    }
    class $D {
        constructor() {
            this.anchorNode = null,
            this.anchorOffset = 0,
            this.focusNode = null,
            this.focusOffset = 0
        }
        eq(e) {
            return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset
        }
        setRange(e) {
            let {anchorNode: t, focusNode: n} = e;
            this.set(t, Math.min(e.anchorOffset, t ? PD(t) : 0), n, Math.min(e.focusOffset, n ? PD(n) : 0))
        }
        set(e, t, n, r) {
            this.anchorNode = e,
            this.anchorOffset = t,
            this.focusNode = n,
            this.focusOffset = r
        }
    }
    let ID, MD = null;
    function LD(e) {
        if (e.setActive)
            return e.setActive();
        if (MD)
            return e.focus(MD);
        let t = [];
        for (let n = e; n && (t.push(n, n.scrollTop, n.scrollLeft),
        n != n.ownerDocument); n = n.parentNode)
            ;
        if (e.focus(null == MD ? {
            get preventScroll() {
                return MD = {
                    preventScroll: !0
                },
                !0
            }
        } : void 0),
        !MD) {
            MD = !1;
            for (let e = 0; e < t.length; ) {
                let n = t[e++]
                  , r = t[e++]
                  , o = t[e++];
                n.scrollTop != r && (n.scrollTop = r),
                n.scrollLeft != o && (n.scrollLeft = o)
            }
        }
    }
    function QD(e, t, n=t) {
        let r = ID || (ID = document.createRange());
        return r.setEnd(e, n),
        r.setStart(e, t),
        r
    }
    function BD(e, t, n, r) {
        let o = {
            key: t,
            code: t,
            keyCode: n,
            which: n,
            cancelable: !0
        };
        r && ({altKey: o.altKey, ctrlKey: o.ctrlKey, shiftKey: o.shiftKey, metaKey: o.metaKey} = r);
        let i = new KeyboardEvent("keydown",o);
        i.synthetic = !0,
        e.dispatchEvent(i);
        let a = new KeyboardEvent("keyup",o);
        return a.synthetic = !0,
        e.dispatchEvent(a),
        i.defaultPrevented || a.defaultPrevented
    }
    function UD(e) {
        for (; e.attributes.length; )
            e.removeAttributeNode(e.attributes[0])
    }
    function FD(e) {
        return e.scrollTop > Math.max(1, e.scrollHeight - e.clientHeight - 4)
    }
    function jD(e, t) {
        for (let n = e, r = t; ; ) {
            if (3 == n.nodeType && r > 0)
                return {
                    node: n,
                    offset: r
                };
            if (1 == n.nodeType && r > 0) {
                if ("false" == n.contentEditable)
                    return null;
                n = n.childNodes[r - 1],
                r = PD(n)
            } else {
                if (!n.parentNode || AD(n))
                    return null;
                r = TD(n),
                n = n.parentNode
            }
        }
    }
    function zD(e, t) {
        for (let n = e, r = t; ; ) {
            if (3 == n.nodeType && r < n.nodeValue.length)
                return {
                    node: n,
                    offset: r
                };
            if (1 == n.nodeType && r < n.childNodes.length) {
                if ("false" == n.contentEditable)
                    return null;
                n = n.childNodes[r],
                r = 0
            } else {
                if (!n.parentNode || AD(n))
                    return null;
                r = TD(n) + 1,
                n = n.parentNode
            }
        }
    }
    class qD {
        constructor(e, t, n=!0) {
            this.node = e,
            this.offset = t,
            this.precise = n
        }
        static before(e, t) {
            return new qD(e.parentNode,TD(e),t)
        }
        static after(e, t) {
            return new qD(e.parentNode,TD(e) + 1,t)
        }
    }
    const HD = [];
    class ZD {
        constructor() {
            this.parent = null,
            this.dom = null,
            this.flags = 2
        }
        get overrideDOMText() {
            return null
        }
        get posAtStart() {
            return this.parent ? this.parent.posBefore(this) : 0
        }
        get posAtEnd() {
            return this.posAtStart + this.length
        }
        posBefore(e) {
            let t = this.posAtStart;
            for (let n of this.children) {
                if (n == e)
                    return t;
                t += n.length + n.breakAfter
            }
            throw new RangeError("Invalid child in posBefore")
        }
        posAfter(e) {
            return this.posBefore(e) + e.length
        }
        sync(e, t) {
            if (2 & this.flags) {
                let n, r = this.dom, o = null;
                for (let i of this.children) {
                    if (7 & i.flags) {
                        if (!i.dom && (n = o ? o.nextSibling : r.firstChild)) {
                            let e = ZD.get(n);
                            (!e || !e.parent && e.canReuseDOM(i)) && i.reuseDOM(n)
                        }
                        i.sync(e, t),
                        i.flags &= -8
                    }
                    if (n = o ? o.nextSibling : r.firstChild,
                    t && !t.written && t.node == r && n != i.dom && (t.written = !0),
                    i.dom.parentNode == r)
                        for (; n && n != i.dom; )
                            n = WD(n);
                    else
                        r.insertBefore(i.dom, n);
                    o = i.dom
                }
                for (n = o ? o.nextSibling : r.firstChild,
                n && t && t.node == r && (t.written = !0); n; )
                    n = WD(n)
            } else if (1 & this.flags)
                for (let n of this.children)
                    7 & n.flags && (n.sync(e, t),
                    n.flags &= -8)
        }
        reuseDOM(e) {}
        localPosFromDOM(e, t) {
            let n;
            if (e == this.dom)
                n = this.dom.childNodes[t];
            else {
                let r = 0 == PD(e) ? 0 : 0 == t ? -1 : 1;
                for (; ; ) {
                    let t = e.parentNode;
                    if (t == this.dom)
                        break;
                    0 == r && t.firstChild != t.lastChild && (r = e == t.firstChild ? -1 : 1),
                    e = t
                }
                n = r < 0 ? e : e.nextSibling
            }
            if (n == this.dom.firstChild)
                return 0;
            for (; n && !ZD.get(n); )
                n = n.nextSibling;
            if (!n)
                return this.length;
            for (let r = 0, o = 0; ; r++) {
                let e = this.children[r];
                if (e.dom == n)
                    return o;
                o += e.length + e.breakAfter
            }
        }
        domBoundsAround(e, t, n=0) {
            let r = -1
              , o = -1
              , i = -1
              , a = -1;
            for (let s = 0, l = n, c = n; s < this.children.length; s++) {
                let n = this.children[s]
                  , u = l + n.length;
                if (l < e && u > t)
                    return n.domBoundsAround(e, t, l);
                if (u >= e && -1 == r && (r = s,
                o = l),
                l > t && n.dom.parentNode == this.dom) {
                    i = s,
                    a = c;
                    break
                }
                c = u,
                l = u + n.breakAfter
            }
            return {
                from: o,
                to: a < 0 ? n + this.length : a,
                startDOM: (r ? this.children[r - 1].dom.nextSibling : null) || this.dom.firstChild,
                endDOM: i < this.children.length && i >= 0 ? this.children[i].dom : null
            }
        }
        markDirty(e=!1) {
            this.flags |= 2,
            this.markParentsDirty(e)
        }
        markParentsDirty(e) {
            for (let t = this.parent; t; t = t.parent) {
                if (e && (t.flags |= 2),
                1 & t.flags)
                    return;
                t.flags |= 1,
                e = !1
            }
        }
        setParent(e) {
            this.parent != e && (this.parent = e,
            7 & this.flags && this.markParentsDirty(!0))
        }
        setDOM(e) {
            this.dom != e && (this.dom && (this.dom.cmView = null),
            this.dom = e,
            e.cmView = this)
        }
        get rootView() {
            for (let e = this; ; ) {
                let t = e.parent;
                if (!t)
                    return e;
                e = t
            }
        }
        replaceChildren(e, t, n=HD) {
            this.markDirty();
            for (let r = e; r < t; r++) {
                let e = this.children[r];
                e.parent == this && n.indexOf(e) < 0 && e.destroy()
            }
            this.children.splice(e, t - e, ...n);
            for (let r = 0; r < n.length; r++)
                n[r].setParent(this)
        }
        ignoreMutation(e) {
            return !1
        }
        ignoreEvent(e) {
            return !1
        }
        childCursor(e=this.length) {
            return new XD(this.children,e,this.children.length)
        }
        childPos(e, t=1) {
            return this.childCursor().findPos(e, t)
        }
        toString() {
            let e = this.constructor.name.replace("View", "");
            return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + ("Text" == e ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "")
        }
        static get(e) {
            return e.cmView
        }
        get isEditable() {
            return !0
        }
        get isWidget() {
            return !1
        }
        get isHidden() {
            return !1
        }
        merge(e, t, n, r, o, i) {
            return !1
        }
        become(e) {
            return !1
        }
        canReuseDOM(e) {
            return e.constructor == this.constructor && !(8 & (this.flags | e.flags))
        }
        getSide() {
            return 0
        }
        destroy() {
            for (let e of this.children)
                e.parent == this && e.destroy();
            this.parent = null
        }
    }
    function WD(e) {
        let t = e.nextSibling;
        return e.parentNode.removeChild(e),
        t
    }
    ZD.prototype.breakAfter = 0;
    class XD {
        constructor(e, t, n) {
            this.children = e,
            this.pos = t,
            this.i = n,
            this.off = 0
        }
        findPos(e, t=1) {
            for (; ; ) {
                if (e > this.pos || e == this.pos && (t > 0 || 0 == this.i || this.children[this.i - 1].breakAfter))
                    return this.off = e - this.pos,
                    this;
                let n = this.children[--this.i];
                this.pos -= n.length + n.breakAfter
            }
        }
    }
    function VD(e, t, n, r, o, i, a, s, l) {
        let {children: c} = e
          , u = c.length ? c[t] : null
          , d = i.length ? i[i.length - 1] : null
          , p = d ? d.breakAfter : a;
        if (!(t == r && u && !a && !p && i.length < 2 && u.merge(n, o, i.length ? d : null, 0 == n, s, l))) {
            if (r < c.length) {
                let e = c[r];
                e && (o < e.length || e.breakAfter && (null == d ? void 0 : d.breakAfter)) ? (t == r && (e = e.split(o),
                o = 0),
                !p && d && e.merge(0, o, d, !0, 0, l) ? i[i.length - 1] = e : ((o || e.children.length && !e.children[0].length) && e.merge(0, o, null, !1, 0, l),
                i.push(e))) : (null == e ? void 0 : e.breakAfter) && (d ? d.breakAfter = 1 : a = 1),
                r++
            }
            for (u && (u.breakAfter = a,
            n > 0 && (!a && i.length && u.merge(n, u.length, i[0], !1, s, 0) ? u.breakAfter = i.shift().breakAfter : (n < u.length || u.children.length && 0 == u.children[u.children.length - 1].length) && u.merge(n, u.length, null, !1, s, 0),
            t++)); t < r && i.length; )
                if (c[r - 1].become(i[i.length - 1]))
                    r--,
                    i.pop(),
                    l = i.length ? 0 : s;
                else {
                    if (!c[t].become(i[0]))
                        break;
                    t++,
                    i.shift(),
                    s = i.length ? 0 : l
                }
            !i.length && t && r < c.length && !c[t - 1].breakAfter && c[r].merge(0, 0, c[t - 1], !1, s, l) && t--,
            (t < r || i.length) && e.replaceChildren(t, r, i)
        }
    }
    function GD(e, t, n, r, o, i) {
        let a = e.childCursor()
          , {i: s, off: l} = a.findPos(n, 1)
          , {i: c, off: u} = a.findPos(t, -1)
          , d = t - n;
        for (let p of r)
            d += p.length;
        e.length += d,
        VD(e, c, u, s, l, r, 0, o, i)
    }
    let YD = "undefined" != typeof navigator ? navigator : {
        userAgent: "",
        vendor: "",
        platform: ""
    }
      , KD = "undefined" != typeof document ? document : {
        documentElement: {
            style: {}
        }
    };
    const JD = /Edge\/(\d+)/.exec(YD.userAgent)
      , eR = /MSIE \d/.test(YD.userAgent)
      , tR = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(YD.userAgent)
      , nR = !!(eR || tR || JD)
      , rR = !nR && /gecko\/(\d+)/i.test(YD.userAgent)
      , oR = !nR && /Chrome\/(\d+)/.exec(YD.userAgent)
      , iR = "webkitFontSmoothing"in KD.documentElement.style
      , aR = !nR && /Apple Computer/.test(YD.vendor)
      , sR = aR && (/Mobile\/\w+/.test(YD.userAgent) || YD.maxTouchPoints > 2);
    var lR = {
        mac: sR || /Mac/.test(YD.platform),
        windows: /Win/.test(YD.platform),
        linux: /Linux|X11/.test(YD.platform),
        ie: nR,
        ie_version: eR ? KD.documentMode || 6 : tR ? +tR[1] : JD ? +JD[1] : 0,
        gecko: rR,
        gecko_version: rR ? +(/Firefox\/(\d+)/.exec(YD.userAgent) || [0, 0])[1] : 0,
        chrome: !!oR,
        chrome_version: oR ? +oR[1] : 0,
        ios: sR,
        android: /Android\b/.test(YD.userAgent),
        webkit: iR,
        safari: aR,
        webkit_version: iR ? +(/\bAppleWebKit\/(\d+)/.exec(YD.userAgent) || [0, 0])[1] : 0,
        tabSize: null != KD.documentElement.style.tabSize ? "tab-size" : "-moz-tab-size"
    };
    class cR extends ZD {
        constructor(e) {
            super(),
            this.text = e
        }
        get length() {
            return this.text.length
        }
        createDOM(e) {
            this.setDOM(e || document.createTextNode(this.text))
        }
        sync(e, t) {
            this.dom || this.createDOM(),
            this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0),
            this.dom.nodeValue = this.text)
        }
        reuseDOM(e) {
            3 == e.nodeType && this.createDOM(e)
        }
        merge(e, t, n) {
            return !(8 & this.flags || n && (!(n instanceof cR) || this.length - (t - e) + n.length > 256 || 8 & n.flags)) && (this.text = this.text.slice(0, e) + (n ? n.text : "") + this.text.slice(t),
            this.markDirty(),
            !0)
        }
        split(e) {
            let t = new cR(this.text.slice(e));
            return this.text = this.text.slice(0, e),
            this.markDirty(),
            t.flags |= 8 & this.flags,
            t
        }
        localPosFromDOM(e, t) {
            return e == this.dom ? t : t ? this.text.length : 0
        }
        domAtPos(e) {
            return new qD(this.dom,e)
        }
        domBoundsAround(e, t, n) {
            return {
                from: n,
                to: n + this.length,
                startDOM: this.dom,
                endDOM: this.dom.nextSibling
            }
        }
        coordsAt(e, t) {
            return function(e, t, n) {
                let r = e.nodeValue.length;
                t > r && (t = r);
                let o = t
                  , i = t
                  , a = 0;
                0 == t && n < 0 || t == r && n >= 0 ? lR.chrome || lR.gecko || (t ? (o--,
                a = 1) : i < r && (i++,
                a = -1)) : n < 0 ? o-- : i < r && i++;
                let s = QD(e, o, i).getClientRects();
                if (!s.length)
                    return null;
                let l = s[(a ? a < 0 : n >= 0) ? 0 : s.length - 1];
                lR.safari && !a && 0 == l.width && (l = Array.prototype.find.call(s, (e=>e.width)) || l);
                return a ? DD(l, a < 0) : l || null
            }(this.dom, e, t)
        }
    }
    class uR extends ZD {
        constructor(e, t=[], n=0) {
            super(),
            this.mark = e,
            this.children = t,
            this.length = n;
            for (let r of t)
                r.setParent(this)
        }
        setAttrs(e) {
            if (UD(e),
            this.mark.class && (e.className = this.mark.class),
            this.mark.attrs)
                for (let t in this.mark.attrs)
                    e.setAttribute(t, this.mark.attrs[t]);
            return e
        }
        canReuseDOM(e) {
            return super.canReuseDOM(e) && !(8 & (this.flags | e.flags))
        }
        reuseDOM(e) {
            e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e),
            this.flags |= 6)
        }
        sync(e, t) {
            this.dom ? 4 & this.flags && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))),
            super.sync(e, t)
        }
        merge(e, t, n, r, o, i) {
            return (!n || !(!(n instanceof uR && n.mark.eq(this.mark)) || e && o <= 0 || t < this.length && i <= 0)) && (GD(this, e, t, n ? n.children.slice() : [], o - 1, i - 1),
            this.markDirty(),
            !0)
        }
        split(e) {
            let t = []
              , n = 0
              , r = -1
              , o = 0;
            for (let a of this.children) {
                let i = n + a.length;
                i > e && t.push(n < e ? a.split(e - n) : a),
                r < 0 && n >= e && (r = o),
                n = i,
                o++
            }
            let i = this.length - e;
            return this.length = e,
            r > -1 && (this.children.length = r,
            this.markDirty()),
            new uR(this.mark,t,i)
        }
        domAtPos(e) {
            return hR(this, e)
        }
        coordsAt(e, t) {
            return mR(this, e, t)
        }
    }
    class dR extends ZD {
        static create(e, t, n) {
            return new dR(e,t,n)
        }
        constructor(e, t, n) {
            super(),
            this.widget = e,
            this.length = t,
            this.side = n,
            this.prevWidget = null
        }
        split(e) {
            let t = dR.create(this.widget, this.length - e, this.side);
            return this.length -= e,
            t
        }
        sync(e) {
            this.dom && this.widget.updateDOM(this.dom, e) || (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom),
            this.prevWidget = null,
            this.setDOM(this.widget.toDOM(e)),
            this.widget.editable || (this.dom.contentEditable = "false"))
        }
        getSide() {
            return this.side
        }
        merge(e, t, n, r, o, i) {
            return !(n && (!(n instanceof dR && this.widget.compare(n.widget)) || e > 0 && o <= 0 || t < this.length && i <= 0)) && (this.length = e + (n ? n.length : 0) + (this.length - t),
            !0)
        }
        become(e) {
            return e instanceof dR && e.side == this.side && this.widget.constructor == e.widget.constructor && (this.widget.compare(e.widget) || this.markDirty(!0),
            this.dom && !this.prevWidget && (this.prevWidget = this.widget),
            this.widget = e.widget,
            this.length = e.length,
            !0)
        }
        ignoreMutation() {
            return !0
        }
        ignoreEvent(e) {
            return this.widget.ignoreEvent(e)
        }
        get overrideDOMText() {
            if (0 == this.length)
                return wC.empty;
            let e = this;
            for (; e.parent; )
                e = e.parent;
            let {view: t} = e
              , n = t && t.state.doc
              , r = this.posAtStart;
            return n ? n.slice(r, r + this.length) : wC.empty
        }
        domAtPos(e) {
            return (this.length ? 0 == e : this.side > 0) ? qD.before(this.dom) : qD.after(this.dom, e == this.length)
        }
        domBoundsAround() {
            return null
        }
        coordsAt(e, t) {
            let n = this.widget.coordsAt(this.dom, e, t);
            if (n)
                return n;
            let r = this.dom.getClientRects()
              , o = null;
            if (!r.length)
                return null;
            let i = this.side ? this.side < 0 : e > 0;
            for (let a = i ? r.length - 1 : 0; o = r[a],
            !(e > 0 ? 0 == a : a == r.length - 1 || o.top < o.bottom); a += i ? -1 : 1)
                ;
            return DD(o, !i)
        }
        get isEditable() {
            return !1
        }
        get isWidget() {
            return !0
        }
        get isHidden() {
            return this.widget.isHidden
        }
        destroy() {
            super.destroy(),
            this.dom && this.widget.destroy(this.dom)
        }
    }
    class pR extends ZD {
        constructor(e) {
            super(),
            this.side = e
        }
        get length() {
            return 0
        }
        merge() {
            return !1
        }
        become(e) {
            return e instanceof pR && e.side == this.side
        }
        split() {
            return new pR(this.side)
        }
        sync() {
            if (!this.dom) {
                let e = document.createElement("img");
                e.className = "cm-widgetBuffer",
                e.setAttribute("aria-hidden", "true"),
                this.setDOM(e)
            }
        }
        getSide() {
            return this.side
        }
        domAtPos(e) {
            return this.side > 0 ? qD.before(this.dom) : qD.after(this.dom)
        }
        localPosFromDOM() {
            return 0
        }
        domBoundsAround() {
            return null
        }
        coordsAt(e) {
            return this.dom.getBoundingClientRect()
        }
        get overrideDOMText() {
            return wC.empty
        }
        get isHidden() {
            return !0
        }
    }
    function hR(e, t) {
        let n = e.dom
          , {children: r} = e
          , o = 0;
        for (let i = 0; o < r.length; o++) {
            let e = r[o]
              , a = i + e.length;
            if (!(a == i && e.getSide() <= 0)) {
                if (t > i && t < a && e.dom.parentNode == n)
                    return e.domAtPos(t - i);
                if (t <= i)
                    break;
                i = a
            }
        }
        for (let i = o; i > 0; i--) {
            let e = r[i - 1];
            if (e.dom.parentNode == n)
                return e.domAtPos(e.length)
        }
        for (let i = o; i < r.length; i++) {
            let e = r[i];
            if (e.dom.parentNode == n)
                return e.domAtPos(0)
        }
        return new qD(n,0)
    }
    function fR(e, t, n) {
        let r, {children: o} = e;
        n > 0 && t instanceof uR && o.length && (r = o[o.length - 1])instanceof uR && r.mark.eq(t.mark) ? fR(r, t.children[0], n - 1) : (o.push(t),
        t.setParent(e)),
        e.length += t.length
    }
    function mR(e, t, n) {
        let r = null
          , o = -1
          , i = null
          , a = -1;
        !function e(t, s) {
            for (let l = 0, c = 0; l < t.children.length && c <= s; l++) {
                let u = t.children[l]
                  , d = c + u.length;
                d >= s && (u.children.length ? e(u, s - c) : (!i || i.isHidden && n > 0) && (d > s || c == d && u.getSide() > 0) ? (i = u,
                a = s - c) : (c < s || c == d && u.getSide() < 0 && !u.isHidden) && (r = u,
                o = s - c)),
                c = d
            }
        }(e, t);
        let s = (n < 0 ? r : i) || r || i;
        return s ? s.coordsAt(Math.max(0, s == r ? o : a), n) : function(e) {
            let t = e.dom.lastChild;
            if (!t)
                return e.dom.getBoundingClientRect();
            let n = ED(t);
            return n[n.length - 1] || null
        }(e)
    }
    function gR(e, t) {
        for (let n in e)
            "class" == n && t.class ? t.class += " " + e.class : "style" == n && t.style ? t.style += ";" + e.style : t[n] = e[n];
        return t
    }
    cR.prototype.children = dR.prototype.children = pR.prototype.children = HD;
    const bR = Object.create(null);
    function OR(e, t, n) {
        if (e == t)
            return !0;
        e || (e = bR),
        t || (t = bR);
        let r = Object.keys(e)
          , o = Object.keys(t);
        if (r.length - (n && r.indexOf(n) > -1 ? 1 : 0) != o.length - (n && o.indexOf(n) > -1 ? 1 : 0))
            return !1;
        for (let i of r)
            if (i != n && (-1 == o.indexOf(i) || e[i] !== t[i]))
                return !1;
        return !0
    }
    function vR(e, t, n) {
        let r = !1;
        if (t)
            for (let o in t)
                n && o in n || (r = !0,
                "style" == o ? e.style.cssText = "" : e.removeAttribute(o));
        if (n)
            for (let o in n)
                t && t[o] == n[o] || (r = !0,
                "style" == o ? e.style.cssText = n[o] : e.setAttribute(o, n[o]));
        return r
    }
    function yR(e) {
        let t = Object.create(null);
        for (let n = 0; n < e.attributes.length; n++) {
            let r = e.attributes[n];
            t[r.name] = r.value
        }
        return t
    }
    class wR extends ZD {
        constructor() {
            super(...arguments),
            this.children = [],
            this.length = 0,
            this.prevAttrs = void 0,
            this.attrs = null,
            this.breakAfter = 0
        }
        merge(e, t, n, r, o, i) {
            if (n) {
                if (!(n instanceof wR))
                    return !1;
                this.dom || n.transferDOM(this)
            }
            return r && this.setDeco(n ? n.attrs : null),
            GD(this, e, t, n ? n.children.slice() : [], o, i),
            !0
        }
        split(e) {
            let t = new wR;
            if (t.breakAfter = this.breakAfter,
            0 == this.length)
                return t;
            let {i: n, off: r} = this.childPos(e);
            r && (t.append(this.children[n].split(r), 0),
            this.children[n].merge(r, this.children[n].length, null, !1, 0, 0),
            n++);
            for (let o = n; o < this.children.length; o++)
                t.append(this.children[o], 0);
            for (; n > 0 && 0 == this.children[n - 1].length; )
                this.children[--n].destroy();
            return this.children.length = n,
            this.markDirty(),
            this.length = e,
            t
        }
        transferDOM(e) {
            this.dom && (this.markDirty(),
            e.setDOM(this.dom),
            e.prevAttrs = void 0 === this.prevAttrs ? this.attrs : this.prevAttrs,
            this.prevAttrs = void 0,
            this.dom = null)
        }
        setDeco(e) {
            OR(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs,
            this.markDirty()),
            this.attrs = e)
        }
        append(e, t) {
            fR(this, e, t)
        }
        addLineDeco(e) {
            let t = e.spec.attributes
              , n = e.spec.class;
            t && (this.attrs = gR(t, this.attrs || {})),
            n && (this.attrs = gR({
                class: n
            }, this.attrs || {}))
        }
        domAtPos(e) {
            return hR(this, e)
        }
        reuseDOM(e) {
            "DIV" == e.nodeName && (this.setDOM(e),
            this.flags |= 6)
        }
        sync(e, t) {
            var n;
            this.dom ? 4 & this.flags && (UD(this.dom),
            this.dom.className = "cm-line",
            this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")),
            this.dom.className = "cm-line",
            this.prevAttrs = this.attrs ? null : void 0),
            void 0 !== this.prevAttrs && (vR(this.dom, this.prevAttrs, this.attrs),
            this.dom.classList.add("cm-line"),
            this.prevAttrs = void 0),
            super.sync(e, t);
            let r = this.dom.lastChild;
            for (; r && ZD.get(r)instanceof uR; )
                r = r.lastChild;
            if (!(r && this.length && ("BR" == r.nodeName || 0 != (null === (n = ZD.get(r)) || void 0 === n ? void 0 : n.isEditable) || lR.ios && this.children.some((e=>e instanceof cR))))) {
                let e = document.createElement("BR");
                e.cmIgnore = !0,
                this.dom.appendChild(e)
            }
        }
        measureTextSize() {
            if (0 == this.children.length || this.length > 20)
                return null;
            let e, t = 0;
            for (let n of this.children) {
                if (!(n instanceof cR) || /[^ -~]/.test(n.text))
                    return null;
                let r = ED(n.dom);
                if (1 != r.length)
                    return null;
                t += r[0].width,
                e = r[0].height
            }
            return t ? {
                lineHeight: this.dom.getBoundingClientRect().height,
                charWidth: t / this.length,
                textHeight: e
            } : null
        }
        coordsAt(e, t) {
            let n = mR(this, e, t);
            if (!this.children.length && n && this.parent) {
                let {heightOracle: e} = this.parent.view.viewState
                  , t = n.bottom - n.top;
                if (Math.abs(t - e.lineHeight) < 2 && e.textHeight < t) {
                    let r = (t - e.textHeight) / 2;
                    return {
                        top: n.top + r,
                        bottom: n.bottom - r,
                        left: n.left,
                        right: n.left
                    }
                }
            }
            return n
        }
        become(e) {
            return !1
        }
        covers() {
            return !0
        }
        static find(e, t) {
            for (let n = 0, r = 0; n < e.children.length; n++) {
                let o = e.children[n]
                  , i = r + o.length;
                if (i >= t) {
                    if (o instanceof wR)
                        return o;
                    if (i > t)
                        break
                }
                r = i + o.breakAfter
            }
            return null
        }
    }
    class _R extends ZD {
        constructor(e, t, n) {
            super(),
            this.widget = e,
            this.length = t,
            this.deco = n,
            this.breakAfter = 0,
            this.prevWidget = null
        }
        merge(e, t, n, r, o, i) {
            return !(n && (!(n instanceof _R && this.widget.compare(n.widget)) || e > 0 && o <= 0 || t < this.length && i <= 0)) && (this.length = e + (n ? n.length : 0) + (this.length - t),
            !0)
        }
        domAtPos(e) {
            return 0 == e ? qD.before(this.dom) : qD.after(this.dom, e == this.length)
        }
        split(e) {
            let t = this.length - e;
            this.length = e;
            let n = new _R(this.widget,t,this.deco);
            return n.breakAfter = this.breakAfter,
            n
        }
        get children() {
            return HD
        }
        sync(e) {
            this.dom && this.widget.updateDOM(this.dom, e) || (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom),
            this.prevWidget = null,
            this.setDOM(this.widget.toDOM(e)),
            this.widget.editable || (this.dom.contentEditable = "false"))
        }
        get overrideDOMText() {
            return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : wC.empty
        }
        domBoundsAround() {
            return null
        }
        become(e) {
            return e instanceof _R && e.widget.constructor == this.widget.constructor && (e.widget.compare(this.widget) || this.markDirty(!0),
            this.dom && !this.prevWidget && (this.prevWidget = this.widget),
            this.widget = e.widget,
            this.length = e.length,
            this.deco = e.deco,
            this.breakAfter = e.breakAfter,
            !0)
        }
        ignoreMutation() {
            return !0
        }
        ignoreEvent(e) {
            return this.widget.ignoreEvent(e)
        }
        get isEditable() {
            return !1
        }
        get isWidget() {
            return !0
        }
        coordsAt(e, t) {
            return this.widget.coordsAt(this.dom, e, t)
        }
        destroy() {
            super.destroy(),
            this.dom && this.widget.destroy(this.dom)
        }
        covers(e) {
            let {startSide: t, endSide: n} = this.deco;
            return t != n && (e < 0 ? t < 0 : n > 0)
        }
    }
    class kR {
        eq(e) {
            return !1
        }
        updateDOM(e, t) {
            return !1
        }
        compare(e) {
            return this == e || this.constructor == e.constructor && this.eq(e)
        }
        get estimatedHeight() {
            return -1
        }
        get lineBreaks() {
            return 0
        }
        ignoreEvent(e) {
            return !0
        }
        coordsAt(e, t, n) {
            return null
        }
        get isHidden() {
            return !1
        }
        get editable() {
            return !1
        }
        destroy(e) {}
    }
    var SR = function(e) {
        return e[e.Text = 0] = "Text",
        e[e.WidgetBefore = 1] = "WidgetBefore",
        e[e.WidgetAfter = 2] = "WidgetAfter",
        e[e.WidgetRange = 3] = "WidgetRange",
        e
    }(SR || (SR = {}));
    class ER extends WP {
        constructor(e, t, n, r) {
            super(),
            this.startSide = e,
            this.endSide = t,
            this.widget = n,
            this.spec = r
        }
        get heightRelevant() {
            return !1
        }
        static mark(e) {
            return new xR(e)
        }
        static widget(e) {
            let t = Math.max(-1e4, Math.min(1e4, e.side || 0))
              , n = !!e.block;
            return t += n && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8,
            new AR(e,t,t,n,e.widget || null,!1)
        }
        static replace(e) {
            let t, n, r = !!e.block;
            if (e.isBlockGap)
                t = -5e8,
                n = 4e8;
            else {
                let {start: o, end: i} = CR(e, r);
                t = (o ? r ? -3e8 : -1 : 5e8) - 1,
                n = 1 + (i ? r ? 2e8 : 1 : -6e8)
            }
            return new AR(e,t,n,r,e.widget || null,!0)
        }
        static line(e) {
            return new TR(e)
        }
        static set(e, t=!1) {
            return YP.of(e, t)
        }
        hasHeight() {
            return !!this.widget && this.widget.estimatedHeight > -1
        }
    }
    ER.none = YP.empty;
    class xR extends ER {
        constructor(e) {
            let {start: t, end: n} = CR(e);
            super(t ? -1 : 5e8, n ? 1 : -6e8, null, e),
            this.tagName = e.tagName || "span",
            this.class = e.class || "",
            this.attrs = e.attributes || null
        }
        eq(e) {
            var t, n;
            return this == e || e instanceof xR && this.tagName == e.tagName && (this.class || (null === (t = this.attrs) || void 0 === t ? void 0 : t.class)) == (e.class || (null === (n = e.attrs) || void 0 === n ? void 0 : n.class)) && OR(this.attrs, e.attrs, "class")
        }
        range(e, t=e) {
            if (e >= t)
                throw new RangeError("Mark decorations may not be empty");
            return super.range(e, t)
        }
    }
    xR.prototype.point = !1;
    class TR extends ER {
        constructor(e) {
            super(-2e8, -2e8, null, e)
        }
        eq(e) {
            return e instanceof TR && this.spec.class == e.spec.class && OR(this.spec.attributes, e.spec.attributes)
        }
        range(e, t=e) {
            if (t != e)
                throw new RangeError("Line decoration ranges must be zero-length");
            return super.range(e, t)
        }
    }
    TR.prototype.mapMode = qC.TrackBefore,
    TR.prototype.point = !0;
    class AR extends ER {
        constructor(e, t, n, r, o, i) {
            super(t, n, o, e),
            this.block = r,
            this.isReplace = i,
            this.mapMode = r ? t <= 0 ? qC.TrackBefore : qC.TrackAfter : qC.TrackDel
        }
        get type() {
            return this.startSide != this.endSide ? SR.WidgetRange : this.startSide <= 0 ? SR.WidgetBefore : SR.WidgetAfter
        }
        get heightRelevant() {
            return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0)
        }
        eq(e) {
            return e instanceof AR && (t = this.widget,
            n = e.widget,
            t == n || !!(t && n && t.compare(n))) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
            var t, n
        }
        range(e, t=e) {
            if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
                throw new RangeError("Invalid range for replacement decoration");
            if (!this.isReplace && t != e)
                throw new RangeError("Widget decorations can only have zero-length ranges");
            return super.range(e, t)
        }
    }
    function CR(e, t=!1) {
        let {inclusiveStart: n, inclusiveEnd: r} = e;
        return null == n && (n = e.inclusive),
        null == r && (r = e.inclusive),
        {
            start: null != n ? n : t,
            end: null != r ? r : t
        }
    }
    function PR(e, t, n, r=0) {
        let o = n.length - 1;
        o >= 0 && n[o] + r >= e ? n[o] = Math.max(n[o], t) : n.push(e, t)
    }
    AR.prototype.point = !0;
    class DR {
        constructor(e, t, n, r) {
            this.doc = e,
            this.pos = t,
            this.end = n,
            this.disallowBlockEffectsFor = r,
            this.content = [],
            this.curLine = null,
            this.breakAtStart = 0,
            this.pendingBuffer = 0,
            this.bufferMarks = [],
            this.atCursorPos = !0,
            this.openStart = -1,
            this.openEnd = -1,
            this.text = "",
            this.textOff = 0,
            this.cursor = e.iter(),
            this.skip = t
        }
        posCovered() {
            if (0 == this.content.length)
                return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
            let e = this.content[this.content.length - 1];
            return !(e.breakAfter || e instanceof _R && e.deco.endSide < 0)
        }
        getLine() {
            return this.curLine || (this.content.push(this.curLine = new wR),
            this.atCursorPos = !0),
            this.curLine
        }
        flushBuffer(e=this.bufferMarks) {
            this.pendingBuffer && (this.curLine.append(RR(new pR(-1), e), e.length),
            this.pendingBuffer = 0)
        }
        addBlockWidget(e) {
            this.flushBuffer(),
            this.curLine = null,
            this.content.push(e)
        }
        finish(e) {
            this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0,
            this.posCovered() || e && this.content.length && this.content[this.content.length - 1]instanceof _R || this.getLine()
        }
        buildText(e, t, n) {
            for (; e > 0; ) {
                if (this.textOff == this.text.length) {
                    let {value: t, lineBreak: n, done: r} = this.cursor.next(this.skip);
                    if (this.skip = 0,
                    r)
                        throw new Error("Ran out of text content when drawing inline views");
                    if (n) {
                        this.posCovered() || this.getLine(),
                        this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1,
                        this.flushBuffer(),
                        this.curLine = null,
                        this.atCursorPos = !0,
                        e--;
                        continue
                    }
                    this.text = t,
                    this.textOff = 0
                }
                let r = Math.min(this.text.length - this.textOff, e, 512);
                this.flushBuffer(t.slice(t.length - n)),
                this.getLine().append(RR(new cR(this.text.slice(this.textOff, this.textOff + r)), t), n),
                this.atCursorPos = !0,
                this.textOff += r,
                e -= r,
                n = 0
            }
        }
        span(e, t, n, r) {
            this.buildText(t - e, n, r),
            this.pos = t,
            this.openStart < 0 && (this.openStart = r)
        }
        point(e, t, n, r, o, i) {
            if (this.disallowBlockEffectsFor[i] && n instanceof AR) {
                if (n.block)
                    throw new RangeError("Block decorations may not be specified via plugins");
                if (t > this.doc.lineAt(this.pos).to)
                    throw new RangeError("Decorations that replace line breaks may not be specified via plugins")
            }
            let a = t - e;
            if (n instanceof AR)
                if (n.block)
                    n.startSide > 0 && !this.posCovered() && this.getLine(),
                    this.addBlockWidget(new _R(n.widget || NR.block,a,n));
                else {
                    let i = dR.create(n.widget || NR.inline, a, a ? 0 : n.startSide)
                      , s = this.atCursorPos && !i.isEditable && o <= r.length && (e < t || n.startSide > 0)
                      , l = !i.isEditable && (e < t || o > r.length || n.startSide <= 0)
                      , c = this.getLine();
                    2 != this.pendingBuffer || s || i.isEditable || (this.pendingBuffer = 0),
                    this.flushBuffer(r),
                    s && (c.append(RR(new pR(1), r), o),
                    o = r.length + Math.max(0, o - r.length)),
                    c.append(RR(i, r), o),
                    this.atCursorPos = l,
                    this.pendingBuffer = l ? e < t || o > r.length ? 1 : 2 : 0,
                    this.pendingBuffer && (this.bufferMarks = r.slice())
                }
            else
                this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(n);
            a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff),
            this.text = "",
            this.textOff = 0),
            this.pos = t),
            this.openStart < 0 && (this.openStart = o)
        }
        static build(e, t, n, r, o) {
            let i = new DR(e,t,n,o);
            return i.openEnd = YP.spans(r, t, n, i),
            i.openStart < 0 && (i.openStart = i.openEnd),
            i.finish(i.openEnd),
            i
        }
    }
    function RR(e, t) {
        for (let n of t)
            e = new uR(n,[e],e.length);
        return e
    }
    class NR extends kR {
        constructor(e) {
            super(),
            this.tag = e
        }
        eq(e) {
            return e.tag == this.tag
        }
        toDOM() {
            return document.createElement(this.tag)
        }
        updateDOM(e) {
            return e.nodeName.toLowerCase() == this.tag
        }
        get isHidden() {
            return !0
        }
    }
    NR.inline = new NR("span"),
    NR.block = new NR("div");
    var $R = function(e) {
        return e[e.LTR = 0] = "LTR",
        e[e.RTL = 1] = "RTL",
        e
    }($R || ($R = {}));
    const IR = $R.LTR
      , MR = $R.RTL;
    function LR(e) {
        let t = [];
        for (let n = 0; n < e.length; n++)
            t.push(1 << +e[n]);
        return t
    }
    const QR = LR("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008")
      , BR = LR("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333")
      , UR = Object.create(null)
      , FR = [];
    for (let Rie of ["()", "[]", "{}"]) {
        let e = Rie.charCodeAt(0)
          , t = Rie.charCodeAt(1);
        UR[e] = t,
        UR[t] = -e
    }
    function jR(e) {
        return e <= 247 ? QR[e] : 1424 <= e && e <= 1524 ? 2 : 1536 <= e && e <= 1785 ? BR[e - 1536] : 1774 <= e && e <= 2220 ? 4 : 8192 <= e && e <= 8204 ? 256 : 64336 <= e && e <= 65023 ? 4 : 1
    }
    const zR = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
    class qR {
        get dir() {
            return this.level % 2 ? MR : IR
        }
        constructor(e, t, n) {
            this.from = e,
            this.to = t,
            this.level = n
        }
        side(e, t) {
            return this.dir == t == e ? this.to : this.from
        }
        forward(e, t) {
            return e == (this.dir == t)
        }
        static find(e, t, n, r) {
            let o = -1;
            for (let i = 0; i < e.length; i++) {
                let a = e[i];
                if (a.from <= t && a.to >= t) {
                    if (a.level == n)
                        return i;
                    (o < 0 || (0 != r ? r < 0 ? a.from < t : a.to > t : e[o].level > a.level)) && (o = i)
                }
            }
            if (o < 0)
                throw new RangeError("Index out of range");
            return o
        }
    }
    function HR(e, t) {
        if (e.length != t.length)
            return !1;
        for (let n = 0; n < e.length; n++) {
            let r = e[n]
              , o = t[n];
            if (r.from != o.from || r.to != o.to || r.direction != o.direction || !HR(r.inner, o.inner))
                return !1
        }
        return !0
    }
    const ZR = [];
    function WR(e, t, n, r, o, i, a) {
        let s = r % 2 ? 2 : 1;
        if (r % 2 == o % 2)
            for (let l = t, c = 0; l < n; ) {
                let t = !0
                  , u = !1;
                if (c == i.length || l < i[c].from) {
                    let e = ZR[l];
                    e != s && (t = !1,
                    u = 16 == e)
                }
                let d = t || 1 != s ? null : []
                  , p = t ? r : r + 1
                  , h = l;
                e: for (; ; )
                    if (c < i.length && h == i[c].from) {
                        if (u)
                            break e;
                        let f = i[c];
                        if (!t)
                            for (let e = f.to, t = c + 1; ; ) {
                                if (e == n)
                                    break e;
                                if (!(t < i.length && i[t].from == e)) {
                                    if (ZR[e] == s)
                                        break e;
                                    break
                                }
                                e = i[t++].to
                            }
                        if (c++,
                        d)
                            d.push(f);
                        else {
                            f.from > l && a.push(new qR(l,f.from,p)),
                            XR(e, f.direction == IR != !(p % 2) ? r + 1 : r, o, f.inner, f.from, f.to, a),
                            l = f.to
                        }
                        h = f.to
                    } else {
                        if (h == n || (t ? ZR[h] != s : ZR[h] == s))
                            break;
                        h++
                    }
                d ? WR(e, l, h, r + 1, o, d, a) : l < h && a.push(new qR(l,h,p)),
                l = h
            }
        else
            for (let l = n, c = i.length; l > t; ) {
                let n = !0
                  , u = !1;
                if (!c || l > i[c - 1].to) {
                    let e = ZR[l - 1];
                    e != s && (n = !1,
                    u = 16 == e)
                }
                let d = n || 1 != s ? null : []
                  , p = n ? r : r + 1
                  , h = l;
                e: for (; ; )
                    if (c && h == i[c - 1].to) {
                        if (u)
                            break e;
                        let f = i[--c];
                        if (!n)
                            for (let e = f.from, n = c; ; ) {
                                if (e == t)
                                    break e;
                                if (!n || i[n - 1].to != e) {
                                    if (ZR[e - 1] == s)
                                        break e;
                                    break
                                }
                                e = i[--n].from
                            }
                        if (d)
                            d.push(f);
                        else {
                            f.to < l && a.push(new qR(f.to,l,p)),
                            XR(e, f.direction == IR != !(p % 2) ? r + 1 : r, o, f.inner, f.from, f.to, a),
                            l = f.from
                        }
                        h = f.from
                    } else {
                        if (h == t || (n ? ZR[h - 1] != s : ZR[h - 1] == s))
                            break;
                        h--
                    }
                d ? WR(e, h, l, r + 1, o, d, a) : h < l && a.push(new qR(h,l,p)),
                l = h
            }
    }
    function XR(e, t, n, r, o, i, a) {
        let s = t % 2 ? 2 : 1;
        !function(e, t, n, r, o) {
            for (let i = 0; i <= r.length; i++) {
                let a = i ? r[i - 1].to : t
                  , s = i < r.length ? r[i].from : n
                  , l = i ? 256 : o;
                for (let t = a, n = l, r = l; t < s; t++) {
                    let o = jR(e.charCodeAt(t));
                    512 == o ? o = n : 8 == o && 4 == r && (o = 16),
                    ZR[t] = 4 == o ? 2 : o,
                    7 & o && (r = o),
                    n = o
                }
                for (let e = a, t = l, r = l; e < s; e++) {
                    let o = ZR[e];
                    if (128 == o)
                        e < s - 1 && t == ZR[e + 1] && 24 & t ? o = ZR[e] = t : ZR[e] = 256;
                    else if (64 == o) {
                        let o = e + 1;
                        for (; o < s && 64 == ZR[o]; )
                            o++;
                        let i = e && 8 == t || o < n && 8 == ZR[o] ? 1 == r ? 1 : 8 : 256;
                        for (let t = e; t < o; t++)
                            ZR[t] = i;
                        e = o - 1
                    } else
                        8 == o && 1 == r && (ZR[e] = 1);
                    t = o,
                    7 & o && (r = o)
                }
            }
        }(e, o, i, r, s),
        function(e, t, n, r, o) {
            let i = 1 == o ? 2 : 1;
            for (let a = 0, s = 0, l = 0; a <= r.length; a++) {
                let c = a ? r[a - 1].to : t
                  , u = a < r.length ? r[a].from : n;
                for (let t, n, r, a = c; a < u; a++)
                    if (n = UR[t = e.charCodeAt(a)])
                        if (n < 0) {
                            for (let e = s - 3; e >= 0; e -= 3)
                                if (FR[e + 1] == -n) {
                                    let t = FR[e + 2]
                                      , n = 2 & t ? o : 4 & t ? 1 & t ? i : o : 0;
                                    n && (ZR[a] = ZR[FR[e]] = n),
                                    s = e;
                                    break
                                }
                        } else {
                            if (189 == FR.length)
                                break;
                            FR[s++] = a,
                            FR[s++] = t,
                            FR[s++] = l
                        }
                    else if (2 == (r = ZR[a]) || 1 == r) {
                        let e = r == o;
                        l = e ? 0 : 1;
                        for (let t = s - 3; t >= 0; t -= 3) {
                            let n = FR[t + 2];
                            if (2 & n)
                                break;
                            if (e)
                                FR[t + 2] |= 2;
                            else {
                                if (4 & n)
                                    break;
                                FR[t + 2] |= 4
                            }
                        }
                    }
            }
        }(e, o, i, r, s),
        function(e, t, n, r) {
            for (let o = 0, i = r; o <= n.length; o++) {
                let a = o ? n[o - 1].to : e
                  , s = o < n.length ? n[o].from : t;
                for (let l = a; l < s; ) {
                    let a = ZR[l];
                    if (256 == a) {
                        let a = l + 1;
                        for (; ; )
                            if (a == s) {
                                if (o == n.length)
                                    break;
                                a = n[o++].to,
                                s = o < n.length ? n[o].from : t
                            } else {
                                if (256 != ZR[a])
                                    break;
                                a++
                            }
                        let c = 1 == i
                          , u = c == (1 == (a < t ? ZR[a] : r)) ? c ? 1 : 2 : r;
                        for (let t = a, r = o, i = r ? n[r - 1].to : e; t > l; )
                            t == i && (t = n[--r].from,
                            i = r ? n[r - 1].to : e),
                            ZR[--t] = u;
                        l = a
                    } else
                        i = a,
                        l++
                }
            }
        }(o, i, r, s),
        WR(e, o, i, t, n, r, a)
    }
    function VR(e) {
        return [new qR(0,e,0)]
    }
    let GR = "";
    function YR(e, t, n, r, o) {
        var i;
        let a = r.head - e.from
          , s = qR.find(t, a, null !== (i = r.bidiLevel) && void 0 !== i ? i : -1, r.assoc)
          , l = t[s]
          , c = l.side(o, n);
        if (a == c) {
            let e = s += o ? 1 : -1;
            if (e < 0 || e >= t.length)
                return null;
            l = t[s = e],
            a = l.side(!o, n),
            c = l.side(o, n)
        }
        let u = IC(e.text, a, l.forward(o, n));
        (u < l.from || u > l.to) && (u = c),
        GR = e.text.slice(Math.min(a, u), Math.max(a, u));
        let d = s == (o ? t.length - 1 : 0) ? null : t[s + (o ? 1 : -1)];
        return d && u == c && d.level + (o ? 0 : 1) < l.level ? eP.cursor(d.side(!o, n) + e.from, d.forward(o, n) ? 1 : -1, d.level) : eP.cursor(u + e.from, l.forward(o, n) ? -1 : 1, l.level)
    }
    function KR(e, t, n) {
        for (let r = t; r < n; r++) {
            let t = jR(e.charCodeAt(r));
            if (1 == t)
                return IR;
            if (2 == t || 4 == t)
                return MR
        }
        return IR
    }
    const JR = rP.define()
      , eN = rP.define()
      , tN = rP.define()
      , nN = rP.define()
      , rN = rP.define()
      , oN = rP.define()
      , iN = rP.define()
      , aN = rP.define({
        combine: e=>e.some((e=>e))
    })
      , sN = rP.define({
        combine: e=>e.some((e=>e))
    })
      , lN = rP.define();
    class cN {
        constructor(e, t="nearest", n="nearest", r=5, o=5, i=!1) {
            this.range = e,
            this.y = t,
            this.x = n,
            this.yMargin = r,
            this.xMargin = o,
            this.isSnapshot = i
        }
        map(e) {
            return e.empty ? this : new cN(this.range.map(e),this.y,this.x,this.yMargin,this.xMargin,this.isSnapshot)
        }
        clip(e) {
            return this.range.to <= e.doc.length ? this : new cN(eP.cursor(e.doc.length),this.y,this.x,this.yMargin,this.xMargin,this.isSnapshot)
        }
    }
    const uN = NP.define({
        map: (e,t)=>e.map(t)
    })
      , dN = NP.define();
    function pN(e, t, n) {
        let r = e.facet(nN);
        r.length ? r[0](t) : window.onerror ? window.onerror(String(t), n, void 0, void 0, t) : n ? console.error(n + ":", t) : console.error(t)
    }
    const hN = rP.define({
        combine: e=>!e.length || e[0]
    });
    let fN = 0;
    const mN = rP.define();
    class gN {
        constructor(e, t, n, r, o) {
            this.id = e,
            this.create = t,
            this.domEventHandlers = n,
            this.domEventObservers = r,
            this.extension = o(this)
        }
        static define(e, t) {
            const {eventHandlers: n, eventObservers: r, provide: o, decorations: i} = t || {};
            return new gN(fN++,e,n,r,(e=>{
                let t = [mN.of(e)];
                return i && t.push(yN.of((t=>{
                    let n = t.plugin(e);
                    return n ? i(n) : ER.none
                }
                ))),
                o && t.push(o(e)),
                t
            }
            ))
        }
        static fromClass(e, t) {
            return gN.define((t=>new e(t)), t)
        }
    }
    class bN {
        constructor(e) {
            this.spec = e,
            this.mustUpdate = null,
            this.value = null
        }
        update(e) {
            if (this.value) {
                if (this.mustUpdate) {
                    let e = this.mustUpdate;
                    if (this.mustUpdate = null,
                    this.value.update)
                        try {
                            this.value.update(e)
                        } catch (Aa) {
                            if (pN(e.state, Aa, "CodeMirror plugin crashed"),
                            this.value.destroy)
                                try {
                                    this.value.destroy()
                                } catch (Die) {}
                            this.deactivate()
                        }
                }
            } else if (this.spec)
                try {
                    this.value = this.spec.create(e)
                } catch (Aa) {
                    pN(e.state, Aa, "CodeMirror plugin crashed"),
                    this.deactivate()
                }
            return this
        }
        destroy(e) {
            var t;
            if (null === (t = this.value) || void 0 === t ? void 0 : t.destroy)
                try {
                    this.value.destroy()
                } catch (Aa) {
                    pN(e.state, Aa, "CodeMirror plugin crashed")
                }
        }
        deactivate() {
            this.spec = this.value = null
        }
    }
    const ON = rP.define()
      , vN = rP.define()
      , yN = rP.define()
      , wN = rP.define()
      , _N = rP.define()
      , kN = rP.define();
    function SN(e, t) {
        let n = e.state.facet(kN);
        if (!n.length)
            return n;
        let r = n.map((t=>t instanceof Function ? t(e) : t))
          , o = [];
        return YP.spans(r, t.from, t.to, {
            point() {},
            span(e, n, r, i) {
                let a = e - t.from
                  , s = n - t.from
                  , l = o;
                for (let o = r.length - 1; o >= 0; o--,
                i--) {
                    let e, n = r[o].spec.bidiIsolate;
                    if (null == n && (n = KR(t.text, a, s)),
                    i > 0 && l.length && (e = l[l.length - 1]).to == a && e.direction == n)
                        e.to = s,
                        l = e.inner;
                    else {
                        let e = {
                            from: a,
                            to: s,
                            direction: n,
                            inner: []
                        };
                        l.push(e),
                        l = e.inner
                    }
                }
            }
        }),
        o
    }
    const EN = rP.define();
    function xN(e) {
        let t = 0
          , n = 0
          , r = 0
          , o = 0;
        for (let i of e.state.facet(EN)) {
            let a = i(e);
            a && (null != a.left && (t = Math.max(t, a.left)),
            null != a.right && (n = Math.max(n, a.right)),
            null != a.top && (r = Math.max(r, a.top)),
            null != a.bottom && (o = Math.max(o, a.bottom)))
        }
        return {
            left: t,
            right: n,
            top: r,
            bottom: o
        }
    }
    const TN = rP.define();
    class AN {
        constructor(e, t, n, r) {
            this.fromA = e,
            this.toA = t,
            this.fromB = n,
            this.toB = r
        }
        join(e) {
            return new AN(Math.min(this.fromA, e.fromA),Math.max(this.toA, e.toA),Math.min(this.fromB, e.fromB),Math.max(this.toB, e.toB))
        }
        addToSet(e) {
            let t = e.length
              , n = this;
            for (; t > 0; t--) {
                let r = e[t - 1];
                if (!(r.fromA > n.toA)) {
                    if (r.toA < n.fromA)
                        break;
                    n = n.join(r),
                    e.splice(t - 1, 1)
                }
            }
            return e.splice(t, 0, n),
            e
        }
        static extendWithRanges(e, t) {
            if (0 == t.length)
                return e;
            let n = [];
            for (let r = 0, o = 0, i = 0, a = 0; ; r++) {
                let s = r == e.length ? null : e[r]
                  , l = i - a
                  , c = s ? s.fromB : 1e9;
                for (; o < t.length && t[o] < c; ) {
                    let e = t[o]
                      , r = t[o + 1]
                      , i = Math.max(a, e)
                      , s = Math.min(c, r);
                    if (i <= s && new AN(i + l,s + l,i,s).addToSet(n),
                    r > c)
                        break;
                    o += 2
                }
                if (!s)
                    return n;
                new AN(s.fromA,s.toA,s.fromB,s.toB).addToSet(n),
                i = s.toA,
                a = s.toB
            }
        }
    }
    class CN {
        constructor(e, t, n) {
            this.view = e,
            this.state = t,
            this.transactions = n,
            this.flags = 0,
            this.startState = e.state,
            this.changes = ZC.empty(this.startState.doc.length);
            for (let o of n)
                this.changes = this.changes.compose(o.changes);
            let r = [];
            this.changes.iterChangedRanges(((e,t,n,o)=>r.push(new AN(e,t,n,o)))),
            this.changedRanges = r
        }
        static create(e, t, n) {
            return new CN(e,t,n)
        }
        get viewportChanged() {
            return (4 & this.flags) > 0
        }
        get heightChanged() {
            return (2 & this.flags) > 0
        }
        get geometryChanged() {
            return this.docChanged || (10 & this.flags) > 0
        }
        get focusChanged() {
            return (1 & this.flags) > 0
        }
        get docChanged() {
            return !this.changes.empty
        }
        get selectionSet() {
            return this.transactions.some((e=>e.selection))
        }
        get empty() {
            return 0 == this.flags && 0 == this.transactions.length
        }
    }
    class PN extends ZD {
        get length() {
            return this.view.state.doc.length
        }
        constructor(e) {
            super(),
            this.view = e,
            this.decorations = [],
            this.dynamicDecorationMap = [!1],
            this.domChanged = null,
            this.hasComposition = null,
            this.markedForComposition = new Set,
            this.editContextFormatting = ER.none,
            this.lastCompositionAfterCursor = !1,
            this.minWidth = 0,
            this.minWidthFrom = 0,
            this.minWidthTo = 0,
            this.impreciseAnchor = null,
            this.impreciseHead = null,
            this.forceSelection = !1,
            this.lastUpdate = Date.now(),
            this.setDOM(e.contentDOM),
            this.children = [new wR],
            this.children[0].setParent(this),
            this.updateDeco(),
            this.updateInner([new AN(0,0,0,e.state.doc.length)], 0, null)
        }
        update(e) {
            var t;
            let n = e.changedRanges;
            this.minWidth > 0 && n.length && (n.every((({fromA: e, toA: t})=>t < this.minWidthFrom || e > this.minWidthTo)) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1),
            this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0),
            this.updateEditContextFormatting(e);
            let r = -1;
            this.view.inputState.composing >= 0 && !this.view.observer.editContext && ((null === (t = this.domChanged) || void 0 === t ? void 0 : t.newSel) ? r = this.domChanged.newSel.head : function(e, t) {
                let n = !1;
                t && e.iterChangedRanges(((e,r)=>{
                    e < t.to && r > t.from && (n = !0)
                }
                ));
                return n
            }(e.changes, this.hasComposition) || e.selectionSet || (r = e.state.selection.main.head));
            let o = r > -1 ? function(e, t, n) {
                let r = RN(e, n);
                if (!r)
                    return null;
                let {node: o, from: i, to: a} = r
                  , s = o.nodeValue;
                if (/[\n\r]/.test(s))
                    return null;
                if (e.state.doc.sliceString(r.from, r.to) != s)
                    return null;
                let l = t.invertedDesc
                  , c = new AN(l.mapPos(i),l.mapPos(a),i,a)
                  , u = [];
                for (let d = o.parentNode; ; d = d.parentNode) {
                    let t = ZD.get(d);
                    if (t instanceof uR)
                        u.push({
                            node: d,
                            deco: t.mark
                        });
                    else {
                        if (t instanceof wR || "DIV" == d.nodeName && d.parentNode == e.contentDOM)
                            return {
                                range: c,
                                text: o,
                                marks: u,
                                line: d
                            };
                        if (d == e.contentDOM)
                            return null;
                        u.push({
                            node: d,
                            deco: new xR({
                                inclusive: !0,
                                attributes: yR(d),
                                tagName: d.tagName.toLowerCase()
                            })
                        })
                    }
                }
            }(this.view, e.changes, r) : null;
            if (this.domChanged = null,
            this.hasComposition) {
                this.markedForComposition.clear();
                let {from: t, to: r} = this.hasComposition;
                n = new AN(t,r,e.changes.mapPos(t, -1),e.changes.mapPos(r, 1)).addToSet(n.slice())
            }
            this.hasComposition = o ? {
                from: o.range.fromB,
                to: o.range.toB
            } : null,
            (lR.ie || lR.chrome) && !o && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
            let i = function(e, t, n) {
                let r = new NN;
                return YP.compare(e, t, n, r),
                r.changes
            }(this.decorations, this.updateDeco(), e.changes);
            return n = AN.extendWithRanges(n, i),
            !!(7 & this.flags || 0 != n.length) && (this.updateInner(n, e.startState.doc.length, o),
            e.transactions.length && (this.lastUpdate = Date.now()),
            !0)
        }
        updateInner(e, t, n) {
            this.view.viewState.mustMeasureContent = !0,
            this.updateChildren(e, t, n);
            let {observer: r} = this.view;
            r.ignore((()=>{
                this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px",
                this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
                let e = lR.chrome || lR.ios ? {
                    node: r.selectionRange.focusNode,
                    written: !1
                } : void 0;
                this.sync(this.view, e),
                this.flags &= -8,
                e && (e.written || r.selectionRange.focusNode != e.node) && (this.forceSelection = !0),
                this.dom.style.height = ""
            }
            )),
            this.markedForComposition.forEach((e=>e.flags &= -9));
            let o = [];
            if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
                for (let i of this.children)
                    i instanceof _R && i.widget instanceof DN && o.push(i.dom);
            r.updateGaps(o)
        }
        updateChildren(e, t, n) {
            let r = n ? n.range.addToSet(e.slice()) : e
              , o = this.childCursor(t);
            for (let i = r.length - 1; ; i--) {
                let e = i >= 0 ? r[i] : null;
                if (!e)
                    break;
                let t, a, s, l, {fromA: c, toA: u, fromB: d, toB: p} = e;
                if (n && n.range.fromB < p && n.range.toB > d) {
                    let e = DR.build(this.view.state.doc, d, n.range.fromB, this.decorations, this.dynamicDecorationMap)
                      , r = DR.build(this.view.state.doc, n.range.toB, p, this.decorations, this.dynamicDecorationMap);
                    a = e.breakAtStart,
                    s = e.openStart,
                    l = r.openEnd;
                    let o = this.compositionView(n);
                    r.breakAtStart ? o.breakAfter = 1 : r.content.length && o.merge(o.length, o.length, r.content[0], !1, r.openStart, 0) && (o.breakAfter = r.content[0].breakAfter,
                    r.content.shift()),
                    e.content.length && o.merge(0, 0, e.content[e.content.length - 1], !0, 0, e.openEnd) && e.content.pop(),
                    t = e.content.concat(o).concat(r.content)
                } else
                    ({content: t, breakAtStart: a, openStart: s, openEnd: l} = DR.build(this.view.state.doc, d, p, this.decorations, this.dynamicDecorationMap));
                let {i: h, off: f} = o.findPos(u, 1)
                  , {i: m, off: g} = o.findPos(c, -1);
                VD(this, m, g, h, f, t, a, s, l)
            }
            n && this.fixCompositionDOM(n)
        }
        updateEditContextFormatting(e) {
            this.editContextFormatting = this.editContextFormatting.map(e.changes);
            for (let t of e.transactions)
                for (let e of t.effects)
                    e.is(dN) && (this.editContextFormatting = e.value)
        }
        compositionView(e) {
            let t = new cR(e.text.nodeValue);
            t.flags |= 8;
            for (let {deco: r} of e.marks)
                t = new uR(r,[t],t.length);
            let n = new wR;
            return n.append(t, 0),
            n
        }
        fixCompositionDOM(e) {
            let t = (e,t)=>{
                t.flags |= 8 | (t.children.some((e=>7 & e.flags)) ? 1 : 0),
                this.markedForComposition.add(t);
                let n = ZD.get(e);
                n && n != t && (n.dom = null),
                t.setDOM(e)
            }
              , n = this.childPos(e.range.fromB, 1)
              , r = this.children[n.i];
            t(e.line, r);
            for (let o = e.marks.length - 1; o >= -1; o--)
                n = r.childPos(n.off, 1),
                r = r.children[n.i],
                t(o >= 0 ? e.marks[o].node : e.text, r)
        }
        updateSelection(e=!1, t=!1) {
            !e && this.view.observer.selectionRange.focusNode || this.view.observer.readSelectionRange();
            let n = this.view.root.activeElement
              , r = n == this.dom
              , o = !r && SD(this.dom, this.view.observer.selectionRange) && !(n && this.dom.contains(n));
            if (!(r || t || o))
                return;
            let i = this.forceSelection;
            this.forceSelection = !1;
            let a = this.view.state.selection.main
              , s = this.moveToLine(this.domAtPos(a.anchor))
              , l = a.empty ? s : this.moveToLine(this.domAtPos(a.head));
            if (lR.gecko && a.empty && !this.hasComposition && (1 == (c = s).node.nodeType && c.node.firstChild && (0 == c.offset || "false" == c.node.childNodes[c.offset - 1].contentEditable) && (c.offset == c.node.childNodes.length || "false" == c.node.childNodes[c.offset].contentEditable))) {
                let e = document.createTextNode("");
                this.view.observer.ignore((()=>s.node.insertBefore(e, s.node.childNodes[s.offset] || null))),
                s = l = new qD(e,0),
                i = !0
            }
            var c;
            let u = this.view.observer.selectionRange;
            !i && u.focusNode && (xD(s.node, s.offset, u.anchorNode, u.anchorOffset) && xD(l.node, l.offset, u.focusNode, u.focusOffset) || this.suppressWidgetCursorChange(u, a)) || (this.view.observer.ignore((()=>{
                lR.android && lR.chrome && this.dom.contains(u.focusNode) && function(e, t) {
                    for (let n = e; n && n != t; n = n.assignedSlot || n.parentNode)
                        if (1 == n.nodeType && "false" == n.contentEditable)
                            return !0;
                    return !1
                }(u.focusNode, this.dom) && (this.dom.blur(),
                this.dom.focus({
                    preventScroll: !0
                }));
                let e = _D(this.view.root);
                if (e)
                    if (a.empty) {
                        if (lR.gecko) {
                            let e = (t = s.node,
                            r = s.offset,
                            1 != t.nodeType ? 0 : (r && "false" == t.childNodes[r - 1].contentEditable ? 1 : 0) | (r < t.childNodes.length && "false" == t.childNodes[r].contentEditable ? 2 : 0));
                            if (e && 3 != e) {
                                let t = (1 == e ? jD : zD)(s.node, s.offset);
                                t && (s = new qD(t.node,t.offset))
                            }
                        }
                        e.collapse(s.node, s.offset),
                        null != a.bidiLevel && void 0 !== e.caretBidiLevel && (e.caretBidiLevel = a.bidiLevel)
                    } else if (e.extend) {
                        e.collapse(s.node, s.offset);
                        try {
                            e.extend(l.node, l.offset)
                        } catch (Die) {}
                    } else {
                        let t = document.createRange();
                        a.anchor > a.head && ([s,l] = [l, s]),
                        t.setEnd(l.node, l.offset),
                        t.setStart(s.node, s.offset),
                        e.removeAllRanges(),
                        e.addRange(t)
                    }
                else
                    ;var t, r;
                o && this.view.root.activeElement == this.dom && (this.dom.blur(),
                n && n.focus())
            }
            )),
            this.view.observer.setSelectionRange(s, l)),
            this.impreciseAnchor = s.precise ? null : new qD(u.anchorNode,u.anchorOffset),
            this.impreciseHead = l.precise ? null : new qD(u.focusNode,u.focusOffset)
        }
        suppressWidgetCursorChange(e, t) {
            return this.hasComposition && t.empty && xD(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == t.head
        }
        enforceCursorAssoc() {
            if (this.hasComposition)
                return;
            let {view: e} = this
              , t = e.state.selection.main
              , n = _D(e.root)
              , {anchorNode: r, anchorOffset: o} = e.observer.selectionRange;
            if (!(n && t.empty && t.assoc && n.modify))
                return;
            let i = wR.find(this, t.head);
            if (!i)
                return;
            let a = i.posAtStart;
            if (t.head == a || t.head == a + i.length)
                return;
            let s = this.coordsAt(t.head, -1)
              , l = this.coordsAt(t.head, 1);
            if (!s || !l || s.bottom > l.top)
                return;
            let c = this.domAtPos(t.head + t.assoc);
            n.collapse(c.node, c.offset),
            n.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"),
            e.observer.readSelectionRange();
            let u = e.observer.selectionRange;
            e.docView.posFromDOM(u.anchorNode, u.anchorOffset) != t.from && n.collapse(r, o)
        }
        moveToLine(e) {
            let t, n = this.dom;
            if (e.node != n)
                return e;
            for (let r = e.offset; !t && r < n.childNodes.length; r++) {
                let e = ZD.get(n.childNodes[r]);
                e instanceof wR && (t = e.domAtPos(0))
            }
            for (let r = e.offset - 1; !t && r >= 0; r--) {
                let e = ZD.get(n.childNodes[r]);
                e instanceof wR && (t = e.domAtPos(e.length))
            }
            return t ? new qD(t.node,t.offset,!0) : e
        }
        nearest(e) {
            for (let t = e; t; ) {
                let e = ZD.get(t);
                if (e && e.rootView == this)
                    return e;
                t = t.parentNode
            }
            return null
        }
        posFromDOM(e, t) {
            let n = this.nearest(e);
            if (!n)
                throw new RangeError("Trying to find position for a DOM position outside of the document");
            return n.localPosFromDOM(e, t) + n.posAtStart
        }
        domAtPos(e) {
            let {i: t, off: n} = this.childCursor().findPos(e, -1);
            for (; t < this.children.length - 1; ) {
                let e = this.children[t];
                if (n < e.length || e instanceof wR)
                    break;
                t++,
                n = 0
            }
            return this.children[t].domAtPos(n)
        }
        coordsAt(e, t) {
            let n = null
              , r = 0;
            for (let o = this.length, i = this.children.length - 1; i >= 0; i--) {
                let a = this.children[i]
                  , s = o - a.breakAfter
                  , l = s - a.length;
                if (s < e)
                    break;
                if (l <= e && (l < e || a.covers(-1)) && (s > e || a.covers(1)) && (!n || a instanceof wR && !(n instanceof wR && t >= 0)))
                    n = a,
                    r = l;
                else if (n && l == e && s == e && a instanceof _R && Math.abs(t) < 2) {
                    if (a.deco.startSide < 0)
                        break;
                    i && (n = null)
                }
                o = l
            }
            return n ? n.coordsAt(e - r, t) : null
        }
        coordsForChar(e) {
            let {i: t, off: n} = this.childPos(e, 1)
              , r = this.children[t];
            if (!(r instanceof wR))
                return null;
            for (; r.children.length; ) {
                let {i: e, off: t} = r.childPos(n, 1);
                for (; ; e++) {
                    if (e == r.children.length)
                        return null;
                    if ((r = r.children[e]).length)
                        break
                }
                n = t
            }
            if (!(r instanceof cR))
                return null;
            let o = IC(r.text, n);
            if (o == n)
                return null;
            let i = QD(r.dom, n, o).getClientRects();
            for (let a = 0; a < i.length; a++) {
                let e = i[a];
                if (a == i.length - 1 || e.top < e.bottom && e.left < e.right)
                    return e
            }
            return null
        }
        measureVisibleLineHeights(e) {
            let t = []
              , {from: n, to: r} = e
              , o = this.view.contentDOM.clientWidth
              , i = o > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1
              , a = -1
              , s = this.view.textDirection == $R.LTR;
            for (let l = 0, c = 0; c < this.children.length; c++) {
                let e = this.children[c]
                  , u = l + e.length;
                if (u > r)
                    break;
                if (l >= n) {
                    let n = e.dom.getBoundingClientRect();
                    if (t.push(n.height),
                    i) {
                        let t = e.dom.lastChild
                          , r = t ? ED(t) : [];
                        if (r.length) {
                            let e = r[r.length - 1]
                              , t = s ? e.right - n.left : n.right - e.left;
                            t > a && (a = t,
                            this.minWidth = o,
                            this.minWidthFrom = l,
                            this.minWidthTo = u)
                        }
                    }
                }
                l = u + e.breakAfter
            }
            return t
        }
        textDirectionAt(e) {
            let {i: t} = this.childPos(e, 1);
            return "rtl" == getComputedStyle(this.children[t].dom).direction ? $R.RTL : $R.LTR
        }
        measureTextSize() {
            for (let o of this.children)
                if (o instanceof wR) {
                    let e = o.measureTextSize();
                    if (e)
                        return e
                }
            let e, t, n, r = document.createElement("div");
            return r.className = "cm-line",
            r.style.width = "99999px",
            r.style.position = "absolute",
            r.textContent = "abc def ghi jkl mno pqr stu",
            this.view.observer.ignore((()=>{
                this.dom.appendChild(r);
                let o = ED(r.firstChild)[0];
                e = r.getBoundingClientRect().height,
                t = o ? o.width / 27 : 7,
                n = o ? o.height : e,
                r.remove()
            }
            )),
            {
                lineHeight: e,
                charWidth: t,
                textHeight: n
            }
        }
        childCursor(e=this.length) {
            let t = this.children.length;
            return t && (e -= this.children[--t].length),
            new XD(this.children,e,t)
        }
        computeBlockGapDeco() {
            let e = []
              , t = this.view.viewState;
            for (let n = 0, r = 0; ; r++) {
                let o = r == t.viewports.length ? null : t.viewports[r]
                  , i = o ? o.from - 1 : this.length;
                if (i > n) {
                    let r = (t.lineBlockAt(i).bottom - t.lineBlockAt(n).top) / this.view.scaleY;
                    e.push(ER.replace({
                        widget: new DN(r),
                        block: !0,
                        inclusive: !0,
                        isBlockGap: !0
                    }).range(n, i))
                }
                if (!o)
                    break;
                n = o.to + 1
            }
            return ER.set(e)
        }
        updateDeco() {
            let e = 1
              , t = this.view.state.facet(yN).map((t=>(this.dynamicDecorationMap[e++] = "function" == typeof t) ? t(this.view) : t))
              , n = !1
              , r = this.view.state.facet(wN).map(((e,t)=>{
                let r = "function" == typeof e;
                return r && (n = !0),
                r ? e(this.view) : e
            }
            ));
            for (r.length && (this.dynamicDecorationMap[e++] = n,
            t.push(YP.join(r))),
            this.decorations = [this.editContextFormatting, ...t, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco]; e < this.decorations.length; )
                this.dynamicDecorationMap[e++] = !1;
            return this.decorations
        }
        scrollIntoView(e) {
            if (e.isSnapshot) {
                let t = this.view.viewState.lineBlockAt(e.range.head);
                return this.view.scrollDOM.scrollTop = t.top - e.yMargin,
                void (this.view.scrollDOM.scrollLeft = e.xMargin)
            }
            for (let l of this.view.state.facet(lN))
                try {
                    if (l(this.view, e.range, e))
                        return !0
                } catch (Aa) {
                    pN(this.view.state, Aa, "scroll handler")
                }
            let t, {range: n} = e, r = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1);
            if (!r)
                return;
            !n.empty && (t = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (r = {
                left: Math.min(r.left, t.left),
                top: Math.min(r.top, t.top),
                right: Math.max(r.right, t.right),
                bottom: Math.max(r.bottom, t.bottom)
            });
            let o = xN(this.view)
              , i = {
                left: r.left - o.left,
                top: r.top - o.top,
                right: r.right + o.right,
                bottom: r.bottom + o.bottom
            }
              , {offsetWidth: a, offsetHeight: s} = this.view.scrollDOM;
            !function(e, t, n, r, o, i, a, s) {
                let l = e.ownerDocument
                  , c = l.defaultView || window;
                for (let u = e, d = !1; u && !d; )
                    if (1 == u.nodeType) {
                        let e, p = u == l.body, h = 1, f = 1;
                        if (p)
                            e = RD(c);
                        else {
                            if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (d = !0),
                            u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
                                u = u.assignedSlot || u.parentNode;
                                continue
                            }
                            let t = u.getBoundingClientRect();
                            ({scaleX: h, scaleY: f} = ND(u, t)),
                            e = {
                                left: t.left,
                                right: t.left + u.clientWidth * h,
                                top: t.top,
                                bottom: t.top + u.clientHeight * f
                            }
                        }
                        let m = 0
                          , g = 0;
                        if ("nearest" == o)
                            t.top < e.top ? (g = -(e.top - t.top + a),
                            n > 0 && t.bottom > e.bottom + g && (g = t.bottom - e.bottom + g + a)) : t.bottom > e.bottom && (g = t.bottom - e.bottom + a,
                            n < 0 && t.top - g < e.top && (g = -(e.top + g - t.top + a)));
                        else {
                            let r = t.bottom - t.top
                              , i = e.bottom - e.top;
                            g = ("center" == o && r <= i ? t.top + r / 2 - i / 2 : "start" == o || "center" == o && n < 0 ? t.top - a : t.bottom - i + a) - e.top
                        }
                        if ("nearest" == r ? t.left < e.left ? (m = -(e.left - t.left + i),
                        n > 0 && t.right > e.right + m && (m = t.right - e.right + m + i)) : t.right > e.right && (m = t.right - e.right + i,
                        n < 0 && t.left < e.left + m && (m = -(e.left + m - t.left + i))) : m = ("center" == r ? t.left + (t.right - t.left) / 2 - (e.right - e.left) / 2 : "start" == r == s ? t.left - i : t.right - (e.right - e.left) + i) - e.left,
                        m || g)
                            if (p)
                                c.scrollBy(m, g);
                            else {
                                let e = 0
                                  , n = 0;
                                if (g) {
                                    let e = u.scrollTop;
                                    u.scrollTop += g / f,
                                    n = (u.scrollTop - e) * f
                                }
                                if (m) {
                                    let t = u.scrollLeft;
                                    u.scrollLeft += m / h,
                                    e = (u.scrollLeft - t) * h
                                }
                                t = {
                                    left: t.left - e,
                                    top: t.top - n,
                                    right: t.right - e,
                                    bottom: t.bottom - n
                                },
                                e && Math.abs(e - m) < 1 && (r = "nearest"),
                                n && Math.abs(n - g) < 1 && (o = "nearest")
                            }
                        if (p)
                            break;
                        u = u.assignedSlot || u.parentNode
                    } else {
                        if (11 != u.nodeType)
                            break;
                        u = u.host
                    }
            }(this.view.scrollDOM, i, n.head < n.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, s), -s), this.view.textDirection == $R.LTR)
        }
    }
    class DN extends kR {
        constructor(e) {
            super(),
            this.height = e
        }
        toDOM() {
            let e = document.createElement("div");
            return e.className = "cm-gap",
            this.updateDOM(e),
            e
        }
        eq(e) {
            return e.height == this.height
        }
        updateDOM(e) {
            return e.style.height = this.height + "px",
            !0
        }
        get editable() {
            return !0
        }
        get estimatedHeight() {
            return this.height
        }
        ignoreEvent() {
            return !1
        }
    }
    function RN(e, t) {
        let n = e.observer.selectionRange;
        if (!n.focusNode)
            return null;
        let r = jD(n.focusNode, n.focusOffset)
          , o = zD(n.focusNode, n.focusOffset)
          , i = r || o;
        if (o && r && o.node != r.node) {
            let t = ZD.get(o.node);
            if (!t || t instanceof cR && t.text != o.node.nodeValue)
                i = o;
            else if (e.docView.lastCompositionAfterCursor) {
                let e = ZD.get(r.node);
                !e || e instanceof cR && e.text != r.node.nodeValue || (i = o)
            }
        }
        if (e.docView.lastCompositionAfterCursor = i != r,
        !i)
            return null;
        let a = t - i.offset;
        return {
            from: a,
            to: a + i.node.nodeValue.length,
            node: i.node
        }
    }
    let NN = class {
        constructor() {
            this.changes = []
        }
        compareRange(e, t) {
            PR(e, t, this.changes)
        }
        comparePoint(e, t) {
            PR(e, t, this.changes)
        }
    }
    ;
    function $N(e, t) {
        return t.left > e ? t.left - e : Math.max(0, e - t.right)
    }
    function IN(e, t) {
        return t.top > e ? t.top - e : Math.max(0, e - t.bottom)
    }
    function MN(e, t) {
        return e.top < t.bottom - 1 && e.bottom > t.top + 1
    }
    function LN(e, t) {
        return t < e.top ? {
            top: t,
            left: e.left,
            right: e.right,
            bottom: e.bottom
        } : e
    }
    function QN(e, t) {
        return t > e.bottom ? {
            top: e.top,
            left: e.left,
            right: e.right,
            bottom: t
        } : e
    }
    function BN(e, t, n) {
        let r, o, i, a, s, l, c, u, d = !1;
        for (let h = e.firstChild; h; h = h.nextSibling) {
            let e = ED(h);
            for (let p = 0; p < e.length; p++) {
                let f = e[p];
                o && MN(o, f) && (f = LN(QN(f, o.bottom), o.top));
                let m = $N(t, f)
                  , g = IN(n, f);
                if (0 == m && 0 == g)
                    return 3 == h.nodeType ? UN(h, t, n) : BN(h, t, n);
                if (!r || a > g || a == g && i > m) {
                    r = h,
                    o = f,
                    i = m,
                    a = g;
                    let s = g ? n < f.top ? -1 : 1 : m ? t < f.left ? -1 : 1 : 0;
                    d = !s || (s > 0 ? p < e.length - 1 : p > 0)
                }
                0 == m ? n > f.bottom && (!c || c.bottom < f.bottom) ? (s = h,
                c = f) : n < f.top && (!u || u.top > f.top) && (l = h,
                u = f) : c && MN(c, f) ? c = QN(c, f.bottom) : u && MN(u, f) && (u = LN(u, f.top))
            }
        }
        if (c && c.bottom >= n ? (r = s,
        o = c) : u && u.top <= n && (r = l,
        o = u),
        !r)
            return {
                node: e,
                offset: 0
            };
        let p = Math.max(o.left, Math.min(o.right, t));
        return 3 == r.nodeType ? UN(r, p, n) : d && "false" != r.contentEditable ? BN(r, p, n) : {
            node: e,
            offset: Array.prototype.indexOf.call(e.childNodes, r) + (t >= (o.left + o.right) / 2 ? 1 : 0)
        }
    }
    function UN(e, t, n) {
        let r = e.nodeValue.length
          , o = -1
          , i = 1e9
          , a = 0;
        for (let s = 0; s < r; s++) {
            let r = QD(e, s, s + 1).getClientRects();
            for (let l = 0; l < r.length; l++) {
                let c = r[l];
                if (c.top == c.bottom)
                    continue;
                a || (a = t - c.left);
                let u = (c.top > n ? c.top - n : n - c.bottom) - 1;
                if (c.left - 1 <= t && c.right + 1 >= t && u < i) {
                    let n = t >= (c.left + c.right) / 2
                      , r = n;
                    if (lR.chrome || lR.gecko) {
                        QD(e, s).getBoundingClientRect().left == c.right && (r = !n)
                    }
                    if (u <= 0)
                        return {
                            node: e,
                            offset: s + (r ? 1 : 0)
                        };
                    o = s + (r ? 1 : 0),
                    i = u
                }
            }
        }
        return {
            node: e,
            offset: o > -1 ? o : a > 0 ? e.nodeValue.length : 0
        }
    }
    function FN(e, t, n, r=-1) {
        var o, i;
        let a, s = e.contentDOM.getBoundingClientRect(), l = s.top + e.viewState.paddingTop, {docHeight: c} = e.viewState, {x: u, y: d} = t, p = d - l;
        if (p < 0)
            return 0;
        if (p > c)
            return e.state.doc.length;
        for (let y = e.viewState.heightOracle.textHeight / 2, w = !1; a = e.elementAtHeight(p),
        a.type != SR.Text; )
            for (; p = r > 0 ? a.bottom + y : a.top - y,
            !(p >= 0 && p <= c); ) {
                if (w)
                    return n ? null : 0;
                w = !0,
                r = -r
            }
        d = l + p;
        let h = a.from;
        if (h < e.viewport.from)
            return 0 == e.viewport.from ? 0 : n ? null : jN(e, s, a, u, d);
        if (h > e.viewport.to)
            return e.viewport.to == e.state.doc.length ? e.state.doc.length : n ? null : jN(e, s, a, u, d);
        let f = e.dom.ownerDocument
          , m = e.root.elementFromPoint ? e.root : f
          , g = m.elementFromPoint(u, d);
        g && !e.contentDOM.contains(g) && (g = null),
        g || (u = Math.max(s.left + 1, Math.min(s.right - 1, u)),
        g = m.elementFromPoint(u, d),
        g && !e.contentDOM.contains(g) && (g = null));
        let b, O = -1;
        if (g && 0 != (null === (o = e.docView.nearest(g)) || void 0 === o ? void 0 : o.isEditable))
            if (f.caretPositionFromPoint) {
                let e = f.caretPositionFromPoint(u, d);
                e && ({offsetNode: b, offset: O} = e)
            } else if (f.caretRangeFromPoint) {
                let t = f.caretRangeFromPoint(u, d);
                t && (({startContainer: b, startOffset: O} = t),
                (!e.contentDOM.contains(b) || lR.safari && function(e, t, n) {
                    let r;
                    if (3 != e.nodeType || t != (r = e.nodeValue.length))
                        return !1;
                    for (let o = e.nextSibling; o; o = o.nextSibling)
                        if (1 != o.nodeType || "BR" != o.nodeName)
                            return !1;
                    return QD(e, r - 1, r).getBoundingClientRect().left > n
                }(b, O, u) || lR.chrome && function(e, t, n) {
                    if (0 != t)
                        return !1;
                    for (let o = e; ; ) {
                        let e = o.parentNode;
                        if (!e || 1 != e.nodeType || e.firstChild != o)
                            return !1;
                        if (e.classList.contains("cm-line"))
                            break;
                        o = e
                    }
                    let r = 1 == e.nodeType ? e.getBoundingClientRect() : QD(e, 0, Math.max(e.nodeValue.length, 1)).getBoundingClientRect();
                    return n - r.left > 5
                }(b, O, u)) && (b = void 0))
            }
        if (!b || !e.docView.dom.contains(b)) {
            let t = wR.find(e.docView, h);
            if (!t)
                return p > a.top + a.height / 2 ? a.to : a.from;
            ({node: b, offset: O} = BN(t.dom, u, d))
        }
        let v = e.docView.nearest(b);
        if (!v)
            return null;
        if (v.isWidget && 1 == (null === (i = v.dom) || void 0 === i ? void 0 : i.nodeType)) {
            let e = v.dom.getBoundingClientRect();
            return t.y < e.top || t.y <= e.bottom && t.x <= (e.left + e.right) / 2 ? v.posAtStart : v.posAtEnd
        }
        return v.localPosFromDOM(b, O) + v.posAtStart
    }
    function jN(e, t, n, r, o) {
        let i = Math.round((r - t.left) * e.defaultCharacterWidth);
        if (e.lineWrapping && n.height > 1.5 * e.defaultLineHeight) {
            let t = e.viewState.heightOracle.textHeight;
            i += Math.floor((o - n.top - .5 * (e.defaultLineHeight - t)) / t) * e.viewState.heightOracle.lineLength
        }
        let a = e.state.sliceDoc(n.from, n.to);
        return n.from + function(e, t, n, r) {
            for (let o = 0, i = 0; ; ) {
                if (i >= t)
                    return o;
                if (o == e.length)
                    break;
                i += 9 == e.charCodeAt(o) ? n - i % n : 1,
                o = IC(e, o)
            }
            return !0 === r ? -1 : e.length
        }(a, i, e.state.tabSize)
    }
    function zN(e, t, n, r) {
        let o = function(e, t) {
            let n = e.lineBlockAt(t);
            if (Array.isArray(n.type))
                for (let r of n.type)
                    if (r.to > t || r.to == t && (r.to == n.to || r.type == SR.Text))
                        return r;
            return n
        }(e, t.head)
          , i = r && o.type == SR.Text && (e.lineWrapping || o.widgetLineBreaks) ? e.coordsAtPos(t.assoc < 0 && t.head > o.from ? t.head - 1 : t.head) : null;
        if (i) {
            let t = e.dom.getBoundingClientRect()
              , r = e.textDirectionAt(o.from)
              , a = e.posAtCoords({
                x: n == (r == $R.LTR) ? t.right - 1 : t.left + 1,
                y: (i.top + i.bottom) / 2
            });
            if (null != a)
                return eP.cursor(a, n ? -1 : 1)
        }
        return eP.cursor(n ? o.to : o.from, n ? -1 : 1)
    }
    function qN(e, t, n, r) {
        let o = e.state.doc.lineAt(t.head)
          , i = e.bidiSpans(o)
          , a = e.textDirectionAt(o.from);
        for (let s = t, l = null; ; ) {
            let t = YR(o, i, a, s, n)
              , c = GR;
            if (!t) {
                if (o.number == (n ? e.state.doc.lines : 1))
                    return s;
                c = "\n",
                o = e.state.doc.line(o.number + (n ? 1 : -1)),
                i = e.bidiSpans(o),
                t = e.visualLineSide(o, !n)
            }
            if (l) {
                if (!l(c))
                    return s
            } else {
                if (!r)
                    return t;
                l = r(c)
            }
            s = t
        }
    }
    function HN(e, t, n) {
        for (; ; ) {
            let r = 0;
            for (let o of e)
                o.between(t - 1, t + 1, ((e,o,i)=>{
                    if (t > e && t < o) {
                        let i = r || n || (t - e < o - t ? -1 : 1);
                        t = i < 0 ? e : o,
                        r = i
                    }
                }
                ));
            if (!r)
                return t
        }
    }
    function ZN(e, t, n) {
        let r = HN(e.state.facet(_N).map((t=>t(e))), n.from, t.head > n.from ? -1 : 1);
        return r == n.from ? n : eP.cursor(r, r < n.from ? 1 : -1)
    }
    class WN {
        setSelectionOrigin(e) {
            this.lastSelectionOrigin = e,
            this.lastSelectionTime = Date.now()
        }
        constructor(e) {
            var t;
            this.view = e,
            this.lastKeyCode = 0,
            this.lastKeyTime = 0,
            this.lastTouchTime = 0,
            this.lastFocusTime = 0,
            this.lastScrollTop = 0,
            this.lastScrollLeft = 0,
            this.pendingIOSKey = void 0,
            this.tabFocusMode = -1,
            this.lastSelectionOrigin = null,
            this.lastSelectionTime = 0,
            this.lastContextMenu = 0,
            this.scrollHandlers = [],
            this.handlers = Object.create(null),
            this.composing = -1,
            this.compositionFirstChange = null,
            this.compositionEndedAt = 0,
            this.compositionPendingKey = !1,
            this.compositionPendingChange = !1,
            this.mouseSelection = null,
            this.draggedContent = null,
            this.handleEvent = this.handleEvent.bind(this),
            this.notifiedFocused = e.hasFocus,
            lR.safari && e.contentDOM.addEventListener("input", (()=>null)),
            lR.gecko && (t = e.contentDOM.ownerDocument,
            v$.has(t) || (v$.add(t),
            t.addEventListener("copy", (()=>{}
            )),
            t.addEventListener("cut", (()=>{}
            ))))
        }
        handleEvent(e) {
            (function(e, t) {
                if (!t.bubbles)
                    return !0;
                if (t.defaultPrevented)
                    return !1;
                for (let n, r = t.target; r != e.contentDOM; r = r.parentNode)
                    if (!r || 11 == r.nodeType || (n = ZD.get(r)) && n.ignoreEvent(t))
                        return !1;
                return !0
            }
            )(this.view, e) && !this.ignoreDuringComposition(e) && ("keydown" == e.type && this.keydown(e) || this.runHandlers(e.type, e))
        }
        runHandlers(e, t) {
            let n = this.handlers[e];
            if (n) {
                for (let e of n.observers)
                    e(this.view, t);
                for (let e of n.handlers) {
                    if (t.defaultPrevented)
                        break;
                    if (e(this.view, t)) {
                        t.preventDefault();
                        break
                    }
                }
            }
        }
        ensureHandlers(e) {
            let t = function(e) {
                let t = Object.create(null);
                function n(e) {
                    return t[e] || (t[e] = {
                        observers: [],
                        handlers: []
                    })
                }
                for (let r of e) {
                    let e = r.spec;
                    if (e && e.domEventHandlers)
                        for (let t in e.domEventHandlers) {
                            let o = e.domEventHandlers[t];
                            o && n(t).handlers.push(XN(r.value, o))
                        }
                    if (e && e.domEventObservers)
                        for (let t in e.domEventObservers) {
                            let o = e.domEventObservers[t];
                            o && n(t).observers.push(XN(r.value, o))
                        }
                }
                for (let r in e$)
                    n(r).handlers.push(e$[r]);
                for (let r in t$)
                    n(r).observers.push(t$[r]);
                return t
            }(e)
              , n = this.handlers
              , r = this.view.contentDOM;
            for (let o in t)
                if ("scroll" != o) {
                    let e = !t[o].handlers.length
                      , i = n[o];
                    i && e != !i.handlers.length && (r.removeEventListener(o, this.handleEvent),
                    i = null),
                    i || r.addEventListener(o, this.handleEvent, {
                        passive: e
                    })
                }
            for (let o in n)
                "scroll" == o || t[o] || r.removeEventListener(o, this.handleEvent);
            this.handlers = t
        }
        keydown(e) {
            if (this.lastKeyCode = e.keyCode,
            this.lastKeyTime = Date.now(),
            9 == e.keyCode && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
                return !0;
            if (this.tabFocusMode > 0 && 27 != e.keyCode && YN.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1),
            lR.android && lR.chrome && !e.synthetic && (13 == e.keyCode || 8 == e.keyCode))
                return this.view.observer.delayAndroidKey(e.key, e.keyCode),
                !0;
            let t;
            return !lR.ios || e.synthetic || e.altKey || e.metaKey || !((t = VN.find((t=>t.keyCode == e.keyCode))) && !e.ctrlKey || GN.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (229 != e.keyCode && this.view.observer.forceFlush(),
            !1) : (this.pendingIOSKey = t || e,
            setTimeout((()=>this.flushIOSKey()), 250),
            !0)
        }
        flushIOSKey(e) {
            let t = this.pendingIOSKey;
            return !!t && (!("Enter" == t.key && e && e.from < e.to && /^\S+$/.test(e.insert.toString())) && (this.pendingIOSKey = void 0,
            BD(this.view.contentDOM, t.key, t.keyCode, t instanceof KeyboardEvent ? t : void 0)))
        }
        ignoreDuringComposition(e) {
            return !!/^key/.test(e.type) && (this.composing > 0 || !!(lR.safari && !lR.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) && (this.compositionPendingKey = !1,
            !0))
        }
        startMouseSelection(e) {
            this.mouseSelection && this.mouseSelection.destroy(),
            this.mouseSelection = e
        }
        update(e) {
            this.view.observer.update(e),
            this.mouseSelection && this.mouseSelection.update(e),
            this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)),
            e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0)
        }
        destroy() {
            this.mouseSelection && this.mouseSelection.destroy()
        }
    }
    function XN(e, t) {
        return (n,r)=>{
            try {
                return t.call(e, r, n)
            } catch (Aa) {
                pN(n.state, Aa)
            }
        }
    }
    const VN = [{
        key: "Backspace",
        keyCode: 8,
        inputType: "deleteContentBackward"
    }, {
        key: "Enter",
        keyCode: 13,
        inputType: "insertParagraph"
    }, {
        key: "Enter",
        keyCode: 13,
        inputType: "insertLineBreak"
    }, {
        key: "Delete",
        keyCode: 46,
        inputType: "deleteContentForward"
    }]
      , GN = "dthko"
      , YN = [16, 17, 18, 20, 91, 92, 224, 225];
    function KN(e) {
        return .7 * Math.max(0, e) + 8
    }
    class JN {
        constructor(e, t, n, r) {
            this.view = e,
            this.startEvent = t,
            this.style = n,
            this.mustSelect = r,
            this.scrollSpeed = {
                x: 0,
                y: 0
            },
            this.scrolling = -1,
            this.lastEvent = t,
            this.scrollParent = function(e) {
                let t = e.ownerDocument;
                for (let n = e.parentNode; n && n != t.body; )
                    if (1 == n.nodeType) {
                        if (n.scrollHeight > n.clientHeight || n.scrollWidth > n.clientWidth)
                            return n;
                        n = n.assignedSlot || n.parentNode
                    } else {
                        if (11 != n.nodeType)
                            break;
                        n = n.host
                    }
                return null
            }(e.contentDOM),
            this.atoms = e.state.facet(_N).map((t=>t(e)));
            let o = e.contentDOM.ownerDocument;
            o.addEventListener("mousemove", this.move = this.move.bind(this)),
            o.addEventListener("mouseup", this.up = this.up.bind(this)),
            this.extend = t.shiftKey,
            this.multiple = e.state.facet(HP.allowMultipleSelections) && function(e, t) {
                let n = e.state.facet(JR);
                return n.length ? n[0](t) : lR.mac ? t.metaKey : t.ctrlKey
            }(e, t),
            this.dragging = !(!function(e, t) {
                let {main: n} = e.state.selection;
                if (n.empty)
                    return !1;
                let r = _D(e.root);
                if (!r || 0 == r.rangeCount)
                    return !0;
                let o = r.getRangeAt(0).getClientRects();
                for (let i = 0; i < o.length; i++) {
                    let e = o[i];
                    if (e.left <= t.clientX && e.right >= t.clientX && e.top <= t.clientY && e.bottom >= t.clientY)
                        return !0
                }
                return !1
            }(e, t) || 1 != h$(t)) && null
        }
        start(e) {
            !1 === this.dragging && this.select(e)
        }
        move(e) {
            var t, n, r;
            if (0 == e.buttons)
                return this.destroy();
            if (this.dragging || null == this.dragging && (n = this.startEvent,
            r = e,
            Math.max(Math.abs(n.clientX - r.clientX), Math.abs(n.clientY - r.clientY)) < 10))
                return;
            this.select(this.lastEvent = e);
            let o = 0
              , i = 0
              , a = (null === (t = this.scrollParent) || void 0 === t ? void 0 : t.getBoundingClientRect()) || {
                left: 0,
                top: 0,
                right: this.view.win.innerWidth,
                bottom: this.view.win.innerHeight
            }
              , s = xN(this.view);
            e.clientX - s.left <= a.left + 6 ? o = -KN(a.left - e.clientX) : e.clientX + s.right >= a.right - 6 && (o = KN(e.clientX - a.right)),
            e.clientY - s.top <= a.top + 6 ? i = -KN(a.top - e.clientY) : e.clientY + s.bottom >= a.bottom - 6 && (i = KN(e.clientY - a.bottom)),
            this.setScrollSpeed(o, i)
        }
        up(e) {
            null == this.dragging && this.select(this.lastEvent),
            this.dragging || e.preventDefault(),
            this.destroy()
        }
        destroy() {
            this.setScrollSpeed(0, 0);
            let e = this.view.contentDOM.ownerDocument;
            e.removeEventListener("mousemove", this.move),
            e.removeEventListener("mouseup", this.up),
            this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null
        }
        setScrollSpeed(e, t) {
            this.scrollSpeed = {
                x: e,
                y: t
            },
            e || t ? this.scrolling < 0 && (this.scrolling = setInterval((()=>this.scroll()), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling),
            this.scrolling = -1)
        }
        scroll() {
            this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x,
            this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y),
            !1 === this.dragging && this.select(this.lastEvent)
        }
        skipAtoms(e) {
            let t = null;
            for (let n = 0; n < e.ranges.length; n++) {
                let r = e.ranges[n]
                  , o = null;
                if (r.empty) {
                    let e = HN(this.atoms, r.from, 0);
                    e != r.from && (o = eP.cursor(e, -1))
                } else {
                    let e = HN(this.atoms, r.from, -1)
                      , t = HN(this.atoms, r.to, 1);
                    e == r.from && t == r.to || (o = eP.range(r.from == r.anchor ? e : t, r.from == r.head ? e : t))
                }
                o && (t || (t = e.ranges.slice()),
                t[n] = o)
            }
            return t ? eP.create(t, e.mainIndex) : e
        }
        select(e) {
            let {view: t} = this
              , n = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
            !this.mustSelect && n.eq(t.state.selection, !1 === this.dragging) || this.view.dispatch({
                selection: n,
                userEvent: "select.pointer"
            }),
            this.mustSelect = !1
        }
        update(e) {
            e.transactions.some((e=>e.isUserEvent("input.type"))) ? this.destroy() : this.style.update(e) && setTimeout((()=>this.select(this.lastEvent)), 20)
        }
    }
    const e$ = Object.create(null)
      , t$ = Object.create(null)
      , n$ = lR.ie && lR.ie_version < 15 || lR.ios && lR.webkit_version < 604;
    function r$(e, t) {
        let n, {state: r} = e, o = 1, i = r.toText(t), a = i.lines == r.selection.ranges.length, s = null != m$ && r.selection.ranges.every((e=>e.empty)) && m$ == i.toString();
        if (s) {
            let e = -1;
            n = r.changeByRange((n=>{
                let s = r.doc.lineAt(n.from);
                if (s.from == e)
                    return {
                        range: n
                    };
                e = s.from;
                let l = r.toText((a ? i.line(o++).text : t) + r.lineBreak);
                return {
                    changes: {
                        from: s.from,
                        insert: l
                    },
                    range: eP.cursor(n.from + l.length)
                }
            }
            ))
        } else
            n = a ? r.changeByRange((e=>{
                let t = i.line(o++);
                return {
                    changes: {
                        from: e.from,
                        to: e.to,
                        insert: t.text
                    },
                    range: eP.cursor(e.from + t.length)
                }
            }
            )) : r.replaceSelection(i);
        e.dispatch(n, {
            userEvent: "input.paste",
            scrollIntoView: !0
        })
    }
    function o$(e, t, n, r) {
        if (1 == r)
            return eP.cursor(t, n);
        if (2 == r)
            return function(e, t, n=1) {
                let r = e.charCategorizer(t)
                  , o = e.doc.lineAt(t)
                  , i = t - o.from;
                if (0 == o.length)
                    return eP.cursor(t);
                0 == i ? n = 1 : i == o.length && (n = -1);
                let a = i
                  , s = i;
                n < 0 ? a = IC(o.text, i, !1) : s = IC(o.text, i);
                let l = r(o.text.slice(a, s));
                for (; a > 0; ) {
                    let e = IC(o.text, a, !1);
                    if (r(o.text.slice(e, a)) != l)
                        break;
                    a = e
                }
                for (; s < o.length; ) {
                    let e = IC(o.text, s);
                    if (r(o.text.slice(s, e)) != l)
                        break;
                    s = e
                }
                return eP.range(a + o.from, s + o.from)
            }(e.state, t, n);
        {
            let n = wR.find(e.docView, t)
              , r = e.state.doc.lineAt(n ? n.posAtEnd : t)
              , o = n ? n.posAtStart : r.from
              , i = n ? n.posAtEnd : r.to;
            return i < e.state.doc.length && i == r.to && i++,
            eP.range(o, i)
        }
    }
    t$.scroll = e=>{
        e.inputState.lastScrollTop = e.scrollDOM.scrollTop,
        e.inputState.lastScrollLeft = e.scrollDOM.scrollLeft
    }
    ,
    e$.keydown = (e,t)=>(e.inputState.setSelectionOrigin("select"),
    27 == t.keyCode && 0 != e.inputState.tabFocusMode && (e.inputState.tabFocusMode = Date.now() + 2e3),
    !1),
    t$.touchstart = (e,t)=>{
        e.inputState.lastTouchTime = Date.now(),
        e.inputState.setSelectionOrigin("select.pointer")
    }
    ,
    t$.touchmove = e=>{
        e.inputState.setSelectionOrigin("select.pointer")
    }
    ,
    e$.mousedown = (e,t)=>{
        if (e.observer.flush(),
        e.inputState.lastTouchTime > Date.now() - 2e3)
            return !1;
        let n = null;
        for (let r of e.state.facet(tN))
            if (n = r(e, t),
            n)
                break;
        if (n || 0 != t.button || (n = function(e, t) {
            let n = l$(e, t)
              , r = h$(t)
              , o = e.state.selection;
            return {
                update(e) {
                    e.docChanged && (n.pos = e.changes.mapPos(n.pos),
                    o = o.map(e.changes))
                },
                get(t, i, a) {
                    let s, l = l$(e, t), c = o$(e, l.pos, l.bias, r);
                    if (n.pos != l.pos && !i) {
                        let t = o$(e, n.pos, n.bias, r)
                          , o = Math.min(t.from, c.from)
                          , i = Math.max(t.to, c.to);
                        c = o < c.from ? eP.range(o, i) : eP.range(i, o)
                    }
                    return i ? o.replaceRange(o.main.extend(c.from, c.to)) : a && 1 == r && o.ranges.length > 1 && (s = function(e, t) {
                        for (let n = 0; n < e.ranges.length; n++) {
                            let {from: r, to: o} = e.ranges[n];
                            if (r <= t && o >= t)
                                return eP.create(e.ranges.slice(0, n).concat(e.ranges.slice(n + 1)), e.mainIndex == n ? 0 : e.mainIndex - (e.mainIndex > n ? 1 : 0))
                        }
                        return null
                    }(o, l.pos)) ? s : a ? o.addRange(c) : eP.create([c])
                }
            }
        }(e, t)),
        n) {
            let r = !e.hasFocus;
            e.inputState.startMouseSelection(new JN(e,t,n,r)),
            r && e.observer.ignore((()=>{
                LD(e.contentDOM);
                let t = e.root.activeElement;
                t && !t.contains(e.contentDOM) && t.blur()
            }
            ));
            let o = e.inputState.mouseSelection;
            if (o)
                return o.start(t),
                !1 === o.dragging
        }
        return !1
    }
    ;
    let i$ = (e,t)=>e >= t.top && e <= t.bottom
      , a$ = (e,t,n)=>i$(t, n) && e >= n.left && e <= n.right;
    function s$(e, t, n, r) {
        let o = wR.find(e.docView, t);
        if (!o)
            return 1;
        let i = t - o.posAtStart;
        if (0 == i)
            return 1;
        if (i == o.length)
            return -1;
        let a = o.coordsAt(i, -1);
        if (a && a$(n, r, a))
            return -1;
        let s = o.coordsAt(i, 1);
        return s && a$(n, r, s) ? 1 : a && i$(r, a) ? -1 : 1
    }
    function l$(e, t) {
        let n = e.posAtCoords({
            x: t.clientX,
            y: t.clientY
        }, !1);
        return {
            pos: n,
            bias: s$(e, n, t.clientX, t.clientY)
        }
    }
    const c$ = lR.ie && lR.ie_version <= 11;
    let u$ = null
      , d$ = 0
      , p$ = 0;
    function h$(e) {
        if (!c$)
            return e.detail;
        let t = u$
          , n = p$;
        return u$ = e,
        p$ = Date.now(),
        d$ = !t || n > Date.now() - 400 && Math.abs(t.clientX - e.clientX) < 2 && Math.abs(t.clientY - e.clientY) < 2 ? (d$ + 1) % 3 : 1
    }
    function f$(e, t, n, r) {
        if (!n)
            return;
        let o = e.posAtCoords({
            x: t.clientX,
            y: t.clientY
        }, !1)
          , {draggedContent: i} = e.inputState
          , a = r && i && function(e, t) {
            let n = e.state.facet(eN);
            return n.length ? n[0](t) : lR.mac ? !t.altKey : !t.ctrlKey
        }(e, t) ? {
            from: i.from,
            to: i.to
        } : null
          , s = {
            from: o,
            insert: n
        }
          , l = e.state.changes(a ? [a, s] : s);
        e.focus(),
        e.dispatch({
            changes: l,
            selection: {
                anchor: l.mapPos(o, -1),
                head: l.mapPos(o, 1)
            },
            userEvent: a ? "move.drop" : "input.drop"
        }),
        e.inputState.draggedContent = null
    }
    e$.dragstart = (e,t)=>{
        let {selection: {main: n}} = e.state;
        if (t.target.draggable) {
            let r = e.docView.nearest(t.target);
            if (r && r.isWidget) {
                let e = r.posAtStart
                  , t = e + r.length;
                (e >= n.to || t <= n.from) && (n = eP.range(e, t))
            }
        }
        let {inputState: r} = e;
        return r.mouseSelection && (r.mouseSelection.dragging = !0),
        r.draggedContent = n,
        t.dataTransfer && (t.dataTransfer.setData("Text", e.state.sliceDoc(n.from, n.to)),
        t.dataTransfer.effectAllowed = "copyMove"),
        !1
    }
    ,
    e$.dragend = e=>(e.inputState.draggedContent = null,
    !1),
    e$.drop = (e,t)=>{
        if (!t.dataTransfer)
            return !1;
        if (e.state.readOnly)
            return !0;
        let n = t.dataTransfer.files;
        if (n && n.length) {
            let r = Array(n.length)
              , o = 0
              , i = ()=>{
                ++o == n.length && f$(e, t, r.filter((e=>null != e)).join(e.state.lineBreak), !1)
            }
            ;
            for (let e = 0; e < n.length; e++) {
                let t = new FileReader;
                t.onerror = i,
                t.onload = ()=>{
                    /[\x00-\x08\x0e-\x1f]{2}/.test(t.result) || (r[e] = t.result),
                    i()
                }
                ,
                t.readAsText(n[e])
            }
            return !0
        }
        {
            let n = t.dataTransfer.getData("Text");
            if (n)
                return f$(e, t, n, !0),
                !0
        }
        return !1
    }
    ,
    e$.paste = (e,t)=>{
        if (e.state.readOnly)
            return !0;
        e.observer.flush();
        let n = n$ ? null : t.clipboardData;
        return n ? (r$(e, n.getData("text/plain") || n.getData("text/uri-list")),
        !0) : (function(e) {
            let t = e.dom.parentNode;
            if (!t)
                return;
            let n = t.appendChild(document.createElement("textarea"));
            n.style.cssText = "position: fixed; left: -10000px; top: 10px",
            n.focus(),
            setTimeout((()=>{
                e.focus(),
                n.remove(),
                r$(e, n.value)
            }
            ), 50)
        }(e),
        !1)
    }
    ;
    let m$ = null;
    e$.copy = e$.cut = (e,t)=>{
        let {text: n, ranges: r, linewise: o} = function(e) {
            let t = []
              , n = []
              , r = !1;
            for (let o of e.selection.ranges)
                o.empty || (t.push(e.sliceDoc(o.from, o.to)),
                n.push(o));
            if (!t.length) {
                let o = -1;
                for (let {from: r} of e.selection.ranges) {
                    let i = e.doc.lineAt(r);
                    i.number > o && (t.push(i.text),
                    n.push({
                        from: i.from,
                        to: Math.min(e.doc.length, i.to + 1)
                    })),
                    o = i.number
                }
                r = !0
            }
            return {
                text: t.join(e.lineBreak),
                ranges: n,
                linewise: r
            }
        }(e.state);
        if (!n && !o)
            return !1;
        m$ = o ? n : null,
        "cut" != t.type || e.state.readOnly || e.dispatch({
            changes: r,
            scrollIntoView: !0,
            userEvent: "delete.cut"
        });
        let i = n$ ? null : t.clipboardData;
        return i ? (i.clearData(),
        i.setData("text/plain", n),
        !0) : (function(e, t) {
            let n = e.dom.parentNode;
            if (!n)
                return;
            let r = n.appendChild(document.createElement("textarea"));
            r.style.cssText = "position: fixed; left: -10000px; top: 10px",
            r.value = t,
            r.focus(),
            r.selectionEnd = t.length,
            r.selectionStart = 0,
            setTimeout((()=>{
                r.remove(),
                e.focus()
            }
            ), 50)
        }(e, n),
        !1)
    }
    ;
    const g$ = PP.define();
    function b$(e, t) {
        let n = [];
        for (let r of e.facet(iN)) {
            let o = r(e, t);
            o && n.push(o)
        }
        return n ? e.update({
            effects: n,
            annotations: g$.of(!0)
        }) : null
    }
    function O$(e) {
        setTimeout((()=>{
            let t = e.hasFocus;
            if (t != e.inputState.notifiedFocused) {
                let n = b$(e.state, t);
                n ? e.dispatch(n) : e.update([])
            }
        }
        ), 10)
    }
    t$.focus = e=>{
        e.inputState.lastFocusTime = Date.now(),
        e.scrollDOM.scrollTop || !e.inputState.lastScrollTop && !e.inputState.lastScrollLeft || (e.scrollDOM.scrollTop = e.inputState.lastScrollTop,
        e.scrollDOM.scrollLeft = e.inputState.lastScrollLeft),
        O$(e)
    }
    ,
    t$.blur = e=>{
        e.observer.clearSelectionRange(),
        O$(e)
    }
    ,
    t$.compositionstart = t$.compositionupdate = e=>{
        e.observer.editContext || (null == e.inputState.compositionFirstChange && (e.inputState.compositionFirstChange = !0),
        e.inputState.composing < 0 && (e.inputState.composing = 0))
    }
    ,
    t$.compositionend = e=>{
        e.observer.editContext || (e.inputState.composing = -1,
        e.inputState.compositionEndedAt = Date.now(),
        e.inputState.compositionPendingKey = !0,
        e.inputState.compositionPendingChange = e.observer.pendingRecords().length > 0,
        e.inputState.compositionFirstChange = null,
        lR.chrome && lR.android ? e.observer.flushSoon() : e.inputState.compositionPendingChange ? Promise.resolve().then((()=>e.observer.flush())) : setTimeout((()=>{
            e.inputState.composing < 0 && e.docView.hasComposition && e.update([])
        }
        ), 50))
    }
    ,
    t$.contextmenu = e=>{
        e.inputState.lastContextMenu = Date.now()
    }
    ,
    e$.beforeinput = (e,t)=>{
        var n;
        let r;
        if (lR.chrome && lR.android && (r = VN.find((e=>e.inputType == t.inputType))) && (e.observer.delayAndroidKey(r.key, r.keyCode),
        "Backspace" == r.key || "Delete" == r.key)) {
            let t = (null === (n = window.visualViewport) || void 0 === n ? void 0 : n.height) || 0;
            setTimeout((()=>{
                var n;
                ((null === (n = window.visualViewport) || void 0 === n ? void 0 : n.height) || 0) > t + 10 && e.hasFocus && (e.contentDOM.blur(),
                e.focus())
            }
            ), 100)
        }
        return lR.ios && "deleteContentForward" == t.inputType && e.observer.flushSoon(),
        lR.safari && "insertText" == t.inputType && e.inputState.composing >= 0 && setTimeout((()=>t$.compositionend(e, t)), 20),
        !1
    }
    ;
    const v$ = new Set;
    const y$ = ["pre-wrap", "normal", "pre-line", "break-spaces"];
    class w$ {
        constructor(e) {
            this.lineWrapping = e,
            this.doc = wC.empty,
            this.heightSamples = {},
            this.lineHeight = 14,
            this.charWidth = 7,
            this.textHeight = 14,
            this.lineLength = 30,
            this.heightChanged = !1
        }
        heightForGap(e, t) {
            let n = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
            return this.lineWrapping && (n += Math.max(0, Math.ceil((t - e - n * this.lineLength * .5) / this.lineLength))),
            this.lineHeight * n
        }
        heightForLine(e) {
            if (!this.lineWrapping)
                return this.lineHeight;
            return (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight
        }
        setDoc(e) {
            return this.doc = e,
            this
        }
        mustRefreshForWrapping(e) {
            return y$.indexOf(e) > -1 != this.lineWrapping
        }
        mustRefreshForHeights(e) {
            let t = !1;
            for (let n = 0; n < e.length; n++) {
                let r = e[n];
                r < 0 ? n++ : this.heightSamples[Math.floor(10 * r)] || (t = !0,
                this.heightSamples[Math.floor(10 * r)] = !0)
            }
            return t
        }
        refresh(e, t, n, r, o, i) {
            let a = y$.indexOf(e) > -1
              , s = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != a;
            if (this.lineWrapping = a,
            this.lineHeight = t,
            this.charWidth = n,
            this.textHeight = r,
            this.lineLength = o,
            s) {
                this.heightSamples = {};
                for (let e = 0; e < i.length; e++) {
                    let t = i[e];
                    t < 0 ? e++ : this.heightSamples[Math.floor(10 * t)] = !0
                }
            }
            return s
        }
    }
    class _$ {
        constructor(e, t) {
            this.from = e,
            this.heights = t,
            this.index = 0
        }
        get more() {
            return this.index < this.heights.length
        }
    }
    class k$ {
        constructor(e, t, n, r, o) {
            this.from = e,
            this.length = t,
            this.top = n,
            this.height = r,
            this._content = o
        }
        get type() {
            return "number" == typeof this._content ? SR.Text : Array.isArray(this._content) ? this._content : this._content.type
        }
        get to() {
            return this.from + this.length
        }
        get bottom() {
            return this.top + this.height
        }
        get widget() {
            return this._content instanceof AR ? this._content.widget : null
        }
        get widgetLineBreaks() {
            return "number" == typeof this._content ? this._content : 0
        }
        join(e) {
            let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
            return new k$(this.from,this.length + e.length,this.top,this.height + e.height,t)
        }
    }
    var S$ = function(e) {
        return e[e.ByPos = 0] = "ByPos",
        e[e.ByHeight = 1] = "ByHeight",
        e[e.ByPosNoHeight = 2] = "ByPosNoHeight",
        e
    }(S$ || (S$ = {}));
    const E$ = .001;
    class x$ {
        constructor(e, t, n=2) {
            this.length = e,
            this.height = t,
            this.flags = n
        }
        get outdated() {
            return (2 & this.flags) > 0
        }
        set outdated(e) {
            this.flags = (e ? 2 : 0) | -3 & this.flags
        }
        setHeight(e, t) {
            this.height != t && (Math.abs(this.height - t) > E$ && (e.heightChanged = !0),
            this.height = t)
        }
        replace(e, t, n) {
            return x$.of(n)
        }
        decomposeLeft(e, t) {
            t.push(this)
        }
        decomposeRight(e, t) {
            t.push(this)
        }
        applyChanges(e, t, n, r) {
            let o = this
              , i = n.doc;
            for (let a = r.length - 1; a >= 0; a--) {
                let {fromA: s, toA: l, fromB: c, toB: u} = r[a]
                  , d = o.lineAt(s, S$.ByPosNoHeight, n.setDoc(t), 0, 0)
                  , p = d.to >= l ? d : o.lineAt(l, S$.ByPosNoHeight, n, 0, 0);
                for (u += p.to - l,
                l = p.to; a > 0 && d.from <= r[a - 1].toA; )
                    s = r[a - 1].fromA,
                    c = r[a - 1].fromB,
                    a--,
                    s < d.from && (d = o.lineAt(s, S$.ByPosNoHeight, n, 0, 0));
                c += d.from - s,
                s = d.from;
                let h = R$.build(n.setDoc(i), e, c, u);
                o = o.replace(s, l, h)
            }
            return o.updateHeight(n, 0)
        }
        static empty() {
            return new A$(0,0)
        }
        static of(e) {
            if (1 == e.length)
                return e[0];
            let t = 0
              , n = e.length
              , r = 0
              , o = 0;
            for (; ; )
                if (t == n)
                    if (r > 2 * o) {
                        let o = e[t - 1];
                        o.break ? e.splice(--t, 1, o.left, null, o.right) : e.splice(--t, 1, o.left, o.right),
                        n += 1 + o.break,
                        r -= o.size
                    } else {
                        if (!(o > 2 * r))
                            break;
                        {
                            let t = e[n];
                            t.break ? e.splice(n, 1, t.left, null, t.right) : e.splice(n, 1, t.left, t.right),
                            n += 2 + t.break,
                            o -= t.size
                        }
                    }
                else if (r < o) {
                    let n = e[t++];
                    n && (r += n.size)
                } else {
                    let t = e[--n];
                    t && (o += t.size)
                }
            let i = 0;
            return null == e[t - 1] ? (i = 1,
            t--) : null == e[t] && (i = 1,
            n++),
            new P$(x$.of(e.slice(0, t)),i,x$.of(e.slice(n)))
        }
    }
    x$.prototype.size = 1;
    class T$ extends x$ {
        constructor(e, t, n) {
            super(e, t),
            this.deco = n
        }
        blockAt(e, t, n, r) {
            return new k$(r,this.length,n,this.height,this.deco || 0)
        }
        lineAt(e, t, n, r, o) {
            return this.blockAt(0, n, r, o)
        }
        forEachLine(e, t, n, r, o, i) {
            e <= o + this.length && t >= o && i(this.blockAt(0, n, r, o))
        }
        updateHeight(e, t=0, n=!1, r) {
            return r && r.from <= t && r.more && this.setHeight(e, r.heights[r.index++]),
            this.outdated = !1,
            this
        }
        toString() {
            return `block(${this.length})`
        }
    }
    class A$ extends T$ {
        constructor(e, t) {
            super(e, t, null),
            this.collapsed = 0,
            this.widgetHeight = 0,
            this.breaks = 0
        }
        blockAt(e, t, n, r) {
            return new k$(r,this.length,n,this.height,this.breaks)
        }
        replace(e, t, n) {
            let r = n[0];
            return 1 == n.length && (r instanceof A$ || r instanceof C$ && 4 & r.flags) && Math.abs(this.length - r.length) < 10 ? (r instanceof C$ ? r = new A$(r.length,this.height) : r.height = this.height,
            this.outdated || (r.outdated = !1),
            r) : x$.of(n)
        }
        updateHeight(e, t=0, n=!1, r) {
            return r && r.from <= t && r.more ? this.setHeight(e, r.heights[r.index++]) : (n || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight),
            this.outdated = !1,
            this
        }
        toString() {
            return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`
        }
    }
    class C$ extends x$ {
        constructor(e) {
            super(e, 0)
        }
        heightMetrics(e, t) {
            let n, r = e.doc.lineAt(t).number, o = e.doc.lineAt(t + this.length).number, i = o - r + 1, a = 0;
            if (e.lineWrapping) {
                let t = Math.min(this.height, e.lineHeight * i);
                n = t / i,
                this.length > i + 1 && (a = (this.height - t) / (this.length - i - 1))
            } else
                n = this.height / i;
            return {
                firstLine: r,
                lastLine: o,
                perLine: n,
                perChar: a
            }
        }
        blockAt(e, t, n, r) {
            let {firstLine: o, lastLine: i, perLine: a, perChar: s} = this.heightMetrics(t, r);
            if (t.lineWrapping) {
                let o = r + (e < t.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - n) / this.height)) * this.length))
                  , i = t.doc.lineAt(o)
                  , l = a + i.length * s
                  , c = Math.max(n, e - l / 2);
                return new k$(i.from,i.length,c,l,0)
            }
            {
                let r = Math.max(0, Math.min(i - o, Math.floor((e - n) / a)))
                  , {from: s, length: l} = t.doc.line(o + r);
                return new k$(s,l,n + a * r,a,0)
            }
        }
        lineAt(e, t, n, r, o) {
            if (t == S$.ByHeight)
                return this.blockAt(e, n, r, o);
            if (t == S$.ByPosNoHeight) {
                let {from: t, to: r} = n.doc.lineAt(e);
                return new k$(t,r - t,0,0,0)
            }
            let {firstLine: i, perLine: a, perChar: s} = this.heightMetrics(n, o)
              , l = n.doc.lineAt(e)
              , c = a + l.length * s
              , u = l.number - i
              , d = r + a * u + s * (l.from - o - u);
            return new k$(l.from,l.length,Math.max(r, Math.min(d, r + this.height - c)),c,0)
        }
        forEachLine(e, t, n, r, o, i) {
            e = Math.max(e, o),
            t = Math.min(t, o + this.length);
            let {firstLine: a, perLine: s, perChar: l} = this.heightMetrics(n, o);
            for (let c = e, u = r; c <= t; ) {
                let t = n.doc.lineAt(c);
                if (c == e) {
                    let n = t.number - a;
                    u += s * n + l * (e - o - n)
                }
                let r = s + l * t.length;
                i(new k$(t.from,t.length,u,r,0)),
                u += r,
                c = t.to + 1
            }
        }
        replace(e, t, n) {
            let r = this.length - t;
            if (r > 0) {
                let e = n[n.length - 1];
                e instanceof C$ ? n[n.length - 1] = new C$(e.length + r) : n.push(null, new C$(r - 1))
            }
            if (e > 0) {
                let t = n[0];
                t instanceof C$ ? n[0] = new C$(e + t.length) : n.unshift(new C$(e - 1), null)
            }
            return x$.of(n)
        }
        decomposeLeft(e, t) {
            t.push(new C$(e - 1), null)
        }
        decomposeRight(e, t) {
            t.push(null, new C$(this.length - e - 1))
        }
        updateHeight(e, t=0, n=!1, r) {
            let o = t + this.length;
            if (r && r.from <= t + this.length && r.more) {
                let n = []
                  , i = Math.max(t, r.from)
                  , a = -1;
                for (r.from > t && n.push(new C$(r.from - t - 1).updateHeight(e, t)); i <= o && r.more; ) {
                    let t = e.doc.lineAt(i).length;
                    n.length && n.push(null);
                    let o = r.heights[r.index++];
                    -1 == a ? a = o : Math.abs(o - a) >= E$ && (a = -2);
                    let s = new A$(t,o);
                    s.outdated = !1,
                    n.push(s),
                    i += t + 1
                }
                i <= o && n.push(null, new C$(o - i).updateHeight(e, i));
                let s = x$.of(n);
                return (a < 0 || Math.abs(s.height - this.height) >= E$ || Math.abs(a - this.heightMetrics(e, t).perLine) >= E$) && (e.heightChanged = !0),
                s
            }
            return (n || this.outdated) && (this.setHeight(e, e.heightForGap(t, t + this.length)),
            this.outdated = !1),
            this
        }
        toString() {
            return `gap(${this.length})`
        }
    }
    class P$ extends x$ {
        constructor(e, t, n) {
            super(e.length + t + n.length, e.height + n.height, t | (e.outdated || n.outdated ? 2 : 0)),
            this.left = e,
            this.right = n,
            this.size = e.size + n.size
        }
        get break() {
            return 1 & this.flags
        }
        blockAt(e, t, n, r) {
            let o = n + this.left.height;
            return e < o ? this.left.blockAt(e, t, n, r) : this.right.blockAt(e, t, o, r + this.left.length + this.break)
        }
        lineAt(e, t, n, r, o) {
            let i = r + this.left.height
              , a = o + this.left.length + this.break
              , s = t == S$.ByHeight ? e < i : e < a
              , l = s ? this.left.lineAt(e, t, n, r, o) : this.right.lineAt(e, t, n, i, a);
            if (this.break || (s ? l.to < a : l.from > a))
                return l;
            let c = t == S$.ByPosNoHeight ? S$.ByPosNoHeight : S$.ByPos;
            return s ? l.join(this.right.lineAt(a, c, n, i, a)) : this.left.lineAt(a, c, n, r, o).join(l)
        }
        forEachLine(e, t, n, r, o, i) {
            let a = r + this.left.height
              , s = o + this.left.length + this.break;
            if (this.break)
                e < s && this.left.forEachLine(e, t, n, r, o, i),
                t >= s && this.right.forEachLine(e, t, n, a, s, i);
            else {
                let l = this.lineAt(s, S$.ByPos, n, r, o);
                e < l.from && this.left.forEachLine(e, l.from - 1, n, r, o, i),
                l.to >= e && l.from <= t && i(l),
                t > l.to && this.right.forEachLine(l.to + 1, t, n, a, s, i)
            }
        }
        replace(e, t, n) {
            let r = this.left.length + this.break;
            if (t < r)
                return this.balanced(this.left.replace(e, t, n), this.right);
            if (e > this.left.length)
                return this.balanced(this.left, this.right.replace(e - r, t - r, n));
            let o = [];
            e > 0 && this.decomposeLeft(e, o);
            let i = o.length;
            for (let a of n)
                o.push(a);
            if (e > 0 && D$(o, i - 1),
            t < this.length) {
                let e = o.length;
                this.decomposeRight(t, o),
                D$(o, e)
            }
            return x$.of(o)
        }
        decomposeLeft(e, t) {
            let n = this.left.length;
            if (e <= n)
                return this.left.decomposeLeft(e, t);
            t.push(this.left),
            this.break && (n++,
            e >= n && t.push(null)),
            e > n && this.right.decomposeLeft(e - n, t)
        }
        decomposeRight(e, t) {
            let n = this.left.length
              , r = n + this.break;
            if (e >= r)
                return this.right.decomposeRight(e - r, t);
            e < n && this.left.decomposeRight(e, t),
            this.break && e < r && t.push(null),
            t.push(this.right)
        }
        balanced(e, t) {
            return e.size > 2 * t.size || t.size > 2 * e.size ? x$.of(this.break ? [e, null, t] : [e, t]) : (this.left = e,
            this.right = t,
            this.height = e.height + t.height,
            this.outdated = e.outdated || t.outdated,
            this.size = e.size + t.size,
            this.length = e.length + this.break + t.length,
            this)
        }
        updateHeight(e, t=0, n=!1, r) {
            let {left: o, right: i} = this
              , a = t + o.length + this.break
              , s = null;
            return r && r.from <= t + o.length && r.more ? s = o = o.updateHeight(e, t, n, r) : o.updateHeight(e, t, n),
            r && r.from <= a + i.length && r.more ? s = i = i.updateHeight(e, a, n, r) : i.updateHeight(e, a, n),
            s ? this.balanced(o, i) : (this.height = this.left.height + this.right.height,
            this.outdated = !1,
            this)
        }
        toString() {
            return this.left + (this.break ? " " : "-") + this.right
        }
    }
    function D$(e, t) {
        let n, r;
        null == e[t] && (n = e[t - 1])instanceof C$ && (r = e[t + 1])instanceof C$ && e.splice(t - 1, 3, new C$(n.length + 1 + r.length))
    }
    class R$ {
        constructor(e, t) {
            this.pos = e,
            this.oracle = t,
            this.nodes = [],
            this.lineStart = -1,
            this.lineEnd = -1,
            this.covering = null,
            this.writtenTo = e
        }
        get isCovered() {
            return this.covering && this.nodes[this.nodes.length - 1] == this.covering
        }
        span(e, t) {
            if (this.lineStart > -1) {
                let e = Math.min(t, this.lineEnd)
                  , n = this.nodes[this.nodes.length - 1];
                n instanceof A$ ? n.length += e - this.pos : (e > this.pos || !this.isCovered) && this.nodes.push(new A$(e - this.pos,-1)),
                this.writtenTo = e,
                t > e && (this.nodes.push(null),
                this.writtenTo++,
                this.lineStart = -1)
            }
            this.pos = t
        }
        point(e, t, n) {
            if (e < t || n.heightRelevant) {
                let r = n.widget ? n.widget.estimatedHeight : 0
                  , o = n.widget ? n.widget.lineBreaks : 0;
                r < 0 && (r = this.oracle.lineHeight);
                let i = t - e;
                n.block ? this.addBlock(new T$(i,r,n)) : (i || o || r >= 5) && this.addLineDeco(r, o, i)
            } else
                t > e && this.span(e, t);
            this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to)
        }
        enterLine() {
            if (this.lineStart > -1)
                return;
            let {from: e, to: t} = this.oracle.doc.lineAt(this.pos);
            this.lineStart = e,
            this.lineEnd = t,
            this.writtenTo < e && ((this.writtenTo < e - 1 || null == this.nodes[this.nodes.length - 1]) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)),
            this.nodes.push(null)),
            this.pos > e && this.nodes.push(new A$(this.pos - e,-1)),
            this.writtenTo = this.pos
        }
        blankContent(e, t) {
            let n = new C$(t - e);
            return this.oracle.doc.lineAt(e).to == t && (n.flags |= 4),
            n
        }
        ensureLine() {
            this.enterLine();
            let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
            if (e instanceof A$)
                return e;
            let t = new A$(0,-1);
            return this.nodes.push(t),
            t
        }
        addBlock(e) {
            this.enterLine();
            let t = e.deco;
            t && t.startSide > 0 && !this.isCovered && this.ensureLine(),
            this.nodes.push(e),
            this.writtenTo = this.pos = this.pos + e.length,
            t && t.endSide > 0 && (this.covering = e)
        }
        addLineDeco(e, t, n) {
            let r = this.ensureLine();
            r.length += n,
            r.collapsed += n,
            r.widgetHeight = Math.max(r.widgetHeight, e),
            r.breaks += t,
            this.writtenTo = this.pos = this.pos + n
        }
        finish(e) {
            let t = 0 == this.nodes.length ? null : this.nodes[this.nodes.length - 1];
            !(this.lineStart > -1) || t instanceof A$ || this.isCovered ? (this.writtenTo < this.pos || null == t) && this.nodes.push(this.blankContent(this.writtenTo, this.pos)) : this.nodes.push(new A$(0,-1));
            let n = e;
            for (let r of this.nodes)
                r instanceof A$ && r.updateHeight(this.oracle, n),
                n += r ? r.length : 1;
            return this.nodes
        }
        static build(e, t, n, r) {
            let o = new R$(n,e);
            return YP.spans(t, n, r, o, 0),
            o.finish(n)
        }
    }
    class N$ {
        constructor() {
            this.changes = []
        }
        compareRange() {}
        comparePoint(e, t, n, r) {
            (e < t || n && n.heightRelevant || r && r.heightRelevant) && PR(e, t, this.changes, 5)
        }
    }
    function $$(e, t) {
        let n = e.getBoundingClientRect()
          , r = e.ownerDocument
          , o = r.defaultView || window
          , i = Math.max(0, n.left)
          , a = Math.min(o.innerWidth, n.right)
          , s = Math.max(0, n.top)
          , l = Math.min(o.innerHeight, n.bottom);
        for (let c = e.parentNode; c && c != r.body; )
            if (1 == c.nodeType) {
                let t = c
                  , n = window.getComputedStyle(t);
                if ((t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth) && "visible" != n.overflow) {
                    let n = t.getBoundingClientRect();
                    i = Math.max(i, n.left),
                    a = Math.min(a, n.right),
                    s = Math.max(s, n.top),
                    l = c == e.parentNode ? n.bottom : Math.min(l, n.bottom)
                }
                c = "absolute" == n.position || "fixed" == n.position ? t.offsetParent : t.parentNode
            } else {
                if (11 != c.nodeType)
                    break;
                c = c.host
            }
        return {
            left: i - n.left,
            right: Math.max(i, a) - n.left,
            top: s - (n.top + t),
            bottom: Math.max(s, l) - (n.top + t)
        }
    }
    function I$(e, t) {
        let n = e.getBoundingClientRect();
        return {
            left: 0,
            right: n.right - n.left,
            top: t,
            bottom: n.bottom - (n.top + t)
        }
    }
    class M$ {
        constructor(e, t, n) {
            this.from = e,
            this.to = t,
            this.size = n
        }
        static same(e, t) {
            if (e.length != t.length)
                return !1;
            for (let n = 0; n < e.length; n++) {
                let r = e[n]
                  , o = t[n];
                if (r.from != o.from || r.to != o.to || r.size != o.size)
                    return !1
            }
            return !0
        }
        draw(e, t) {
            return ER.replace({
                widget: new L$(this.size * (t ? e.scaleY : e.scaleX),t)
            }).range(this.from, this.to)
        }
    }
    class L$ extends kR {
        constructor(e, t) {
            super(),
            this.size = e,
            this.vertical = t
        }
        eq(e) {
            return e.size == this.size && e.vertical == this.vertical
        }
        toDOM() {
            let e = document.createElement("div");
            return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px",
            e.style.height = "2px",
            e.style.display = "inline-block"),
            e
        }
        get estimatedHeight() {
            return this.vertical ? this.size : -1
        }
    }
    class Q$ {
        constructor(e) {
            this.state = e,
            this.pixelViewport = {
                left: 0,
                right: window.innerWidth,
                top: 0,
                bottom: 0
            },
            this.inView = !0,
            this.paddingTop = 0,
            this.paddingBottom = 0,
            this.contentDOMWidth = 0,
            this.contentDOMHeight = 0,
            this.editorHeight = 0,
            this.editorWidth = 0,
            this.scrollTop = 0,
            this.scrolledToBottom = !1,
            this.scaleX = 1,
            this.scaleY = 1,
            this.scrollAnchorPos = 0,
            this.scrollAnchorHeight = -1,
            this.scaler = j$,
            this.scrollTarget = null,
            this.printing = !1,
            this.mustMeasureContent = !0,
            this.defaultTextDirection = $R.LTR,
            this.visibleRanges = [],
            this.mustEnforceCursorAssoc = !1;
            let t = e.facet(vN).some((e=>"function" != typeof e && "cm-lineWrapping" == e.class));
            this.heightOracle = new w$(t),
            this.stateDeco = e.facet(yN).filter((e=>"function" != typeof e)),
            this.heightMap = x$.empty().applyChanges(this.stateDeco, wC.empty, this.heightOracle.setDoc(e.doc), [new AN(0,0,0,e.doc.length)]);
            for (let n = 0; n < 2 && (this.viewport = this.getViewport(0, null),
            this.updateForViewport()); n++)
                ;
            this.updateViewportLines(),
            this.lineGaps = this.ensureLineGaps([]),
            this.lineGapDeco = ER.set(this.lineGaps.map((e=>e.draw(this, !1)))),
            this.computeVisibleRanges()
        }
        updateForViewport() {
            let e = [this.viewport]
              , {main: t} = this.state.selection;
            for (let n = 0; n <= 1; n++) {
                let r = n ? t.head : t.anchor;
                if (!e.some((({from: e, to: t})=>r >= e && r <= t))) {
                    let {from: t, to: n} = this.lineBlockAt(r);
                    e.push(new B$(t,n))
                }
            }
            return this.viewports = e.sort(((e,t)=>e.from - t.from)),
            this.updateScaler()
        }
        updateScaler() {
            let e = this.scaler;
            return this.scaler = this.heightMap.height <= 7e6 ? j$ : new z$(this.heightOracle,this.heightMap,this.viewports),
            e.eq(this.scaler) ? 0 : 2
        }
        updateViewportLines() {
            this.viewportLines = [],
            this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e=>{
                this.viewportLines.push(q$(e, this.scaler))
            }
            ))
        }
        update(e, t=null) {
            this.state = e.state;
            let n = this.stateDeco;
            this.stateDeco = this.state.facet(yN).filter((e=>"function" != typeof e));
            let r = e.changedRanges
              , o = AN.extendWithRanges(r, function(e, t, n) {
                let r = new N$;
                return YP.compare(e, t, n, r, 0),
                r.changes
            }(n, this.stateDeco, e ? e.changes : ZC.empty(this.state.doc.length)))
              , i = this.heightMap.height
              , a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
            this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), o),
            this.heightMap.height != i && (e.flags |= 2),
            a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1),
            this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1,
            this.scrollAnchorHeight = this.heightMap.height);
            let s = o.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
            (t && (t.range.head < s.from || t.range.head > s.to) || !this.viewportIsAppropriate(s)) && (s = this.getViewport(0, t));
            let l = s.from != this.viewport.from || s.to != this.viewport.to;
            this.viewport = s,
            e.flags |= this.updateForViewport(),
            (l || !e.changes.empty || 2 & e.flags) && this.updateViewportLines(),
            (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))),
            e.flags |= this.computeVisibleRanges(),
            t && (this.scrollTarget = t),
            !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(sN) && (this.mustEnforceCursorAssoc = !0)
        }
        measure(e) {
            let t = e.contentDOM
              , n = window.getComputedStyle(t)
              , r = this.heightOracle
              , o = n.whiteSpace;
            this.defaultTextDirection = "rtl" == n.direction ? $R.RTL : $R.LTR;
            let i = this.heightOracle.mustRefreshForWrapping(o)
              , a = t.getBoundingClientRect()
              , s = i || this.mustMeasureContent || this.contentDOMHeight != a.height;
            this.contentDOMHeight = a.height,
            this.mustMeasureContent = !1;
            let l = 0
              , c = 0;
            if (a.width && a.height) {
                let {scaleX: e, scaleY: n} = ND(t, a);
                (e > .005 && Math.abs(this.scaleX - e) > .005 || n > .005 && Math.abs(this.scaleY - n) > .005) && (this.scaleX = e,
                this.scaleY = n,
                l |= 8,
                i = s = !0)
            }
            let u = (parseInt(n.paddingTop) || 0) * this.scaleY
              , d = (parseInt(n.paddingBottom) || 0) * this.scaleY;
            this.paddingTop == u && this.paddingBottom == d || (this.paddingTop = u,
            this.paddingBottom = d,
            l |= 10),
            this.editorWidth != e.scrollDOM.clientWidth && (r.lineWrapping && (s = !0),
            this.editorWidth = e.scrollDOM.clientWidth,
            l |= 8);
            let p = e.scrollDOM.scrollTop * this.scaleY;
            this.scrollTop != p && (this.scrollAnchorHeight = -1,
            this.scrollTop = p),
            this.scrolledToBottom = FD(e.scrollDOM);
            let h = (this.printing ? I$ : $$)(t, this.paddingTop)
              , f = h.top - this.pixelViewport.top
              , m = h.bottom - this.pixelViewport.bottom;
            this.pixelViewport = h;
            let g = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
            if (g != this.inView && (this.inView = g,
            g && (s = !0)),
            !this.inView && !this.scrollTarget)
                return 0;
            let b = a.width;
            if (this.contentDOMWidth == b && this.editorHeight == e.scrollDOM.clientHeight || (this.contentDOMWidth = a.width,
            this.editorHeight = e.scrollDOM.clientHeight,
            l |= 8),
            s) {
                let t = e.docView.measureVisibleLineHeights(this.viewport);
                if (r.mustRefreshForHeights(t) && (i = !0),
                i || r.lineWrapping && Math.abs(b - this.contentDOMWidth) > r.charWidth) {
                    let {lineHeight: n, charWidth: a, textHeight: s} = e.docView.measureTextSize();
                    i = n > 0 && r.refresh(o, n, a, s, b / a, t),
                    i && (e.docView.minWidth = 0,
                    l |= 8)
                }
                f > 0 && m > 0 ? c = Math.max(f, m) : f < 0 && m < 0 && (c = Math.min(f, m)),
                r.heightChanged = !1;
                for (let n of this.viewports) {
                    let o = n.from == this.viewport.from ? t : e.docView.measureVisibleLineHeights(n);
                    this.heightMap = (i ? x$.empty().applyChanges(this.stateDeco, wC.empty, this.heightOracle, [new AN(0,0,0,e.state.doc.length)]) : this.heightMap).updateHeight(r, 0, i, new _$(n.from,o))
                }
                r.heightChanged && (l |= 2)
            }
            let O = !this.viewportIsAppropriate(this.viewport, c) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
            return O && (2 & l && (l |= this.updateScaler()),
            this.viewport = this.getViewport(c, this.scrollTarget),
            l |= this.updateForViewport()),
            (2 & l || O) && this.updateViewportLines(),
            (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(i ? [] : this.lineGaps, e)),
            l |= this.computeVisibleRanges(),
            this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1,
            e.docView.enforceCursorAssoc()),
            l
        }
        get visibleTop() {
            return this.scaler.fromDOM(this.pixelViewport.top)
        }
        get visibleBottom() {
            return this.scaler.fromDOM(this.pixelViewport.bottom)
        }
        getViewport(e, t) {
            let n = .5 - Math.max(-.5, Math.min(.5, e / 1e3 / 2))
              , r = this.heightMap
              , o = this.heightOracle
              , {visibleTop: i, visibleBottom: a} = this
              , s = new B$(r.lineAt(i - 1e3 * n, S$.ByHeight, o, 0, 0).from,r.lineAt(a + 1e3 * (1 - n), S$.ByHeight, o, 0, 0).to);
            if (t) {
                let {head: e} = t.range;
                if (e < s.from || e > s.to) {
                    let n, i = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), a = r.lineAt(e, S$.ByPos, o, 0, 0);
                    n = "center" == t.y ? (a.top + a.bottom) / 2 - i / 2 : "start" == t.y || "nearest" == t.y && e < s.from ? a.top : a.bottom - i,
                    s = new B$(r.lineAt(n - 500, S$.ByHeight, o, 0, 0).from,r.lineAt(n + i + 500, S$.ByHeight, o, 0, 0).to)
                }
            }
            return s
        }
        mapViewport(e, t) {
            let n = t.mapPos(e.from, -1)
              , r = t.mapPos(e.to, 1);
            return new B$(this.heightMap.lineAt(n, S$.ByPos, this.heightOracle, 0, 0).from,this.heightMap.lineAt(r, S$.ByPos, this.heightOracle, 0, 0).to)
        }
        viewportIsAppropriate({from: e, to: t}, n=0) {
            if (!this.inView)
                return !0;
            let {top: r} = this.heightMap.lineAt(e, S$.ByPos, this.heightOracle, 0, 0)
              , {bottom: o} = this.heightMap.lineAt(t, S$.ByPos, this.heightOracle, 0, 0)
              , {visibleTop: i, visibleBottom: a} = this;
            return (0 == e || r <= i - Math.max(10, Math.min(-n, 250))) && (t == this.state.doc.length || o >= a + Math.max(10, Math.min(n, 250))) && r > i - 2e3 && o < a + 2e3
        }
        mapLineGaps(e, t) {
            if (!e.length || t.empty)
                return e;
            let n = [];
            for (let r of e)
                t.touchesRange(r.from, r.to) || n.push(new M$(t.mapPos(r.from),t.mapPos(r.to),r.size));
            return n
        }
        ensureLineGaps(e, t) {
            let n = this.heightOracle.lineWrapping
              , r = n ? 1e4 : 2e3
              , o = r >> 1
              , i = r << 1;
            if (this.defaultTextDirection != $R.LTR && !n)
                return [];
            let a = []
              , s = (r,i,l,c)=>{
                if (i - r < o)
                    return;
                let u = this.state.selection.main
                  , d = [u.from];
                u.empty || d.push(u.to);
                for (let e of d)
                    if (e > r && e < i)
                        return s(r, e - 10, l, c),
                        void s(e + 10, i, l, c);
                let p = function(e, t) {
                    for (let n of e)
                        if (t(n))
                            return n;
                    return
                }(e, (e=>e.from >= l.from && e.to <= l.to && Math.abs(e.from - r) < o && Math.abs(e.to - i) < o && !d.some((t=>e.from < t && e.to > t))));
                if (!p) {
                    if (i < l.to && t && n && t.visibleRanges.some((e=>e.from <= i && e.to >= i))) {
                        let e = t.moveToLineBoundary(eP.cursor(i), !1, !0).head;
                        e > r && (i = e)
                    }
                    p = new M$(r,i,this.gapSize(l, r, i, c))
                }
                a.push(p)
            }
              , l = e=>{
                if (e.length < i || e.type != SR.Text)
                    return;
                let t = function(e, t, n) {
                    let r = []
                      , o = e
                      , i = 0;
                    YP.spans(n, e, t, {
                        span() {},
                        point(e, t) {
                            e > o && (r.push({
                                from: o,
                                to: e
                            }),
                            i += e - o),
                            o = t
                        }
                    }, 20),
                    o < t && (r.push({
                        from: o,
                        to: t
                    }),
                    i += t - o);
                    return {
                        total: i,
                        ranges: r
                    }
                }(e.from, e.to, this.stateDeco);
                if (t.total < i)
                    return;
                let o, a, l = this.scrollTarget ? this.scrollTarget.range.head : null;
                if (n) {
                    let n, i, s = r / this.heightOracle.lineLength * this.heightOracle.lineHeight;
                    if (null != l) {
                        let r = F$(t, l)
                          , o = ((this.visibleBottom - this.visibleTop) / 2 + s) / e.height;
                        n = r - o,
                        i = r + o
                    } else
                        n = (this.visibleTop - e.top - s) / e.height,
                        i = (this.visibleBottom - e.top + s) / e.height;
                    o = U$(t, n),
                    a = U$(t, i)
                } else {
                    let e, n, i = t.total * this.heightOracle.charWidth, s = r * this.heightOracle.charWidth;
                    if (null != l) {
                        let r = F$(t, l)
                          , o = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + s) / i;
                        e = r - o,
                        n = r + o
                    } else
                        e = (this.pixelViewport.left - s) / i,
                        n = (this.pixelViewport.right + s) / i;
                    o = U$(t, e),
                    a = U$(t, n)
                }
                o > e.from && s(e.from, o, e, t),
                a < e.to && s(a, e.to, e, t)
            }
            ;
            for (let c of this.viewportLines)
                Array.isArray(c.type) ? c.type.forEach(l) : l(c);
            return a
        }
        gapSize(e, t, n, r) {
            let o = F$(r, n) - F$(r, t);
            return this.heightOracle.lineWrapping ? e.height * o : r.total * this.heightOracle.charWidth * o
        }
        updateLineGaps(e) {
            M$.same(e, this.lineGaps) || (this.lineGaps = e,
            this.lineGapDeco = ER.set(e.map((e=>e.draw(this, this.heightOracle.lineWrapping)))))
        }
        computeVisibleRanges() {
            let e = this.stateDeco;
            this.lineGaps.length && (e = e.concat(this.lineGapDeco));
            let t = [];
            YP.spans(e, this.viewport.from, this.viewport.to, {
                span(e, n) {
                    t.push({
                        from: e,
                        to: n
                    })
                },
                point() {}
            }, 20);
            let n = t.length != this.visibleRanges.length || this.visibleRanges.some(((e,n)=>e.from != t[n].from || e.to != t[n].to));
            return this.visibleRanges = t,
            n ? 4 : 0
        }
        lineBlockAt(e) {
            return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t=>t.from <= e && t.to >= e)) || q$(this.heightMap.lineAt(e, S$.ByPos, this.heightOracle, 0, 0), this.scaler)
        }
        lineBlockAtHeight(e) {
            return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((t=>t.top <= e && t.bottom >= e)) || q$(this.heightMap.lineAt(this.scaler.fromDOM(e), S$.ByHeight, this.heightOracle, 0, 0), this.scaler)
        }
        scrollAnchorAt(e) {
            let t = this.lineBlockAtHeight(e + 8);
            return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0]
        }
        elementAtHeight(e) {
            return q$(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler)
        }
        get docHeight() {
            return this.scaler.toDOM(this.heightMap.height)
        }
        get contentHeight() {
            return this.docHeight + this.paddingTop + this.paddingBottom
        }
    }
    class B$ {
        constructor(e, t) {
            this.from = e,
            this.to = t
        }
    }
    function U$({total: e, ranges: t}, n) {
        if (n <= 0)
            return t[0].from;
        if (n >= 1)
            return t[t.length - 1].to;
        let r = Math.floor(e * n);
        for (let o = 0; ; o++) {
            let {from: e, to: n} = t[o]
              , i = n - e;
            if (r <= i)
                return e + r;
            r -= i
        }
    }
    function F$(e, t) {
        let n = 0;
        for (let {from: r, to: o} of e.ranges) {
            if (t <= o) {
                n += t - r;
                break
            }
            n += o - r
        }
        return n / e.total
    }
    const j$ = {
        toDOM: e=>e,
        fromDOM: e=>e,
        scale: 1,
        eq(e) {
            return e == this
        }
    };
    class z$ {
        constructor(e, t, n) {
            let r = 0
              , o = 0
              , i = 0;
            this.viewports = n.map((({from: n, to: o})=>{
                let i = t.lineAt(n, S$.ByPos, e, 0, 0).top
                  , a = t.lineAt(o, S$.ByPos, e, 0, 0).bottom;
                return r += a - i,
                {
                    from: n,
                    to: o,
                    top: i,
                    bottom: a,
                    domTop: 0,
                    domBottom: 0
                }
            }
            )),
            this.scale = (7e6 - r) / (t.height - r);
            for (let a of this.viewports)
                a.domTop = i + (a.top - o) * this.scale,
                i = a.domBottom = a.domTop + (a.bottom - a.top),
                o = a.bottom
        }
        toDOM(e) {
            for (let t = 0, n = 0, r = 0; ; t++) {
                let o = t < this.viewports.length ? this.viewports[t] : null;
                if (!o || e < o.top)
                    return r + (e - n) * this.scale;
                if (e <= o.bottom)
                    return o.domTop + (e - o.top);
                n = o.bottom,
                r = o.domBottom
            }
        }
        fromDOM(e) {
            for (let t = 0, n = 0, r = 0; ; t++) {
                let o = t < this.viewports.length ? this.viewports[t] : null;
                if (!o || e < o.domTop)
                    return n + (e - r) / this.scale;
                if (e <= o.domBottom)
                    return o.top + (e - o.domTop);
                n = o.bottom,
                r = o.domBottom
            }
        }
        eq(e) {
            return e instanceof z$ && (this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every(((t,n)=>t.from == e.viewports[n].from && t.to == e.viewports[n].to)))
        }
    }
    function q$(e, t) {
        if (1 == t.scale)
            return e;
        let n = t.toDOM(e.top)
          , r = t.toDOM(e.bottom);
        return new k$(e.from,e.length,n,r - n,Array.isArray(e._content) ? e._content.map((e=>q$(e, t))) : e._content)
    }
    const H$ = rP.define({
        combine: e=>e.join(" ")
    })
      , Z$ = rP.define({
        combine: e=>e.indexOf(!0) > -1
    })
      , W$ = hD.newName()
      , X$ = hD.newName()
      , V$ = hD.newName()
      , G$ = {
        "&light": "." + X$,
        "&dark": "." + V$
    };
    function Y$(e, t, n) {
        return new hD(t,{
            finish: t=>/&/.test(t) ? t.replace(/&\w*/, (t=>{
                if ("&" == t)
                    return e;
                if (!n || !n[t])
                    throw new RangeError(`Unsupported selector: ${t}`);
                return n[t]
            }
            )) : e + " " + t
        })
    }
    const K$ = Y$("." + W$, {
        "&": {
            position: "relative !important",
            boxSizing: "border-box",
            "&.cm-focused": {
                outline: "1px dotted #212121"
            },
            display: "flex !important",
            flexDirection: "column"
        },
        ".cm-scroller": {
            display: "flex !important",
            alignItems: "flex-start !important",
            fontFamily: "monospace",
            lineHeight: 1.4,
            height: "100%",
            overflowX: "auto",
            position: "relative",
            zIndex: 0
        },
        ".cm-content": {
            margin: 0,
            flexGrow: 2,
            flexShrink: 0,
            display: "block",
            whiteSpace: "pre",
            wordWrap: "normal",
            boxSizing: "border-box",
            minHeight: "100%",
            padding: "4px 0",
            outline: "none",
            "&[contenteditable=true]": {
                WebkitUserModify: "read-write-plaintext-only"
            }
        },
        ".cm-lineWrapping": {
            whiteSpace_fallback: "pre-wrap",
            whiteSpace: "break-spaces",
            wordBreak: "break-word",
            overflowWrap: "anywhere",
            flexShrink: 1
        },
        "&light .cm-content": {
            caretColor: "black"
        },
        "&dark .cm-content": {
            caretColor: "white"
        },
        ".cm-line": {
            display: "block",
            padding: "0 2px 0 6px"
        },
        ".cm-layer": {
            position: "absolute",
            left: 0,
            top: 0,
            contain: "size style",
            "& > *": {
                position: "absolute"
            }
        },
        "&light .cm-selectionBackground": {
            background: "#d9d9d9"
        },
        "&dark .cm-selectionBackground": {
            background: "#222"
        },
        "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
            background: "#d7d4f0"
        },
        "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
            background: "#233"
        },
        ".cm-cursorLayer": {
            pointerEvents: "none"
        },
        "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
            animation: "steps(1) cm-blink 1.2s infinite"
        },
        "@keyframes cm-blink": {
            "0%": {},
            "50%": {
                opacity: 0
            },
            "100%": {}
        },
        "@keyframes cm-blink2": {
            "0%": {},
            "50%": {
                opacity: 0
            },
            "100%": {}
        },
        ".cm-cursor, .cm-dropCursor": {
            borderLeft: "1.2px solid black",
            marginLeft: "-0.6px",
            pointerEvents: "none"
        },
        ".cm-cursor": {
            display: "none"
        },
        "&dark .cm-cursor": {
            borderLeftColor: "#444"
        },
        ".cm-dropCursor": {
            position: "absolute"
        },
        "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
            display: "block"
        },
        ".cm-iso": {
            unicodeBidi: "isolate"
        },
        ".cm-announced": {
            position: "fixed",
            top: "-10000px"
        },
        "@media print": {
            ".cm-announced": {
                display: "none"
            }
        },
        "&light .cm-activeLine": {
            backgroundColor: "#cceeff44"
        },
        "&dark .cm-activeLine": {
            backgroundColor: "#99eeff33"
        },
        "&light .cm-specialChar": {
            color: "red"
        },
        "&dark .cm-specialChar": {
            color: "#f78"
        },
        ".cm-gutters": {
            flexShrink: 0,
            display: "flex",
            height: "100%",
            boxSizing: "border-box",
            insetInlineStart: 0,
            zIndex: 200
        },
        "&light .cm-gutters": {
            backgroundColor: "#f5f5f5",
            color: "#6c6c6c",
            borderRight: "1px solid #ddd"
        },
        "&dark .cm-gutters": {
            backgroundColor: "#333338",
            color: "#ccc"
        },
        ".cm-gutter": {
            display: "flex !important",
            flexDirection: "column",
            flexShrink: 0,
            boxSizing: "border-box",
            minHeight: "100%",
            overflow: "hidden"
        },
        ".cm-gutterElement": {
            boxSizing: "border-box"
        },
        ".cm-lineNumbers .cm-gutterElement": {
            padding: "0 3px 0 5px",
            minWidth: "20px",
            textAlign: "right",
            whiteSpace: "nowrap"
        },
        "&light .cm-activeLineGutter": {
            backgroundColor: "#e2f2ff"
        },
        "&dark .cm-activeLineGutter": {
            backgroundColor: "#222227"
        },
        ".cm-panels": {
            boxSizing: "border-box",
            position: "sticky",
            left: 0,
            right: 0
        },
        "&light .cm-panels": {
            backgroundColor: "#f5f5f5",
            color: "black"
        },
        "&light .cm-panels-top": {
            borderBottom: "1px solid #ddd"
        },
        "&light .cm-panels-bottom": {
            borderTop: "1px solid #ddd"
        },
        "&dark .cm-panels": {
            backgroundColor: "#333338",
            color: "white"
        },
        ".cm-tab": {
            display: "inline-block",
            overflow: "hidden",
            verticalAlign: "bottom"
        },
        ".cm-widgetBuffer": {
            verticalAlign: "text-top",
            height: "1em",
            width: 0,
            display: "inline"
        },
        ".cm-placeholder": {
            color: "#888",
            display: "inline-block",
            verticalAlign: "top"
        },
        ".cm-highlightSpace:before": {
            content: "attr(data-display)",
            position: "absolute",
            pointerEvents: "none",
            color: "#888"
        },
        ".cm-highlightTab": {
            backgroundImage: 'url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>\')',
            backgroundSize: "auto 100%",
            backgroundPosition: "right 90%",
            backgroundRepeat: "no-repeat"
        },
        ".cm-trailingSpace": {
            backgroundColor: "#ff332255"
        },
        ".cm-button": {
            verticalAlign: "middle",
            color: "inherit",
            fontSize: "70%",
            padding: ".2em 1em",
            borderRadius: "1px"
        },
        "&light .cm-button": {
            backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
            border: "1px solid #888",
            "&:active": {
                backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
            }
        },
        "&dark .cm-button": {
            backgroundImage: "linear-gradient(#393939, #111)",
            border: "1px solid #888",
            "&:active": {
                backgroundImage: "linear-gradient(#111, #333)"
            }
        },
        ".cm-textfield": {
            verticalAlign: "middle",
            color: "inherit",
            fontSize: "70%",
            border: "1px solid silver",
            padding: ".2em .5em"
        },
        "&light .cm-textfield": {
            backgroundColor: "white"
        },
        "&dark .cm-textfield": {
            border: "1px solid #555",
            backgroundColor: "inherit"
        }
    }, G$)
      , J$ = "￿";
    class eI {
        constructor(e, t) {
            this.points = e,
            this.text = "",
            this.lineSeparator = t.facet(HP.lineSeparator)
        }
        append(e) {
            this.text += e
        }
        lineBreak() {
            this.text += J$
        }
        readRange(e, t) {
            if (!e)
                return this;
            let n = e.parentNode;
            for (let r = e; ; ) {
                this.findPointBefore(n, r);
                let e = this.text.length;
                this.readNode(r);
                let o = r.nextSibling;
                if (o == t)
                    break;
                let i = ZD.get(r)
                  , a = ZD.get(o);
                (i && a ? i.breakAfter : (i ? i.breakAfter : AD(r)) || AD(o) && ("BR" != r.nodeName || r.cmIgnore) && this.text.length > e) && this.lineBreak(),
                r = o
            }
            return this.findPointBefore(n, t),
            this
        }
        readTextNode(e) {
            let t = e.nodeValue;
            for (let n of this.points)
                n.node == e && (n.pos = this.text.length + Math.min(n.offset, t.length));
            for (let n = 0, r = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
                let o, i = -1, a = 1;
                if (this.lineSeparator ? (i = t.indexOf(this.lineSeparator, n),
                a = this.lineSeparator.length) : (o = r.exec(t)) && (i = o.index,
                a = o[0].length),
                this.append(t.slice(n, i < 0 ? t.length : i)),
                i < 0)
                    break;
                if (this.lineBreak(),
                a > 1)
                    for (let t of this.points)
                        t.node == e && t.pos > this.text.length && (t.pos -= a - 1);
                n = i + a
            }
        }
        readNode(e) {
            if (e.cmIgnore)
                return;
            let t = ZD.get(e)
              , n = t && t.overrideDOMText;
            if (null != n) {
                this.findPointInside(e, n.length);
                for (let e = n.iter(); !e.next().done; )
                    e.lineBreak ? this.lineBreak() : this.append(e.value)
            } else
                3 == e.nodeType ? this.readTextNode(e) : "BR" == e.nodeName ? e.nextSibling && this.lineBreak() : 1 == e.nodeType && this.readRange(e.firstChild, null)
        }
        findPointBefore(e, t) {
            for (let n of this.points)
                n.node == e && e.childNodes[n.offset] == t && (n.pos = this.text.length)
        }
        findPointInside(e, t) {
            for (let n of this.points)
                (3 == e.nodeType ? n.node == e : e.contains(n.node)) && (n.pos = this.text.length + (tI(e, n.node, n.offset) ? t : 0))
        }
    }
    function tI(e, t, n) {
        for (; ; ) {
            if (!t || n < PD(t))
                return !1;
            if (t == e)
                return !0;
            n = TD(t) + 1,
            t = t.parentNode
        }
    }
    class nI {
        constructor(e, t) {
            this.node = e,
            this.offset = t,
            this.pos = -1
        }
    }
    class rI {
        constructor(e, t, n, r) {
            this.typeOver = r,
            this.bounds = null,
            this.text = "",
            this.domChanged = t > -1;
            let {impreciseHead: o, impreciseAnchor: i} = e.docView;
            if (e.state.readOnly && t > -1)
                this.newSel = null;
            else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, n, 0))) {
                let t = o || i ? [] : function(e) {
                    let t = [];
                    if (e.root.activeElement != e.contentDOM)
                        return t;
                    let {anchorNode: n, anchorOffset: r, focusNode: o, focusOffset: i} = e.observer.selectionRange;
                    n && (t.push(new nI(n,r)),
                    o == n && i == r || t.push(new nI(o,i)));
                    return t
                }(e)
                  , n = new eI(t,e.state);
                n.readRange(this.bounds.startDOM, this.bounds.endDOM),
                this.text = n.text,
                this.newSel = function(e, t) {
                    if (0 == e.length)
                        return null;
                    let n = e[0].pos
                      , r = 2 == e.length ? e[1].pos : n;
                    return n > -1 && r > -1 ? eP.single(n + t, r + t) : null
                }(t, this.bounds.from)
            } else {
                let t = e.observer.selectionRange
                  , n = o && o.node == t.focusNode && o.offset == t.focusOffset || !kD(e.contentDOM, t.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(t.focusNode, t.focusOffset)
                  , r = i && i.node == t.anchorNode && i.offset == t.anchorOffset || !kD(e.contentDOM, t.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(t.anchorNode, t.anchorOffset)
                  , a = e.viewport;
                if ((lR.ios || lR.chrome) && e.state.selection.main.empty && n != r && (a.from > 0 || a.to < e.state.doc.length)) {
                    let t = Math.min(n, r)
                      , o = Math.max(n, r)
                      , i = a.from - t
                      , s = a.to - o;
                    0 != i && 1 != i && 0 != t || 0 != s && -1 != s && o != e.state.doc.length || (n = 0,
                    r = e.state.doc.length)
                }
                this.newSel = eP.single(r, n)
            }
        }
    }
    function oI(e, t) {
        let n, {newSel: r} = t, o = e.state.selection.main, i = e.inputState.lastKeyTime > Date.now() - 100 ? e.inputState.lastKeyCode : -1;
        if (t.bounds) {
            let {from: r, to: a} = t.bounds
              , s = o.from
              , l = null;
            (8 === i || lR.android && t.text.length < a - r) && (s = o.to,
            l = "end");
            let c = function(e, t, n, r) {
                let o = Math.min(e.length, t.length)
                  , i = 0;
                for (; i < o && e.charCodeAt(i) == t.charCodeAt(i); )
                    i++;
                if (i == o && e.length == t.length)
                    return null;
                let a = e.length
                  , s = t.length;
                for (; a > 0 && s > 0 && e.charCodeAt(a - 1) == t.charCodeAt(s - 1); )
                    a--,
                    s--;
                if ("end" == r) {
                    n -= a + Math.max(0, i - Math.min(a, s)) - i
                }
                if (a < i && e.length < t.length) {
                    i -= n <= i && n >= a ? i - n : 0,
                    s = i + (s - a),
                    a = i
                } else if (s < i) {
                    i -= n <= i && n >= s ? i - n : 0,
                    a = i + (a - s),
                    s = i
                }
                return {
                    from: i,
                    toA: a,
                    toB: s
                }
            }(e.state.doc.sliceString(r, a, J$), t.text, s - r, l);
            c && (lR.chrome && 13 == i && c.toB == c.from + 2 && t.text.slice(c.from, c.toB) == J$ + J$ && c.toB--,
            n = {
                from: r + c.from,
                to: r + c.toA,
                insert: wC.of(t.text.slice(c.from, c.toB).split(J$))
            })
        } else
            r && (!e.hasFocus && e.state.facet(hN) || r.main.eq(o)) && (r = null);
        if (!n && !r)
            return !1;
        if (!n && t.typeOver && !o.empty && r && r.main.empty ? n = {
            from: o.from,
            to: o.to,
            insert: e.state.doc.slice(o.from, o.to)
        } : n && n.from >= o.from && n.to <= o.to && (n.from != o.from || n.to != o.to) && o.to - o.from - (n.to - n.from) <= 4 ? n = {
            from: o.from,
            to: o.to,
            insert: e.state.doc.slice(o.from, n.from).append(n.insert).append(e.state.doc.slice(n.to, o.to))
        } : (lR.mac || lR.android) && n && n.from == n.to && n.from == o.head - 1 && /^\. ?$/.test(n.insert.toString()) && "off" == e.contentDOM.getAttribute("autocorrect") ? (r && 2 == n.insert.length && (r = eP.single(r.main.anchor - 1, r.main.head - 1)),
        n = {
            from: o.from,
            to: o.to,
            insert: wC.of([" "])
        }) : lR.chrome && n && n.from == n.to && n.from == o.head && "\n " == n.insert.toString() && e.lineWrapping && (r && (r = eP.single(r.main.anchor - 1, r.main.head - 1)),
        n = {
            from: o.from,
            to: o.to,
            insert: wC.of([" "])
        }),
        n)
            return iI(e, n, r, i);
        if (r && !r.main.eq(o)) {
            let t = !1
              , n = "select";
            return e.inputState.lastSelectionTime > Date.now() - 50 && ("select" == e.inputState.lastSelectionOrigin && (t = !0),
            n = e.inputState.lastSelectionOrigin),
            e.dispatch({
                selection: r,
                scrollIntoView: t,
                userEvent: n
            }),
            !0
        }
        return !1
    }
    function iI(e, t, n, r=-1) {
        if (lR.ios && e.inputState.flushIOSKey(t))
            return !0;
        let o = e.state.selection.main;
        if (lR.android && (t.to == o.to && (t.from == o.from || t.from == o.from - 1 && " " == e.state.sliceDoc(t.from, o.from)) && 1 == t.insert.length && 2 == t.insert.lines && BD(e.contentDOM, "Enter", 13) || (t.from == o.from - 1 && t.to == o.to && 0 == t.insert.length || 8 == r && t.insert.length < t.to - t.from && t.to > o.head) && BD(e.contentDOM, "Backspace", 8) || t.from == o.from && t.to == o.to + 1 && 0 == t.insert.length && BD(e.contentDOM, "Delete", 46)))
            return !0;
        let i, a = t.insert.toString();
        e.inputState.composing >= 0 && e.inputState.composing++;
        let s = ()=>i || (i = function(e, t, n) {
            let r, o = e.state, i = o.selection.main;
            if (t.from >= i.from && t.to <= i.to && t.to - t.from >= (i.to - i.from) / 3 && (!n || n.main.empty && n.main.from == t.from + t.insert.length) && e.inputState.composing < 0) {
                let n = i.from < t.from ? o.sliceDoc(i.from, t.from) : ""
                  , a = i.to > t.to ? o.sliceDoc(t.to, i.to) : "";
                r = o.replaceSelection(e.state.toText(n + t.insert.sliceString(0, void 0, e.state.lineBreak) + a))
            } else {
                let a = o.changes(t)
                  , s = n && n.main.to <= a.newLength ? n.main : void 0;
                if (o.selection.ranges.length > 1 && e.inputState.composing >= 0 && t.to <= i.to && t.to >= i.to - 10) {
                    let l, c = e.state.sliceDoc(t.from, t.to), u = n && RN(e, n.main.head);
                    if (u) {
                        let e = t.insert.length - (t.to - t.from);
                        l = {
                            from: u.from,
                            to: u.to - e
                        }
                    } else
                        l = e.state.doc.lineAt(i.head);
                    let d = i.to - t.to
                      , p = i.to - i.from;
                    r = o.changeByRange((n=>{
                        if (n.from == i.from && n.to == i.to)
                            return {
                                changes: a,
                                range: s || n.map(a)
                            };
                        let r = n.to - d
                          , u = r - c.length;
                        if (n.to - n.from != p || e.state.sliceDoc(u, r) != c || n.to >= l.from && n.from <= l.to)
                            return {
                                range: n
                            };
                        let h = o.changes({
                            from: u,
                            to: r,
                            insert: t.insert
                        })
                          , f = n.to - i.to;
                        return {
                            changes: h,
                            range: s ? eP.range(Math.max(0, s.anchor + f), Math.max(0, s.head + f)) : n.map(h)
                        }
                    }
                    ))
                } else
                    r = {
                        changes: a,
                        selection: s && o.selection.replaceRange(s)
                    }
            }
            let a = "input.type";
            (e.composing || e.inputState.compositionPendingChange && e.inputState.compositionEndedAt > Date.now() - 50) && (e.inputState.compositionPendingChange = !1,
            a += ".compose",
            e.inputState.compositionFirstChange && (a += ".start",
            e.inputState.compositionFirstChange = !1));
            return o.update(r, {
                userEvent: a,
                scrollIntoView: !0
            })
        }(e, t, n));
        return e.state.facet(oN).some((n=>n(e, t.from, t.to, a, s))) || e.dispatch(s()),
        !0
    }
    const aI = {
        childList: !0,
        characterData: !0,
        subtree: !0,
        attributes: !0,
        characterDataOldValue: !0
    }
      , sI = lR.ie && lR.ie_version <= 11;
    class lI {
        constructor(e) {
            this.view = e,
            this.active = !1,
            this.editContext = null,
            this.selectionRange = new $D,
            this.selectionChanged = !1,
            this.delayedFlush = -1,
            this.resizeTimeout = -1,
            this.queue = [],
            this.delayedAndroidKey = null,
            this.flushingAndroidKey = -1,
            this.lastChange = 0,
            this.scrollTargets = [],
            this.intersection = null,
            this.resizeScroll = null,
            this.intersecting = !1,
            this.gapIntersection = null,
            this.gaps = [],
            this.printQuery = null,
            this.parentCheck = -1,
            this.dom = e.contentDOM,
            this.observer = new MutationObserver((t=>{
                for (let e of t)
                    this.queue.push(e);
                (lR.ie && lR.ie_version <= 11 || lR.ios && e.composing) && t.some((e=>"childList" == e.type && e.removedNodes.length || "characterData" == e.type && e.oldValue.length > e.target.nodeValue.length)) ? this.flushSoon() : this.flush()
            }
            )),
            window.EditContext && !0 === e.constructor.EDIT_CONTEXT && (this.editContext = new dI(e),
            e.state.facet(hN) && (e.contentDOM.editContext = this.editContext.editContext)),
            sI && (this.onCharData = e=>{
                this.queue.push({
                    target: e.target,
                    type: "characterData",
                    oldValue: e.prevValue
                }),
                this.flushSoon()
            }
            ),
            this.onSelectionChange = this.onSelectionChange.bind(this),
            this.onResize = this.onResize.bind(this),
            this.onPrint = this.onPrint.bind(this),
            this.onScroll = this.onScroll.bind(this),
            window.matchMedia && (this.printQuery = window.matchMedia("print")),
            "function" == typeof ResizeObserver && (this.resizeScroll = new ResizeObserver((()=>{
                var e;
                (null === (e = this.view.docView) || void 0 === e ? void 0 : e.lastUpdate) < Date.now() - 75 && this.onResize()
            }
            )),
            this.resizeScroll.observe(e.scrollDOM)),
            this.addWindowListeners(this.win = e.win),
            this.start(),
            "function" == typeof IntersectionObserver && (this.intersection = new IntersectionObserver((e=>{
                this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)),
                e.length > 0 && e[e.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting,
                this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")))
            }
            ),{
                threshold: [0, .001]
            }),
            this.intersection.observe(this.dom),
            this.gapIntersection = new IntersectionObserver((e=>{
                e.length > 0 && e[e.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"))
            }
            ),{})),
            this.listenForScroll(),
            this.readSelectionRange()
        }
        onScrollChanged(e) {
            this.view.inputState.runHandlers("scroll", e),
            this.intersecting && this.view.measure()
        }
        onScroll(e) {
            this.intersecting && this.flush(!1),
            this.editContext && this.view.requestMeasure(this.editContext.measureReq),
            this.onScrollChanged(e)
        }
        onResize() {
            this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout((()=>{
                this.resizeTimeout = -1,
                this.view.requestMeasure()
            }
            ), 50))
        }
        onPrint(e) {
            ("change" != e.type || e.matches) && (this.view.viewState.printing = !0,
            this.view.measure(),
            setTimeout((()=>{
                this.view.viewState.printing = !1,
                this.view.requestMeasure()
            }
            ), 500))
        }
        updateGaps(e) {
            if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some(((t,n)=>t != e[n])))) {
                this.gapIntersection.disconnect();
                for (let t of e)
                    this.gapIntersection.observe(t);
                this.gaps = e
            }
        }
        onSelectionChange(e) {
            let t = this.selectionChanged;
            if (!this.readSelectionRange() || this.delayedAndroidKey)
                return;
            let {view: n} = this
              , r = this.selectionRange;
            if (n.state.facet(hN) ? n.root.activeElement != this.dom : !SD(n.dom, r))
                return;
            let o = r.anchorNode && n.docView.nearest(r.anchorNode);
            o && o.ignoreEvent(e) ? t || (this.selectionChanged = !1) : (lR.ie && lR.ie_version <= 11 || lR.android && lR.chrome) && !n.state.selection.main.empty && r.focusNode && xD(r.focusNode, r.focusOffset, r.anchorNode, r.anchorOffset) ? this.flushSoon() : this.flush(!1)
        }
        readSelectionRange() {
            let {view: e} = this
              , t = _D(e.root);
            if (!t)
                return !1;
            let n = lR.safari && 11 == e.root.nodeType && function(e) {
                let t = e.activeElement;
                for (; t && t.shadowRoot; )
                    t = t.shadowRoot.activeElement;
                return t
            }(this.dom.ownerDocument) == this.dom && function(e, t) {
                if (t.getComposedRanges) {
                    let n = t.getComposedRanges(e.root)[0];
                    if (n)
                        return uI(e, n)
                }
                let n = null;
                function r(e) {
                    e.preventDefault(),
                    e.stopImmediatePropagation(),
                    n = e.getTargetRanges()[0]
                }
                return e.contentDOM.addEventListener("beforeinput", r, !0),
                e.dom.ownerDocument.execCommand("indent"),
                e.contentDOM.removeEventListener("beforeinput", r, !0),
                n ? uI(e, n) : null
            }(this.view, t) || t;
            if (!n || this.selectionRange.eq(n))
                return !1;
            let r = SD(this.dom, n);
            return r && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && function(e, t) {
                let n = t.focusNode
                  , r = t.focusOffset;
                if (!n || t.anchorNode != n || t.anchorOffset != r)
                    return !1;
                for (r = Math.min(r, PD(n)); ; )
                    if (r) {
                        if (1 != n.nodeType)
                            return !1;
                        let e = n.childNodes[r - 1];
                        "false" == e.contentEditable ? r-- : (n = e,
                        r = PD(n))
                    } else {
                        if (n == e)
                            return !0;
                        r = TD(n),
                        n = n.parentNode
                    }
            }(this.dom, n) ? (this.view.inputState.lastFocusTime = 0,
            e.docView.updateSelection(),
            !1) : (this.selectionRange.setRange(n),
            r && (this.selectionChanged = !0),
            !0)
        }
        setSelectionRange(e, t) {
            this.selectionRange.set(e.node, e.offset, t.node, t.offset),
            this.selectionChanged = !1
        }
        clearSelectionRange() {
            this.selectionRange.set(null, 0, null, 0)
        }
        listenForScroll() {
            this.parentCheck = -1;
            let e = 0
              , t = null;
            for (let n = this.dom; n; )
                if (1 == n.nodeType)
                    !t && e < this.scrollTargets.length && this.scrollTargets[e] == n ? e++ : t || (t = this.scrollTargets.slice(0, e)),
                    t && t.push(n),
                    n = n.assignedSlot || n.parentNode;
                else {
                    if (11 != n.nodeType)
                        break;
                    n = n.host
                }
            if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)),
            t) {
                for (let e of this.scrollTargets)
                    e.removeEventListener("scroll", this.onScroll);
                for (let e of this.scrollTargets = t)
                    e.addEventListener("scroll", this.onScroll)
            }
        }
        ignore(e) {
            if (!this.active)
                return e();
            try {
                return this.stop(),
                e()
            } finally {
                this.start(),
                this.clear()
            }
        }
        start() {
            this.active || (this.observer.observe(this.dom, aI),
            sI && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData),
            this.active = !0)
        }
        stop() {
            this.active && (this.active = !1,
            this.observer.disconnect(),
            sI && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData))
        }
        clear() {
            this.processRecords(),
            this.queue.length = 0,
            this.selectionChanged = !1
        }
        delayAndroidKey(e, t) {
            var n;
            if (!this.delayedAndroidKey) {
                let e = ()=>{
                    let e = this.delayedAndroidKey;
                    if (e) {
                        this.clearDelayedAndroidKey(),
                        this.view.inputState.lastKeyCode = e.keyCode,
                        this.view.inputState.lastKeyTime = Date.now(),
                        !this.flush() && e.force && BD(this.dom, e.key, e.keyCode)
                    }
                }
                ;
                this.flushingAndroidKey = this.view.win.requestAnimationFrame(e)
            }
            this.delayedAndroidKey && "Enter" != e || (this.delayedAndroidKey = {
                key: e,
                keyCode: t,
                force: this.lastChange < Date.now() - 50 || !!(null === (n = this.delayedAndroidKey) || void 0 === n ? void 0 : n.force)
            })
        }
        clearDelayedAndroidKey() {
            this.win.cancelAnimationFrame(this.flushingAndroidKey),
            this.delayedAndroidKey = null,
            this.flushingAndroidKey = -1
        }
        flushSoon() {
            this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame((()=>{
                this.delayedFlush = -1,
                this.flush()
            }
            )))
        }
        forceFlush() {
            this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush),
            this.delayedFlush = -1),
            this.flush()
        }
        pendingRecords() {
            for (let e of this.observer.takeRecords())
                this.queue.push(e);
            return this.queue
        }
        processRecords() {
            let e = this.pendingRecords();
            e.length && (this.queue = []);
            let t = -1
              , n = -1
              , r = !1;
            for (let o of e) {
                let e = this.readMutation(o);
                e && (e.typeOver && (r = !0),
                -1 == t ? ({from: t, to: n} = e) : (t = Math.min(e.from, t),
                n = Math.max(e.to, n)))
            }
            return {
                from: t,
                to: n,
                typeOver: r
            }
        }
        readChange() {
            let {from: e, to: t, typeOver: n} = this.processRecords()
              , r = this.selectionChanged && SD(this.dom, this.selectionRange);
            if (e < 0 && !r)
                return null;
            e > -1 && (this.lastChange = Date.now()),
            this.view.inputState.lastFocusTime = 0,
            this.selectionChanged = !1;
            let o = new rI(this.view,e,t,n);
            return this.view.docView.domChanged = {
                newSel: o.newSel ? o.newSel.main : null
            },
            o
        }
        flush(e=!0) {
            if (this.delayedFlush >= 0 || this.delayedAndroidKey)
                return !1;
            e && this.readSelectionRange();
            let t = this.readChange();
            if (!t)
                return this.view.requestMeasure(),
                !1;
            let n = this.view.state
              , r = oI(this.view, t);
            return this.view.state == n && (t.domChanged || t.newSel && !t.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]),
            r
        }
        readMutation(e) {
            let t = this.view.docView.nearest(e.target);
            if (!t || t.ignoreMutation(e))
                return null;
            if (t.markDirty("attributes" == e.type),
            "attributes" == e.type && (t.flags |= 4),
            "childList" == e.type) {
                let n = cI(t, e.previousSibling || e.target.previousSibling, -1)
                  , r = cI(t, e.nextSibling || e.target.nextSibling, 1);
                return {
                    from: n ? t.posAfter(n) : t.posAtStart,
                    to: r ? t.posBefore(r) : t.posAtEnd,
                    typeOver: !1
                }
            }
            return "characterData" == e.type ? {
                from: t.posAtStart,
                to: t.posAtEnd,
                typeOver: e.target.nodeValue == e.oldValue
            } : null
        }
        setWindow(e) {
            e != this.win && (this.removeWindowListeners(this.win),
            this.win = e,
            this.addWindowListeners(this.win))
        }
        addWindowListeners(e) {
            e.addEventListener("resize", this.onResize),
            this.printQuery ? this.printQuery.addEventListener("change", this.onPrint) : e.addEventListener("beforeprint", this.onPrint),
            e.addEventListener("scroll", this.onScroll),
            e.document.addEventListener("selectionchange", this.onSelectionChange)
        }
        removeWindowListeners(e) {
            e.removeEventListener("scroll", this.onScroll),
            e.removeEventListener("resize", this.onResize),
            this.printQuery ? this.printQuery.removeEventListener("change", this.onPrint) : e.removeEventListener("beforeprint", this.onPrint),
            e.document.removeEventListener("selectionchange", this.onSelectionChange)
        }
        update(e) {
            this.editContext && (this.editContext.update(e),
            e.startState.facet(hN) != e.state.facet(hN) && (e.view.contentDOM.editContext = e.state.facet(hN) ? this.editContext.editContext : null))
        }
        destroy() {
            var e, t, n;
            this.stop(),
            null === (e = this.intersection) || void 0 === e || e.disconnect(),
            null === (t = this.gapIntersection) || void 0 === t || t.disconnect(),
            null === (n = this.resizeScroll) || void 0 === n || n.disconnect();
            for (let r of this.scrollTargets)
                r.removeEventListener("scroll", this.onScroll);
            this.removeWindowListeners(this.win),
            clearTimeout(this.parentCheck),
            clearTimeout(this.resizeTimeout),
            this.win.cancelAnimationFrame(this.delayedFlush),
            this.win.cancelAnimationFrame(this.flushingAndroidKey)
        }
    }
    function cI(e, t, n) {
        for (; t; ) {
            let r = ZD.get(t);
            if (r && r.parent == e)
                return r;
            let o = t.parentNode;
            t = o != e.dom ? o : n > 0 ? t.nextSibling : t.previousSibling
        }
        return null
    }
    function uI(e, t) {
        let n = t.startContainer
          , r = t.startOffset
          , o = t.endContainer
          , i = t.endOffset
          , a = e.docView.domAtPos(e.state.selection.main.anchor);
        return xD(a.node, a.offset, o, i) && ([n,r,o,i] = [o, i, n, r]),
        {
            anchorNode: n,
            anchorOffset: r,
            focusNode: o,
            focusOffset: i
        }
    }
    class dI {
        constructor(e) {
            this.from = 0,
            this.to = 0,
            this.pendingContextChange = null,
            this.resetRange(e.state);
            let t = this.editContext = new window.EditContext({
                text: e.state.doc.sliceString(this.from, this.to),
                selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
                selectionEnd: this.toContextPos(e.state.selection.main.head)
            });
            t.addEventListener("textupdate", (t=>{
                let {anchor: n} = e.state.selection.main
                  , r = {
                    from: this.toEditorPos(t.updateRangeStart),
                    to: this.toEditorPos(t.updateRangeEnd),
                    insert: wC.of(t.text.split("\n"))
                };
                r.from == this.from && n < this.from ? r.from = n : r.to == this.to && n > this.to && (r.to = n),
                (r.from != r.to || r.insert.length) && (this.pendingContextChange = r,
                iI(e, r, eP.single(this.toEditorPos(t.selectionStart), this.toEditorPos(t.selectionEnd))),
                this.pendingContextChange && this.revertPending(e.state))
            }
            )),
            t.addEventListener("characterboundsupdate", (n=>{
                let r = []
                  , o = null;
                for (let t = this.toEditorPos(n.rangeStart), i = this.toEditorPos(n.rangeEnd); t < i; t++) {
                    let n = e.coordsForChar(t);
                    o = n && new DOMRect(n.left,n.right,n.right - n.left,n.bottom - n.top) || o || new DOMRect,
                    r.push(o)
                }
                t.updateCharacterBounds(n.rangeStart, r)
            }
            )),
            t.addEventListener("textformatupdate", (t=>{
                let n = [];
                for (let e of t.getTextFormats()) {
                    let t = e.underlineStyle
                      , r = e.underlineThickness;
                    if ("None" != t && "None" != r) {
                        let o = `text-decoration: underline ${"Dashed" == t ? "dashed " : "Squiggle" == t ? "wavy " : ""}${"Thin" == r ? 1 : 2}px`;
                        n.push(ER.mark({
                            attributes: {
                                style: o
                            }
                        }).range(this.toEditorPos(e.rangeStart), this.toEditorPos(e.rangeEnd)))
                    }
                }
                e.dispatch({
                    effects: dN.of(ER.set(n))
                })
            }
            )),
            t.addEventListener("compositionstart", (()=>{
                e.inputState.composing < 0 && (e.inputState.composing = 0,
                e.inputState.compositionFirstChange = !0)
            }
            )),
            t.addEventListener("compositionend", (()=>{
                e.inputState.composing = -1,
                e.inputState.compositionFirstChange = null
            }
            )),
            this.measureReq = {
                read: e=>{
                    this.editContext.updateControlBounds(e.contentDOM.getBoundingClientRect());
                    let t = _D(e.root);
                    t && t.rangeCount && this.editContext.updateSelectionBounds(t.getRangeAt(0).getBoundingClientRect())
                }
            }
        }
        applyEdits(e) {
            let t = 0
              , n = !1
              , r = this.pendingContextChange;
            return e.changes.iterChanges(((o,i,a,s,l)=>{
                if (n)
                    return;
                let c = l.length - (i - o);
                if (r && i >= r.to) {
                    if (r.from == o && r.to == i && r.insert.eq(l))
                        return r = this.pendingContextChange = null,
                        void (t += c);
                    r = null,
                    this.revertPending(e.state)
                }
                if (o += t,
                (i += t) <= this.from)
                    this.from += c,
                    this.to += c;
                else if (o < this.to) {
                    if (o < this.from || i > this.to || this.to - this.from + l.length > 3e4)
                        return void (n = !0);
                    this.editContext.updateText(this.toContextPos(o), this.toContextPos(i), l.toString()),
                    this.to += c
                }
                t += c
            }
            )),
            r && !n && this.revertPending(e.state),
            !n
        }
        update(e) {
            this.applyEdits(e) && this.rangeIsValid(e.state) ? (e.docChanged || e.selectionSet) && this.setSelection(e.state) : (this.pendingContextChange = null,
            this.resetRange(e.state),
            this.editContext.updateText(0, this.editContext.text.length, e.state.doc.sliceString(this.from, this.to)),
            this.setSelection(e.state)),
            (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq)
        }
        resetRange(e) {
            let {head: t} = e.selection.main;
            this.from = Math.max(0, t - 1e4),
            this.to = Math.min(e.doc.length, t + 1e4)
        }
        revertPending(e) {
            let t = this.pendingContextChange;
            this.pendingContextChange = null,
            this.editContext.updateText(this.toContextPos(t.from), this.toContextPos(t.to + t.insert.length), e.doc.sliceString(t.from, t.to))
        }
        setSelection(e) {
            let {main: t} = e.selection
              , n = this.toContextPos(Math.max(this.from, Math.min(this.to, t.anchor)))
              , r = this.toContextPos(t.head);
            this.editContext.selectionStart == n && this.editContext.selectionEnd == r || this.editContext.updateSelection(n, r)
        }
        rangeIsValid(e) {
            let {head: t} = e.selection.main;
            return !(this.from > 0 && t - this.from < 500 || this.to < e.doc.length && this.to - t < 500 || this.to - this.from > 3e4)
        }
        toEditorPos(e) {
            return e + this.from
        }
        toContextPos(e) {
            return e - this.from
        }
    }
    class pI {
        get state() {
            return this.viewState.state
        }
        get viewport() {
            return this.viewState.viewport
        }
        get visibleRanges() {
            return this.viewState.visibleRanges
        }
        get inView() {
            return this.viewState.inView
        }
        get composing() {
            return this.inputState.composing > 0
        }
        get compositionStarted() {
            return this.inputState.composing >= 0
        }
        get root() {
            return this._root
        }
        get win() {
            return this.dom.ownerDocument.defaultView || window
        }
        constructor(e={}) {
            this.plugins = [],
            this.pluginMap = new Map,
            this.editorAttrs = {},
            this.contentAttrs = {},
            this.bidiCache = [],
            this.destroyed = !1,
            this.updateState = 2,
            this.measureScheduled = -1,
            this.measureRequests = [],
            this.contentDOM = document.createElement("div"),
            this.scrollDOM = document.createElement("div"),
            this.scrollDOM.tabIndex = -1,
            this.scrollDOM.className = "cm-scroller",
            this.scrollDOM.appendChild(this.contentDOM),
            this.announceDOM = document.createElement("div"),
            this.announceDOM.className = "cm-announced",
            this.announceDOM.setAttribute("aria-live", "polite"),
            this.dom = document.createElement("div"),
            this.dom.appendChild(this.announceDOM),
            this.dom.appendChild(this.scrollDOM),
            e.parent && e.parent.appendChild(this.dom);
            let {dispatch: t} = e;
            this.dispatchTransactions = e.dispatchTransactions || t && (e=>e.forEach((e=>t(e, this)))) || (e=>this.update(e)),
            this.dispatch = this.dispatch.bind(this),
            this._root = e.root || function(e) {
                for (; e; ) {
                    if (e && (9 == e.nodeType || 11 == e.nodeType && e.host))
                        return e;
                    e = e.assignedSlot || e.parentNode
                }
                return null
            }(e.parent) || document,
            this.viewState = new Q$(e.state || HP.create(e)),
            e.scrollTo && e.scrollTo.is(uN) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)),
            this.plugins = this.state.facet(mN).map((e=>new bN(e)));
            for (let n of this.plugins)
                n.update(this);
            this.observer = new lI(this),
            this.inputState = new WN(this),
            this.inputState.ensureHandlers(this.plugins),
            this.docView = new PN(this),
            this.mountStyles(),
            this.updateAttrs(),
            this.updateState = 0,
            this.requestMeasure()
        }
        dispatch(...e) {
            let t = 1 == e.length && e[0]instanceof $P ? e : 1 == e.length && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
            this.dispatchTransactions(t, this)
        }
        update(e) {
            if (0 != this.updateState)
                throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
            let t, n = !1, r = !1, o = this.state;
            for (let d of e) {
                if (d.startState != o)
                    throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
                o = d.state
            }
            if (this.destroyed)
                return void (this.viewState.state = o);
            let i = this.hasFocus
              , a = 0
              , s = null;
            e.some((e=>e.annotation(g$))) ? (this.inputState.notifiedFocused = i,
            a = 1) : i != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = i,
            s = b$(o, i),
            s || (a = 1));
            let l = this.observer.delayedAndroidKey
              , c = null;
            if (l ? (this.observer.clearDelayedAndroidKey(),
            c = this.observer.readChange(),
            (c && !this.state.doc.eq(o.doc) || !this.state.selection.eq(o.selection)) && (c = null)) : this.observer.clear(),
            o.facet(HP.phrases) != this.state.facet(HP.phrases))
                return this.setState(o);
            t = CN.create(this, o, e),
            t.flags |= a;
            let u = this.viewState.scrollTarget;
            try {
                this.updateState = 2;
                for (let t of e) {
                    if (u && (u = u.map(t.changes)),
                    t.scrollIntoView) {
                        let {main: e} = t.state.selection;
                        u = new cN(e.empty ? e : eP.cursor(e.head, e.head > e.anchor ? -1 : 1))
                    }
                    for (let e of t.effects)
                        e.is(uN) && (u = e.value.clip(this.state))
                }
                this.viewState.update(t, u),
                this.bidiCache = mI.update(this.bidiCache, t.changes),
                t.empty || (this.updatePlugins(t),
                this.inputState.update(t)),
                n = this.docView.update(t),
                this.state.facet(TN) != this.styleModules && this.mountStyles(),
                r = this.updateAttrs(),
                this.showAnnouncements(e),
                this.docView.updateSelection(n, e.some((e=>e.isUserEvent("select.pointer"))))
            } finally {
                this.updateState = 0
            }
            if (t.startState.facet(H$) != t.state.facet(H$) && (this.viewState.mustMeasureContent = !0),
            (n || r || u || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(),
            n && this.docViewUpdate(),
            !t.empty)
                for (let d of this.state.facet(rN))
                    try {
                        d(t)
                    } catch (Aa) {
                        pN(this.state, Aa, "update listener")
                    }
            (s || c) && Promise.resolve().then((()=>{
                s && this.state == s.startState && this.dispatch(s),
                c && !oI(this, c) && l.force && BD(this.contentDOM, l.key, l.keyCode)
            }
            ))
        }
        setState(e) {
            if (0 != this.updateState)
                throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
            if (this.destroyed)
                return void (this.viewState.state = e);
            this.updateState = 2;
            let t = this.hasFocus;
            try {
                for (let e of this.plugins)
                    e.destroy(this);
                this.viewState = new Q$(e),
                this.plugins = e.facet(mN).map((e=>new bN(e))),
                this.pluginMap.clear();
                for (let e of this.plugins)
                    e.update(this);
                this.docView.destroy(),
                this.docView = new PN(this),
                this.inputState.ensureHandlers(this.plugins),
                this.mountStyles(),
                this.updateAttrs(),
                this.bidiCache = []
            } finally {
                this.updateState = 0
            }
            t && this.focus(),
            this.requestMeasure()
        }
        updatePlugins(e) {
            let t = e.startState.facet(mN)
              , n = e.state.facet(mN);
            if (t != n) {
                let r = [];
                for (let o of n) {
                    let n = t.indexOf(o);
                    if (n < 0)
                        r.push(new bN(o));
                    else {
                        let t = this.plugins[n];
                        t.mustUpdate = e,
                        r.push(t)
                    }
                }
                for (let t of this.plugins)
                    t.mustUpdate != e && t.destroy(this);
                this.plugins = r,
                this.pluginMap.clear()
            } else
                for (let r of this.plugins)
                    r.mustUpdate = e;
            for (let r = 0; r < this.plugins.length; r++)
                this.plugins[r].update(this);
            t != n && this.inputState.ensureHandlers(this.plugins)
        }
        docViewUpdate() {
            for (let e of this.plugins) {
                let t = e.value;
                if (t && t.docViewUpdate)
                    try {
                        t.docViewUpdate(this)
                    } catch (Aa) {
                        pN(this.state, Aa, "doc view update listener")
                    }
            }
        }
        measure(e=!0) {
            if (this.destroyed)
                return;
            if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled),
            this.observer.delayedAndroidKey)
                return this.measureScheduled = -1,
                void this.requestMeasure();
            this.measureScheduled = 0,
            e && this.observer.forceFlush();
            let t = null
              , n = this.scrollDOM
              , r = n.scrollTop * this.scaleY
              , {scrollAnchorPos: o, scrollAnchorHeight: i} = this.viewState;
            Math.abs(r - this.viewState.scrollTop) > 1 && (i = -1),
            this.viewState.scrollAnchorHeight = -1;
            try {
                for (let e = 0; ; e++) {
                    if (i < 0)
                        if (FD(n))
                            o = -1,
                            i = this.viewState.heightMap.height;
                        else {
                            let e = this.viewState.scrollAnchorAt(r);
                            o = e.from,
                            i = e.top
                        }
                    this.updateState = 1;
                    let a = this.viewState.measure(this);
                    if (!a && !this.measureRequests.length && null == this.viewState.scrollTarget)
                        break;
                    if (e > 5) {
                        console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
                        break
                    }
                    let s = [];
                    4 & a || ([this.measureRequests,s] = [s, this.measureRequests]);
                    let l = s.map((e=>{
                        try {
                            return e.read(this)
                        } catch (Aa) {
                            return pN(this.state, Aa),
                            fI
                        }
                    }
                    ))
                      , c = CN.create(this, this.state, [])
                      , u = !1;
                    c.flags |= a,
                    t ? t.flags |= a : t = c,
                    this.updateState = 2,
                    c.empty || (this.updatePlugins(c),
                    this.inputState.update(c),
                    this.updateAttrs(),
                    u = this.docView.update(c),
                    u && this.docViewUpdate());
                    for (let e = 0; e < s.length; e++)
                        if (l[e] != fI)
                            try {
                                let t = s[e];
                                t.write && t.write(l[e], this)
                            } catch (Aa) {
                                pN(this.state, Aa)
                            }
                    if (u && this.docView.updateSelection(!0),
                    !c.viewportChanged && 0 == this.measureRequests.length) {
                        if (this.viewState.editorHeight) {
                            if (this.viewState.scrollTarget) {
                                this.docView.scrollIntoView(this.viewState.scrollTarget),
                                this.viewState.scrollTarget = null,
                                i = -1;
                                continue
                            }
                            {
                                let e = (o < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(o).top) - i;
                                if (e > 1 || e < -1) {
                                    r += e,
                                    n.scrollTop = r / this.scaleY,
                                    i = -1;
                                    continue
                                }
                            }
                        }
                        break
                    }
                }
            } finally {
                this.updateState = 0,
                this.measureScheduled = -1
            }
            if (t && !t.empty)
                for (let a of this.state.facet(rN))
                    a(t)
        }
        get themeClasses() {
            return W$ + " " + (this.state.facet(Z$) ? V$ : X$) + " " + this.state.facet(H$)
        }
        updateAttrs() {
            let e = gI(this, ON, {
                class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
            })
              , t = {
                spellcheck: "false",
                autocorrect: "off",
                autocapitalize: "off",
                translate: "no",
                contenteditable: this.state.facet(hN) ? "true" : "false",
                class: "cm-content",
                style: `${lR.tabSize}: ${this.state.tabSize}`,
                role: "textbox",
                "aria-multiline": "true"
            };
            this.state.readOnly && (t["aria-readonly"] = "true"),
            gI(this, vN, t);
            let n = this.observer.ignore((()=>{
                let n = vR(this.contentDOM, this.contentAttrs, t)
                  , r = vR(this.dom, this.editorAttrs, e);
                return n || r
            }
            ));
            return this.editorAttrs = e,
            this.contentAttrs = t,
            n
        }
        showAnnouncements(e) {
            let t = !0;
            for (let n of e)
                for (let e of n.effects)
                    if (e.is(pI.announce)) {
                        t && (this.announceDOM.textContent = ""),
                        t = !1,
                        this.announceDOM.appendChild(document.createElement("div")).textContent = e.value
                    }
        }
        mountStyles() {
            this.styleModules = this.state.facet(TN);
            let e = this.state.facet(pI.cspNonce);
            hD.mount(this.root, this.styleModules.concat(K$).reverse(), e ? {
                nonce: e
            } : void 0)
        }
        readMeasured() {
            if (2 == this.updateState)
                throw new Error("Reading the editor layout isn't allowed during an update");
            0 == this.updateState && this.measureScheduled > -1 && this.measure(!1)
        }
        requestMeasure(e) {
            if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame((()=>this.measure()))),
            e) {
                if (this.measureRequests.indexOf(e) > -1)
                    return;
                if (null != e.key)
                    for (let t = 0; t < this.measureRequests.length; t++)
                        if (this.measureRequests[t].key === e.key)
                            return void (this.measureRequests[t] = e);
                this.measureRequests.push(e)
            }
        }
        plugin(e) {
            let t = this.pluginMap.get(e);
            return (void 0 === t || t && t.spec != e) && this.pluginMap.set(e, t = this.plugins.find((t=>t.spec == e)) || null),
            t && t.update(this).value
        }
        get documentTop() {
            return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop
        }
        get documentPadding() {
            return {
                top: this.viewState.paddingTop,
                bottom: this.viewState.paddingBottom
            }
        }
        get scaleX() {
            return this.viewState.scaleX
        }
        get scaleY() {
            return this.viewState.scaleY
        }
        elementAtHeight(e) {
            return this.readMeasured(),
            this.viewState.elementAtHeight(e)
        }
        lineBlockAtHeight(e) {
            return this.readMeasured(),
            this.viewState.lineBlockAtHeight(e)
        }
        get viewportLineBlocks() {
            return this.viewState.viewportLines
        }
        lineBlockAt(e) {
            return this.viewState.lineBlockAt(e)
        }
        get contentHeight() {
            return this.viewState.contentHeight
        }
        moveByChar(e, t, n) {
            return ZN(this, e, qN(this, e, t, n))
        }
        moveByGroup(e, t) {
            return ZN(this, e, qN(this, e, t, (t=>function(e, t, n) {
                let r = e.state.charCategorizer(t)
                  , o = r(n);
                return e=>{
                    let t = r(e);
                    return o == FP.Space && (o = t),
                    o == t
                }
            }(this, e.head, t))))
        }
        visualLineSide(e, t) {
            let n = this.bidiSpans(e)
              , r = this.textDirectionAt(e.from)
              , o = n[t ? n.length - 1 : 0];
            return eP.cursor(o.side(t, r) + e.from, o.forward(!t, r) ? 1 : -1)
        }
        moveToLineBoundary(e, t, n=!0) {
            return zN(this, e, t, n)
        }
        moveVertically(e, t, n) {
            return ZN(this, e, function(e, t, n, r) {
                let o = t.head
                  , i = n ? 1 : -1;
                if (o == (n ? e.state.doc.length : 0))
                    return eP.cursor(o, t.assoc);
                let a, s = t.goalColumn, l = e.contentDOM.getBoundingClientRect(), c = e.coordsAtPos(o, t.assoc || -1), u = e.documentTop;
                if (c)
                    null == s && (s = c.left - l.left),
                    a = i < 0 ? c.top : c.bottom;
                else {
                    let t = e.viewState.lineBlockAt(o);
                    null == s && (s = Math.min(l.right - l.left, e.defaultCharacterWidth * (o - t.from))),
                    a = (i < 0 ? t.top : t.bottom) + u
                }
                let d = l.left + s
                  , p = null != r ? r : e.viewState.heightOracle.textHeight >> 1;
                for (let h = 0; ; h += 10) {
                    let t = a + (p + h) * i
                      , n = FN(e, {
                        x: d,
                        y: t
                    }, !1, i);
                    if (t < l.top || t > l.bottom || (i < 0 ? n < o : n > o)) {
                        let r = e.docView.coordsForChar(n)
                          , o = !r || t < r.top ? -1 : 1;
                        return eP.cursor(n, o, void 0, s)
                    }
                }
            }(this, e, t, n))
        }
        domAtPos(e) {
            return this.docView.domAtPos(e)
        }
        posAtDOM(e, t=0) {
            return this.docView.posFromDOM(e, t)
        }
        posAtCoords(e, t=!0) {
            return this.readMeasured(),
            FN(this, e, t)
        }
        coordsAtPos(e, t=1) {
            this.readMeasured();
            let n = this.docView.coordsAt(e, t);
            if (!n || n.left == n.right)
                return n;
            let r = this.state.doc.lineAt(e)
              , o = this.bidiSpans(r);
            return DD(n, o[qR.find(o, e - r.from, -1, t)].dir == $R.LTR == t > 0)
        }
        coordsForChar(e) {
            return this.readMeasured(),
            this.docView.coordsForChar(e)
        }
        get defaultCharacterWidth() {
            return this.viewState.heightOracle.charWidth
        }
        get defaultLineHeight() {
            return this.viewState.heightOracle.lineHeight
        }
        get textDirection() {
            return this.viewState.defaultTextDirection
        }
        textDirectionAt(e) {
            return !this.state.facet(aN) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(),
            this.docView.textDirectionAt(e))
        }
        get lineWrapping() {
            return this.viewState.heightOracle.lineWrapping
        }
        bidiSpans(e) {
            if (e.length > hI)
                return VR(e.length);
            let t, n = this.textDirectionAt(e.from);
            for (let o of this.bidiCache)
                if (o.from == e.from && o.dir == n && (o.fresh || HR(o.isolates, t = SN(this, e))))
                    return o.order;
            t || (t = SN(this, e));
            let r = function(e, t, n) {
                if (!e)
                    return [new qR(0,0,t == MR ? 1 : 0)];
                if (t == IR && !n.length && !zR.test(e))
                    return VR(e.length);
                if (n.length)
                    for (; e.length > ZR.length; )
                        ZR[ZR.length] = 256;
                let r = []
                  , o = t == IR ? 0 : 1;
                return XR(e, o, o, n, 0, e.length, r),
                r
            }(e.text, n, t);
            return this.bidiCache.push(new mI(e.from,e.to,n,t,!0,r)),
            r
        }
        get hasFocus() {
            var e;
            return (this.dom.ownerDocument.hasFocus() || lR.safari && (null === (e = this.inputState) || void 0 === e ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM
        }
        focus() {
            this.observer.ignore((()=>{
                LD(this.contentDOM),
                this.docView.updateSelection()
            }
            ))
        }
        setRoot(e) {
            this._root != e && (this._root = e,
            this.observer.setWindow((9 == e.nodeType ? e : e.ownerDocument).defaultView || window),
            this.mountStyles())
        }
        destroy() {
            this.root.activeElement == this.contentDOM && this.contentDOM.blur();
            for (let e of this.plugins)
                e.destroy(this);
            this.plugins = [],
            this.inputState.destroy(),
            this.docView.destroy(),
            this.dom.remove(),
            this.observer.destroy(),
            this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled),
            this.destroyed = !0
        }
        static scrollIntoView(e, t={}) {
            return uN.of(new cN("number" == typeof e ? eP.cursor(e) : e,t.y,t.x,t.yMargin,t.xMargin))
        }
        scrollSnapshot() {
            let {scrollTop: e, scrollLeft: t} = this.scrollDOM
              , n = this.viewState.scrollAnchorAt(e);
            return uN.of(new cN(eP.cursor(n.from),"start","start",n.top - e,t,!0))
        }
        setTabFocusMode(e) {
            null == e ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : "boolean" == typeof e ? this.inputState.tabFocusMode = e ? 0 : -1 : 0 != this.inputState.tabFocusMode && (this.inputState.tabFocusMode = Date.now() + e)
        }
        static domEventHandlers(e) {
            return gN.define((()=>({})), {
                eventHandlers: e
            })
        }
        static domEventObservers(e) {
            return gN.define((()=>({})), {
                eventObservers: e
            })
        }
        static theme(e, t) {
            let n = hD.newName()
              , r = [H$.of(n), TN.of(Y$(`.${n}`, e))];
            return t && t.dark && r.push(Z$.of(!0)),
            r
        }
        static baseTheme(e) {
            return gP.lowest(TN.of(Y$("." + W$, e, G$)))
        }
        static findFromDOM(e) {
            var t;
            let n = e.querySelector(".cm-content")
              , r = n && ZD.get(n) || ZD.get(e);
            return (null === (t = null == r ? void 0 : r.rootView) || void 0 === t ? void 0 : t.view) || null
        }
    }
    pI.styleModule = TN,
    pI.inputHandler = oN,
    pI.scrollHandler = lN,
    pI.focusChangeEffect = iN,
    pI.perLineTextDirection = aN,
    pI.exceptionSink = nN,
    pI.updateListener = rN,
    pI.editable = hN,
    pI.mouseSelectionStyle = tN,
    pI.dragMovesSelection = eN,
    pI.clickAddsSelectionRange = JR,
    pI.decorations = yN,
    pI.outerDecorations = wN,
    pI.atomicRanges = _N,
    pI.bidiIsolatedRanges = kN,
    pI.scrollMargins = EN,
    pI.darkTheme = Z$,
    pI.cspNonce = rP.define({
        combine: e=>e.length ? e[0] : ""
    }),
    pI.contentAttributes = vN,
    pI.editorAttributes = ON,
    pI.lineWrapping = pI.contentAttributes.of({
        class: "cm-lineWrapping"
    }),
    pI.announce = NP.define();
    const hI = 4096
      , fI = {};
    class mI {
        constructor(e, t, n, r, o, i) {
            this.from = e,
            this.to = t,
            this.dir = n,
            this.isolates = r,
            this.fresh = o,
            this.order = i
        }
        static update(e, t) {
            if (t.empty && !e.some((e=>e.fresh)))
                return e;
            let n = []
              , r = e.length ? e[e.length - 1].dir : $R.LTR;
            for (let o = Math.max(0, e.length - 10); o < e.length; o++) {
                let i = e[o];
                i.dir != r || t.touchesRange(i.from, i.to) || n.push(new mI(t.mapPos(i.from, 1),t.mapPos(i.to, -1),i.dir,i.isolates,!1,i.order))
            }
            return n
        }
    }
    function gI(e, t, n) {
        for (let r = e.state.facet(t), o = r.length - 1; o >= 0; o--) {
            let t = r[o]
              , i = "function" == typeof t ? t(e) : t;
            i && gR(i, n)
        }
        return n
    }
    const bI = lR.mac ? "mac" : lR.windows ? "win" : lR.linux ? "linux" : "key";
    function OI(e, t, n) {
        return t.altKey && (e = "Alt-" + e),
        t.ctrlKey && (e = "Ctrl-" + e),
        t.metaKey && (e = "Meta-" + e),
        !1 !== n && t.shiftKey && (e = "Shift-" + e),
        e
    }
    const vI = gP.default(pI.domEventHandlers({
        keydown: (e,t)=>function(e, t, n, r) {
            SI = t;
            let o = function(e) {
                var t = !(OD && e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey || vD && e.shiftKey && e.key && 1 == e.key.length || "Unidentified" == e.key) && e.key || (e.shiftKey ? bD : gD)[e.keyCode] || e.key || "Unidentified";
                return "Esc" == t && (t = "Escape"),
                "Del" == t && (t = "Delete"),
                "Left" == t && (t = "ArrowLeft"),
                "Up" == t && (t = "ArrowUp"),
                "Right" == t && (t = "ArrowRight"),
                "Down" == t && (t = "ArrowDown"),
                t
            }(t)
              , i = jC(UC(o, 0)) == o.length && " " != o
              , a = ""
              , s = !1
              , l = !1
              , c = !1;
            _I && _I.view == n && _I.scope == r && (a = _I.prefix + " ",
            YN.indexOf(t.keyCode) < 0 && (l = !0,
            _I = null));
            let u, d, p = new Set, h = e=>{
                if (e) {
                    for (let t of e.run)
                        if (!p.has(t) && (p.add(t),
                        t(n)))
                            return e.stopPropagation && (c = !0),
                            !0;
                    e.preventDefault && (e.stopPropagation && (c = !0),
                    l = !0)
                }
                return !1
            }
            , f = e[r];
            f && (h(f[a + OI(o, t, !i)]) ? s = !0 : i && (t.altKey || t.metaKey || t.ctrlKey) && !(lR.windows && t.ctrlKey && t.altKey) && (u = gD[t.keyCode]) && u != o ? (h(f[a + OI(u, t, !0)]) || t.shiftKey && (d = bD[t.keyCode]) != o && d != u && h(f[a + OI(d, t, !1)])) && (s = !0) : i && t.shiftKey && h(f[a + OI(o, t, !0)]) && (s = !0),
            !s && h(f._any) && (s = !0));
            l && (s = !0);
            s && c && t.stopPropagation();
            return SI = null,
            s
        }(function(e) {
            let t = e.facet(yI)
              , n = wI.get(t);
            n || wI.set(t, n = function(e, t=bI) {
                let n = Object.create(null)
                  , r = Object.create(null)
                  , o = (e,t)=>{
                    let n = r[e];
                    if (null == n)
                        r[e] = t;
                    else if (n != t)
                        throw new Error("Key binding " + e + " is used both as a regular binding and as a multi-stroke prefix")
                }
                  , i = (e,r,i,a,s)=>{
                    var l, c;
                    let u = n[e] || (n[e] = Object.create(null))
                      , d = r.split(/ (?!$)/).map((e=>function(e, t) {
                        const n = e.split(/-(?!$)/);
                        let r, o, i, a, s = n[n.length - 1];
                        "Space" == s && (s = " ");
                        for (let l = 0; l < n.length - 1; ++l) {
                            const e = n[l];
                            if (/^(cmd|meta|m)$/i.test(e))
                                a = !0;
                            else if (/^a(lt)?$/i.test(e))
                                r = !0;
                            else if (/^(c|ctrl|control)$/i.test(e))
                                o = !0;
                            else if (/^s(hift)?$/i.test(e))
                                i = !0;
                            else {
                                if (!/^mod$/i.test(e))
                                    throw new Error("Unrecognized modifier name: " + e);
                                "mac" == t ? a = !0 : o = !0
                            }
                        }
                        return r && (s = "Alt-" + s),
                        o && (s = "Ctrl-" + s),
                        a && (s = "Meta-" + s),
                        i && (s = "Shift-" + s),
                        s
                    }(e, t)));
                    for (let t = 1; t < d.length; t++) {
                        let n = d.slice(0, t).join(" ");
                        o(n, !0),
                        u[n] || (u[n] = {
                            preventDefault: !0,
                            stopPropagation: !1,
                            run: [t=>{
                                let r = _I = {
                                    view: t,
                                    prefix: n,
                                    scope: e
                                };
                                return setTimeout((()=>{
                                    _I == r && (_I = null)
                                }
                                ), kI),
                                !0
                            }
                            ]
                        })
                    }
                    let p = d.join(" ");
                    o(p, !1);
                    let h = u[p] || (u[p] = {
                        preventDefault: !1,
                        stopPropagation: !1,
                        run: (null === (c = null === (l = u._any) || void 0 === l ? void 0 : l.run) || void 0 === c ? void 0 : c.slice()) || []
                    });
                    i && h.run.push(i),
                    a && (h.preventDefault = !0),
                    s && (h.stopPropagation = !0)
                }
                ;
                for (let a of e) {
                    let e = a.scope ? a.scope.split(" ") : ["editor"];
                    if (a.any)
                        for (let t of e) {
                            let e = n[t] || (n[t] = Object.create(null));
                            e._any || (e._any = {
                                preventDefault: !1,
                                stopPropagation: !1,
                                run: []
                            });
                            let {any: r} = a;
                            for (let t in e)
                                e[t].run.push((e=>r(e, SI)))
                        }
                    let r = a[t] || a.key;
                    if (r)
                        for (let t of e)
                            i(t, r, a.run, a.preventDefault, a.stopPropagation),
                            a.shift && i(t, "Shift-" + r, a.shift, a.preventDefault, a.stopPropagation)
                }
                return n
            }(t.reduce(((e,t)=>e.concat(t)), [])));
            return n
        }(t.state), e, t, "editor")
    }))
      , yI = rP.define({
        enables: vI
    })
      , wI = new WeakMap;
    let _I = null;
    const kI = 4e3;
    let SI = null;
    const EI = {
        ".cm-line": {
            "& ::selection, &::selection": {
                backgroundColor: "transparent !important"
            }
        },
        ".cm-content": {
            "& :focus": {
                caretColor: "initial !important",
                "&::selection, & ::selection": {
                    backgroundColor: "Highlight !important"
                }
            }
        }
    };
    function xI(e, t, n, r, o) {
        t.lastIndex = 0;
        for (let i, a = e.iterRange(n, r), s = n; !a.next().done; s += a.value.length)
            if (!a.lineBreak)
                for (; i = t.exec(a.value); )
                    o(s + i.index, i)
    }
    !lR.ios && (EI[".cm-line"].caretColor = EI[".cm-content"].caretColor = "transparent !important");
    class TI {
        constructor(e) {
            const {regexp: t, decoration: n, decorate: r, boundary: o, maxLength: i=1e3} = e;
            if (!t.global)
                throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
            if (this.regexp = t,
            r)
                this.addMatch = (e,t,n,o)=>r(o, n, n + e[0].length, e, t);
            else if ("function" == typeof n)
                this.addMatch = (e,t,r,o)=>{
                    let i = n(e, t, r);
                    i && o(r, r + e[0].length, i)
                }
                ;
            else {
                if (!n)
                    throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
                this.addMatch = (e,t,r,o)=>o(r, r + e[0].length, n)
            }
            this.boundary = o,
            this.maxLength = i
        }
        createDeco(e) {
            let t = new KP
              , n = t.add.bind(t);
            for (let {from: r, to: o} of function(e, t) {
                let n = e.visibleRanges;
                if (1 == n.length && n[0].from == e.viewport.from && n[0].to == e.viewport.to)
                    return n;
                let r = [];
                for (let {from: o, to: i} of n)
                    o = Math.max(e.state.doc.lineAt(o).from, o - t),
                    i = Math.min(e.state.doc.lineAt(i).to, i + t),
                    r.length && r[r.length - 1].to >= o ? r[r.length - 1].to = i : r.push({
                        from: o,
                        to: i
                    });
                return r
            }(e, this.maxLength))
                xI(e.state.doc, this.regexp, r, o, ((t,r)=>this.addMatch(r, e, t, n)));
            return t.finish()
        }
        updateDeco(e, t) {
            let n = 1e9
              , r = -1;
            return e.docChanged && e.changes.iterChanges(((t,o,i,a)=>{
                a > e.view.viewport.from && i < e.view.viewport.to && (n = Math.min(i, n),
                r = Math.max(a, r))
            }
            )),
            e.viewportChanged || r - n > 1e3 ? this.createDeco(e.view) : r > -1 ? this.updateRange(e.view, t.map(e.changes), n, r) : t
        }
        updateRange(e, t, n, r) {
            for (let o of e.visibleRanges) {
                let i = Math.max(o.from, n)
                  , a = Math.min(o.to, r);
                if (a > i) {
                    let n = e.state.doc.lineAt(i)
                      , r = n.to < a ? e.state.doc.lineAt(a) : n
                      , s = Math.max(o.from, n.from)
                      , l = Math.min(o.to, r.to);
                    if (this.boundary) {
                        for (; i > n.from; i--)
                            if (this.boundary.test(n.text[i - 1 - n.from])) {
                                s = i;
                                break
                            }
                        for (; a < r.to; a++)
                            if (this.boundary.test(r.text[a - r.from])) {
                                l = a;
                                break
                            }
                    }
                    let c, u = [], d = (e,t,n)=>u.push(n.range(e, t));
                    if (n == r)
                        for (this.regexp.lastIndex = s - n.from; (c = this.regexp.exec(n.text)) && c.index < l - n.from; )
                            this.addMatch(c, e, c.index + n.from, d);
                    else
                        xI(e.state.doc, this.regexp, s, l, ((t,n)=>this.addMatch(n, e, t, d)));
                    t = t.update({
                        filterFrom: s,
                        filterTo: l,
                        filter: (e,t)=>e < s || t > l,
                        add: u
                    })
                }
            }
            return t
        }
    }
    const AI = null != /x/.unicode ? "gu" : "g"
      , CI = new RegExp("[\0-\b\n--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\ufeff￹-￼]",AI)
      , PI = {
        0: "null",
        7: "bell",
        8: "backspace",
        10: "newline",
        11: "vertical tab",
        13: "carriage return",
        27: "escape",
        8203: "zero width space",
        8204: "zero width non-joiner",
        8205: "zero width joiner",
        8206: "left-to-right mark",
        8207: "right-to-left mark",
        8232: "line separator",
        8237: "left-to-right override",
        8238: "right-to-left override",
        8294: "left-to-right isolate",
        8295: "right-to-left isolate",
        8297: "pop directional isolate",
        8233: "paragraph separator",
        65279: "zero width no-break space",
        65532: "object replacement"
    };
    let DI = null;
    const RI = rP.define({
        combine(e) {
            let t = ZP(e, {
                render: null,
                specialChars: CI,
                addSpecialChars: null
            });
            return (t.replaceTabs = !function() {
                var e;
                if (null == DI && "undefined" != typeof document && document.body) {
                    let t = document.body.style;
                    DI = null != (null !== (e = t.tabSize) && void 0 !== e ? e : t.MozTabSize)
                }
                return DI || !1
            }()) && (t.specialChars = new RegExp("\t|" + t.specialChars.source,AI)),
            t.addSpecialChars && (t.specialChars = new RegExp(t.specialChars.source + "|" + t.addSpecialChars.source,AI)),
            t
        }
    });
    function NI(e={}) {
        return [RI.of(e), $I || ($I = gN.fromClass(class {
            constructor(e) {
                this.view = e,
                this.decorations = ER.none,
                this.decorationCache = Object.create(null),
                this.decorator = this.makeDecorator(e.state.facet(RI)),
                this.decorations = this.decorator.createDeco(e)
            }
            makeDecorator(e) {
                return new TI({
                    regexp: e.specialChars,
                    decoration: (t,n,r)=>{
                        let {doc: o} = n.state
                          , i = UC(t[0], 0);
                        if (9 == i) {
                            let e = o.lineAt(r)
                              , t = n.state.tabSize
                              , i = cD(e.text, t, r - e.from);
                            return ER.replace({
                                widget: new MI((t - i % t) * this.view.defaultCharacterWidth / this.view.scaleX)
                            })
                        }
                        return this.decorationCache[i] || (this.decorationCache[i] = ER.replace({
                            widget: new II(e,i)
                        }))
                    }
                    ,
                    boundary: e.replaceTabs ? void 0 : /[^]/
                })
            }
            update(e) {
                let t = e.state.facet(RI);
                e.startState.facet(RI) != t ? (this.decorator = this.makeDecorator(t),
                this.decorations = this.decorator.createDeco(e.view)) : this.decorations = this.decorator.updateDeco(e, this.decorations)
            }
        }
        , {
            decorations: e=>e.decorations
        }))]
    }
    let $I = null;
    class II extends kR {
        constructor(e, t) {
            super(),
            this.options = e,
            this.code = t
        }
        eq(e) {
            return e.code == this.code
        }
        toDOM(e) {
            let t = (n = this.code) >= 32 ? "•" : 10 == n ? "␤" : String.fromCharCode(9216 + n);
            var n;
            let r = e.state.phrase("Control character") + " " + (PI[this.code] || "0x" + this.code.toString(16))
              , o = this.options.render && this.options.render(this.code, r, t);
            if (o)
                return o;
            let i = document.createElement("span");
            return i.textContent = t,
            i.title = r,
            i.setAttribute("aria-label", r),
            i.className = "cm-specialChar",
            i
        }
        ignoreEvent() {
            return !1
        }
    }
    class MI extends kR {
        constructor(e) {
            super(),
            this.width = e
        }
        eq(e) {
            return e.width == this.width
        }
        toDOM() {
            let e = document.createElement("span");
            return e.textContent = "\t",
            e.className = "cm-tab",
            e.style.width = this.width + "px",
            e
        }
        ignoreEvent() {
            return !1
        }
    }
    const LI = "-10000px";
    class QI {
        constructor(e, t, n, r) {
            this.facet = t,
            this.createTooltipView = n,
            this.removeTooltipView = r,
            this.input = e.state.facet(t),
            this.tooltips = this.input.filter((e=>e));
            let o = null;
            this.tooltipViews = this.tooltips.map((e=>o = n(e, o)))
        }
        update(e, t) {
            var n;
            let r = e.state.facet(this.facet)
              , o = r.filter((e=>e));
            if (r === this.input) {
                for (let t of this.tooltipViews)
                    t.update && t.update(e);
                return !1
            }
            let i = []
              , a = t ? [] : null;
            for (let s = 0; s < o.length; s++) {
                let n = o[s]
                  , r = -1;
                if (n) {
                    for (let e = 0; e < this.tooltips.length; e++) {
                        let t = this.tooltips[e];
                        t && t.create == n.create && (r = e)
                    }
                    if (r < 0)
                        i[s] = this.createTooltipView(n, s ? i[s - 1] : null),
                        a && (a[s] = !!n.above);
                    else {
                        let n = i[s] = this.tooltipViews[r];
                        a && (a[s] = t[r]),
                        n.update && n.update(e)
                    }
                }
            }
            for (let s of this.tooltipViews)
                i.indexOf(s) < 0 && (this.removeTooltipView(s),
                null === (n = s.destroy) || void 0 === n || n.call(s));
            return t && (a.forEach(((e,n)=>t[n] = e)),
            t.length = a.length),
            this.input = r,
            this.tooltips = o,
            this.tooltipViews = i,
            !0
        }
    }
    function BI(e) {
        let {win: t} = e;
        return {
            top: 0,
            left: 0,
            bottom: t.innerHeight,
            right: t.innerWidth
        }
    }
    const UI = rP.define({
        combine: e=>{
            var t, n, r;
            return {
                position: lR.ios ? "absolute" : (null === (t = e.find((e=>e.position))) || void 0 === t ? void 0 : t.position) || "fixed",
                parent: (null === (n = e.find((e=>e.parent))) || void 0 === n ? void 0 : n.parent) || null,
                tooltipSpace: (null === (r = e.find((e=>e.tooltipSpace))) || void 0 === r ? void 0 : r.tooltipSpace) || BI
            }
        }
    })
      , FI = new WeakMap
      , jI = gN.fromClass(class {
        constructor(e) {
            this.view = e,
            this.above = [],
            this.inView = !0,
            this.madeAbsolute = !1,
            this.lastTransaction = 0,
            this.measureTimeout = -1;
            let t = e.state.facet(UI);
            this.position = t.position,
            this.parent = t.parent,
            this.classes = e.themeClasses,
            this.createContainer(),
            this.measureReq = {
                read: this.readMeasure.bind(this),
                write: this.writeMeasure.bind(this),
                key: this
            },
            this.resizeObserver = "function" == typeof ResizeObserver ? new ResizeObserver((()=>this.measureSoon())) : null,
            this.manager = new QI(e,HI,((e,t)=>this.createTooltip(e, t)),(e=>{
                this.resizeObserver && this.resizeObserver.unobserve(e.dom),
                e.dom.remove()
            }
            )),
            this.above = this.manager.tooltips.map((e=>!!e.above)),
            this.intersectionObserver = "function" == typeof IntersectionObserver ? new IntersectionObserver((e=>{
                Date.now() > this.lastTransaction - 50 && e.length > 0 && e[e.length - 1].intersectionRatio < 1 && this.measureSoon()
            }
            ),{
                threshold: [1]
            }) : null,
            this.observeIntersection(),
            e.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)),
            this.maybeMeasure()
        }
        createContainer() {
            this.parent ? (this.container = document.createElement("div"),
            this.container.style.position = "relative",
            this.container.className = this.view.themeClasses,
            this.parent.appendChild(this.container)) : this.container = this.view.dom
        }
        observeIntersection() {
            if (this.intersectionObserver) {
                this.intersectionObserver.disconnect();
                for (let e of this.manager.tooltipViews)
                    this.intersectionObserver.observe(e.dom)
            }
        }
        measureSoon() {
            this.measureTimeout < 0 && (this.measureTimeout = setTimeout((()=>{
                this.measureTimeout = -1,
                this.maybeMeasure()
            }
            ), 50))
        }
        update(e) {
            e.transactions.length && (this.lastTransaction = Date.now());
            let t = this.manager.update(e, this.above);
            t && this.observeIntersection();
            let n = t || e.geometryChanged
              , r = e.state.facet(UI);
            if (r.position != this.position && !this.madeAbsolute) {
                this.position = r.position;
                for (let e of this.manager.tooltipViews)
                    e.dom.style.position = this.position;
                n = !0
            }
            if (r.parent != this.parent) {
                this.parent && this.container.remove(),
                this.parent = r.parent,
                this.createContainer();
                for (let e of this.manager.tooltipViews)
                    this.container.appendChild(e.dom);
                n = !0
            } else
                this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
            n && this.maybeMeasure()
        }
        createTooltip(e, t) {
            let n = e.create(this.view)
              , r = t ? t.dom : null;
            if (n.dom.classList.add("cm-tooltip"),
            e.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
                let e = document.createElement("div");
                e.className = "cm-tooltip-arrow",
                n.dom.appendChild(e)
            }
            return n.dom.style.position = this.position,
            n.dom.style.top = LI,
            n.dom.style.left = "0px",
            this.container.insertBefore(n.dom, r),
            n.mount && n.mount(this.view),
            this.resizeObserver && this.resizeObserver.observe(n.dom),
            n
        }
        destroy() {
            var e, t, n;
            this.view.win.removeEventListener("resize", this.measureSoon);
            for (let r of this.manager.tooltipViews)
                r.dom.remove(),
                null === (e = r.destroy) || void 0 === e || e.call(r);
            this.parent && this.container.remove(),
            null === (t = this.resizeObserver) || void 0 === t || t.disconnect(),
            null === (n = this.intersectionObserver) || void 0 === n || n.disconnect(),
            clearTimeout(this.measureTimeout)
        }
        readMeasure() {
            let e = this.view.dom.getBoundingClientRect()
              , t = 1
              , n = 1
              , r = !1;
            if ("fixed" == this.position && this.manager.tooltipViews.length) {
                let {dom: e} = this.manager.tooltipViews[0];
                if (lR.gecko)
                    r = e.offsetParent != this.container.ownerDocument.body;
                else if (e.style.top == LI && "0px" == e.style.left) {
                    let t = e.getBoundingClientRect();
                    r = Math.abs(t.top + 1e4) > 1 || Math.abs(t.left) > 1
                }
            }
            if (r || "absolute" == this.position)
                if (this.parent) {
                    let e = this.parent.getBoundingClientRect();
                    e.width && e.height && (t = e.width / this.parent.offsetWidth,
                    n = e.height / this.parent.offsetHeight)
                } else
                    ({scaleX: t, scaleY: n} = this.view.viewState);
            return {
                editor: e,
                parent: this.parent ? this.container.getBoundingClientRect() : e,
                pos: this.manager.tooltips.map(((e,t)=>{
                    let n = this.manager.tooltipViews[t];
                    return n.getCoords ? n.getCoords(e.pos) : this.view.coordsAtPos(e.pos)
                }
                )),
                size: this.manager.tooltipViews.map((({dom: e})=>e.getBoundingClientRect())),
                space: this.view.state.facet(UI).tooltipSpace(this.view),
                scaleX: t,
                scaleY: n,
                makeAbsolute: r
            }
        }
        writeMeasure(e) {
            var t;
            if (e.makeAbsolute) {
                this.madeAbsolute = !0,
                this.position = "absolute";
                for (let e of this.manager.tooltipViews)
                    e.dom.style.position = "absolute"
            }
            let {editor: n, space: r, scaleX: o, scaleY: i} = e
              , a = [];
            for (let s = 0; s < this.manager.tooltips.length; s++) {
                let l = this.manager.tooltips[s]
                  , c = this.manager.tooltipViews[s]
                  , {dom: u} = c
                  , d = e.pos[s]
                  , p = e.size[s];
                if (!d || d.bottom <= Math.max(n.top, r.top) || d.top >= Math.min(n.bottom, r.bottom) || d.right < Math.max(n.left, r.left) - .1 || d.left > Math.min(n.right, r.right) + .1) {
                    u.style.top = LI;
                    continue
                }
                let h = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null
                  , f = h ? 7 : 0
                  , m = p.right - p.left
                  , g = null !== (t = FI.get(c)) && void 0 !== t ? t : p.bottom - p.top
                  , b = c.offset || qI
                  , O = this.view.textDirection == $R.LTR
                  , v = p.width > r.right - r.left ? O ? r.left : r.right - p.width : O ? Math.min(d.left - (h ? 14 : 0) + b.x, r.right - m) : Math.max(r.left, d.left - m + (h ? 14 : 0) - b.x)
                  , y = this.above[s];
                !l.strictSide && (y ? d.top - (p.bottom - p.top) - b.y < r.top : d.bottom + (p.bottom - p.top) + b.y > r.bottom) && y == r.bottom - d.bottom > d.top - r.top && (y = this.above[s] = !y);
                let w = (y ? d.top - r.top : r.bottom - d.bottom) - f;
                if (w < g && !1 !== c.resize) {
                    if (w < this.view.defaultLineHeight) {
                        u.style.top = LI;
                        continue
                    }
                    FI.set(c, g),
                    u.style.height = (g = w) / i + "px"
                } else
                    u.style.height && (u.style.height = "");
                let _ = y ? d.top - g - f - b.y : d.bottom + f + b.y
                  , k = v + m;
                if (!0 !== c.overlap)
                    for (let e of a)
                        e.left < k && e.right > v && e.top < _ + g && e.bottom > _ && (_ = y ? e.top - g - 2 - f : e.bottom + f + 2);
                if ("absolute" == this.position ? (u.style.top = (_ - e.parent.top) / i + "px",
                u.style.left = (v - e.parent.left) / o + "px") : (u.style.top = _ / i + "px",
                u.style.left = v / o + "px"),
                h) {
                    let e = d.left + (O ? b.x : -b.x) - (v + 14 - 7);
                    h.style.left = e / o + "px"
                }
                !0 !== c.overlap && a.push({
                    left: v,
                    top: _,
                    right: k,
                    bottom: _ + g
                }),
                u.classList.toggle("cm-tooltip-above", y),
                u.classList.toggle("cm-tooltip-below", !y),
                c.positioned && c.positioned(e.space)
            }
        }
        maybeMeasure() {
            if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq),
            this.inView != this.view.inView && (this.inView = this.view.inView,
            !this.inView)))
                for (let e of this.manager.tooltipViews)
                    e.dom.style.top = LI
        }
    }
    , {
        eventObservers: {
            scroll() {
                this.maybeMeasure()
            }
        }
    })
      , zI = pI.baseTheme({
        ".cm-tooltip": {
            zIndex: 100,
            boxSizing: "border-box"
        },
        "&light .cm-tooltip": {
            border: "1px solid #bbb",
            backgroundColor: "#f5f5f5"
        },
        "&light .cm-tooltip-section:not(:first-child)": {
            borderTop: "1px solid #bbb"
        },
        "&dark .cm-tooltip": {
            backgroundColor: "#333338",
            color: "white"
        },
        ".cm-tooltip-arrow": {
            height: "7px",
            width: "14px",
            position: "absolute",
            zIndex: -1,
            overflow: "hidden",
            "&:before, &:after": {
                content: "''",
                position: "absolute",
                width: 0,
                height: 0,
                borderLeft: "7px solid transparent",
                borderRight: "7px solid transparent"
            },
            ".cm-tooltip-above &": {
                bottom: "-7px",
                "&:before": {
                    borderTop: "7px solid #bbb"
                },
                "&:after": {
                    borderTop: "7px solid #f5f5f5",
                    bottom: "1px"
                }
            },
            ".cm-tooltip-below &": {
                top: "-7px",
                "&:before": {
                    borderBottom: "7px solid #bbb"
                },
                "&:after": {
                    borderBottom: "7px solid #f5f5f5",
                    top: "1px"
                }
            }
        },
        "&dark .cm-tooltip .cm-tooltip-arrow": {
            "&:before": {
                borderTopColor: "#333338",
                borderBottomColor: "#333338"
            },
            "&:after": {
                borderTopColor: "transparent",
                borderBottomColor: "transparent"
            }
        }
    })
      , qI = {
        x: 0,
        y: 0
    }
      , HI = rP.define({
        enables: [jI, zI]
    });
    function ZI(e, t) {
        let n = e.plugin(jI);
        if (!n)
            return null;
        let r = n.manager.tooltips.indexOf(t);
        return r < 0 ? null : n.manager.tooltipViews[r]
    }
    class WI extends WP {
        compare(e) {
            return this == e || this.constructor == e.constructor && this.eq(e)
        }
        eq(e) {
            return !1
        }
        destroy(e) {}
    }
    WI.prototype.elementClass = "",
    WI.prototype.toDOM = void 0,
    WI.prototype.mapMode = qC.TrackBefore,
    WI.prototype.startSide = WI.prototype.endSide = -1,
    WI.prototype.point = !0;
    const XI = rP.define()
      , VI = rP.define()
      , GI = rP.define({
        combine: e=>e.some((e=>e))
    });
    const YI = gN.fromClass(class {
        constructor(e) {
            this.view = e,
            this.prevViewport = e.viewport,
            this.dom = document.createElement("div"),
            this.dom.className = "cm-gutters",
            this.dom.setAttribute("aria-hidden", "true"),
            this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px",
            this.gutters = e.state.facet(VI).map((t=>new tM(e,t)));
            for (let t of this.gutters)
                this.dom.appendChild(t.dom);
            this.fixed = !e.state.facet(GI),
            this.fixed && (this.dom.style.position = "sticky"),
            this.syncGutters(!1),
            e.scrollDOM.insertBefore(this.dom, e.contentDOM)
        }
        update(e) {
            if (this.updateGutters(e)) {
                let t = this.prevViewport
                  , n = e.view.viewport
                  , r = Math.min(t.to, n.to) - Math.max(t.from, n.from);
                this.syncGutters(r < .8 * (n.to - n.from))
            }
            e.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"),
            this.view.state.facet(GI) != !this.fixed && (this.fixed = !this.fixed,
            this.dom.style.position = this.fixed ? "sticky" : ""),
            this.prevViewport = e.view.viewport
        }
        syncGutters(e) {
            let t = this.dom.nextSibling;
            e && this.dom.remove();
            let n = YP.iter(this.view.state.facet(XI), this.view.viewport.from)
              , r = []
              , o = this.gutters.map((e=>new eM(e,this.view.viewport,-this.view.documentPadding.top)));
            for (let i of this.view.viewportLineBlocks)
                if (r.length && (r = []),
                Array.isArray(i.type)) {
                    let e = !0;
                    for (let t of i.type)
                        if (t.type == SR.Text && e) {
                            JI(n, r, t.from);
                            for (let e of o)
                                e.line(this.view, t, r);
                            e = !1
                        } else if (t.widget)
                            for (let e of o)
                                e.widget(this.view, t)
                } else if (i.type == SR.Text) {
                    JI(n, r, i.from);
                    for (let e of o)
                        e.line(this.view, i, r)
                } else if (i.widget)
                    for (let e of o)
                        e.widget(this.view, i);
            for (let i of o)
                i.finish();
            e && this.view.scrollDOM.insertBefore(this.dom, t)
        }
        updateGutters(e) {
            let t = e.startState.facet(VI)
              , n = e.state.facet(VI)
              , r = e.docChanged || e.heightChanged || e.viewportChanged || !YP.eq(e.startState.facet(XI), e.state.facet(XI), e.view.viewport.from, e.view.viewport.to);
            if (t == n)
                for (let o of this.gutters)
                    o.update(e) && (r = !0);
            else {
                r = !0;
                let o = [];
                for (let r of n) {
                    let n = t.indexOf(r);
                    n < 0 ? o.push(new tM(this.view,r)) : (this.gutters[n].update(e),
                    o.push(this.gutters[n]))
                }
                for (let e of this.gutters)
                    e.dom.remove(),
                    o.indexOf(e) < 0 && e.destroy();
                for (let e of o)
                    this.dom.appendChild(e.dom);
                this.gutters = o
            }
            return r
        }
        destroy() {
            for (let e of this.gutters)
                e.destroy();
            this.dom.remove()
        }
    }
    , {
        provide: e=>pI.scrollMargins.of((t=>{
            let n = t.plugin(e);
            return n && 0 != n.gutters.length && n.fixed ? t.textDirection == $R.LTR ? {
                left: n.dom.offsetWidth * t.scaleX
            } : {
                right: n.dom.offsetWidth * t.scaleX
            } : null
        }
        ))
    });
    function KI(e) {
        return Array.isArray(e) ? e : [e]
    }
    function JI(e, t, n) {
        for (; e.value && e.from <= n; )
            e.from == n && t.push(e.value),
            e.next()
    }
    class eM {
        constructor(e, t, n) {
            this.gutter = e,
            this.height = n,
            this.i = 0,
            this.cursor = YP.iter(e.markers, t.from)
        }
        addElement(e, t, n) {
            let {gutter: r} = this
              , o = (t.top - this.height) / e.scaleY
              , i = t.height / e.scaleY;
            if (this.i == r.elements.length) {
                let t = new nM(e,i,o,n);
                r.elements.push(t),
                r.dom.appendChild(t.dom)
            } else
                r.elements[this.i].update(e, i, o, n);
            this.height = t.bottom,
            this.i++
        }
        line(e, t, n) {
            let r = [];
            JI(this.cursor, r, t.from),
            n.length && (r = r.concat(n));
            let o = this.gutter.config.lineMarker(e, t, r);
            o && r.unshift(o);
            let i = this.gutter;
            (0 != r.length || i.config.renderEmptyElements) && this.addElement(e, t, r)
        }
        widget(e, t) {
            let n = this.gutter.config.widgetMarker(e, t.widget, t);
            n && this.addElement(e, t, [n])
        }
        finish() {
            let e = this.gutter;
            for (; e.elements.length > this.i; ) {
                let t = e.elements.pop();
                e.dom.removeChild(t.dom),
                t.destroy()
            }
        }
    }
    class tM {
        constructor(e, t) {
            this.view = e,
            this.config = t,
            this.elements = [],
            this.spacer = null,
            this.dom = document.createElement("div"),
            this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
            for (let n in t.domEventHandlers)
                this.dom.addEventListener(n, (r=>{
                    let o, i = r.target;
                    if (i != this.dom && this.dom.contains(i)) {
                        for (; i.parentNode != this.dom; )
                            i = i.parentNode;
                        let e = i.getBoundingClientRect();
                        o = (e.top + e.bottom) / 2
                    } else
                        o = r.clientY;
                    let a = e.lineBlockAtHeight(o - e.documentTop);
                    t.domEventHandlers[n](e, a, r) && r.preventDefault()
                }
                ));
            this.markers = KI(t.markers(e)),
            t.initialSpacer && (this.spacer = new nM(e,0,0,[t.initialSpacer(e)]),
            this.dom.appendChild(this.spacer.dom),
            this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none")
        }
        update(e) {
            let t = this.markers;
            if (this.markers = KI(this.config.markers(e.view)),
            this.spacer && this.config.updateSpacer) {
                let t = this.config.updateSpacer(this.spacer.markers[0], e);
                t != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [t])
            }
            let n = e.view.viewport;
            return !YP.eq(this.markers, t, n.from, n.to) || !!this.config.lineMarkerChange && this.config.lineMarkerChange(e)
        }
        destroy() {
            for (let e of this.elements)
                e.destroy()
        }
    }
    class nM {
        constructor(e, t, n, r) {
            this.height = -1,
            this.above = 0,
            this.markers = [],
            this.dom = document.createElement("div"),
            this.dom.className = "cm-gutterElement",
            this.update(e, t, n, r)
        }
        update(e, t, n, r) {
            this.height != t && (this.height = t,
            this.dom.style.height = t + "px"),
            this.above != n && (this.dom.style.marginTop = (this.above = n) ? n + "px" : ""),
            function(e, t) {
                if (e.length != t.length)
                    return !1;
                for (let n = 0; n < e.length; n++)
                    if (!e[n].compare(t[n]))
                        return !1;
                return !0
            }(this.markers, r) || this.setMarkers(e, r)
        }
        setMarkers(e, t) {
            let n = "cm-gutterElement"
              , r = this.dom.firstChild;
            for (let o = 0, i = 0; ; ) {
                let a = i
                  , s = o < t.length ? t[o++] : null
                  , l = !1;
                if (s) {
                    let e = s.elementClass;
                    e && (n += " " + e);
                    for (let t = i; t < this.markers.length; t++)
                        if (this.markers[t].compare(s)) {
                            a = t,
                            l = !0;
                            break
                        }
                } else
                    a = this.markers.length;
                for (; i < a; ) {
                    let e = this.markers[i++];
                    if (e.toDOM) {
                        e.destroy(r);
                        let t = r.nextSibling;
                        r.remove(),
                        r = t
                    }
                }
                if (!s)
                    break;
                s.toDOM && (l ? r = r.nextSibling : this.dom.insertBefore(s.toDOM(e), r)),
                l && i++
            }
            this.dom.className = n,
            this.markers = t
        }
        destroy() {
            this.setMarkers(null, [])
        }
    }
    const rM = rP.define()
      , oM = rP.define({
        combine: e=>ZP(e, {
            formatNumber: String,
            domEventHandlers: {}
        }, {
            domEventHandlers(e, t) {
                let n = Object.assign({}, e);
                for (let r in t) {
                    let e = n[r]
                      , o = t[r];
                    n[r] = e ? (t,n,r)=>e(t, n, r) || o(t, n, r) : o
                }
                return n
            }
        })
    });
    class iM extends WI {
        constructor(e) {
            super(),
            this.number = e
        }
        eq(e) {
            return this.number == e.number
        }
        toDOM() {
            return document.createTextNode(this.number)
        }
    }
    function aM(e, t) {
        return e.state.facet(oM).formatNumber(t, e.state)
    }
    const sM = VI.compute([oM], (e=>({
        class: "cm-lineNumbers",
        renderEmptyElements: !1,
        markers: e=>e.state.facet(rM),
        lineMarker: (e,t,n)=>n.some((e=>e.toDOM)) ? null : new iM(aM(e, e.state.doc.lineAt(t.from).number)),
        widgetMarker: ()=>null,
        lineMarkerChange: e=>e.startState.facet(oM) != e.state.facet(oM),
        initialSpacer: e=>new iM(aM(e, lM(e.state.doc.lines))),
        updateSpacer(e, t) {
            let n = aM(t.view, lM(t.view.state.doc.lines));
            return n == e.number ? e : new iM(n)
        },
        domEventHandlers: e.facet(oM).domEventHandlers
    })));
    function lM(e) {
        let t = 9;
        for (; t < e; )
            t = 10 * t + 9;
        return t
    }
    const cM = 1024;
    let uM = 0;
    class dM {
        constructor(e, t) {
            this.from = e,
            this.to = t
        }
    }
    class pM {
        constructor(e={}) {
            this.id = uM++,
            this.perNode = !!e.perNode,
            this.deserialize = e.deserialize || (()=>{
                throw new Error("This node type doesn't define a deserialize function")
            }
            )
        }
        add(e) {
            if (this.perNode)
                throw new RangeError("Can't add per-node props to node types");
            return "function" != typeof e && (e = mM.match(e)),
            t=>{
                let n = e(t);
                return void 0 === n ? null : [this, n]
            }
        }
    }
    pM.closedBy = new pM({
        deserialize: e=>e.split(" ")
    }),
    pM.openedBy = new pM({
        deserialize: e=>e.split(" ")
    }),
    pM.group = new pM({
        deserialize: e=>e.split(" ")
    }),
    pM.isolate = new pM({
        deserialize: e=>{
            if (e && "rtl" != e && "ltr" != e && "auto" != e)
                throw new RangeError("Invalid value for isolate: " + e);
            return e || "auto"
        }
    }),
    pM.contextHash = new pM({
        perNode: !0
    }),
    pM.lookAhead = new pM({
        perNode: !0
    }),
    pM.mounted = new pM({
        perNode: !0
    });
    class hM {
        constructor(e, t, n) {
            this.tree = e,
            this.overlay = t,
            this.parser = n
        }
        static get(e) {
            return e && e.props && e.props[pM.mounted.id]
        }
    }
    const fM = Object.create(null);
    class mM {
        constructor(e, t, n, r=0) {
            this.name = e,
            this.props = t,
            this.id = n,
            this.flags = r
        }
        static define(e) {
            let t = e.props && e.props.length ? Object.create(null) : fM
              , n = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (null == e.name ? 8 : 0)
              , r = new mM(e.name || "",t,e.id,n);
            if (e.props)
                for (let o of e.props)
                    if (Array.isArray(o) || (o = o(r)),
                    o) {
                        if (o[0].perNode)
                            throw new RangeError("Can't store a per-node prop on a node type");
                        t[o[0].id] = o[1]
                    }
            return r
        }
        prop(e) {
            return this.props[e.id]
        }
        get isTop() {
            return (1 & this.flags) > 0
        }
        get isSkipped() {
            return (2 & this.flags) > 0
        }
        get isError() {
            return (4 & this.flags) > 0
        }
        get isAnonymous() {
            return (8 & this.flags) > 0
        }
        is(e) {
            if ("string" == typeof e) {
                if (this.name == e)
                    return !0;
                let t = this.prop(pM.group);
                return !!t && t.indexOf(e) > -1
            }
            return this.id == e
        }
        static match(e) {
            let t = Object.create(null);
            for (let n in e)
                for (let r of n.split(" "))
                    t[r] = e[n];
            return e=>{
                for (let n = e.prop(pM.group), r = -1; r < (n ? n.length : 0); r++) {
                    let o = t[r < 0 ? e.name : n[r]];
                    if (o)
                        return o
                }
            }
        }
    }
    mM.none = new mM("",Object.create(null),0,8);
    class gM {
        constructor(e) {
            this.types = e;
            for (let t = 0; t < e.length; t++)
                if (e[t].id != t)
                    throw new RangeError("Node type ids should correspond to array positions when creating a node set")
        }
        extend(...e) {
            let t = [];
            for (let n of this.types) {
                let r = null;
                for (let t of e) {
                    let e = t(n);
                    e && (r || (r = Object.assign({}, n.props)),
                    r[e[0].id] = e[1])
                }
                t.push(r ? new mM(n.name,r,n.id,n.flags) : n)
            }
            return new gM(t)
        }
    }
    const bM = new WeakMap
      , OM = new WeakMap;
    var vM, yM;
    (yM = vM || (vM = {}))[yM.ExcludeBuffers = 1] = "ExcludeBuffers",
    yM[yM.IncludeAnonymous = 2] = "IncludeAnonymous",
    yM[yM.IgnoreMounts = 4] = "IgnoreMounts",
    yM[yM.IgnoreOverlays = 8] = "IgnoreOverlays";
    class wM {
        constructor(e, t, n, r, o) {
            if (this.type = e,
            this.children = t,
            this.positions = n,
            this.length = r,
            this.props = null,
            o && o.length) {
                this.props = Object.create(null);
                for (let[e,t] of o)
                    this.props["number" == typeof e ? e : e.id] = t
            }
        }
        toString() {
            let e = hM.get(this);
            if (e && !e.overlay)
                return e.tree.toString();
            let t = "";
            for (let n of this.children) {
                let e = n.toString();
                e && (t && (t += ","),
                t += e)
            }
            return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t
        }
        cursor(e=0) {
            return new $M(this.topNode,e)
        }
        cursorAt(e, t=0, n=0) {
            let r = bM.get(this) || this.topNode
              , o = new $M(r);
            return o.moveTo(e, t),
            bM.set(this, o._tree),
            o
        }
        get topNode() {
            return new TM(this,0,0,null)
        }
        resolve(e, t=0) {
            let n = EM(bM.get(this) || this.topNode, e, t, !1);
            return bM.set(this, n),
            n
        }
        resolveInner(e, t=0) {
            let n = EM(OM.get(this) || this.topNode, e, t, !0);
            return OM.set(this, n),
            n
        }
        resolveStack(e, t=0) {
            return function(e, t, n) {
                let r = e.resolveInner(t, n)
                  , o = null;
                for (let i = r instanceof TM ? r : r.context.parent; i; i = i.parent)
                    if (i.index < 0) {
                        let e = i.parent;
                        (o || (o = [r])).push(e.resolve(t, n)),
                        i = e
                    } else {
                        let e = hM.get(i.tree);
                        if (e && e.overlay && e.overlay[0].from <= t && e.overlay[e.overlay.length - 1].to >= t) {
                            let a = new TM(e.tree,e.overlay[0].from + i.from,-1,i);
                            (o || (o = [r])).push(EM(a, t, n, !1))
                        }
                    }
                return o ? RM(o) : r
            }(this, e, t)
        }
        iterate(e) {
            let {enter: t, leave: n, from: r=0, to: o=this.length} = e
              , i = e.mode || 0
              , a = (i & vM.IncludeAnonymous) > 0;
            for (let s = this.cursor(i | vM.IncludeAnonymous); ; ) {
                let e = !1;
                if (s.from <= o && s.to >= r && (!a && s.type.isAnonymous || !1 !== t(s))) {
                    if (s.firstChild())
                        continue;
                    e = !0
                }
                for (; e && n && (a || !s.type.isAnonymous) && n(s),
                !s.nextSibling(); ) {
                    if (!s.parent())
                        return;
                    e = !0
                }
            }
        }
        prop(e) {
            return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e)
        }
        get propValues() {
            let e = [];
            if (this.props)
                for (let t in this.props)
                    e.push([+t, this.props[t]]);
            return e
        }
        balance(e={}) {
            return this.children.length <= 8 ? this : QM(mM.none, this.children, this.positions, 0, this.children.length, 0, this.length, ((e,t,n)=>new wM(this.type,e,t,n,this.propValues)), e.makeTree || ((e,t,n)=>new wM(mM.none,e,t,n)))
        }
        static build(e) {
            return function(e) {
                var t;
                let {buffer: n, nodeSet: r, maxBufferLength: o=cM, reused: i=[], minRepeatType: a=r.types.length} = e
                  , s = Array.isArray(n) ? new _M(n,n.length) : n
                  , l = r.types
                  , c = 0
                  , u = 0;
                function d(e, t, n, O, v, y) {
                    let {id: w, start: _, end: k, size: S} = s
                      , E = u;
                    for (; S < 0; ) {
                        if (s.next(),
                        -1 == S) {
                            let t = i[w];
                            return n.push(t),
                            void O.push(_ - e)
                        }
                        if (-3 == S)
                            return void (c = w);
                        if (-4 == S)
                            return void (u = w);
                        throw new RangeError(`Unrecognized record size: ${S}`)
                    }
                    let x, T, A = l[w], C = _ - e;
                    if (k - _ <= o && (T = g(s.pos - t, v))) {
                        let t = new Uint16Array(T.size - T.skip)
                          , n = s.pos - T.size
                          , o = t.length;
                        for (; s.pos > n; )
                            o = b(T.start, t, o);
                        x = new kM(t,k - T.start,r),
                        C = T.start - e
                    } else {
                        let e = s.pos - S;
                        s.next();
                        let t = []
                          , n = []
                          , r = w >= a ? w : -1
                          , i = 0
                          , l = k;
                        for (; s.pos > e; )
                            r >= 0 && s.id == r && s.size >= 0 ? (s.end <= l - o && (f(t, n, _, i, s.end, l, r, E),
                            i = t.length,
                            l = s.end),
                            s.next()) : y > 2500 ? p(_, e, t, n) : d(_, e, t, n, r, y + 1);
                        if (r >= 0 && i > 0 && i < t.length && f(t, n, _, i, _, l, r, E),
                        t.reverse(),
                        n.reverse(),
                        r > -1 && i > 0) {
                            let e = h(A);
                            x = QM(A, t, n, 0, t.length, 0, k - _, e, e)
                        } else
                            x = m(A, t, n, k - _, E - k)
                    }
                    n.push(x),
                    O.push(C)
                }
                function p(e, t, n, i) {
                    let a = []
                      , l = 0
                      , c = -1;
                    for (; s.pos > t; ) {
                        let {id: e, start: t, end: n, size: r} = s;
                        if (r > 4)
                            s.next();
                        else {
                            if (c > -1 && t < c)
                                break;
                            c < 0 && (c = n - o),
                            a.push(e, t, n),
                            l++,
                            s.next()
                        }
                    }
                    if (l) {
                        let t = new Uint16Array(4 * l)
                          , o = a[a.length - 2];
                        for (let e = a.length - 3, n = 0; e >= 0; e -= 3)
                            t[n++] = a[e],
                            t[n++] = a[e + 1] - o,
                            t[n++] = a[e + 2] - o,
                            t[n++] = n;
                        n.push(new kM(t,a[2] - o,r)),
                        i.push(o - e)
                    }
                }
                function h(e) {
                    return (t,n,r)=>{
                        let o, i, a = 0, s = t.length - 1;
                        if (s >= 0 && (o = t[s])instanceof wM) {
                            if (!s && o.type == e && o.length == r)
                                return o;
                            (i = o.prop(pM.lookAhead)) && (a = n[s] + o.length + i)
                        }
                        return m(e, t, n, r, a)
                    }
                }
                function f(e, t, n, o, i, a, s, l) {
                    let c = []
                      , u = [];
                    for (; e.length > o; )
                        c.push(e.pop()),
                        u.push(t.pop() + n - i);
                    e.push(m(r.types[s], c, u, a - i, l - a)),
                    t.push(i - n)
                }
                function m(e, t, n, r, o=0, i) {
                    if (c) {
                        let e = [pM.contextHash, c];
                        i = i ? [e].concat(i) : [e]
                    }
                    if (o > 25) {
                        let e = [pM.lookAhead, o];
                        i = i ? [e].concat(i) : [e]
                    }
                    return new wM(e,t,n,r,i)
                }
                function g(e, t) {
                    let n = s.fork()
                      , r = 0
                      , i = 0
                      , l = 0
                      , c = n.end - o
                      , u = {
                        size: 0,
                        start: 0,
                        skip: 0
                    };
                    e: for (let o = n.pos - e; n.pos > o; ) {
                        let e = n.size;
                        if (n.id == t && e >= 0) {
                            u.size = r,
                            u.start = i,
                            u.skip = l,
                            l += 4,
                            r += 4,
                            n.next();
                            continue
                        }
                        let s = n.pos - e;
                        if (e < 0 || s < o || n.start < c)
                            break;
                        let d = n.id >= a ? 4 : 0
                          , p = n.start;
                        for (n.next(); n.pos > s; ) {
                            if (n.size < 0) {
                                if (-3 != n.size)
                                    break e;
                                d += 4
                            } else
                                n.id >= a && (d += 4);
                            n.next()
                        }
                        i = p,
                        r += e,
                        l += d
                    }
                    return (t < 0 || r == e) && (u.size = r,
                    u.start = i,
                    u.skip = l),
                    u.size > 4 ? u : void 0
                }
                function b(e, t, n) {
                    let {id: r, start: o, end: i, size: l} = s;
                    if (s.next(),
                    l >= 0 && r < a) {
                        let a = n;
                        if (l > 4) {
                            let r = s.pos - (l - 4);
                            for (; s.pos > r; )
                                n = b(e, t, n)
                        }
                        t[--n] = a,
                        t[--n] = i - e,
                        t[--n] = o - e,
                        t[--n] = r
                    } else
                        -3 == l ? c = r : -4 == l && (u = r);
                    return n
                }
                let O = []
                  , v = [];
                for (; s.pos > 0; )
                    d(e.start || 0, e.bufferStart || 0, O, v, -1, 0);
                let y = null !== (t = e.length) && void 0 !== t ? t : O.length ? v[0] + O[0].length : 0;
                return new wM(l[e.topID],O.reverse(),v.reverse(),y)
            }(e)
        }
    }
    wM.empty = new wM(mM.none,[],[],0);
    class _M {
        constructor(e, t) {
            this.buffer = e,
            this.index = t
        }
        get id() {
            return this.buffer[this.index - 4]
        }
        get start() {
            return this.buffer[this.index - 3]
        }
        get end() {
            return this.buffer[this.index - 2]
        }
        get size() {
            return this.buffer[this.index - 1]
        }
        get pos() {
            return this.index
        }
        next() {
            this.index -= 4
        }
        fork() {
            return new _M(this.buffer,this.index)
        }
    }
    class kM {
        constructor(e, t, n) {
            this.buffer = e,
            this.length = t,
            this.set = n
        }
        get type() {
            return mM.none
        }
        toString() {
            let e = [];
            for (let t = 0; t < this.buffer.length; )
                e.push(this.childString(t)),
                t = this.buffer[t + 3];
            return e.join(",")
        }
        childString(e) {
            let t = this.buffer[e]
              , n = this.buffer[e + 3]
              , r = this.set.types[t]
              , o = r.name;
            if (/\W/.test(o) && !r.isError && (o = JSON.stringify(o)),
            n == (e += 4))
                return o;
            let i = [];
            for (; e < n; )
                i.push(this.childString(e)),
                e = this.buffer[e + 3];
            return o + "(" + i.join(",") + ")"
        }
        findChild(e, t, n, r, o) {
            let {buffer: i} = this
              , a = -1;
            for (let s = e; s != t && !(SM(o, r, i[s + 1], i[s + 2]) && (a = s,
            n > 0)); s = i[s + 3])
                ;
            return a
        }
        slice(e, t, n) {
            let r = this.buffer
              , o = new Uint16Array(t - e)
              , i = 0;
            for (let a = e, s = 0; a < t; ) {
                o[s++] = r[a++],
                o[s++] = r[a++] - n;
                let t = o[s++] = r[a++] - n;
                o[s++] = r[a++] - e,
                i = Math.max(i, t)
            }
            return new kM(o,i,this.set)
        }
    }
    function SM(e, t, n, r) {
        switch (e) {
        case -2:
            return n < t;
        case -1:
            return r >= t && n < t;
        case 0:
            return n < t && r > t;
        case 1:
            return n <= t && r > t;
        case 2:
            return r > t;
        case 4:
            return !0
        }
    }
    function EM(e, t, n, r) {
        for (var o; e.from == e.to || (n < 1 ? e.from >= t : e.from > t) || (n > -1 ? e.to <= t : e.to < t); ) {
            let t = !r && e instanceof TM && e.index < 0 ? null : e.parent;
            if (!t)
                return e;
            e = t
        }
        let i = r ? 0 : vM.IgnoreOverlays;
        if (r)
            for (let a = e, s = a.parent; s; a = s,
            s = a.parent)
                a instanceof TM && a.index < 0 && (null === (o = s.enter(t, n, i)) || void 0 === o ? void 0 : o.from) != a.from && (e = s);
        for (; ; ) {
            let r = e.enter(t, n, i);
            if (!r)
                return e;
            e = r
        }
    }
    class xM {
        cursor(e=0) {
            return new $M(this,e)
        }
        getChild(e, t=null, n=null) {
            let r = AM(this, e, t, n);
            return r.length ? r[0] : null
        }
        getChildren(e, t=null, n=null) {
            return AM(this, e, t, n)
        }
        resolve(e, t=0) {
            return EM(this, e, t, !1)
        }
        resolveInner(e, t=0) {
            return EM(this, e, t, !0)
        }
        matchContext(e) {
            return CM(this, e)
        }
        enterUnfinishedNodesBefore(e) {
            let t = this.childBefore(e)
              , n = this;
            for (; t; ) {
                let e = t.lastChild;
                if (!e || e.to != t.to)
                    break;
                e.type.isError && e.from == e.to ? (n = t,
                t = e.prevSibling) : t = e
            }
            return n
        }
        get node() {
            return this
        }
        get next() {
            return this.parent
        }
    }
    class TM extends xM {
        constructor(e, t, n, r) {
            super(),
            this._tree = e,
            this.from = t,
            this.index = n,
            this._parent = r
        }
        get type() {
            return this._tree.type
        }
        get name() {
            return this._tree.type.name
        }
        get to() {
            return this.from + this._tree.length
        }
        nextChild(e, t, n, r, o=0) {
            for (let i = this; ; ) {
                for (let {children: a, positions: s} = i._tree, l = t > 0 ? a.length : -1; e != l; e += t) {
                    let l = a[e]
                      , c = s[e] + i.from;
                    if (SM(r, n, c, c + l.length))
                        if (l instanceof kM) {
                            if (o & vM.ExcludeBuffers)
                                continue;
                            let a = l.findChild(0, l.buffer.length, t, n - c, r);
                            if (a > -1)
                                return new DM(new PM(i,l,e,c),null,a)
                        } else if (o & vM.IncludeAnonymous || !l.type.isAnonymous || IM(l)) {
                            let a;
                            if (!(o & vM.IgnoreMounts) && (a = hM.get(l)) && !a.overlay)
                                return new TM(a.tree,c,e,i);
                            let s = new TM(l,c,e,i);
                            return o & vM.IncludeAnonymous || !s.type.isAnonymous ? s : s.nextChild(t < 0 ? l.children.length - 1 : 0, t, n, r)
                        }
                }
                if (o & vM.IncludeAnonymous || !i.type.isAnonymous)
                    return null;
                if (e = i.index >= 0 ? i.index + t : t < 0 ? -1 : i._parent._tree.children.length,
                i = i._parent,
                !i)
                    return null
            }
        }
        get firstChild() {
            return this.nextChild(0, 1, 0, 4)
        }
        get lastChild() {
            return this.nextChild(this._tree.children.length - 1, -1, 0, 4)
        }
        childAfter(e) {
            return this.nextChild(0, 1, e, 2)
        }
        childBefore(e) {
            return this.nextChild(this._tree.children.length - 1, -1, e, -2)
        }
        enter(e, t, n=0) {
            let r;
            if (!(n & vM.IgnoreOverlays) && (r = hM.get(this._tree)) && r.overlay) {
                let n = e - this.from;
                for (let {from: e, to: o} of r.overlay)
                    if ((t > 0 ? e <= n : e < n) && (t < 0 ? o >= n : o > n))
                        return new TM(r.tree,r.overlay[0].from + this.from,-1,this)
            }
            return this.nextChild(0, 1, e, t, n)
        }
        nextSignificantParent() {
            let e = this;
            for (; e.type.isAnonymous && e._parent; )
                e = e._parent;
            return e
        }
        get parent() {
            return this._parent ? this._parent.nextSignificantParent() : null
        }
        get nextSibling() {
            return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null
        }
        get prevSibling() {
            return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null
        }
        get tree() {
            return this._tree
        }
        toTree() {
            return this._tree
        }
        toString() {
            return this._tree.toString()
        }
    }
    function AM(e, t, n, r) {
        let o = e.cursor()
          , i = [];
        if (!o.firstChild())
            return i;
        if (null != n)
            for (let a = !1; !a; )
                if (a = o.type.is(n),
                !o.nextSibling())
                    return i;
        for (; ; ) {
            if (null != r && o.type.is(r))
                return i;
            if (o.type.is(t) && i.push(o.node),
            !o.nextSibling())
                return null == r ? i : []
        }
    }
    function CM(e, t, n=t.length - 1) {
        for (let r = e.parent; n >= 0; r = r.parent) {
            if (!r)
                return !1;
            if (!r.type.isAnonymous) {
                if (t[n] && t[n] != r.name)
                    return !1;
                n--
            }
        }
        return !0
    }
    class PM {
        constructor(e, t, n, r) {
            this.parent = e,
            this.buffer = t,
            this.index = n,
            this.start = r
        }
    }
    class DM extends xM {
        get name() {
            return this.type.name
        }
        get from() {
            return this.context.start + this.context.buffer.buffer[this.index + 1]
        }
        get to() {
            return this.context.start + this.context.buffer.buffer[this.index + 2]
        }
        constructor(e, t, n) {
            super(),
            this.context = e,
            this._parent = t,
            this.index = n,
            this.type = e.buffer.set.types[e.buffer.buffer[n]]
        }
        child(e, t, n) {
            let {buffer: r} = this.context
              , o = r.findChild(this.index + 4, r.buffer[this.index + 3], e, t - this.context.start, n);
            return o < 0 ? null : new DM(this.context,this,o)
        }
        get firstChild() {
            return this.child(1, 0, 4)
        }
        get lastChild() {
            return this.child(-1, 0, 4)
        }
        childAfter(e) {
            return this.child(1, e, 2)
        }
        childBefore(e) {
            return this.child(-1, e, -2)
        }
        enter(e, t, n=0) {
            if (n & vM.ExcludeBuffers)
                return null;
            let {buffer: r} = this.context
              , o = r.findChild(this.index + 4, r.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
            return o < 0 ? null : new DM(this.context,this,o)
        }
        get parent() {
            return this._parent || this.context.parent.nextSignificantParent()
        }
        externalSibling(e) {
            return this._parent ? null : this.context.parent.nextChild(this.context.index + e, e, 0, 4)
        }
        get nextSibling() {
            let {buffer: e} = this.context
              , t = e.buffer[this.index + 3];
            return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new DM(this.context,this._parent,t) : this.externalSibling(1)
        }
        get prevSibling() {
            let {buffer: e} = this.context
              , t = this._parent ? this._parent.index + 4 : 0;
            return this.index == t ? this.externalSibling(-1) : new DM(this.context,this._parent,e.findChild(t, this.index, -1, 0, 4))
        }
        get tree() {
            return null
        }
        toTree() {
            let e = []
              , t = []
              , {buffer: n} = this.context
              , r = this.index + 4
              , o = n.buffer[this.index + 3];
            if (o > r) {
                let i = n.buffer[this.index + 1];
                e.push(n.slice(r, o, i)),
                t.push(0)
            }
            return new wM(this.type,e,t,this.to - this.from)
        }
        toString() {
            return this.context.buffer.childString(this.index)
        }
    }
    function RM(e) {
        if (!e.length)
            return null;
        let t = 0
          , n = e[0];
        for (let i = 1; i < e.length; i++) {
            let r = e[i];
            (r.from > n.from || r.to < n.to) && (n = r,
            t = i)
        }
        let r = n instanceof TM && n.index < 0 ? null : n.parent
          , o = e.slice();
        return r ? o[t] = r : o.splice(t, 1),
        new NM(o,n)
    }
    class NM {
        constructor(e, t) {
            this.heads = e,
            this.node = t
        }
        get next() {
            return RM(this.heads)
        }
    }
    class $M {
        get name() {
            return this.type.name
        }
        constructor(e, t=0) {
            if (this.mode = t,
            this.buffer = null,
            this.stack = [],
            this.index = 0,
            this.bufferNode = null,
            e instanceof TM)
                this.yieldNode(e);
            else {
                this._tree = e.context.parent,
                this.buffer = e.context;
                for (let t = e._parent; t; t = t._parent)
                    this.stack.unshift(t.index);
                this.bufferNode = e,
                this.yieldBuf(e.index)
            }
        }
        yieldNode(e) {
            return !!e && (this._tree = e,
            this.type = e.type,
            this.from = e.from,
            this.to = e.to,
            !0)
        }
        yieldBuf(e, t) {
            this.index = e;
            let {start: n, buffer: r} = this.buffer;
            return this.type = t || r.set.types[r.buffer[e]],
            this.from = n + r.buffer[e + 1],
            this.to = n + r.buffer[e + 2],
            !0
        }
        yield(e) {
            return !!e && (e instanceof TM ? (this.buffer = null,
            this.yieldNode(e)) : (this.buffer = e.context,
            this.yieldBuf(e.index, e.type)))
        }
        toString() {
            return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString()
        }
        enterChild(e, t, n) {
            if (!this.buffer)
                return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, n, this.mode));
            let {buffer: r} = this.buffer
              , o = r.findChild(this.index + 4, r.buffer[this.index + 3], e, t - this.buffer.start, n);
            return !(o < 0) && (this.stack.push(this.index),
            this.yieldBuf(o))
        }
        firstChild() {
            return this.enterChild(1, 0, 4)
        }
        lastChild() {
            return this.enterChild(-1, 0, 4)
        }
        childAfter(e) {
            return this.enterChild(1, e, 2)
        }
        childBefore(e) {
            return this.enterChild(-1, e, -2)
        }
        enter(e, t, n=this.mode) {
            return this.buffer ? !(n & vM.ExcludeBuffers) && this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, n))
        }
        parent() {
            if (!this.buffer)
                return this.yieldNode(this.mode & vM.IncludeAnonymous ? this._tree._parent : this._tree.parent);
            if (this.stack.length)
                return this.yieldBuf(this.stack.pop());
            let e = this.mode & vM.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
            return this.buffer = null,
            this.yieldNode(e)
        }
        sibling(e) {
            if (!this.buffer)
                return !!this._tree._parent && this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode));
            let {buffer: t} = this.buffer
              , n = this.stack.length - 1;
            if (e < 0) {
                let e = n < 0 ? 0 : this.stack[n] + 4;
                if (this.index != e)
                    return this.yieldBuf(t.findChild(e, this.index, -1, 0, 4))
            } else {
                let e = t.buffer[this.index + 3];
                if (e < (n < 0 ? t.buffer.length : t.buffer[this.stack[n] + 3]))
                    return this.yieldBuf(e)
            }
            return n < 0 && this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode))
        }
        nextSibling() {
            return this.sibling(1)
        }
        prevSibling() {
            return this.sibling(-1)
        }
        atLastNode(e) {
            let t, n, {buffer: r} = this;
            if (r) {
                if (e > 0) {
                    if (this.index < r.buffer.buffer.length)
                        return !1
                } else
                    for (let e = 0; e < this.index; e++)
                        if (r.buffer.buffer[e + 3] < this.index)
                            return !1;
                ({index: t, parent: n} = r)
            } else
                ({index: t, _parent: n} = this._tree);
            for (; n; ({index: t, _parent: n} = n))
                if (t > -1)
                    for (let r = t + e, o = e < 0 ? -1 : n._tree.children.length; r != o; r += e) {
                        let e = n._tree.children[r];
                        if (this.mode & vM.IncludeAnonymous || e instanceof kM || !e.type.isAnonymous || IM(e))
                            return !1
                    }
            return !0
        }
        move(e, t) {
            if (t && this.enterChild(e, 0, 4))
                return !0;
            for (; ; ) {
                if (this.sibling(e))
                    return !0;
                if (this.atLastNode(e) || !this.parent())
                    return !1
            }
        }
        next(e=!0) {
            return this.move(1, e)
        }
        prev(e=!0) {
            return this.move(-1, e)
        }
        moveTo(e, t=0) {
            for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
                ;
            for (; this.enterChild(1, e, t); )
                ;
            return this
        }
        get node() {
            if (!this.buffer)
                return this._tree;
            let e = this.bufferNode
              , t = null
              , n = 0;
            if (e && e.context == this.buffer)
                e: for (let r = this.index, o = this.stack.length; o >= 0; ) {
                    for (let i = e; i; i = i._parent)
                        if (i.index == r) {
                            if (r == this.index)
                                return i;
                            t = i,
                            n = o + 1;
                            break e
                        }
                    r = this.stack[--o]
                }
            for (let r = n; r < this.stack.length; r++)
                t = new DM(this.buffer,t,this.stack[r]);
            return this.bufferNode = new DM(this.buffer,t,this.index)
        }
        get tree() {
            return this.buffer ? null : this._tree._tree
        }
        iterate(e, t) {
            for (let n = 0; ; ) {
                let r = !1;
                if (this.type.isAnonymous || !1 !== e(this)) {
                    if (this.firstChild()) {
                        n++;
                        continue
                    }
                    this.type.isAnonymous || (r = !0)
                }
                for (; r && t && t(this),
                r = this.type.isAnonymous,
                !this.nextSibling(); ) {
                    if (!n)
                        return;
                    this.parent(),
                    n--,
                    r = !0
                }
            }
        }
        matchContext(e) {
            if (!this.buffer)
                return CM(this.node, e);
            let {buffer: t} = this.buffer
              , {types: n} = t.set;
            for (let r = e.length - 1, o = this.stack.length - 1; r >= 0; o--) {
                if (o < 0)
                    return CM(this.node, e, r);
                let i = n[t.buffer[this.stack[o]]];
                if (!i.isAnonymous) {
                    if (e[r] && e[r] != i.name)
                        return !1;
                    r--
                }
            }
            return !0
        }
    }
    function IM(e) {
        return e.children.some((e=>e instanceof kM || !e.type.isAnonymous || IM(e)))
    }
    const MM = new WeakMap;
    function LM(e, t) {
        if (!e.isAnonymous || t instanceof kM || t.type != e)
            return 1;
        let n = MM.get(t);
        if (null == n) {
            n = 1;
            for (let r of t.children) {
                if (r.type != e || !(r instanceof wM)) {
                    n = 1;
                    break
                }
                n += LM(e, r)
            }
            MM.set(t, n)
        }
        return n
    }
    function QM(e, t, n, r, o, i, a, s, l) {
        let c = 0;
        for (let h = r; h < o; h++)
            c += LM(e, t[h]);
        let u = Math.ceil(1.5 * c / 8)
          , d = []
          , p = [];
        return function t(n, r, o, a, s) {
            for (let c = o; c < a; ) {
                let o = c
                  , h = r[c]
                  , f = LM(e, n[c]);
                for (c++; c < a; c++) {
                    let t = LM(e, n[c]);
                    if (f + t >= u)
                        break;
                    f += t
                }
                if (c == o + 1) {
                    if (f > u) {
                        let e = n[o];
                        t(e.children, e.positions, 0, e.children.length, r[o] + s);
                        continue
                    }
                    d.push(n[o])
                } else {
                    let t = r[c - 1] + n[c - 1].length - h;
                    d.push(QM(e, n, r, o, c, h, t, null, l))
                }
                p.push(h + s - i)
            }
        }(t, n, r, o, 0),
        (s || l)(d, p, a)
    }
    class BM {
        constructor() {
            this.map = new WeakMap
        }
        setBuffer(e, t, n) {
            let r = this.map.get(e);
            r || this.map.set(e, r = new Map),
            r.set(t, n)
        }
        getBuffer(e, t) {
            let n = this.map.get(e);
            return n && n.get(t)
        }
        set(e, t) {
            e instanceof DM ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof TM && this.map.set(e.tree, t)
        }
        get(e) {
            return e instanceof DM ? this.getBuffer(e.context.buffer, e.index) : e instanceof TM ? this.map.get(e.tree) : void 0
        }
        cursorSet(e, t) {
            e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t)
        }
        cursorGet(e) {
            return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree)
        }
    }
    class UM {
        constructor(e, t, n, r, o=!1, i=!1) {
            this.from = e,
            this.to = t,
            this.tree = n,
            this.offset = r,
            this.open = (o ? 1 : 0) | (i ? 2 : 0)
        }
        get openStart() {
            return (1 & this.open) > 0
        }
        get openEnd() {
            return (2 & this.open) > 0
        }
        static addTree(e, t=[], n=!1) {
            let r = [new UM(0,e.length,e,0,!1,n)];
            for (let o of t)
                o.to > e.length && r.push(o);
            return r
        }
        static applyChanges(e, t, n=128) {
            if (!t.length)
                return e;
            let r = []
              , o = 1
              , i = e.length ? e[0] : null;
            for (let a = 0, s = 0, l = 0; ; a++) {
                let c = a < t.length ? t[a] : null
                  , u = c ? c.fromA : 1e9;
                if (u - s >= n)
                    for (; i && i.from < u; ) {
                        let t = i;
                        if (s >= t.from || u <= t.to || l) {
                            let e = Math.max(t.from, s) - l
                              , n = Math.min(t.to, u) - l;
                            t = e >= n ? null : new UM(e,n,t.tree,t.offset + l,a > 0,!!c)
                        }
                        if (t && r.push(t),
                        i.to > u)
                            break;
                        i = o < e.length ? e[o++] : null
                    }
                if (!c)
                    break;
                s = c.toA,
                l = c.toA - c.toB
            }
            return r
        }
    }
    class FM {
        startParse(e, t, n) {
            return "string" == typeof e && (e = new jM(e)),
            n = n ? n.length ? n.map((e=>new dM(e.from,e.to))) : [new dM(0,0)] : [new dM(0,e.length)],
            this.createParse(e, t || [], n)
        }
        parse(e, t, n) {
            let r = this.startParse(e, t, n);
            for (; ; ) {
                let e = r.advance();
                if (e)
                    return e
            }
        }
    }
    class jM {
        constructor(e) {
            this.string = e
        }
        get length() {
            return this.string.length
        }
        chunk(e) {
            return this.string.slice(e)
        }
        get lineChunks() {
            return !1
        }
        read(e, t) {
            return this.string.slice(e, t)
        }
    }
    class zM {
        constructor(e, t, n, r, o) {
            this.parser = e,
            this.parse = t,
            this.overlay = n,
            this.target = r,
            this.from = o
        }
    }
    function qM(e) {
        if (!e.length || e.some((e=>e.from >= e.to)))
            throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(e))
    }
    class HM {
        constructor(e, t, n, r, o, i, a) {
            this.parser = e,
            this.predicate = t,
            this.mounts = n,
            this.index = r,
            this.start = o,
            this.target = i,
            this.prev = a,
            this.depth = 0,
            this.ranges = []
        }
    }
    const ZM = new pM({
        perNode: !0
    });
    class WM {
        constructor(e, t, n, r, o) {
            this.nest = t,
            this.input = n,
            this.fragments = r,
            this.ranges = o,
            this.inner = [],
            this.innerDone = 0,
            this.baseTree = null,
            this.stoppedAt = null,
            this.baseParse = e
        }
        advance() {
            if (this.baseParse) {
                let e = this.baseParse.advance();
                if (!e)
                    return null;
                if (this.baseParse = null,
                this.baseTree = e,
                this.startInner(),
                null != this.stoppedAt)
                    for (let t of this.inner)
                        t.parse.stopAt(this.stoppedAt)
            }
            if (this.innerDone == this.inner.length) {
                let e = this.baseTree;
                return null != this.stoppedAt && (e = new wM(e.type,e.children,e.positions,e.length,e.propValues.concat([[ZM, this.stoppedAt]]))),
                e
            }
            let e = this.inner[this.innerDone]
              , t = e.parse.advance();
            if (t) {
                this.innerDone++;
                let n = Object.assign(Object.create(null), e.target.props);
                n[pM.mounted.id] = new hM(t,e.overlay,e.parser),
                e.target.props = n
            }
            return null
        }
        get parsedPos() {
            if (this.baseParse)
                return 0;
            let e = this.input.length;
            for (let t = this.innerDone; t < this.inner.length; t++)
                this.inner[t].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
            return e
        }
        stopAt(e) {
            if (this.stoppedAt = e,
            this.baseParse)
                this.baseParse.stopAt(e);
            else
                for (let t = this.innerDone; t < this.inner.length; t++)
                    this.inner[t].parse.stopAt(e)
        }
        startInner() {
            let e = new KM(this.fragments)
              , t = null
              , n = null
              , r = new $M(new TM(this.baseTree,this.ranges[0].from,0,null),vM.IncludeAnonymous | vM.IgnoreMounts);
            e: for (let o, i; ; ) {
                let a, s = !0;
                if (null != this.stoppedAt && r.from >= this.stoppedAt)
                    s = !1;
                else if (e.hasNode(r)) {
                    if (t) {
                        let e = t.mounts.find((e=>e.frag.from <= r.from && e.frag.to >= r.to && e.mount.overlay));
                        if (e)
                            for (let n of e.mount.overlay) {
                                let o = n.from + e.pos
                                  , i = n.to + e.pos;
                                o >= r.from && i <= r.to && !t.ranges.some((e=>e.from < i && e.to > o)) && t.ranges.push({
                                    from: o,
                                    to: i
                                })
                            }
                    }
                    s = !1
                } else if (n && (i = XM(n.ranges, r.from, r.to)))
                    s = 2 != i;
                else if (!r.type.isAnonymous && (o = this.nest(r, this.input)) && (r.from < r.to || !o.overlay)) {
                    r.tree || GM(r);
                    let i = e.findMounts(r.from, o.parser);
                    if ("function" == typeof o.overlay)
                        t = new HM(o.parser,o.overlay,i,this.inner.length,r.from,r.tree,t);
                    else {
                        let e = JM(this.ranges, o.overlay || (r.from < r.to ? [new dM(r.from,r.to)] : []));
                        e.length && qM(e),
                        !e.length && o.overlay || this.inner.push(new zM(o.parser,e.length ? o.parser.startParse(this.input, tL(i, e), e) : o.parser.startParse(""),o.overlay ? o.overlay.map((e=>new dM(e.from - r.from,e.to - r.from))) : null,r.tree,e.length ? e[0].from : r.from)),
                        o.overlay ? e.length && (n = {
                            ranges: e,
                            depth: 0,
                            prev: n
                        }) : s = !1
                    }
                } else
                    t && (a = t.predicate(r)) && (!0 === a && (a = new dM(r.from,r.to)),
                    a.from < a.to && t.ranges.push(a));
                if (s && r.firstChild())
                    t && t.depth++,
                    n && n.depth++;
                else
                    for (; !r.nextSibling(); ) {
                        if (!r.parent())
                            break e;
                        if (t && !--t.depth) {
                            let e = JM(this.ranges, t.ranges);
                            e.length && (qM(e),
                            this.inner.splice(t.index, 0, new zM(t.parser,t.parser.startParse(this.input, tL(t.mounts, e), e),t.ranges.map((e=>new dM(e.from - t.start,e.to - t.start))),t.target,e[0].from))),
                            t = t.prev
                        }
                        n && !--n.depth && (n = n.prev)
                    }
            }
        }
    }
    function XM(e, t, n) {
        for (let r of e) {
            if (r.from >= n)
                break;
            if (r.to > t)
                return r.from <= t && r.to >= n ? 2 : 1
        }
        return 0
    }
    function VM(e, t, n, r, o, i) {
        if (t < n) {
            let a = e.buffer[t + 1];
            r.push(e.slice(t, n, a)),
            o.push(a - i)
        }
    }
    function GM(e) {
        let {node: t} = e
          , n = []
          , r = t.context.buffer;
        do {
            n.push(e.index),
            e.parent()
        } while (!e.tree);
        let o = e.tree
          , i = o.children.indexOf(r)
          , a = o.children[i]
          , s = a.buffer
          , l = [i];
        o.children[i] = function e(r, o, i, c, u, d) {
            let p = n[d]
              , h = []
              , f = [];
            VM(a, r, p, h, f, c);
            let m = s[p + 1]
              , g = s[p + 2];
            l.push(h.length);
            let b = d ? e(p + 4, s[p + 3], a.set.types[s[p]], m, g - m, d - 1) : t.toTree();
            return h.push(b),
            f.push(m - c),
            VM(a, s[p + 3], o, h, f, c),
            new wM(i,h,f,u)
        }(0, s.length, mM.none, 0, a.length, n.length - 1);
        for (let c of l) {
            let t = e.tree.children[c]
              , n = e.tree.positions[c];
            e.yield(new TM(t,n + e.from,c,e._tree))
        }
    }
    class YM {
        constructor(e, t) {
            this.offset = t,
            this.done = !1,
            this.cursor = e.cursor(vM.IncludeAnonymous | vM.IgnoreMounts)
        }
        moveTo(e) {
            let {cursor: t} = this
              , n = e - this.offset;
            for (; !this.done && t.from < n; )
                t.to >= e && t.enter(n, 1, vM.IgnoreOverlays | vM.ExcludeBuffers) || t.next(!1) || (this.done = !0)
        }
        hasNode(e) {
            if (this.moveTo(e.from),
            !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
                for (let t = this.cursor.tree; ; ) {
                    if (t == e.tree)
                        return !0;
                    if (!(t.children.length && 0 == t.positions[0] && t.children[0]instanceof wM))
                        break;
                    t = t.children[0]
                }
            return !1
        }
    }
    let KM = class {
        constructor(e) {
            var t;
            if (this.fragments = e,
            this.curTo = 0,
            this.fragI = 0,
            e.length) {
                let n = this.curFrag = e[0];
                this.curTo = null !== (t = n.tree.prop(ZM)) && void 0 !== t ? t : n.to,
                this.inner = new YM(n.tree,-n.offset)
            } else
                this.curFrag = this.inner = null
        }
        hasNode(e) {
            for (; this.curFrag && e.from >= this.curTo; )
                this.nextFrag();
            return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e)
        }
        nextFrag() {
            var e;
            if (this.fragI++,
            this.fragI == this.fragments.length)
                this.curFrag = this.inner = null;
            else {
                let t = this.curFrag = this.fragments[this.fragI];
                this.curTo = null !== (e = t.tree.prop(ZM)) && void 0 !== e ? e : t.to,
                this.inner = new YM(t.tree,-t.offset)
            }
        }
        findMounts(e, t) {
            var n;
            let r = [];
            if (this.inner) {
                this.inner.cursor.moveTo(e, 1);
                for (let e = this.inner.cursor.node; e; e = e.parent) {
                    let o = null === (n = e.tree) || void 0 === n ? void 0 : n.prop(pM.mounted);
                    if (o && o.parser == t)
                        for (let t = this.fragI; t < this.fragments.length; t++) {
                            let n = this.fragments[t];
                            if (n.from >= e.to)
                                break;
                            n.tree == this.curFrag.tree && r.push({
                                frag: n,
                                pos: e.from - n.offset,
                                mount: o
                            })
                        }
                }
            }
            return r
        }
    }
    ;
    function JM(e, t) {
        let n = null
          , r = t;
        for (let o = 1, i = 0; o < e.length; o++) {
            let a = e[o - 1].to
              , s = e[o].from;
            for (; i < r.length; i++) {
                let e = r[i];
                if (e.from >= s)
                    break;
                e.to <= a || (n || (r = n = t.slice()),
                e.from < a ? (n[i] = new dM(e.from,a),
                e.to > s && n.splice(i + 1, 0, new dM(s,e.to))) : e.to > s ? n[i--] = new dM(s,e.to) : n.splice(i--, 1))
            }
        }
        return r
    }
    function eL(e, t, n, r) {
        let o = 0
          , i = 0
          , a = !1
          , s = !1
          , l = -1e9
          , c = [];
        for (; ; ) {
            let u = o == e.length ? 1e9 : a ? e[o].to : e[o].from
              , d = i == t.length ? 1e9 : s ? t[i].to : t[i].from;
            if (a != s) {
                let e = Math.max(l, n)
                  , t = Math.min(u, d, r);
                e < t && c.push(new dM(e,t))
            }
            if (l = Math.min(u, d),
            1e9 == l)
                break;
            u == l && (a ? (a = !1,
            o++) : a = !0),
            d == l && (s ? (s = !1,
            i++) : s = !0)
        }
        return c
    }
    function tL(e, t) {
        let n = [];
        for (let {pos: r, mount: o, frag: i} of e) {
            let e = r + (o.overlay ? o.overlay[0].from : 0)
              , a = e + o.tree.length
              , s = Math.max(i.from, e)
              , l = Math.min(i.to, a);
            if (o.overlay) {
                let a = o.overlay.map((e=>new dM(e.from + r,e.to + r)))
                  , c = eL(t, a, s, l);
                for (let t = 0, r = s; ; t++) {
                    let a = t == c.length
                      , s = a ? l : c[t].from;
                    if (s > r && n.push(new UM(r,s,o.tree,-e,i.from >= r || i.openStart,i.to <= s || i.openEnd)),
                    a)
                        break;
                    r = c[t].to
                }
            } else
                n.push(new UM(s,l,o.tree,-e,i.from >= e || i.openStart,i.to <= a || i.openEnd))
        }
        return n
    }
    let nL = 0
      , rL = class e {
        constructor(e, t, n) {
            this.set = e,
            this.base = t,
            this.modified = n,
            this.id = nL++
        }
        static define(t) {
            if (null == t ? void 0 : t.base)
                throw new Error("Can not derive from a modified tag");
            let n = new e([],null,[]);
            if (n.set.push(n),
            t)
                for (let e of t.set)
                    n.set.push(e);
            return n
        }
        static defineModifier() {
            let e = new iL;
            return t=>t.modified.indexOf(e) > -1 ? t : iL.get(t.base || t, t.modified.concat(e).sort(((e,t)=>e.id - t.id)))
        }
    }
      , oL = 0;
    class iL {
        constructor() {
            this.instances = [],
            this.id = oL++
        }
        static get(e, t) {
            if (!t.length)
                return e;
            let n = t[0].instances.find((n=>{
                return n.base == e && (r = t,
                o = n.modified,
                r.length == o.length && r.every(((e,t)=>e == o[t])));
                var r, o
            }
            ));
            if (n)
                return n;
            let r = []
              , o = new rL(r,e,t);
            for (let a of t)
                a.instances.push(o);
            let i = function(e) {
                let t = [[]];
                for (let n = 0; n < e.length; n++)
                    for (let r = 0, o = t.length; r < o; r++)
                        t.push(t[r].concat(e[n]));
                return t.sort(((e,t)=>t.length - e.length))
            }(t);
            for (let a of e.set)
                if (!a.modified.length)
                    for (let e of i)
                        r.push(iL.get(a, e));
            return o
        }
    }
    function aL(e) {
        let t = Object.create(null);
        for (let n in e) {
            let r = e[n];
            Array.isArray(r) || (r = [r]);
            for (let e of n.split(" "))
                if (e) {
                    let n = []
                      , o = 2
                      , i = e;
                    for (let t = 0; ; ) {
                        if ("..." == i && t > 0 && t + 3 == e.length) {
                            o = 1;
                            break
                        }
                        let r = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(i);
                        if (!r)
                            throw new RangeError("Invalid path: " + e);
                        if (n.push("*" == r[0] ? "" : '"' == r[0][0] ? JSON.parse(r[0]) : r[0]),
                        t += r[0].length,
                        t == e.length)
                            break;
                        let a = e[t++];
                        if (t == e.length && "!" == a) {
                            o = 0;
                            break
                        }
                        if ("/" != a)
                            throw new RangeError("Invalid path: " + e);
                        i = e.slice(t)
                    }
                    let a = n.length - 1
                      , s = n[a];
                    if (!s)
                        throw new RangeError("Invalid path: " + e);
                    let l = new lL(r,o,a > 0 ? n.slice(0, a) : null);
                    t[s] = l.sort(t[s])
                }
        }
        return sL.add(t)
    }
    const sL = new pM;
    class lL {
        constructor(e, t, n, r) {
            this.tags = e,
            this.mode = t,
            this.context = n,
            this.next = r
        }
        get opaque() {
            return 0 == this.mode
        }
        get inherit() {
            return 1 == this.mode
        }
        sort(e) {
            return !e || e.depth < this.depth ? (this.next = e,
            this) : (e.next = this.sort(e.next),
            e)
        }
        get depth() {
            return this.context ? this.context.length : 0
        }
    }
    function cL(e, t) {
        let n = Object.create(null);
        for (let i of e)
            if (Array.isArray(i.tag))
                for (let e of i.tag)
                    n[e.id] = i.class;
            else
                n[i.tag.id] = i.class;
        let {scope: r, all: o=null} = t || {};
        return {
            style: e=>{
                let t = o;
                for (let r of e)
                    for (let e of r.set) {
                        let r = n[e.id];
                        if (r) {
                            t = t ? t + " " + r : r;
                            break
                        }
                    }
                return t
            }
            ,
            scope: r
        }
    }
    function uL(e, t, n, r=0, o=e.length) {
        let i = new dL(r,Array.isArray(t) ? t : [t],n);
        i.highlightRange(e.cursor(), r, o, "", i.highlighters),
        i.flush(o)
    }
    lL.empty = new lL([],2,null);
    class dL {
        constructor(e, t, n) {
            this.at = e,
            this.highlighters = t,
            this.span = n,
            this.class = ""
        }
        startSpan(e, t) {
            t != this.class && (this.flush(e),
            e > this.at && (this.at = e),
            this.class = t)
        }
        flush(e) {
            e > this.at && this.class && this.span(this.at, e, this.class)
        }
        highlightRange(e, t, n, r, o) {
            let {type: i, from: a, to: s} = e;
            if (a >= n || s <= t)
                return;
            i.isTop && (o = this.highlighters.filter((e=>!e.scope || e.scope(i))));
            let l = r
              , c = function(e) {
                let t = e.type.prop(sL);
                for (; t && t.context && !e.matchContext(t.context); )
                    t = t.next;
                return t || null
            }(e) || lL.empty
              , u = function(e, t) {
                let n = null;
                for (let r of e) {
                    let e = r.style(t);
                    e && (n = n ? n + " " + e : e)
                }
                return n
            }(o, c.tags);
            if (u && (l && (l += " "),
            l += u,
            1 == c.mode && (r += (r ? " " : "") + u)),
            this.startSpan(Math.max(t, a), l),
            c.opaque)
                return;
            let d = e.tree && e.tree.prop(pM.mounted);
            if (d && d.overlay) {
                let i = e.node.enter(d.overlay[0].from + a, 1)
                  , c = this.highlighters.filter((e=>!e.scope || e.scope(d.tree.type)))
                  , u = e.firstChild();
                for (let p = 0, h = a; ; p++) {
                    let f = p < d.overlay.length ? d.overlay[p] : null
                      , m = f ? f.from + a : s
                      , g = Math.max(t, h)
                      , b = Math.min(n, m);
                    if (g < b && u)
                        for (; e.from < b && (this.highlightRange(e, g, b, r, o),
                        this.startSpan(Math.min(b, e.to), l),
                        !(e.to >= m) && e.nextSibling()); )
                            ;
                    if (!f || m > n)
                        break;
                    h = f.to + a,
                    h > t && (this.highlightRange(i.cursor(), Math.max(t, f.from + a), Math.min(n, h), "", c),
                    this.startSpan(Math.min(n, h), l))
                }
                u && e.parent()
            } else if (e.firstChild()) {
                d && (r = "");
                do {
                    if (!(e.to <= t)) {
                        if (e.from >= n)
                            break;
                        this.highlightRange(e, t, n, r, o),
                        this.startSpan(Math.min(n, e.to), l)
                    }
                } while (e.nextSibling());
                e.parent()
            }
        }
    }
    const pL = rL.define
      , hL = pL()
      , fL = pL()
      , mL = pL(fL)
      , gL = pL(fL)
      , bL = pL()
      , OL = pL(bL)
      , vL = pL(bL)
      , yL = pL()
      , wL = pL(yL)
      , _L = pL()
      , kL = pL()
      , SL = pL()
      , EL = pL(SL)
      , xL = pL()
      , TL = {
        comment: hL,
        lineComment: pL(hL),
        blockComment: pL(hL),
        docComment: pL(hL),
        name: fL,
        variableName: pL(fL),
        typeName: mL,
        tagName: pL(mL),
        propertyName: gL,
        attributeName: pL(gL),
        className: pL(fL),
        labelName: pL(fL),
        namespace: pL(fL),
        macroName: pL(fL),
        literal: bL,
        string: OL,
        docString: pL(OL),
        character: pL(OL),
        attributeValue: pL(OL),
        number: vL,
        integer: pL(vL),
        float: pL(vL),
        bool: pL(bL),
        regexp: pL(bL),
        escape: pL(bL),
        color: pL(bL),
        url: pL(bL),
        keyword: _L,
        self: pL(_L),
        null: pL(_L),
        atom: pL(_L),
        unit: pL(_L),
        modifier: pL(_L),
        operatorKeyword: pL(_L),
        controlKeyword: pL(_L),
        definitionKeyword: pL(_L),
        moduleKeyword: pL(_L),
        operator: kL,
        derefOperator: pL(kL),
        arithmeticOperator: pL(kL),
        logicOperator: pL(kL),
        bitwiseOperator: pL(kL),
        compareOperator: pL(kL),
        updateOperator: pL(kL),
        definitionOperator: pL(kL),
        typeOperator: pL(kL),
        controlOperator: pL(kL),
        punctuation: SL,
        separator: pL(SL),
        bracket: EL,
        angleBracket: pL(EL),
        squareBracket: pL(EL),
        paren: pL(EL),
        brace: pL(EL),
        content: yL,
        heading: wL,
        heading1: pL(wL),
        heading2: pL(wL),
        heading3: pL(wL),
        heading4: pL(wL),
        heading5: pL(wL),
        heading6: pL(wL),
        contentSeparator: pL(yL),
        list: pL(yL),
        quote: pL(yL),
        emphasis: pL(yL),
        strong: pL(yL),
        link: pL(yL),
        monospace: pL(yL),
        strikethrough: pL(yL),
        inserted: pL(),
        deleted: pL(),
        changed: pL(),
        invalid: pL(),
        meta: xL,
        documentMeta: pL(xL),
        annotation: pL(xL),
        processingInstruction: pL(xL),
        definition: rL.defineModifier(),
        constant: rL.defineModifier(),
        function: rL.defineModifier(),
        standard: rL.defineModifier(),
        local: rL.defineModifier(),
        special: rL.defineModifier()
    };
    var AL;
    cL([{
        tag: TL.link,
        class: "tok-link"
    }, {
        tag: TL.heading,
        class: "tok-heading"
    }, {
        tag: TL.emphasis,
        class: "tok-emphasis"
    }, {
        tag: TL.strong,
        class: "tok-strong"
    }, {
        tag: TL.keyword,
        class: "tok-keyword"
    }, {
        tag: TL.atom,
        class: "tok-atom"
    }, {
        tag: TL.bool,
        class: "tok-bool"
    }, {
        tag: TL.url,
        class: "tok-url"
    }, {
        tag: TL.labelName,
        class: "tok-labelName"
    }, {
        tag: TL.inserted,
        class: "tok-inserted"
    }, {
        tag: TL.deleted,
        class: "tok-deleted"
    }, {
        tag: TL.literal,
        class: "tok-literal"
    }, {
        tag: TL.string,
        class: "tok-string"
    }, {
        tag: TL.number,
        class: "tok-number"
    }, {
        tag: [TL.regexp, TL.escape, TL.special(TL.string)],
        class: "tok-string2"
    }, {
        tag: TL.variableName,
        class: "tok-variableName"
    }, {
        tag: TL.local(TL.variableName),
        class: "tok-variableName tok-local"
    }, {
        tag: TL.definition(TL.variableName),
        class: "tok-variableName tok-definition"
    }, {
        tag: TL.special(TL.variableName),
        class: "tok-variableName2"
    }, {
        tag: TL.definition(TL.propertyName),
        class: "tok-propertyName tok-definition"
    }, {
        tag: TL.typeName,
        class: "tok-typeName"
    }, {
        tag: TL.namespace,
        class: "tok-namespace"
    }, {
        tag: TL.className,
        class: "tok-className"
    }, {
        tag: TL.macroName,
        class: "tok-macroName"
    }, {
        tag: TL.propertyName,
        class: "tok-propertyName"
    }, {
        tag: TL.operator,
        class: "tok-operator"
    }, {
        tag: TL.comment,
        class: "tok-comment"
    }, {
        tag: TL.meta,
        class: "tok-meta"
    }, {
        tag: TL.invalid,
        class: "tok-invalid"
    }, {
        tag: TL.punctuation,
        class: "tok-punctuation"
    }]);
    const CL = new pM;
    function PL(e) {
        return rP.define({
            combine: e ? t=>t.concat(e) : void 0
        })
    }
    const DL = new pM;
    class RL {
        constructor(e, t, n=[], r="") {
            this.data = e,
            this.name = r,
            HP.prototype.hasOwnProperty("tree") || Object.defineProperty(HP.prototype, "tree", {
                get() {
                    return IL(this)
                }
            }),
            this.parser = t,
            this.extension = [qL.of(this), HP.languageData.of(((e,t,n)=>{
                let r = NL(e, t, n)
                  , o = r.type.prop(CL);
                if (!o)
                    return [];
                let i = e.facet(o)
                  , a = r.type.prop(DL);
                if (a) {
                    let o = r.resolve(t - r.from, n);
                    for (let t of a)
                        if (t.test(o, e)) {
                            let n = e.facet(t.facet);
                            return "replace" == t.type ? n : n.concat(i)
                        }
                }
                return i
            }
            ))].concat(n)
        }
        isActiveAt(e, t, n=-1) {
            return NL(e, t, n).type.prop(CL) == this.data
        }
        findRegions(e) {
            let t = e.facet(qL);
            if ((null == t ? void 0 : t.data) == this.data)
                return [{
                    from: 0,
                    to: e.doc.length
                }];
            if (!t || !t.allowsNesting)
                return [];
            let n = []
              , r = (e,t)=>{
                if (e.prop(CL) == this.data)
                    return void n.push({
                        from: t,
                        to: t + e.length
                    });
                let o = e.prop(pM.mounted);
                if (o) {
                    if (o.tree.prop(CL) == this.data) {
                        if (o.overlay)
                            for (let e of o.overlay)
                                n.push({
                                    from: e.from + t,
                                    to: e.to + t
                                });
                        else
                            n.push({
                                from: t,
                                to: t + e.length
                            });
                        return
                    }
                    if (o.overlay) {
                        let e = n.length;
                        if (r(o.tree, o.overlay[0].from + t),
                        n.length > e)
                            return
                    }
                }
                for (let n = 0; n < e.children.length; n++) {
                    let o = e.children[n];
                    o instanceof wM && r(o, e.positions[n] + t)
                }
            }
            ;
            return r(IL(e), 0),
            n
        }
        get allowsNesting() {
            return !0
        }
    }
    function NL(e, t, n) {
        let r = e.facet(qL)
          , o = IL(e).topNode;
        if (!r || r.allowsNesting)
            for (let i = o; i; i = i.enter(t, n, vM.ExcludeBuffers))
                i.type.isTop && (o = i);
        return o
    }
    RL.setState = NP.define();
    class $L extends RL {
        constructor(e, t, n) {
            super(e, t, [], n),
            this.parser = t
        }
        static define(e) {
            let t = PL(e.languageData);
            return new $L(t,e.parser.configure({
                props: [CL.add((e=>e.isTop ? t : void 0))]
            }),e.name)
        }
        configure(e, t) {
            return new $L(this.data,this.parser.configure(e),t || this.name)
        }
        get allowsNesting() {
            return this.parser.hasWrappers()
        }
    }
    function IL(e) {
        let t = e.field(RL.state, !1);
        return t ? t.tree : wM.empty
    }
    class ML {
        constructor(e) {
            this.doc = e,
            this.cursorPos = 0,
            this.string = "",
            this.cursor = e.iter()
        }
        get length() {
            return this.doc.length
        }
        syncTo(e) {
            return this.string = this.cursor.next(e - this.cursorPos).value,
            this.cursorPos = e + this.string.length,
            this.cursorPos - this.string.length
        }
        chunk(e) {
            return this.syncTo(e),
            this.string
        }
        get lineChunks() {
            return !0
        }
        read(e, t) {
            let n = this.cursorPos - this.string.length;
            return e < n || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - n, t - n)
        }
    }
    let LL = null;
    class QL {
        constructor(e, t, n=[], r, o, i, a, s) {
            this.parser = e,
            this.state = t,
            this.fragments = n,
            this.tree = r,
            this.treeLen = o,
            this.viewport = i,
            this.skipped = a,
            this.scheduleOn = s,
            this.parse = null,
            this.tempSkipped = []
        }
        static create(e, t, n) {
            return new QL(e,t,[],wM.empty,0,n,[],null)
        }
        startParse() {
            return this.parser.startParse(new ML(this.state.doc), this.fragments)
        }
        work(e, t) {
            return null != t && t >= this.state.doc.length && (t = void 0),
            this.tree != wM.empty && this.isDone(null != t ? t : this.state.doc.length) ? (this.takeTree(),
            !0) : this.withContext((()=>{
                var n;
                if ("number" == typeof e) {
                    let t = Date.now() + e;
                    e = ()=>Date.now() > t
                }
                for (this.parse || (this.parse = this.startParse()),
                null != t && (null == this.parse.stoppedAt || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
                    let r = this.parse.advance();
                    if (r) {
                        if (this.fragments = this.withoutTempSkipped(UM.addTree(r, this.fragments, null != this.parse.stoppedAt)),
                        this.treeLen = null !== (n = this.parse.stoppedAt) && void 0 !== n ? n : this.state.doc.length,
                        this.tree = r,
                        this.parse = null,
                        !(this.treeLen < (null != t ? t : this.state.doc.length)))
                            return !0;
                        this.parse = this.startParse()
                    }
                    if (e())
                        return !1
                }
            }
            ))
        }
        takeTree() {
            let e, t;
            this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((null == this.parse.stoppedAt || this.parse.stoppedAt > e) && this.parse.stopAt(e),
            this.withContext((()=>{
                for (; !(t = this.parse.advance()); )
                    ;
            }
            )),
            this.treeLen = e,
            this.tree = t,
            this.fragments = this.withoutTempSkipped(UM.addTree(this.tree, this.fragments, !0)),
            this.parse = null)
        }
        withContext(e) {
            let t = LL;
            LL = this;
            try {
                return e()
            } finally {
                LL = t
            }
        }
        withoutTempSkipped(e) {
            for (let t; t = this.tempSkipped.pop(); )
                e = BL(e, t.from, t.to);
            return e
        }
        changes(e, t) {
            let {fragments: n, tree: r, treeLen: o, viewport: i, skipped: a} = this;
            if (this.takeTree(),
            !e.empty) {
                let t = [];
                if (e.iterChangedRanges(((e,n,r,o)=>t.push({
                    fromA: e,
                    toA: n,
                    fromB: r,
                    toB: o
                }))),
                n = UM.applyChanges(n, t),
                r = wM.empty,
                o = 0,
                i = {
                    from: e.mapPos(i.from, -1),
                    to: e.mapPos(i.to, 1)
                },
                this.skipped.length) {
                    a = [];
                    for (let t of this.skipped) {
                        let n = e.mapPos(t.from, 1)
                          , r = e.mapPos(t.to, -1);
                        n < r && a.push({
                            from: n,
                            to: r
                        })
                    }
                }
            }
            return new QL(this.parser,t,n,r,o,i,a,this.scheduleOn)
        }
        updateViewport(e) {
            if (this.viewport.from == e.from && this.viewport.to == e.to)
                return !1;
            this.viewport = e;
            let t = this.skipped.length;
            for (let n = 0; n < this.skipped.length; n++) {
                let {from: t, to: r} = this.skipped[n];
                t < e.to && r > e.from && (this.fragments = BL(this.fragments, t, r),
                this.skipped.splice(n--, 1))
            }
            return !(this.skipped.length >= t) && (this.reset(),
            !0)
        }
        reset() {
            this.parse && (this.takeTree(),
            this.parse = null)
        }
        skipUntilInView(e, t) {
            this.skipped.push({
                from: e,
                to: t
            })
        }
        static getSkippingParser(e) {
            return new class extends FM {
                createParse(t, n, r) {
                    let o = r[0].from
                      , i = r[r.length - 1].to
                      , a = {
                        parsedPos: o,
                        advance() {
                            let t = LL;
                            if (t) {
                                for (let e of r)
                                    t.tempSkipped.push(e);
                                e && (t.scheduleOn = t.scheduleOn ? Promise.all([t.scheduleOn, e]) : e)
                            }
                            return this.parsedPos = i,
                            new wM(mM.none,[],[],i - o)
                        },
                        stoppedAt: null,
                        stopAt() {}
                    };
                    return a
                }
            }
        }
        isDone(e) {
            e = Math.min(e, this.state.doc.length);
            let t = this.fragments;
            return this.treeLen >= e && t.length && 0 == t[0].from && t[0].to >= e
        }
        static get() {
            return LL
        }
    }
    function BL(e, t, n) {
        return UM.applyChanges(e, [{
            fromA: t,
            toA: n,
            fromB: t,
            toB: n
        }])
    }
    class UL {
        constructor(e) {
            this.context = e,
            this.tree = e.tree
        }
        apply(e) {
            if (!e.docChanged && this.tree == this.context.tree)
                return this;
            let t = this.context.changes(e.changes, e.state)
              , n = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
            return t.work(20, n) || t.takeTree(),
            new UL(t)
        }
        static init(e) {
            let t = Math.min(3e3, e.doc.length)
              , n = QL.create(e.facet(qL).parser, e, {
                from: 0,
                to: t
            });
            return n.work(20, t) || n.takeTree(),
            new UL(n)
        }
    }
    RL.state = uP.define({
        create: UL.init,
        update(e, t) {
            for (let n of t.effects)
                if (n.is(RL.setState))
                    return n.value;
            return t.startState.facet(qL) != t.state.facet(qL) ? UL.init(t.state) : e.apply(t)
        }
    });
    let FL = e=>{
        let t = setTimeout((()=>e()), 500);
        return ()=>clearTimeout(t)
    }
    ;
    "undefined" != typeof requestIdleCallback && (FL = e=>{
        let t = -1
          , n = setTimeout((()=>{
            t = requestIdleCallback(e, {
                timeout: 400
            })
        }
        ), 100);
        return ()=>t < 0 ? clearTimeout(n) : cancelIdleCallback(t)
    }
    );
    const jL = "undefined" != typeof navigator && (null === (AL = navigator.scheduling) || void 0 === AL ? void 0 : AL.isInputPending) ? ()=>navigator.scheduling.isInputPending() : null
      , zL = gN.fromClass(class {
        constructor(e) {
            this.view = e,
            this.working = null,
            this.workScheduled = 0,
            this.chunkEnd = -1,
            this.chunkBudget = -1,
            this.work = this.work.bind(this),
            this.scheduleWork()
        }
        update(e) {
            let t = this.view.state.field(RL.state).context;
            (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(),
            (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50),
            this.scheduleWork()),
            this.checkAsyncSchedule(t)
        }
        scheduleWork() {
            if (this.working)
                return;
            let {state: e} = this.view
              , t = e.field(RL.state);
            t.tree == t.context.tree && t.context.isDone(e.doc.length) || (this.working = FL(this.work))
        }
        work(e) {
            this.working = null;
            let t = Date.now();
            if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4,
            this.chunkBudget = 3e3),
            this.chunkBudget <= 0)
                return;
            let {state: n, viewport: {to: r}} = this.view
              , o = n.field(RL.state);
            if (o.tree == o.context.tree && o.context.isDone(r + 1e5))
                return;
            let i = Date.now() + Math.min(this.chunkBudget, 100, e && !jL ? Math.max(25, e.timeRemaining() - 5) : 1e9)
              , a = o.context.treeLen < r && n.doc.length > r + 1e3
              , s = o.context.work((()=>jL && jL() || Date.now() > i), r + (a ? 0 : 1e5));
            this.chunkBudget -= Date.now() - t,
            (s || this.chunkBudget <= 0) && (o.context.takeTree(),
            this.view.dispatch({
                effects: RL.setState.of(new UL(o.context))
            })),
            this.chunkBudget > 0 && (!s || a) && this.scheduleWork(),
            this.checkAsyncSchedule(o.context)
        }
        checkAsyncSchedule(e) {
            e.scheduleOn && (this.workScheduled++,
            e.scheduleOn.then((()=>this.scheduleWork())).catch((e=>pN(this.view.state, e))).then((()=>this.workScheduled--)),
            e.scheduleOn = null)
        }
        destroy() {
            this.working && this.working()
        }
        isWorking() {
            return !!(this.working || this.workScheduled > 0)
        }
    }
    , {
        eventHandlers: {
            focus() {
                this.scheduleWork()
            }
        }
    })
      , qL = rP.define({
        combine: e=>e.length ? e[0] : null,
        enables: e=>[RL.state, zL, pI.contentAttributes.compute([e], (t=>{
            let n = t.facet(e);
            return n && n.name ? {
                "data-language": n.name
            } : {}
        }
        ))]
    });
    class HL {
        constructor(e, t=[]) {
            this.language = e,
            this.support = t,
            this.extension = [e, t]
        }
    }
    const ZL = rP.define()
      , WL = rP.define({
        combine: e=>{
            if (!e.length)
                return "  ";
            let t = e[0];
            if (!t || /\S/.test(t) || Array.from(t).some((e=>e != t[0])))
                throw new Error("Invalid indent unit: " + JSON.stringify(e[0]));
            return t
        }
    });
    function XL(e) {
        let t = e.facet(WL);
        return 9 == t.charCodeAt(0) ? e.tabSize * t.length : t.length
    }
    function VL(e, t) {
        let n = ""
          , r = e.tabSize
          , o = e.facet(WL)[0];
        if ("\t" == o) {
            for (; t >= r; )
                n += "\t",
                t -= r;
            o = " "
        }
        for (let i = 0; i < t; i++)
            n += o;
        return n
    }
    function GL(e, t) {
        e instanceof HP && (e = new YL(e));
        for (let r of e.state.facet(ZL)) {
            let n = r(e, t);
            if (void 0 !== n)
                return n
        }
        let n = IL(e.state);
        return n.length >= t ? function(e, t, n) {
            let r = t.resolveStack(n)
              , o = r.node.enterUnfinishedNodesBefore(n);
            if (o != r.node) {
                let e = [];
                for (let t = o; t != r.node; t = t.parent)
                    e.push(t);
                for (let t = e.length - 1; t >= 0; t--)
                    r = {
                        node: e[t],
                        next: r
                    }
            }
            return JL(r, e, n)
        }(e, n, t) : null
    }
    class YL {
        constructor(e, t={}) {
            this.state = e,
            this.options = t,
            this.unit = XL(e)
        }
        lineAt(e, t=1) {
            let n = this.state.doc.lineAt(e)
              , {simulateBreak: r, simulateDoubleBreak: o} = this.options;
            return null != r && r >= n.from && r <= n.to ? o && r == e ? {
                text: "",
                from: e
            } : (t < 0 ? r < e : r <= e) ? {
                text: n.text.slice(r - n.from),
                from: r
            } : {
                text: n.text.slice(0, r - n.from),
                from: n.from
            } : n
        }
        textAfterPos(e, t=1) {
            if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
                return "";
            let {text: n, from: r} = this.lineAt(e, t);
            return n.slice(e - r, Math.min(n.length, e + 100 - r))
        }
        column(e, t=1) {
            let {text: n, from: r} = this.lineAt(e, t)
              , o = this.countColumn(n, e - r)
              , i = this.options.overrideIndentation ? this.options.overrideIndentation(r) : -1;
            return i > -1 && (o += i - this.countColumn(n, n.search(/\S|$/))),
            o
        }
        countColumn(e, t=e.length) {
            return cD(e, this.state.tabSize, t)
        }
        lineIndent(e, t=1) {
            let {text: n, from: r} = this.lineAt(e, t)
              , o = this.options.overrideIndentation;
            if (o) {
                let e = o(r);
                if (e > -1)
                    return e
            }
            return this.countColumn(n, n.search(/\S|$/))
        }
        get simulatedBreak() {
            return this.options.simulateBreak || null
        }
    }
    const KL = new pM;
    function JL(e, t, n) {
        for (let r = e; r; r = r.next) {
            let e = eQ(r.node);
            if (e)
                return e(nQ.create(t, n, r))
        }
        return 0
    }
    function eQ(e) {
        let t = e.type.prop(KL);
        if (t)
            return t;
        let n, r = e.firstChild;
        if (r && (n = r.type.prop(pM.closedBy))) {
            let t = e.lastChild
              , r = t && n.indexOf(t.name) > -1;
            return e=>iQ(e, !0, 1, void 0, r && !function(e) {
                return e.pos == e.options.simulateBreak && e.options.simulateDoubleBreak
            }(e) ? t.from : void 0)
        }
        return null == e.parent ? tQ : null
    }
    function tQ() {
        return 0
    }
    class nQ extends YL {
        constructor(e, t, n) {
            super(e.state, e.options),
            this.base = e,
            this.pos = t,
            this.context = n
        }
        get node() {
            return this.context.node
        }
        static create(e, t, n) {
            return new nQ(e,t,n)
        }
        get textAfter() {
            return this.textAfterPos(this.pos)
        }
        get baseIndent() {
            return this.baseIndentFor(this.node)
        }
        baseIndentFor(e) {
            let t = this.state.doc.lineAt(e.from);
            for (; ; ) {
                let n = e.resolve(t.from);
                for (; n.parent && n.parent.from == n.from; )
                    n = n.parent;
                if (rQ(n, e))
                    break;
                t = this.state.doc.lineAt(n.from)
            }
            return this.lineIndent(t.from)
        }
        continue() {
            return JL(this.context.next, this.base, this.pos)
        }
    }
    function rQ(e, t) {
        for (let n = t; n; n = n.parent)
            if (e == n)
                return !0;
        return !1
    }
    function oQ({closing: e, align: t=!0, units: n=1}) {
        return r=>iQ(r, t, n, e)
    }
    function iQ(e, t, n, r, o) {
        let i = e.textAfter
          , a = i.match(/^\s*/)[0].length
          , s = r && i.slice(a, a + r.length) == r || o == e.pos + a
          , l = t ? function(e) {
            let t = e.node
              , n = t.childAfter(t.from)
              , r = t.lastChild;
            if (!n)
                return null;
            let o = e.options.simulateBreak
              , i = e.state.doc.lineAt(n.from)
              , a = null == o || o <= i.from ? i.to : Math.min(i.to, o);
            for (let s = n.to; ; ) {
                let e = t.childAfter(s);
                if (!e || e == r)
                    return null;
                if (!e.type.isSkipped)
                    return e.from < a ? n : null;
                s = e.to
            }
        }(e) : null;
        return l ? s ? e.column(l.from) : e.column(l.to) : e.baseIndent + (s ? 0 : e.unit * n)
    }
    function aQ({except: e, units: t=1}={}) {
        return n=>{
            let r = e && e.test(n.textAfter);
            return n.baseIndent + (r ? 0 : t * n.unit)
        }
    }
    const sQ = 200;
    const lQ = new pM;
    function cQ(e) {
        let t = e.firstChild
          , n = e.lastChild;
        return t && t.to < n.from ? {
            from: t.to,
            to: n.type.isError ? e.to : n.from
        } : null
    }
    class uQ {
        constructor(e, t) {
            let n;
            function r(e) {
                let t = hD.newName();
                return (n || (n = Object.create(null)))["." + t] = e,
                t
            }
            this.specs = e;
            const o = "string" == typeof t.all ? t.all : t.all ? r(t.all) : void 0
              , i = t.scope;
            this.scope = i instanceof RL ? e=>e.prop(CL) == i.data : i ? e=>e == i : void 0,
            this.style = cL(e.map((e=>({
                tag: e.tag,
                class: e.class || r(Object.assign({}, e, {
                    tag: null
                }))
            }))), {
                all: o
            }).style,
            this.module = n ? new hD(n) : null,
            this.themeType = t.themeType
        }
        static define(e, t) {
            return new uQ(e,t || {})
        }
    }
    const dQ = rP.define()
      , pQ = rP.define({
        combine: e=>e.length ? [e[0]] : null
    });
    function hQ(e) {
        let t = e.facet(dQ);
        return t.length ? t : e.facet(pQ)
    }
    function fQ(e, t) {
        let n, r = [gQ];
        return e instanceof uQ && (e.module && r.push(pI.styleModule.of(e.module)),
        n = e.themeType),
        (null == t ? void 0 : t.fallback) ? r.push(pQ.of(e)) : n ? r.push(dQ.computeN([pI.darkTheme], (t=>t.facet(pI.darkTheme) == ("dark" == n) ? [e] : []))) : r.push(dQ.of(e)),
        r
    }
    class mQ {
        constructor(e) {
            this.markCache = Object.create(null),
            this.tree = IL(e.state),
            this.decorations = this.buildDeco(e, hQ(e.state)),
            this.decoratedTo = e.viewport.to
        }
        update(e) {
            let t = IL(e.state)
              , n = hQ(e.state)
              , r = n != hQ(e.startState)
              , {viewport: o} = e.view
              , i = e.changes.mapPos(this.decoratedTo, 1);
            t.length < o.to && !r && t.type == this.tree.type && i >= o.to ? (this.decorations = this.decorations.map(e.changes),
            this.decoratedTo = i) : (t != this.tree || e.viewportChanged || r) && (this.tree = t,
            this.decorations = this.buildDeco(e.view, n),
            this.decoratedTo = o.to)
        }
        buildDeco(e, t) {
            if (!t || !this.tree.length)
                return ER.none;
            let n = new KP;
            for (let {from: r, to: o} of e.visibleRanges)
                uL(this.tree, t, ((e,t,r)=>{
                    n.add(e, t, this.markCache[r] || (this.markCache[r] = ER.mark({
                        class: r
                    })))
                }
                ), r, o);
            return n.finish()
        }
    }
    const gQ = gP.high(gN.fromClass(mQ, {
        decorations: e=>e.decorations
    }))
      , bQ = uQ.define([{
        tag: TL.meta,
        color: "#404740"
    }, {
        tag: TL.link,
        textDecoration: "underline"
    }, {
        tag: TL.heading,
        textDecoration: "underline",
        fontWeight: "bold"
    }, {
        tag: TL.emphasis,
        fontStyle: "italic"
    }, {
        tag: TL.strong,
        fontWeight: "bold"
    }, {
        tag: TL.strikethrough,
        textDecoration: "line-through"
    }, {
        tag: TL.keyword,
        color: "#708"
    }, {
        tag: [TL.atom, TL.bool, TL.url, TL.contentSeparator, TL.labelName],
        color: "#219"
    }, {
        tag: [TL.literal, TL.inserted],
        color: "#164"
    }, {
        tag: [TL.string, TL.deleted],
        color: "#a11"
    }, {
        tag: [TL.regexp, TL.escape, TL.special(TL.string)],
        color: "#e40"
    }, {
        tag: TL.definition(TL.variableName),
        color: "#00f"
    }, {
        tag: TL.local(TL.variableName),
        color: "#30a"
    }, {
        tag: [TL.typeName, TL.namespace],
        color: "#085"
    }, {
        tag: TL.className,
        color: "#167"
    }, {
        tag: [TL.special(TL.variableName), TL.macroName],
        color: "#256"
    }, {
        tag: TL.definition(TL.propertyName),
        color: "#00c"
    }, {
        tag: TL.comment,
        color: "#940"
    }, {
        tag: TL.invalid,
        color: "#f00"
    }])
      , OQ = pI.baseTheme({
        "&.cm-focused .cm-matchingBracket": {
            backgroundColor: "#328c8252"
        },
        "&.cm-focused .cm-nonmatchingBracket": {
            backgroundColor: "#bb555544"
        }
    })
      , vQ = "()[]{}"
      , yQ = rP.define({
        combine: e=>ZP(e, {
            afterCursor: !0,
            brackets: vQ,
            maxScanDistance: 1e4,
            renderMatch: kQ
        })
    })
      , wQ = ER.mark({
        class: "cm-matchingBracket"
    })
      , _Q = ER.mark({
        class: "cm-nonmatchingBracket"
    });
    function kQ(e) {
        let t = []
          , n = e.matched ? wQ : _Q;
        return t.push(n.range(e.start.from, e.start.to)),
        e.end && t.push(n.range(e.end.from, e.end.to)),
        t
    }
    const SQ = [uP.define({
        create: ()=>ER.none,
        update(e, t) {
            if (!t.docChanged && !t.selection)
                return e;
            let n = []
              , r = t.state.facet(yQ);
            for (let o of t.state.selection.ranges) {
                if (!o.empty)
                    continue;
                let e = AQ(t.state, o.head, -1, r) || o.head > 0 && AQ(t.state, o.head - 1, 1, r) || r.afterCursor && (AQ(t.state, o.head, 1, r) || o.head < t.state.doc.length && AQ(t.state, o.head + 1, -1, r));
                e && (n = n.concat(r.renderMatch(e, t.state)))
            }
            return ER.set(n, !0)
        },
        provide: e=>pI.decorations.from(e)
    }), OQ];
    const EQ = new pM;
    function xQ(e, t, n) {
        let r = e.prop(t < 0 ? pM.openedBy : pM.closedBy);
        if (r)
            return r;
        if (1 == e.name.length) {
            let r = n.indexOf(e.name);
            if (r > -1 && r % 2 == (t < 0 ? 1 : 0))
                return [n[r + t]]
        }
        return null
    }
    function TQ(e) {
        let t = e.type.prop(EQ);
        return t ? t(e.node) : e
    }
    function AQ(e, t, n, r={}) {
        let o = r.maxScanDistance || 1e4
          , i = r.brackets || vQ
          , a = IL(e)
          , s = a.resolveInner(t, n);
        for (let l = s; l; l = l.parent) {
            let r = xQ(l.type, n, i);
            if (r && l.from < l.to) {
                let o = TQ(l);
                if (o && (n > 0 ? t >= o.from && t < o.to : t > o.from && t <= o.to))
                    return CQ(e, t, n, l, o, r, i)
            }
        }
        return function(e, t, n, r, o, i, a) {
            let s = n < 0 ? e.sliceDoc(t - 1, t) : e.sliceDoc(t, t + 1)
              , l = a.indexOf(s);
            if (l < 0 || l % 2 == 0 != n > 0)
                return null;
            let c = {
                from: n < 0 ? t - 1 : t,
                to: n > 0 ? t + 1 : t
            }
              , u = e.doc.iterRange(t, n > 0 ? e.doc.length : 0)
              , d = 0;
            for (let p = 0; !u.next().done && p <= i; ) {
                let e = u.value;
                n < 0 && (p += e.length);
                let i = t + p * n;
                for (let t = n > 0 ? 0 : e.length - 1, s = n > 0 ? e.length : -1; t != s; t += n) {
                    let s = a.indexOf(e[t]);
                    if (!(s < 0 || r.resolveInner(i + t, 1).type != o))
                        if (s % 2 == 0 == n > 0)
                            d++;
                        else {
                            if (1 == d)
                                return {
                                    start: c,
                                    end: {
                                        from: i + t,
                                        to: i + t + 1
                                    },
                                    matched: s >> 1 == l >> 1
                                };
                            d--
                        }
                }
                n > 0 && (p += e.length)
            }
            return u.done ? {
                start: c,
                matched: !1
            } : null
        }(e, t, n, a, s.type, o, i)
    }
    function CQ(e, t, n, r, o, i, a) {
        let s = r.parent
          , l = {
            from: o.from,
            to: o.to
        }
          , c = 0
          , u = null == s ? void 0 : s.cursor();
        if (u && (n < 0 ? u.childBefore(r.from) : u.childAfter(r.to)))
            do {
                if (n < 0 ? u.to <= r.from : u.from >= r.to) {
                    if (0 == c && i.indexOf(u.type.name) > -1 && u.from < u.to) {
                        let e = TQ(u);
                        return {
                            start: l,
                            end: e ? {
                                from: e.from,
                                to: e.to
                            } : void 0,
                            matched: !0
                        }
                    }
                    if (xQ(u.type, n, a))
                        c++;
                    else if (xQ(u.type, -n, a)) {
                        if (0 == c) {
                            let e = TQ(u);
                            return {
                                start: l,
                                end: e && e.from < e.to ? {
                                    from: e.from,
                                    to: e.to
                                } : void 0,
                                matched: !1
                            }
                        }
                        c--
                    }
                }
            } while (n < 0 ? u.prevSibling() : u.nextSibling());
        return {
            start: l,
            matched: !1
        }
    }
    const PQ = Object.create(null)
      , DQ = [mM.none]
      , RQ = []
      , NQ = Object.create(null)
      , $Q = Object.create(null);
    for (let[Rie,Nie] of [["variable", "variableName"], ["variable-2", "variableName.special"], ["string-2", "string.special"], ["def", "variableName.definition"], ["tag", "tagName"], ["attribute", "attributeName"], ["type", "typeName"], ["builtin", "variableName.standard"], ["qualifier", "modifier"], ["error", "invalid"], ["header", "heading"], ["property", "propertyName"]])
        $Q[Rie] = MQ(PQ, Nie);
    function IQ(e, t) {
        RQ.indexOf(e) > -1 || (RQ.push(e),
        console.warn(t))
    }
    function MQ(e, t) {
        let n = [];
        for (let s of t.split(" ")) {
            let t = [];
            for (let n of s.split(".")) {
                let r = e[n] || TL[n];
                r ? "function" == typeof r ? t.length ? t = t.map(r) : IQ(n, `Modifier ${n} used at start of tag`) : t.length ? IQ(n, `Tag ${n} used as modifier`) : t = Array.isArray(r) ? r : [r] : IQ(n, `Unknown highlighting tag ${n}`)
            }
            for (let e of t)
                n.push(e)
        }
        if (!n.length)
            return 0;
        let r = t.replace(/ /g, "_")
          , o = r + " " + n.map((e=>e.id))
          , i = NQ[o];
        if (i)
            return i.id;
        let a = NQ[o] = mM.define({
            id: DQ.length,
            name: r,
            props: [aL({
                [r]: n
            })]
        });
        return DQ.push(a),
        a.id
    }
    $R.RTL,
    $R.LTR;
    class LQ {
        constructor(e, t, n) {
            this.state = e,
            this.pos = t,
            this.explicit = n,
            this.abortListeners = []
        }
        tokenBefore(e) {
            let t = IL(this.state).resolveInner(this.pos, -1);
            for (; t && e.indexOf(t.name) < 0; )
                t = t.parent;
            return t ? {
                from: t.from,
                to: this.pos,
                text: this.state.sliceDoc(t.from, this.pos),
                type: t.type
            } : null
        }
        matchBefore(e) {
            let t = this.state.doc.lineAt(this.pos)
              , n = Math.max(t.from, this.pos - 250)
              , r = t.text.slice(n - t.from, this.pos - t.from)
              , o = r.search(jQ(e, !1));
            return o < 0 ? null : {
                from: n + o,
                to: this.pos,
                text: r.slice(o)
            }
        }
        get aborted() {
            return null == this.abortListeners
        }
        addEventListener(e, t) {
            "abort" == e && this.abortListeners && this.abortListeners.push(t)
        }
    }
    function QQ(e) {
        let t = Object.keys(e).join("")
          , n = /\w/.test(t);
        return n && (t = t.replace(/\w/g, "")),
        `[${n ? "\\w" : ""}${t.replace(/[^\w\s]/g, "\\$&")}]`
    }
    function BQ(e) {
        let t = e.map((e=>"string" == typeof e ? {
            label: e
        } : e))
          , [n,r] = t.every((e=>/^\w+$/.test(e.label))) ? [/\w*$/, /\w+$/] : function(e) {
            let t = Object.create(null)
              , n = Object.create(null);
            for (let {label: o} of e) {
                t[o[0]] = !0;
                for (let e = 1; e < o.length; e++)
                    n[o[e]] = !0
            }
            let r = QQ(t) + QQ(n) + "*$";
            return [new RegExp("^" + r), new RegExp(r)]
        }(t);
        return e=>{
            let o = e.matchBefore(r);
            return o || e.explicit ? {
                from: o ? o.from : e.pos,
                options: t,
                validFor: n
            } : null
        }
    }
    class UQ {
        constructor(e, t, n, r) {
            this.completion = e,
            this.source = t,
            this.match = n,
            this.score = r
        }
    }
    function FQ(e) {
        return e.selection.main.from
    }
    function jQ(e, t) {
        var n;
        let {source: r} = e
          , o = t && "^" != r[0]
          , i = "$" != r[r.length - 1];
        return o || i ? new RegExp(`${o ? "^" : ""}(?:${r})${i ? "$" : ""}`,null !== (n = e.flags) && void 0 !== n ? n : e.ignoreCase ? "i" : "") : e
    }
    const zQ = PP.define();
    const qQ = new WeakMap;
    function HQ(e) {
        if (!Array.isArray(e))
            return e;
        let t = qQ.get(e);
        return t || qQ.set(e, t = BQ(e)),
        t
    }
    const ZQ = NP.define()
      , WQ = NP.define();
    class XQ {
        constructor(e) {
            this.pattern = e,
            this.chars = [],
            this.folded = [],
            this.any = [],
            this.precise = [],
            this.byWord = [],
            this.score = 0,
            this.matched = [];
            for (let t = 0; t < e.length; ) {
                let n = UC(e, t)
                  , r = jC(n);
                this.chars.push(n);
                let o = e.slice(t, t + r)
                  , i = o.toUpperCase();
                this.folded.push(UC(i == o ? o.toLowerCase() : i, 0)),
                t += r
            }
            this.astral = e.length != this.chars.length
        }
        ret(e, t) {
            return this.score = e,
            this.matched = t,
            this
        }
        match(e) {
            if (0 == this.pattern.length)
                return this.ret(-100, []);
            if (e.length < this.pattern.length)
                return null;
            let {chars: t, folded: n, any: r, precise: o, byWord: i} = this;
            if (1 == t.length) {
                let r = UC(e, 0)
                  , o = jC(r)
                  , i = o == e.length ? 0 : -100;
                if (r == t[0])
                    ;
                else {
                    if (r != n[0])
                        return null;
                    i += -200
                }
                return this.ret(i, [0, o])
            }
            let a = e.indexOf(this.pattern);
            if (0 == a)
                return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
            let s = t.length
              , l = 0;
            if (a < 0) {
                for (let o = 0, i = Math.min(e.length, 200); o < i && l < s; ) {
                    let i = UC(e, o);
                    i != t[l] && i != n[l] || (r[l++] = o),
                    o += jC(i)
                }
                if (l < s)
                    return null
            }
            let c = 0
              , u = 0
              , d = !1
              , p = 0
              , h = -1
              , f = -1
              , m = /[a-z]/.test(e)
              , g = !0;
            for (let b = 0, O = Math.min(e.length, 200), v = 0; b < O && u < s; ) {
                let r = UC(e, b);
                a < 0 && (c < s && r == t[c] && (o[c++] = b),
                p < s && (r == t[p] || r == n[p] ? (0 == p && (h = b),
                f = b + 1,
                p++) : p = 0));
                let l, O = r < 255 ? r >= 48 && r <= 57 || r >= 97 && r <= 122 ? 2 : r >= 65 && r <= 90 ? 1 : 0 : (l = FC(r)) != l.toLowerCase() ? 1 : l != l.toUpperCase() ? 2 : 0;
                (!b || 1 == O && m || 0 == v && 0 != O) && (t[u] == r || n[u] == r && (d = !0) ? i[u++] = b : i.length && (g = !1)),
                v = O,
                b += jC(r)
            }
            return u == s && 0 == i[0] && g ? this.result((d ? -200 : 0) - 100, i, e) : p == s && 0 == h ? this.ret(-200 - e.length + (f == e.length ? 0 : -100), [0, f]) : a > -1 ? this.ret(-700 - e.length, [a, a + this.pattern.length]) : p == s ? this.ret(-900 - e.length, [h, f]) : u == s ? this.result((d ? -200 : 0) - 100 - 700 + (g ? 0 : -1100), i, e) : 2 == t.length ? null : this.result((r[0] ? -700 : 0) - 200 - 1100, r, e)
        }
        result(e, t, n) {
            let r = []
              , o = 0;
            for (let i of t) {
                let e = i + (this.astral ? jC(UC(n, i)) : 1);
                o && r[o - 1] == i ? r[o - 1] = e : (r[o++] = i,
                r[o++] = e)
            }
            return this.ret(e - n.length, r)
        }
    }
    class VQ {
        constructor(e) {
            this.pattern = e,
            this.matched = [],
            this.score = 0,
            this.folded = e.toLowerCase()
        }
        match(e) {
            if (e.length < this.pattern.length)
                return null;
            let t = e.slice(0, this.pattern.length)
              , n = t == this.pattern ? 0 : t.toLowerCase() == this.folded ? -200 : null;
            return null == n ? null : (this.matched = [0, t.length],
            this.score = n + (e.length == this.pattern.length ? 0 : -100),
            this)
        }
    }
    const GQ = rP.define({
        combine: e=>ZP(e, {
            activateOnTyping: !0,
            activateOnCompletion: ()=>!1,
            activateOnTypingDelay: 100,
            selectOnOpen: !0,
            override: null,
            closeOnBlur: !0,
            maxRenderedOptions: 100,
            defaultKeymap: !0,
            tooltipClass: ()=>"",
            optionClass: ()=>"",
            aboveCursor: !1,
            icons: !0,
            addToOptions: [],
            positionInfo: KQ,
            filterStrict: !1,
            compareCompletions: (e,t)=>e.label.localeCompare(t.label),
            interactionDelay: 75,
            updateSyncTime: 100
        }, {
            defaultKeymap: (e,t)=>e && t,
            closeOnBlur: (e,t)=>e && t,
            icons: (e,t)=>e && t,
            tooltipClass: (e,t)=>n=>YQ(e(n), t(n)),
            optionClass: (e,t)=>n=>YQ(e(n), t(n)),
            addToOptions: (e,t)=>e.concat(t),
            filterStrict: (e,t)=>e || t
        })
    });
    function YQ(e, t) {
        return e ? t ? e + " " + t : e : t
    }
    function KQ(e, t, n, r, o, i) {
        let a, s, l = e.textDirection == $R.RTL, c = l, u = !1, d = "top", p = t.left - o.left, h = o.right - t.right, f = r.right - r.left, m = r.bottom - r.top;
        if (c && p < Math.min(f, h) ? c = !1 : !c && h < Math.min(f, p) && (c = !0),
        f <= (c ? p : h))
            a = Math.max(o.top, Math.min(n.top, o.bottom - m)) - t.top,
            s = Math.min(400, c ? p : h);
        else {
            u = !0,
            s = Math.min(400, (l ? t.right : o.right - t.left) - 30);
            let e = o.bottom - t.bottom;
            e >= m || e > t.top ? a = n.bottom - t.top : (d = "bottom",
            a = t.bottom - n.top)
        }
        return {
            style: `${d}: ${a / ((t.bottom - t.top) / i.offsetHeight)}px; max-width: ${s / ((t.right - t.left) / i.offsetWidth)}px`,
            class: "cm-completionInfo-" + (u ? l ? "left-narrow" : "right-narrow" : c ? "left" : "right")
        }
    }
    function JQ(e, t, n) {
        if (e <= n)
            return {
                from: 0,
                to: e
            };
        if (t < 0 && (t = 0),
        t <= e >> 1) {
            let e = Math.floor(t / n);
            return {
                from: e * n,
                to: (e + 1) * n
            }
        }
        let r = Math.floor((e - t) / n);
        return {
            from: e - (r + 1) * n,
            to: e - r * n
        }
    }
    class eB {
        constructor(e, t, n) {
            this.view = e,
            this.stateField = t,
            this.applyCompletion = n,
            this.info = null,
            this.infoDestroy = null,
            this.placeInfoReq = {
                read: ()=>this.measureInfo(),
                write: e=>this.placeInfo(e),
                key: this
            },
            this.space = null,
            this.currentClass = "";
            let r = e.state.field(t)
              , {options: o, selected: i} = r.open
              , a = e.state.facet(GQ);
            this.optionContent = function(e) {
                let t = e.addToOptions.slice();
                return e.icons && t.push({
                    render(e) {
                        let t = document.createElement("div");
                        return t.classList.add("cm-completionIcon"),
                        e.type && t.classList.add(...e.type.split(/\s+/g).map((e=>"cm-completionIcon-" + e))),
                        t.setAttribute("aria-hidden", "true"),
                        t
                    },
                    position: 20
                }),
                t.push({
                    render(e, t, n, r) {
                        let o = document.createElement("span");
                        o.className = "cm-completionLabel";
                        let i = e.displayLabel || e.label
                          , a = 0;
                        for (let s = 0; s < r.length; ) {
                            let e = r[s++]
                              , t = r[s++];
                            e > a && o.appendChild(document.createTextNode(i.slice(a, e)));
                            let n = o.appendChild(document.createElement("span"));
                            n.appendChild(document.createTextNode(i.slice(e, t))),
                            n.className = "cm-completionMatchedText",
                            a = t
                        }
                        return a < i.length && o.appendChild(document.createTextNode(i.slice(a))),
                        o
                    },
                    position: 50
                }, {
                    render(e) {
                        if (!e.detail)
                            return null;
                        let t = document.createElement("span");
                        return t.className = "cm-completionDetail",
                        t.textContent = e.detail,
                        t
                    },
                    position: 80
                }),
                t.sort(((e,t)=>e.position - t.position)).map((e=>e.render))
            }(a),
            this.optionClass = a.optionClass,
            this.tooltipClass = a.tooltipClass,
            this.range = JQ(o.length, i, a.maxRenderedOptions),
            this.dom = document.createElement("div"),
            this.dom.className = "cm-tooltip-autocomplete",
            this.updateTooltipClass(e.state),
            this.dom.addEventListener("mousedown", (n=>{
                let {options: r} = e.state.field(t).open;
                for (let t, o = n.target; o && o != this.dom; o = o.parentNode)
                    if ("LI" == o.nodeName && (t = /-(\d+)$/.exec(o.id)) && +t[1] < r.length)
                        return this.applyCompletion(e, r[+t[1]]),
                        void n.preventDefault()
            }
            )),
            this.dom.addEventListener("focusout", (t=>{
                let n = e.state.field(this.stateField, !1);
                n && n.tooltip && e.state.facet(GQ).closeOnBlur && t.relatedTarget != e.contentDOM && e.dispatch({
                    effects: WQ.of(null)
                })
            }
            )),
            this.showOptions(o, r.id)
        }
        mount() {
            this.updateSel()
        }
        showOptions(e, t) {
            this.list && this.list.remove(),
            this.list = this.dom.appendChild(this.createListBox(e, t, this.range)),
            this.list.addEventListener("scroll", (()=>{
                this.info && this.view.requestMeasure(this.placeInfoReq)
            }
            ))
        }
        update(e) {
            var t;
            let n = e.state.field(this.stateField)
              , r = e.startState.field(this.stateField);
            if (this.updateTooltipClass(e.state),
            n != r) {
                let {options: o, selected: i, disabled: a} = n.open;
                r.open && r.open.options == o || (this.range = JQ(o.length, i, e.state.facet(GQ).maxRenderedOptions),
                this.showOptions(o, n.id)),
                this.updateSel(),
                a != (null === (t = r.open) || void 0 === t ? void 0 : t.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a)
            }
        }
        updateTooltipClass(e) {
            let t = this.tooltipClass(e);
            if (t != this.currentClass) {
                for (let e of this.currentClass.split(" "))
                    e && this.dom.classList.remove(e);
                for (let e of t.split(" "))
                    e && this.dom.classList.add(e);
                this.currentClass = t
            }
        }
        positioned(e) {
            this.space = e,
            this.info && this.view.requestMeasure(this.placeInfoReq)
        }
        updateSel() {
            let e = this.view.state.field(this.stateField)
              , t = e.open;
            if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = JQ(t.options.length, t.selected, this.view.state.facet(GQ).maxRenderedOptions),
            this.showOptions(t.options, e.id)),
            this.updateSelectedOption(t.selected)) {
                this.destroyInfo();
                let {completion: n} = t.options[t.selected]
                  , {info: r} = n;
                if (!r)
                    return;
                let o = "string" == typeof r ? document.createTextNode(r) : r(n);
                if (!o)
                    return;
                "then"in o ? o.then((t=>{
                    t && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(t, n)
                }
                )).catch((e=>pN(this.view.state, e, "completion info"))) : this.addInfoPane(o, n)
            }
        }
        addInfoPane(e, t) {
            this.destroyInfo();
            let n = this.info = document.createElement("div");
            if (n.className = "cm-tooltip cm-completionInfo",
            null != e.nodeType)
                n.appendChild(e),
                this.infoDestroy = null;
            else {
                let {dom: t, destroy: r} = e;
                n.appendChild(t),
                this.infoDestroy = r || null
            }
            this.dom.appendChild(n),
            this.view.requestMeasure(this.placeInfoReq)
        }
        updateSelectedOption(e) {
            let t = null;
            for (let n = this.list.firstChild, r = this.range.from; n; n = n.nextSibling,
            r++)
                "LI" == n.nodeName && n.id ? r == e ? n.hasAttribute("aria-selected") || (n.setAttribute("aria-selected", "true"),
                t = n) : n.hasAttribute("aria-selected") && n.removeAttribute("aria-selected") : r--;
            return t && function(e, t) {
                let n = e.getBoundingClientRect()
                  , r = t.getBoundingClientRect()
                  , o = n.height / e.offsetHeight;
                r.top < n.top ? e.scrollTop -= (n.top - r.top) / o : r.bottom > n.bottom && (e.scrollTop += (r.bottom - n.bottom) / o)
            }(this.list, t),
            t
        }
        measureInfo() {
            let e = this.dom.querySelector("[aria-selected]");
            if (!e || !this.info)
                return null;
            let t = this.dom.getBoundingClientRect()
              , n = this.info.getBoundingClientRect()
              , r = e.getBoundingClientRect()
              , o = this.space;
            if (!o) {
                let e = this.dom.ownerDocument.defaultView || window;
                o = {
                    left: 0,
                    top: 0,
                    right: e.innerWidth,
                    bottom: e.innerHeight
                }
            }
            return r.top > Math.min(o.bottom, t.bottom) - 10 || r.bottom < Math.max(o.top, t.top) + 10 ? null : this.view.state.facet(GQ).positionInfo(this.view, t, r, n, o, this.dom)
        }
        placeInfo(e) {
            this.info && (e ? (e.style && (this.info.style.cssText = e.style),
            this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px")
        }
        createListBox(e, t, n) {
            const r = document.createElement("ul");
            r.id = t,
            r.setAttribute("role", "listbox"),
            r.setAttribute("aria-expanded", "true"),
            r.setAttribute("aria-label", this.view.state.phrase("Completions"));
            let o = null;
            for (let i = n.from; i < n.to; i++) {
                let {completion: a, match: s} = e[i]
                  , {section: l} = a;
                if (l) {
                    let e = "string" == typeof l ? l : l.name;
                    if (e != o && (i > n.from || 0 == n.from))
                        if (o = e,
                        "string" != typeof l && l.header)
                            r.appendChild(l.header(l));
                        else {
                            r.appendChild(document.createElement("completion-section")).textContent = e
                        }
                }
                const c = r.appendChild(document.createElement("li"));
                c.id = t + "-" + i,
                c.setAttribute("role", "option");
                let u = this.optionClass(a);
                u && (c.className = u);
                for (let e of this.optionContent) {
                    let t = e(a, this.view.state, this.view, s);
                    t && c.appendChild(t)
                }
            }
            return n.from && r.classList.add("cm-completionListIncompleteTop"),
            n.to < e.length && r.classList.add("cm-completionListIncompleteBottom"),
            r
        }
        destroyInfo() {
            this.info && (this.infoDestroy && this.infoDestroy(),
            this.info.remove(),
            this.info = null)
        }
        destroy() {
            this.destroyInfo()
        }
    }
    function tB(e, t) {
        return n=>new eB(n,e,t)
    }
    function nB(e) {
        return 100 * (e.boost || 0) + (e.apply ? 10 : 0) + (e.info ? 5 : 0) + (e.type ? 1 : 0)
    }
    class rB {
        constructor(e, t, n, r, o, i) {
            this.options = e,
            this.attrs = t,
            this.tooltip = n,
            this.timestamp = r,
            this.selected = o,
            this.disabled = i
        }
        setSelected(e, t) {
            return e == this.selected || e >= this.options.length ? this : new rB(this.options,aB(t, e),this.tooltip,this.timestamp,e,this.disabled)
        }
        static build(e, t, n, r, o) {
            let i = function(e, t) {
                let n = []
                  , r = null
                  , o = e=>{
                    n.push(e);
                    let {section: t} = e.completion;
                    if (t) {
                        r || (r = []);
                        let e = "string" == typeof t ? t : t.name;
                        r.some((t=>t.name == e)) || r.push("string" == typeof t ? {
                            name: e
                        } : t)
                    }
                }
                  , i = t.facet(GQ);
                for (let c of e)
                    if (c.hasResult()) {
                        let e = c.result.getMatch;
                        if (!1 === c.result.filter)
                            for (let t of c.result.options)
                                o(new UQ(t,c.source,e ? e(t) : [],1e9 - n.length));
                        else {
                            let n, r = t.sliceDoc(c.from, c.to), a = i.filterStrict ? new VQ(r) : new XQ(r);
                            for (let t of c.result.options)
                                if (n = a.match(t.label)) {
                                    let r = t.displayLabel ? e ? e(t, n.matched) : [] : n.matched;
                                    o(new UQ(t,c.source,r,n.score + (t.boost || 0)))
                                }
                        }
                    }
                if (r) {
                    let e = Object.create(null)
                      , t = 0
                      , o = (e,t)=>{
                        var n, r;
                        return (null !== (n = e.rank) && void 0 !== n ? n : 1e9) - (null !== (r = t.rank) && void 0 !== r ? r : 1e9) || (e.name < t.name ? -1 : 1)
                    }
                    ;
                    for (let n of r.sort(o))
                        t -= 1e5,
                        e[n.name] = t;
                    for (let r of n) {
                        let {section: t} = r.completion;
                        t && (r.score += e["string" == typeof t ? t : t.name])
                    }
                }
                let a = []
                  , s = null
                  , l = i.compareCompletions;
                for (let c of n.sort(((e,t)=>t.score - e.score || l(e.completion, t.completion)))) {
                    let e = c.completion;
                    !s || s.label != e.label || s.detail != e.detail || null != s.type && null != e.type && s.type != e.type || s.apply != e.apply || s.boost != e.boost ? a.push(c) : nB(c.completion) > nB(s) && (a[a.length - 1] = c),
                    s = c.completion
                }
                return a
            }(e, t);
            if (!i.length)
                return r && e.some((e=>1 == e.state)) ? new rB(r.options,r.attrs,r.tooltip,r.timestamp,r.selected,!0) : null;
            let a = t.facet(GQ).selectOnOpen ? 0 : -1;
            if (r && r.selected != a && -1 != r.selected) {
                let e = r.options[r.selected].completion;
                for (let t = 0; t < i.length; t++)
                    if (i[t].completion == e) {
                        a = t;
                        break
                    }
            }
            return new rB(i,aB(n, a),{
                pos: e.reduce(((e,t)=>t.hasResult() ? Math.min(e, t.from) : e), 1e8),
                create: mB,
                above: o.aboveCursor
            },r ? r.timestamp : Date.now(),a,!1)
        }
        map(e) {
            return new rB(this.options,this.attrs,Object.assign(Object.assign({}, this.tooltip), {
                pos: e.mapPos(this.tooltip.pos)
            }),this.timestamp,this.selected,this.disabled)
        }
    }
    class oB {
        constructor(e, t, n) {
            this.active = e,
            this.id = t,
            this.open = n
        }
        static start() {
            return new oB(sB,"cm-ac-" + Math.floor(2e6 * Math.random()).toString(36),null)
        }
        update(e) {
            let {state: t} = e
              , n = t.facet(GQ)
              , r = (n.override || t.languageDataAt("autocomplete", FQ(t)).map(HQ)).map((t=>{
                let r = this.active.find((e=>e.source == t)) || new cB(t,this.active.some((e=>0 != e.state)) ? 1 : 0);
                return r.update(e, n)
            }
            ));
            r.length == this.active.length && r.every(((e,t)=>e == this.active[t])) && (r = this.active);
            let o = this.open;
            o && e.docChanged && (o = o.map(e.changes)),
            e.selection || r.some((t=>t.hasResult() && e.changes.touchesRange(t.from, t.to))) || !function(e, t) {
                if (e == t)
                    return !0;
                for (let n = 0, r = 0; ; ) {
                    for (; n < e.length && !e[n].hasResult; )
                        n++;
                    for (; r < t.length && !t[r].hasResult; )
                        r++;
                    let o = n == e.length
                      , i = r == t.length;
                    if (o || i)
                        return o == i;
                    if (e[n++].result != t[r++].result)
                        return !1
                }
            }(r, this.active) ? o = rB.build(r, t, this.id, o, n) : o && o.disabled && !r.some((e=>1 == e.state)) && (o = null),
            !o && r.every((e=>1 != e.state)) && r.some((e=>e.hasResult())) && (r = r.map((e=>e.hasResult() ? new cB(e.source,0) : e)));
            for (let i of e.effects)
                i.is(pB) && (o = o && o.setSelected(i.value, this.id));
            return r == this.active && o == this.open ? this : new oB(r,this.id,o)
        }
        get tooltip() {
            return this.open ? this.open.tooltip : null
        }
        get attrs() {
            return this.open ? this.open.attrs : iB
        }
    }
    const iB = {
        "aria-autocomplete": "list"
    };
    function aB(e, t) {
        let n = {
            "aria-autocomplete": "list",
            "aria-haspopup": "listbox",
            "aria-controls": e
        };
        return t > -1 && (n["aria-activedescendant"] = e + "-" + t),
        n
    }
    const sB = [];
    function lB(e, t) {
        if (e.isUserEvent("input.complete")) {
            let n = e.annotation(zQ);
            if (n && t.activateOnCompletion(n))
                return "input"
        }
        return e.isUserEvent("input.type") ? "input" : e.isUserEvent("delete.backward") ? "delete" : null
    }
    class cB {
        constructor(e, t, n=-1) {
            this.source = e,
            this.state = t,
            this.explicitPos = n
        }
        hasResult() {
            return !1
        }
        update(e, t) {
            let n = lB(e, t)
              , r = this;
            n ? r = r.handleUserEvent(e, n, t) : e.docChanged ? r = r.handleChange(e) : e.selection && 0 != r.state && (r = new cB(r.source,0));
            for (let o of e.effects)
                if (o.is(ZQ))
                    r = new cB(r.source,1,o.value ? FQ(e.state) : -1);
                else if (o.is(WQ))
                    r = new cB(r.source,0);
                else if (o.is(dB))
                    for (let e of o.value)
                        e.source == r.source && (r = e);
            return r
        }
        handleUserEvent(e, t, n) {
            return "delete" != t && n.activateOnTyping ? new cB(this.source,1) : this.map(e.changes)
        }
        handleChange(e) {
            return e.changes.touchesRange(FQ(e.startState)) ? new cB(this.source,0) : this.map(e.changes)
        }
        map(e) {
            return e.empty || this.explicitPos < 0 ? this : new cB(this.source,this.state,e.mapPos(this.explicitPos))
        }
    }
    class uB extends cB {
        constructor(e, t, n, r, o) {
            super(e, 2, t),
            this.result = n,
            this.from = r,
            this.to = o
        }
        hasResult() {
            return !0
        }
        handleUserEvent(e, t, n) {
            var r;
            let o = this.result;
            o.map && !e.changes.empty && (o = o.map(o, e.changes));
            let i = e.changes.mapPos(this.from)
              , a = e.changes.mapPos(this.to, 1)
              , s = FQ(e.state);
            if ((this.explicitPos < 0 ? s <= i : s < this.from) || s > a || !o || "delete" == t && FQ(e.startState) == this.from)
                return new cB(this.source,"input" == t && n.activateOnTyping ? 1 : 0);
            let l = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos);
            return function(e, t, n, r) {
                if (!e)
                    return !1;
                let o = t.sliceDoc(n, r);
                return "function" == typeof e ? e(o, n, r, t) : jQ(e, !0).test(o)
            }(o.validFor, e.state, i, a) ? new uB(this.source,l,o,i,a) : o.update && (o = o.update(o, i, a, new LQ(e.state,s,l >= 0))) ? new uB(this.source,l,o,o.from,null !== (r = o.to) && void 0 !== r ? r : FQ(e.state)) : new cB(this.source,1,l)
        }
        handleChange(e) {
            return e.changes.touchesRange(this.from, this.to) ? new cB(this.source,0) : this.map(e.changes)
        }
        map(e) {
            if (e.empty)
                return this;
            return (this.result.map ? this.result.map(this.result, e) : this.result) ? new uB(this.source,this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos),this.result,e.mapPos(this.from),e.mapPos(this.to, 1)) : new cB(this.source,0)
        }
    }
    const dB = NP.define({
        map: (e,t)=>e.map((e=>e.map(t)))
    })
      , pB = NP.define()
      , hB = uP.define({
        create: ()=>oB.start(),
        update: (e,t)=>e.update(t),
        provide: e=>[HI.from(e, (e=>e.tooltip)), pI.contentAttributes.from(e, (e=>e.attrs))]
    });
    function fB(e, t) {
        const n = t.completion.apply || t.completion.label;
        let r = e.state.field(hB).active.find((e=>e.source == t.source));
        return r instanceof uB && ("string" == typeof n ? e.dispatch(Object.assign(Object.assign({}, function(e, t, n, r) {
            let {main: o} = e.selection
              , i = n - o.from
              , a = r - o.from;
            return Object.assign(Object.assign({}, e.changeByRange((s=>s != o && n != r && e.sliceDoc(s.from + i, s.from + a) != e.sliceDoc(n, r) ? {
                range: s
            } : {
                changes: {
                    from: s.from + i,
                    to: r == o.from ? s.to : s.from + a,
                    insert: t
                },
                range: eP.cursor(s.from + i + t.length)
            }))), {
                scrollIntoView: !0,
                userEvent: "input.complete"
            })
        }(e.state, n, r.from, r.to)), {
            annotations: zQ.of(t.completion)
        })) : n(e, t.completion, r.from, r.to),
        !0)
    }
    const mB = tB(hB, fB);
    function gB(e, t="option") {
        return n=>{
            let r = n.state.field(hB, !1);
            if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < n.state.facet(GQ).interactionDelay)
                return !1;
            let o, i = 1;
            "page" == t && (o = ZI(n, r.open.tooltip)) && (i = Math.max(2, Math.floor(o.dom.offsetHeight / o.dom.querySelector("li").offsetHeight) - 1));
            let {length: a} = r.open.options
              , s = r.open.selected > -1 ? r.open.selected + i * (e ? 1 : -1) : e ? 0 : a - 1;
            return s < 0 ? s = "page" == t ? 0 : a - 1 : s >= a && (s = "page" == t ? a - 1 : 0),
            n.dispatch({
                effects: pB.of(s)
            }),
            !0
        }
    }
    class bB {
        constructor(e, t) {
            this.active = e,
            this.context = t,
            this.time = Date.now(),
            this.updates = [],
            this.done = void 0
        }
    }
    const OB = gN.fromClass(class {
        constructor(e) {
            this.view = e,
            this.debounceUpdate = -1,
            this.running = [],
            this.debounceAccept = -1,
            this.pendingStart = !1,
            this.composing = 0;
            for (let t of e.state.field(hB).active)
                1 == t.state && this.startQuery(t)
        }
        update(e) {
            let t = e.state.field(hB)
              , n = e.state.facet(GQ);
            if (!e.selectionSet && !e.docChanged && e.startState.field(hB) == t)
                return;
            let r = e.transactions.some((e=>(e.selection || e.docChanged) && !lB(e, n)));
            for (let i = 0; i < this.running.length; i++) {
                let t = this.running[i];
                if (r || t.updates.length + e.transactions.length > 50 && Date.now() - t.time > 1e3) {
                    for (let e of t.context.abortListeners)
                        try {
                            e()
                        } catch (Aa) {
                            pN(this.view.state, Aa)
                        }
                    t.context.abortListeners = null,
                    this.running.splice(i--, 1)
                } else
                    t.updates.push(...e.transactions)
            }
            this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate),
            e.transactions.some((e=>e.effects.some((e=>e.is(ZQ))))) && (this.pendingStart = !0);
            let o = this.pendingStart ? 50 : n.activateOnTypingDelay;
            if (this.debounceUpdate = t.active.some((e=>1 == e.state && !this.running.some((t=>t.active.source == e.source)))) ? setTimeout((()=>this.startUpdate()), o) : -1,
            0 != this.composing)
                for (let i of e.transactions)
                    "input" == lB(i, n) ? this.composing = 2 : 2 == this.composing && i.selection && (this.composing = 3)
        }
        startUpdate() {
            this.debounceUpdate = -1,
            this.pendingStart = !1;
            let {state: e} = this.view
              , t = e.field(hB);
            for (let n of t.active)
                1 != n.state || this.running.some((e=>e.active.source == n.source)) || this.startQuery(n)
        }
        startQuery(e) {
            let {state: t} = this.view
              , n = FQ(t)
              , r = new LQ(t,n,e.explicitPos == n)
              , o = new bB(e,r);
            this.running.push(o),
            Promise.resolve(e.source(r)).then((e=>{
                o.context.aborted || (o.done = e || null,
                this.scheduleAccept())
            }
            ), (e=>{
                this.view.dispatch({
                    effects: WQ.of(null)
                }),
                pN(this.view.state, e)
            }
            ))
        }
        scheduleAccept() {
            this.running.every((e=>void 0 !== e.done)) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout((()=>this.accept()), this.view.state.facet(GQ).updateSyncTime))
        }
        accept() {
            var e;
            this.debounceAccept > -1 && clearTimeout(this.debounceAccept),
            this.debounceAccept = -1;
            let t = []
              , n = this.view.state.facet(GQ);
            for (let r = 0; r < this.running.length; r++) {
                let o = this.running[r];
                if (void 0 === o.done)
                    continue;
                if (this.running.splice(r--, 1),
                o.done) {
                    let r = new uB(o.active.source,o.active.explicitPos,o.done,o.done.from,null !== (e = o.done.to) && void 0 !== e ? e : FQ(o.updates.length ? o.updates[0].startState : this.view.state));
                    for (let e of o.updates)
                        r = r.update(e, n);
                    if (r.hasResult()) {
                        t.push(r);
                        continue
                    }
                }
                let i = this.view.state.field(hB).active.find((e=>e.source == o.active.source));
                if (i && 1 == i.state)
                    if (null == o.done) {
                        let e = new cB(o.active.source,0);
                        for (let t of o.updates)
                            e = e.update(t, n);
                        1 != e.state && t.push(e)
                    } else
                        this.startQuery(i)
            }
            t.length && this.view.dispatch({
                effects: dB.of(t)
            })
        }
    }
    , {
        eventHandlers: {
            blur(e) {
                let t = this.view.state.field(hB, !1);
                if (t && t.tooltip && this.view.state.facet(GQ).closeOnBlur) {
                    let n = t.open && ZI(this.view, t.open.tooltip);
                    n && n.dom.contains(e.relatedTarget) || setTimeout((()=>this.view.dispatch({
                        effects: WQ.of(null)
                    })), 10)
                }
            },
            compositionstart() {
                this.composing = 1
            },
            compositionend() {
                3 == this.composing && setTimeout((()=>this.view.dispatch({
                    effects: ZQ.of(!1)
                })), 20),
                this.composing = 0
            }
        }
    })
      , vB = "object" == typeof navigator && /Win/.test(navigator.platform)
      , yB = gP.highest(pI.domEventHandlers({
        keydown(e, t) {
            let n = t.state.field(hB, !1);
            if (!n || !n.open || n.open.disabled || n.open.selected < 0 || e.key.length > 1 || e.ctrlKey && (!vB || !e.altKey) || e.metaKey)
                return !1;
            let r = n.open.options[n.open.selected]
              , o = n.active.find((e=>e.source == r.source))
              , i = r.completion.commitCharacters || o.result.commitCharacters;
            return i && i.indexOf(e.key) > -1 && fB(t, r),
            !1
        }
    }))
      , wB = pI.baseTheme({
        ".cm-tooltip.cm-tooltip-autocomplete": {
            "& > ul": {
                fontFamily: "monospace",
                whiteSpace: "nowrap",
                overflow: "hidden auto",
                maxWidth_fallback: "700px",
                maxWidth: "min(700px, 95vw)",
                minWidth: "250px",
                maxHeight: "10em",
                height: "100%",
                listStyle: "none",
                margin: 0,
                padding: 0,
                "& > li, & > completion-section": {
                    padding: "1px 3px",
                    lineHeight: 1.2
                },
                "& > li": {
                    overflowX: "hidden",
                    textOverflow: "ellipsis",
                    cursor: "pointer"
                },
                "& > completion-section": {
                    display: "list-item",
                    borderBottom: "1px solid silver",
                    paddingLeft: "0.5em",
                    opacity: .7
                }
            }
        },
        "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
            background: "#17c",
            color: "white"
        },
        "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
            background: "#777"
        },
        "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
            background: "#347",
            color: "white"
        },
        "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
            background: "#444"
        },
        ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
            content: '"···"',
            opacity: .5,
            display: "block",
            textAlign: "center"
        },
        ".cm-tooltip.cm-completionInfo": {
            position: "absolute",
            padding: "3px 9px",
            width: "max-content",
            maxWidth: "400px",
            boxSizing: "border-box"
        },
        ".cm-completionInfo.cm-completionInfo-left": {
            right: "100%"
        },
        ".cm-completionInfo.cm-completionInfo-right": {
            left: "100%"
        },
        ".cm-completionInfo.cm-completionInfo-left-narrow": {
            right: "30px"
        },
        ".cm-completionInfo.cm-completionInfo-right-narrow": {
            left: "30px"
        },
        "&light .cm-snippetField": {
            backgroundColor: "#00000022"
        },
        "&dark .cm-snippetField": {
            backgroundColor: "#ffffff22"
        },
        ".cm-snippetFieldPosition": {
            verticalAlign: "text-top",
            width: 0,
            height: "1.15em",
            display: "inline-block",
            margin: "0 -0.7px -.7em",
            borderLeft: "1.4px dotted #888"
        },
        ".cm-completionMatchedText": {
            textDecoration: "underline"
        },
        ".cm-completionDetail": {
            marginLeft: "0.5em",
            fontStyle: "italic"
        },
        ".cm-completionIcon": {
            fontSize: "90%",
            width: ".8em",
            display: "inline-block",
            textAlign: "center",
            paddingRight: ".6em",
            opacity: "0.6",
            boxSizing: "content-box"
        },
        ".cm-completionIcon-function, .cm-completionIcon-method": {
            "&:after": {
                content: "'ƒ'"
            }
        },
        ".cm-completionIcon-class": {
            "&:after": {
                content: "'○'"
            }
        },
        ".cm-completionIcon-interface": {
            "&:after": {
                content: "'◌'"
            }
        },
        ".cm-completionIcon-variable": {
            "&:after": {
                content: "'𝑥'"
            }
        },
        ".cm-completionIcon-constant": {
            "&:after": {
                content: "'𝐶'"
            }
        },
        ".cm-completionIcon-type": {
            "&:after": {
                content: "'𝑡'"
            }
        },
        ".cm-completionIcon-enum": {
            "&:after": {
                content: "'∪'"
            }
        },
        ".cm-completionIcon-property": {
            "&:after": {
                content: "'□'"
            }
        },
        ".cm-completionIcon-keyword": {
            "&:after": {
                content: "'🔑︎'"
            }
        },
        ".cm-completionIcon-namespace": {
            "&:after": {
                content: "'▢'"
            }
        },
        ".cm-completionIcon-text": {
            "&:after": {
                content: "'abc'",
                fontSize: "50%",
                verticalAlign: "middle"
            }
        }
    });
    class _B {
        constructor(e, t, n, r) {
            this.field = e,
            this.line = t,
            this.from = n,
            this.to = r
        }
    }
    class kB {
        constructor(e, t, n) {
            this.field = e,
            this.from = t,
            this.to = n
        }
        map(e) {
            let t = e.mapPos(this.from, -1, qC.TrackDel)
              , n = e.mapPos(this.to, 1, qC.TrackDel);
            return null == t || null == n ? null : new kB(this.field,t,n)
        }
    }
    class SB {
        constructor(e, t) {
            this.lines = e,
            this.fieldPositions = t
        }
        instantiate(e, t) {
            let n = []
              , r = [t]
              , o = e.doc.lineAt(t)
              , i = /^\s*/.exec(o.text)[0];
            for (let a of this.lines) {
                if (n.length) {
                    let n = i
                      , o = /^\t*/.exec(a)[0].length;
                    for (let t = 0; t < o; t++)
                        n += e.facet(WL);
                    r.push(t + n.length - o),
                    a = n + a.slice(o)
                }
                n.push(a),
                t += a.length + 1
            }
            return {
                text: n,
                ranges: this.fieldPositions.map((e=>new kB(e.field,r[e.line] + e.from,r[e.line] + e.to)))
            }
        }
        static parse(e) {
            let t, n = [], r = [], o = [];
            for (let i of e.split(/\r\n?|\n/)) {
                for (; t = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(i); ) {
                    let e = t[1] ? +t[1] : null
                      , a = t[2] || t[3] || ""
                      , s = -1
                      , l = a.replace(/\\[{}]/g, (e=>e[1]));
                    for (let t = 0; t < n.length; t++)
                        (null != e ? n[t].seq == e : l && n[t].name == l) && (s = t);
                    if (s < 0) {
                        let t = 0;
                        for (; t < n.length && (null == e || null != n[t].seq && n[t].seq < e); )
                            t++;
                        n.splice(t, 0, {
                            seq: e,
                            name: l
                        }),
                        s = t;
                        for (let e of o)
                            e.field >= s && e.field++
                    }
                    o.push(new _B(s,r.length,t.index,t.index + l.length)),
                    i = i.slice(0, t.index) + a + i.slice(t.index + t[0].length)
                }
                i = i.replace(/\\([{}])/g, ((e,t,n)=>{
                    for (let i of o)
                        i.line == r.length && i.from > n && (i.from--,
                        i.to--);
                    return t
                }
                )),
                r.push(i)
            }
            return new SB(r,o)
        }
    }
    let EB = ER.widget({
        widget: new class extends kR {
            toDOM() {
                let e = document.createElement("span");
                return e.className = "cm-snippetFieldPosition",
                e
            }
            ignoreEvent() {
                return !1
            }
        }
    })
      , xB = ER.mark({
        class: "cm-snippetField"
    });
    class TB {
        constructor(e, t) {
            this.ranges = e,
            this.active = t,
            this.deco = ER.set(e.map((e=>(e.from == e.to ? EB : xB).range(e.from, e.to))))
        }
        map(e) {
            let t = [];
            for (let n of this.ranges) {
                let r = n.map(e);
                if (!r)
                    return null;
                t.push(r)
            }
            return new TB(t,this.active)
        }
        selectionInsideField(e) {
            return e.ranges.every((e=>this.ranges.some((t=>t.field == this.active && t.from <= e.from && t.to >= e.to))))
        }
    }
    const AB = NP.define({
        map: (e,t)=>e && e.map(t)
    })
      , CB = NP.define()
      , PB = uP.define({
        create: ()=>null,
        update(e, t) {
            for (let n of t.effects) {
                if (n.is(AB))
                    return n.value;
                if (n.is(CB) && e)
                    return new TB(e.ranges,n.value)
            }
            return e && t.docChanged && (e = e.map(t.changes)),
            e && t.selection && !e.selectionInsideField(t.selection) && (e = null),
            e
        },
        provide: e=>pI.decorations.from(e, (e=>e ? e.deco : ER.none))
    });
    function DB(e, t) {
        return eP.create(e.filter((e=>e.field == t)).map((e=>eP.range(e.from, e.to))))
    }
    function RB(e) {
        let t = SB.parse(e);
        return (e,n,r,o)=>{
            let {text: i, ranges: a} = t.instantiate(e.state, r)
              , s = {
                changes: {
                    from: r,
                    to: o,
                    insert: wC.of(i)
                },
                scrollIntoView: !0,
                annotations: n ? [zQ.of(n), $P.userEvent.of("input.complete")] : void 0
            };
            if (a.length && (s.selection = DB(a, 0)),
            a.some((e=>e.field > 0))) {
                let t = new TB(a,0)
                  , n = s.effects = [AB.of(t)];
                void 0 === e.state.field(PB, !1) && n.push(NP.appendConfig.of([PB, MB, QB, wB]))
            }
            e.dispatch(e.state.update(s))
        }
    }
    function NB(e) {
        return ({state: t, dispatch: n})=>{
            let r = t.field(PB, !1);
            if (!r || e < 0 && 0 == r.active)
                return !1;
            let o = r.active + e
              , i = e > 0 && !r.ranges.some((t=>t.field == o + e));
            return n(t.update({
                selection: DB(r.ranges, o),
                effects: AB.of(i ? null : new TB(r.ranges,o)),
                scrollIntoView: !0
            })),
            !0
        }
    }
    const $B = [{
        key: "Tab",
        run: NB(1),
        shift: NB(-1)
    }, {
        key: "Escape",
        run: ({state: e, dispatch: t})=>!!e.field(PB, !1) && (t(e.update({
            effects: AB.of(null)
        })),
        !0)
    }]
      , IB = rP.define({
        combine: e=>e.length ? e[0] : $B
    })
      , MB = gP.highest(yI.compute([IB], (e=>e.facet(IB))));
    function LB(e, t) {
        return Object.assign(Object.assign({}, t), {
            apply: RB(e)
        })
    }
    const QB = pI.domEventHandlers({
        mousedown(e, t) {
            let n, r = t.state.field(PB, !1);
            if (!r || null == (n = t.posAtCoords({
                x: e.clientX,
                y: e.clientY
            })))
                return !1;
            let o = r.ranges.find((e=>e.from <= n && e.to >= n));
            return !(!o || o.field == r.active) && (t.dispatch({
                selection: DB(r.ranges, o.field),
                effects: AB.of(r.ranges.some((e=>e.field > o.field)) ? new TB(r.ranges,o.field) : null),
                scrollIntoView: !0
            }),
            !0)
        }
    })
      , BB = {
        brackets: ["(", "[", "{", "'", '"'],
        before: ")]}:;>",
        stringPrefixes: []
    }
      , UB = NP.define({
        map(e, t) {
            let n = t.mapPos(e, -1, qC.TrackAfter);
            return null == n ? void 0 : n
        }
    })
      , FB = new class extends WP {
    }
    ;
    FB.startSide = 1,
    FB.endSide = -1;
    const jB = uP.define({
        create: ()=>YP.empty,
        update(e, t) {
            if (e = e.map(t.changes),
            t.selection) {
                let n = t.state.doc.lineAt(t.selection.main.head);
                e = e.update({
                    filter: e=>e >= n.from && e <= n.to
                })
            }
            for (let n of t.effects)
                n.is(UB) && (e = e.update({
                    add: [FB.range(n.value, n.value + 1)]
                }));
            return e
        }
    });
    const zB = "()[]{}<>";
    function qB(e) {
        for (let t = 0; t < zB.length; t += 2)
            if (zB.charCodeAt(t) == e)
                return zB.charAt(t + 1);
        return FC(e < 128 ? e : e + 1)
    }
    function HB(e, t) {
        return e.languageDataAt("closeBrackets", t)[0] || BB
    }
    const ZB = "object" == typeof navigator && /Android\b/.test(navigator.userAgent)
      , WB = pI.inputHandler.of(((e,t,n,r)=>{
        if ((ZB ? e.composing : e.compositionStarted) || e.state.readOnly)
            return !1;
        let o = e.state.selection.main;
        if (r.length > 2 || 2 == r.length && 1 == jC(UC(r, 0)) || t != o.from || n != o.to)
            return !1;
        let i = function(e, t) {
            let n = HB(e, e.selection.main.head)
              , r = n.brackets || BB.brackets;
            for (let o of r) {
                let i = qB(UC(o, 0));
                if (t == o)
                    return i == o ? JB(e, o, r.indexOf(o + o + o) > -1, n) : YB(e, o, i, n.before || BB.before);
                if (t == i && VB(e, e.selection.main.from))
                    return KB(e, o, i)
            }
            return null
        }(e.state, r);
        return !!i && (e.dispatch(i),
        !0)
    }
    ))
      , XB = [{
        key: "Backspace",
        run: ({state: e, dispatch: t})=>{
            if (e.readOnly)
                return !1;
            let n = HB(e, e.selection.main.head).brackets || BB.brackets
              , r = null
              , o = e.changeByRange((t=>{
                if (t.empty) {
                    let r = function(e, t) {
                        let n = e.sliceString(t - 2, t);
                        return jC(UC(n, 0)) == n.length ? n : n.slice(1)
                    }(e.doc, t.head);
                    for (let o of n)
                        if (o == r && GB(e.doc, t.head) == qB(UC(o, 0)))
                            return {
                                changes: {
                                    from: t.head - o.length,
                                    to: t.head + o.length
                                },
                                range: eP.cursor(t.head - o.length)
                            }
                }
                return {
                    range: r = t
                }
            }
            ));
            return r || t(e.update(o, {
                scrollIntoView: !0,
                userEvent: "delete.backward"
            })),
            !r
        }
    }];
    function VB(e, t) {
        let n = !1;
        return e.field(jB).between(0, e.doc.length, (e=>{
            e == t && (n = !0)
        }
        )),
        n
    }
    function GB(e, t) {
        let n = e.sliceString(t, t + 2);
        return n.slice(0, jC(UC(n, 0)))
    }
    function YB(e, t, n, r) {
        let o = null
          , i = e.changeByRange((i=>{
            if (!i.empty)
                return {
                    changes: [{
                        insert: t,
                        from: i.from
                    }, {
                        insert: n,
                        from: i.to
                    }],
                    effects: UB.of(i.to + t.length),
                    range: eP.range(i.anchor + t.length, i.head + t.length)
                };
            let a = GB(e.doc, i.head);
            return !a || /\s/.test(a) || r.indexOf(a) > -1 ? {
                changes: {
                    insert: t + n,
                    from: i.head
                },
                effects: UB.of(i.head + t.length),
                range: eP.cursor(i.head + t.length)
            } : {
                range: o = i
            }
        }
        ));
        return o ? null : e.update(i, {
            scrollIntoView: !0,
            userEvent: "input.type"
        })
    }
    function KB(e, t, n) {
        let r = null
          , o = e.changeByRange((t=>t.empty && GB(e.doc, t.head) == n ? {
            changes: {
                from: t.head,
                to: t.head + n.length,
                insert: n
            },
            range: eP.cursor(t.head + n.length)
        } : r = {
            range: t
        }));
        return r ? null : e.update(o, {
            scrollIntoView: !0,
            userEvent: "input.type"
        })
    }
    function JB(e, t, n, r) {
        let o = r.stringPrefixes || BB.stringPrefixes
          , i = null
          , a = e.changeByRange((r=>{
            if (!r.empty)
                return {
                    changes: [{
                        insert: t,
                        from: r.from
                    }, {
                        insert: t,
                        from: r.to
                    }],
                    effects: UB.of(r.to + t.length),
                    range: eP.range(r.anchor + t.length, r.head + t.length)
                };
            let a, s = r.head, l = GB(e.doc, s);
            if (l == t) {
                if (eU(e, s))
                    return {
                        changes: {
                            insert: t + t,
                            from: s
                        },
                        effects: UB.of(s + t.length),
                        range: eP.cursor(s + t.length)
                    };
                if (VB(e, s)) {
                    let r = n && e.sliceDoc(s, s + 3 * t.length) == t + t + t ? t + t + t : t;
                    return {
                        changes: {
                            from: s,
                            to: s + r.length,
                            insert: r
                        },
                        range: eP.cursor(s + r.length)
                    }
                }
            } else {
                if (n && e.sliceDoc(s - 2 * t.length, s) == t + t && (a = tU(e, s - 2 * t.length, o)) > -1 && eU(e, a))
                    return {
                        changes: {
                            insert: t + t + t + t,
                            from: s
                        },
                        effects: UB.of(s + t.length),
                        range: eP.cursor(s + t.length)
                    };
                if (e.charCategorizer(s)(l) != FP.Word && tU(e, s, o) > -1 && !function(e, t, n, r) {
                    let o = IL(e).resolveInner(t, -1)
                      , i = r.reduce(((e,t)=>Math.max(e, t.length)), 0);
                    for (let a = 0; a < 5; a++) {
                        let a = e.sliceDoc(o.from, Math.min(o.to, o.from + n.length + i))
                          , s = a.indexOf(n);
                        if (!s || s > -1 && r.indexOf(a.slice(0, s)) > -1) {
                            let t = o.firstChild;
                            for (; t && t.from == o.from && t.to - t.from > n.length + s; ) {
                                if (e.sliceDoc(t.to - n.length, t.to) == n)
                                    return !1;
                                t = t.firstChild
                            }
                            return !0
                        }
                        let l = o.to == t && o.parent;
                        if (!l)
                            break;
                        o = l
                    }
                    return !1
                }(e, s, t, o))
                    return {
                        changes: {
                            insert: t + t,
                            from: s
                        },
                        effects: UB.of(s + t.length),
                        range: eP.cursor(s + t.length)
                    }
            }
            return {
                range: i = r
            }
        }
        ));
        return i ? null : e.update(a, {
            scrollIntoView: !0,
            userEvent: "input.type"
        })
    }
    function eU(e, t) {
        let n = IL(e).resolveInner(t + 1);
        return n.parent && n.from == t
    }
    function tU(e, t, n) {
        let r = e.charCategorizer(t);
        if (r(e.sliceDoc(t - 1, t)) != FP.Word)
            return t;
        for (let o of n) {
            let n = t - o.length;
            if (e.sliceDoc(n, t) == o && r(e.sliceDoc(n - 1, n)) != FP.Word)
                return n
        }
        return -1
    }
    const nU = [{
        key: "Ctrl-Space",
        run: e=>!!e.state.field(hB, !1) && (e.dispatch({
            effects: ZQ.of(!0)
        }),
        !0)
    }, {
        key: "Escape",
        run: e=>{
            let t = e.state.field(hB, !1);
            return !(!t || !t.active.some((e=>0 != e.state))) && (e.dispatch({
                effects: WQ.of(null)
            }),
            !0)
        }
    }, {
        key: "ArrowDown",
        run: gB(!0)
    }, {
        key: "ArrowUp",
        run: gB(!1)
    }, {
        key: "PageDown",
        run: gB(!0, "page")
    }, {
        key: "PageUp",
        run: gB(!1, "page")
    }, {
        key: "Enter",
        run: e=>{
            let t = e.state.field(hB, !1);
            return !(e.state.readOnly || !t || !t.open || t.open.selected < 0 || t.open.disabled || Date.now() - t.open.timestamp < e.state.facet(GQ).interactionDelay) && fB(e, t.open.options[t.open.selected])
        }
    }]
      , rU = gP.highest(yI.computeN([GQ], (e=>e.facet(GQ).defaultKeymap ? [nU] : [])));
    function oU(e, t) {
        let n = -1;
        return e.changeByRange((r=>{
            let o = [];
            for (let a = r.from; a <= r.to; ) {
                let i = e.doc.lineAt(a);
                i.number > n && (r.empty || r.to > i.from) && (t(i, o, r),
                n = i.number),
                a = i.to + 1
            }
            let i = e.changes(o);
            return {
                changes: o,
                range: eP.range(i.mapPos(r.anchor, 1), i.mapPos(r.head, 1))
            }
        }
        ))
    }
    const iU = {
        key: "Tab",
        run: ({state: e, dispatch: t})=>!e.readOnly && (t(e.update(oU(e, ((t,n)=>{
            n.push({
                from: t.from,
                insert: e.facet(WL)
            })
        }
        )), {
            userEvent: "input.indent"
        })),
        !0),
        shift: ({state: e, dispatch: t})=>!e.readOnly && (t(e.update(oU(e, ((t,n)=>{
            let r = /^\s*/.exec(t.text)[0];
            if (!r)
                return;
            let o = cD(r, e.tabSize)
              , i = 0
              , a = VL(e, Math.max(0, o - XL(e)));
            for (; i < r.length && i < a.length && r.charCodeAt(i) == a.charCodeAt(i); )
                i++;
            n.push({
                from: t.from + i,
                to: t.from + r.length,
                insert: a.slice(i)
            })
        }
        )), {
            userEvent: "delete.dedent"
        })),
        !0)
    };
    class aU {
        constructor(e, t, n, r, o, i, a, s, l, c=0, u) {
            this.p = e,
            this.stack = t,
            this.state = n,
            this.reducePos = r,
            this.pos = o,
            this.score = i,
            this.buffer = a,
            this.bufferBase = s,
            this.curContext = l,
            this.lookAhead = c,
            this.parent = u
        }
        toString() {
            return `[${this.stack.filter(((e,t)=>t % 3 == 0)).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`
        }
        static start(e, t, n=0) {
            let r = e.parser.context;
            return new aU(e,[],t,n,n,0,[],0,r ? new sU(r,r.start) : null,0,null)
        }
        get context() {
            return this.curContext ? this.curContext.context : null
        }
        pushState(e, t) {
            this.stack.push(this.state, t, this.bufferBase + this.buffer.length),
            this.state = e
        }
        reduce(e) {
            var t;
            let n = e >> 19
              , r = 65535 & e
              , {parser: o} = this.p;
            this.reducePos < this.pos - 25 && this.setLookAhead(this.pos);
            let i = o.dynamicPrecedence(r);
            if (i && (this.score += i),
            0 == n)
                return this.pushState(o.getGoto(this.state, r, !0), this.reducePos),
                r < o.minRepeatTerm && this.storeNode(r, this.reducePos, this.reducePos, 4, !0),
                void this.reduceContext(r, this.reducePos);
            let a = this.stack.length - 3 * (n - 1) - (262144 & e ? 6 : 0)
              , s = a ? this.stack[a - 2] : this.p.ranges[0].from
              , l = this.reducePos - s;
            l >= 2e3 && !(null === (t = this.p.parser.nodeSet.types[r]) || void 0 === t ? void 0 : t.isAnonymous) && (s == this.p.lastBigReductionStart ? (this.p.bigReductionCount++,
            this.p.lastBigReductionSize = l) : this.p.lastBigReductionSize < l && (this.p.bigReductionCount = 1,
            this.p.lastBigReductionStart = s,
            this.p.lastBigReductionSize = l));
            let c = a ? this.stack[a - 1] : 0
              , u = this.bufferBase + this.buffer.length - c;
            if (r < o.minRepeatTerm || 131072 & e) {
                let e = o.stateFlag(this.state, 1) ? this.pos : this.reducePos;
                this.storeNode(r, s, e, u + 4, !0)
            }
            if (262144 & e)
                this.state = this.stack[a];
            else {
                let e = this.stack[a - 3];
                this.state = o.getGoto(e, r, !0)
            }
            for (; this.stack.length > a; )
                this.stack.pop();
            this.reduceContext(r, s)
        }
        storeNode(e, t, n, r=4, o=!1) {
            if (0 == e && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
                let e = this
                  , r = this.buffer.length;
                if (0 == r && e.parent && (r = e.bufferBase - e.parent.bufferBase,
                e = e.parent),
                r > 0 && 0 == e.buffer[r - 4] && e.buffer[r - 1] > -1) {
                    if (t == n)
                        return;
                    if (e.buffer[r - 2] >= t)
                        return void (e.buffer[r - 2] = n)
                }
            }
            if (o && this.pos != n) {
                let o = this.buffer.length;
                if (o > 0 && 0 != this.buffer[o - 4])
                    for (; o > 0 && this.buffer[o - 2] > n; )
                        this.buffer[o] = this.buffer[o - 4],
                        this.buffer[o + 1] = this.buffer[o - 3],
                        this.buffer[o + 2] = this.buffer[o - 2],
                        this.buffer[o + 3] = this.buffer[o - 1],
                        o -= 4,
                        r > 4 && (r -= 4);
                this.buffer[o] = e,
                this.buffer[o + 1] = t,
                this.buffer[o + 2] = n,
                this.buffer[o + 3] = r
            } else
                this.buffer.push(e, t, n, r)
        }
        shift(e, t, n, r) {
            if (131072 & e)
                this.pushState(65535 & e, this.pos);
            else if (262144 & e)
                this.pos = r,
                this.shiftContext(t, n),
                t <= this.p.parser.maxNode && this.buffer.push(t, n, r, 4);
            else {
                let o = e
                  , {parser: i} = this.p;
                (r > this.pos || t <= i.maxNode) && (this.pos = r,
                i.stateFlag(o, 1) || (this.reducePos = r)),
                this.pushState(o, n),
                this.shiftContext(t, n),
                t <= i.maxNode && this.buffer.push(t, n, r, 4)
            }
        }
        apply(e, t, n, r) {
            65536 & e ? this.reduce(e) : this.shift(e, t, n, r)
        }
        useNode(e, t) {
            let n = this.p.reused.length - 1;
            (n < 0 || this.p.reused[n] != e) && (this.p.reused.push(e),
            n++);
            let r = this.pos;
            this.reducePos = this.pos = r + e.length,
            this.pushState(t, r),
            this.buffer.push(n, r, this.reducePos, -1),
            this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)))
        }
        split() {
            let e = this
              , t = e.buffer.length;
            for (; t > 0 && e.buffer[t - 2] > e.reducePos; )
                t -= 4;
            let n = e.buffer.slice(t)
              , r = e.bufferBase + t;
            for (; e && r == e.bufferBase; )
                e = e.parent;
            return new aU(this.p,this.stack.slice(),this.state,this.reducePos,this.pos,this.score,n,r,this.curContext,this.lookAhead,e)
        }
        recoverByDelete(e, t) {
            let n = e <= this.p.parser.maxNode;
            n && this.storeNode(e, this.pos, t, 4),
            this.storeNode(0, this.pos, t, n ? 8 : 4),
            this.pos = this.reducePos = t,
            this.score -= 190
        }
        canShift(e) {
            for (let t = new lU(this); ; ) {
                let n = this.p.parser.stateSlot(t.state, 4) || this.p.parser.hasAction(t.state, e);
                if (0 == n)
                    return !1;
                if (!(65536 & n))
                    return !0;
                t.reduce(n)
            }
        }
        recoverByInsert(e) {
            if (this.stack.length >= 300)
                return [];
            let t = this.p.parser.nextStates(this.state);
            if (t.length > 8 || this.stack.length >= 120) {
                let n = [];
                for (let r, o = 0; o < t.length; o += 2)
                    (r = t[o + 1]) != this.state && this.p.parser.hasAction(r, e) && n.push(t[o], r);
                if (this.stack.length < 120)
                    for (let e = 0; n.length < 8 && e < t.length; e += 2) {
                        let r = t[e + 1];
                        n.some(((e,t)=>1 & t && e == r)) || n.push(t[e], r)
                    }
                t = n
            }
            let n = [];
            for (let r = 0; r < t.length && n.length < 4; r += 2) {
                let e = t[r + 1];
                if (e == this.state)
                    continue;
                let o = this.split();
                o.pushState(e, this.pos),
                o.storeNode(0, o.pos, o.pos, 4, !0),
                o.shiftContext(t[r], this.pos),
                o.reducePos = this.pos,
                o.score -= 200,
                n.push(o)
            }
            return n
        }
        forceReduce() {
            let {parser: e} = this.p
              , t = e.stateSlot(this.state, 5);
            if (!(65536 & t))
                return !1;
            if (!e.validAction(this.state, t)) {
                let n = t >> 19
                  , r = 65535 & t
                  , o = this.stack.length - 3 * n;
                if (o < 0 || e.getGoto(this.stack[o], r, !1) < 0) {
                    let e = this.findForcedReduction();
                    if (null == e)
                        return !1;
                    t = e
                }
                this.storeNode(0, this.pos, this.pos, 4, !0),
                this.score -= 100
            }
            return this.reducePos = this.pos,
            this.reduce(t),
            !0
        }
        findForcedReduction() {
            let {parser: e} = this.p
              , t = []
              , n = (r,o)=>{
                if (!t.includes(r))
                    return t.push(r),
                    e.allActions(r, (t=>{
                        if (393216 & t)
                            ;
                        else if (65536 & t) {
                            let n = (t >> 19) - o;
                            if (n > 1) {
                                let r = 65535 & t
                                  , o = this.stack.length - 3 * n;
                                if (o >= 0 && e.getGoto(this.stack[o], r, !1) >= 0)
                                    return n << 19 | 65536 | r
                            }
                        } else {
                            let e = n(t, o + 1);
                            if (null != e)
                                return e
                        }
                    }
                    ))
            }
            ;
            return n(this.state, 0)
        }
        forceAll() {
            for (; !this.p.parser.stateFlag(this.state, 2); )
                if (!this.forceReduce()) {
                    this.storeNode(0, this.pos, this.pos, 4, !0);
                    break
                }
            return this
        }
        get deadEnd() {
            if (3 != this.stack.length)
                return !1;
            let {parser: e} = this.p;
            return 65535 == e.data[e.stateSlot(this.state, 1)] && !e.stateSlot(this.state, 4)
        }
        restart() {
            this.storeNode(0, this.pos, this.pos, 4, !0),
            this.state = this.stack[0],
            this.stack.length = 0
        }
        sameState(e) {
            if (this.state != e.state || this.stack.length != e.stack.length)
                return !1;
            for (let t = 0; t < this.stack.length; t += 3)
                if (this.stack[t] != e.stack[t])
                    return !1;
            return !0
        }
        get parser() {
            return this.p.parser
        }
        dialectEnabled(e) {
            return this.p.parser.dialect.flags[e]
        }
        shiftContext(e, t) {
            this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(t)))
        }
        reduceContext(e, t) {
            this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(t)))
        }
        emitContext() {
            let e = this.buffer.length - 1;
            (e < 0 || -3 != this.buffer[e]) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3)
        }
        emitLookAhead() {
            let e = this.buffer.length - 1;
            (e < 0 || -4 != this.buffer[e]) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4)
        }
        updateContext(e) {
            if (e != this.curContext.context) {
                let t = new sU(this.curContext.tracker,e);
                t.hash != this.curContext.hash && this.emitContext(),
                this.curContext = t
            }
        }
        setLookAhead(e) {
            e > this.lookAhead && (this.emitLookAhead(),
            this.lookAhead = e)
        }
        close() {
            this.curContext && this.curContext.tracker.strict && this.emitContext(),
            this.lookAhead > 0 && this.emitLookAhead()
        }
    }
    class sU {
        constructor(e, t) {
            this.tracker = e,
            this.context = t,
            this.hash = e.strict ? e.hash(t) : 0
        }
    }
    class lU {
        constructor(e) {
            this.start = e,
            this.state = e.state,
            this.stack = e.stack,
            this.base = this.stack.length
        }
        reduce(e) {
            let t = 65535 & e
              , n = e >> 19;
            0 == n ? (this.stack == this.start.stack && (this.stack = this.stack.slice()),
            this.stack.push(this.state, 0, 0),
            this.base += 3) : this.base -= 3 * (n - 1);
            let r = this.start.p.parser.getGoto(this.stack[this.base - 3], t, !0);
            this.state = r
        }
    }
    class cU {
        constructor(e, t, n) {
            this.stack = e,
            this.pos = t,
            this.index = n,
            this.buffer = e.buffer,
            0 == this.index && this.maybeNext()
        }
        static create(e, t=e.bufferBase + e.buffer.length) {
            return new cU(e,t,t - e.bufferBase)
        }
        maybeNext() {
            let e = this.stack.parent;
            null != e && (this.index = this.stack.bufferBase - e.bufferBase,
            this.stack = e,
            this.buffer = e.buffer)
        }
        get id() {
            return this.buffer[this.index - 4]
        }
        get start() {
            return this.buffer[this.index - 3]
        }
        get end() {
            return this.buffer[this.index - 2]
        }
        get size() {
            return this.buffer[this.index - 1]
        }
        next() {
            this.index -= 4,
            this.pos -= 4,
            0 == this.index && this.maybeNext()
        }
        fork() {
            return new cU(this.stack,this.pos,this.index)
        }
    }
    function uU(e, t=Uint16Array) {
        if ("string" != typeof e)
            return e;
        let n = null;
        for (let r = 0, o = 0; r < e.length; ) {
            let i = 0;
            for (; ; ) {
                let t = e.charCodeAt(r++)
                  , n = !1;
                if (126 == t) {
                    i = 65535;
                    break
                }
                t >= 92 && t--,
                t >= 34 && t--;
                let o = t - 32;
                if (o >= 46 && (o -= 46,
                n = !0),
                i += o,
                n)
                    break;
                i *= 46
            }
            n ? n[o++] = i : n = new t(i)
        }
        return n
    }
    class dU {
        constructor() {
            this.start = -1,
            this.value = -1,
            this.end = -1,
            this.extended = -1,
            this.lookAhead = 0,
            this.mask = 0,
            this.context = 0
        }
    }
    const pU = new dU;
    class hU {
        constructor(e, t) {
            this.input = e,
            this.ranges = t,
            this.chunk = "",
            this.chunkOff = 0,
            this.chunk2 = "",
            this.chunk2Pos = 0,
            this.next = -1,
            this.token = pU,
            this.rangeIndex = 0,
            this.pos = this.chunkPos = t[0].from,
            this.range = t[0],
            this.end = t[t.length - 1].to,
            this.readNext()
        }
        resolveOffset(e, t) {
            let n = this.range
              , r = this.rangeIndex
              , o = this.pos + e;
            for (; o < n.from; ) {
                if (!r)
                    return null;
                let e = this.ranges[--r];
                o -= n.from - e.to,
                n = e
            }
            for (; t < 0 ? o > n.to : o >= n.to; ) {
                if (r == this.ranges.length - 1)
                    return null;
                let e = this.ranges[++r];
                o += e.from - n.to,
                n = e
            }
            return o
        }
        clipPos(e) {
            if (e >= this.range.from && e < this.range.to)
                return e;
            for (let t of this.ranges)
                if (t.to > e)
                    return Math.max(e, t.from);
            return this.end
        }
        peek(e) {
            let t, n, r = this.chunkOff + e;
            if (r >= 0 && r < this.chunk.length)
                t = this.pos + e,
                n = this.chunk.charCodeAt(r);
            else {
                let r = this.resolveOffset(e, 1);
                if (null == r)
                    return -1;
                if (t = r,
                t >= this.chunk2Pos && t < this.chunk2Pos + this.chunk2.length)
                    n = this.chunk2.charCodeAt(t - this.chunk2Pos);
                else {
                    let e = this.rangeIndex
                      , r = this.range;
                    for (; r.to <= t; )
                        r = this.ranges[++e];
                    this.chunk2 = this.input.chunk(this.chunk2Pos = t),
                    t + this.chunk2.length > r.to && (this.chunk2 = this.chunk2.slice(0, r.to - t)),
                    n = this.chunk2.charCodeAt(0)
                }
            }
            return t >= this.token.lookAhead && (this.token.lookAhead = t + 1),
            n
        }
        acceptToken(e, t=0) {
            let n = t ? this.resolveOffset(t, -1) : this.pos;
            if (null == n || n < this.token.start)
                throw new RangeError("Token end out of bounds");
            this.token.value = e,
            this.token.end = n
        }
        acceptTokenTo(e, t) {
            this.token.value = e,
            this.token.end = t
        }
        getChunk() {
            if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
                let {chunk: e, chunkPos: t} = this;
                this.chunk = this.chunk2,
                this.chunkPos = this.chunk2Pos,
                this.chunk2 = e,
                this.chunk2Pos = t,
                this.chunkOff = this.pos - this.chunkPos
            } else {
                this.chunk2 = this.chunk,
                this.chunk2Pos = this.chunkPos;
                let e = this.input.chunk(this.pos)
                  , t = this.pos + e.length;
                this.chunk = t > this.range.to ? e.slice(0, this.range.to - this.pos) : e,
                this.chunkPos = this.pos,
                this.chunkOff = 0
            }
        }
        readNext() {
            return this.chunkOff >= this.chunk.length && (this.getChunk(),
            this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff)
        }
        advance(e=1) {
            for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
                if (this.rangeIndex == this.ranges.length - 1)
                    return this.setDone();
                e -= this.range.to - this.pos,
                this.range = this.ranges[++this.rangeIndex],
                this.pos = this.range.from
            }
            return this.pos += e,
            this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1),
            this.readNext()
        }
        setDone() {
            return this.pos = this.chunkPos = this.end,
            this.range = this.ranges[this.rangeIndex = this.ranges.length - 1],
            this.chunk = "",
            this.next = -1
        }
        reset(e, t) {
            if (t ? (this.token = t,
            t.start = e,
            t.lookAhead = e + 1,
            t.value = t.extended = -1) : this.token = pU,
            this.pos != e) {
                if (this.pos = e,
                e == this.end)
                    return this.setDone(),
                    this;
                for (; e < this.range.from; )
                    this.range = this.ranges[--this.rangeIndex];
                for (; e >= this.range.to; )
                    this.range = this.ranges[++this.rangeIndex];
                e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "",
                this.chunkOff = 0),
                this.readNext()
            }
            return this
        }
        read(e, t) {
            if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length)
                return this.chunk.slice(e - this.chunkPos, t - this.chunkPos);
            if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length)
                return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos);
            if (e >= this.range.from && t <= this.range.to)
                return this.input.read(e, t);
            let n = "";
            for (let r of this.ranges) {
                if (r.from >= t)
                    break;
                r.to > e && (n += this.input.read(Math.max(r.from, e), Math.min(r.to, t)))
            }
            return n
        }
    }
    class fU {
        constructor(e, t) {
            this.data = e,
            this.id = t
        }
        token(e, t) {
            let {parser: n} = t.p;
            bU(this.data, e, t, this.id, n.data, n.tokenPrecTable)
        }
    }
    fU.prototype.contextual = fU.prototype.fallback = fU.prototype.extend = !1;
    class mU {
        constructor(e, t, n) {
            this.precTable = t,
            this.elseToken = n,
            this.data = "string" == typeof e ? uU(e) : e
        }
        token(e, t) {
            let n = e.pos
              , r = 0;
            for (; ; ) {
                let n = e.next < 0
                  , o = e.resolveOffset(1, 1);
                if (bU(this.data, e, t, 0, this.data, this.precTable),
                e.token.value > -1)
                    break;
                if (null == this.elseToken)
                    return;
                if (n || r++,
                null == o)
                    break;
                e.reset(o, e.token)
            }
            r && (e.reset(n, e.token),
            e.acceptToken(this.elseToken, r))
        }
    }
    mU.prototype.contextual = fU.prototype.fallback = fU.prototype.extend = !1;
    class gU {
        constructor(e, t={}) {
            this.token = e,
            this.contextual = !!t.contextual,
            this.fallback = !!t.fallback,
            this.extend = !!t.extend
        }
    }
    function bU(e, t, n, r, o, i) {
        let a = 0
          , s = 1 << r
          , {dialect: l} = n.p.parser;
        e: for (; s & e[a]; ) {
            let n = e[a + 1];
            for (let d = a + 3; d < n; d += 2)
                if ((e[d + 1] & s) > 0) {
                    let n = e[d];
                    if (l.allows(n) && (-1 == t.token.value || t.token.value == n || vU(n, t.token.value, o, i))) {
                        t.acceptToken(n);
                        break
                    }
                }
            let r = t.next
              , c = 0
              , u = e[a + 2];
            if (!(t.next < 0 && u > c && 65535 == e[n + 3 * u - 3])) {
                for (; c < u; ) {
                    let o = c + u >> 1
                      , i = n + o + (o << 1)
                      , s = e[i]
                      , l = e[i + 1] || 65536;
                    if (r < s)
                        u = o;
                    else {
                        if (!(r >= l)) {
                            a = e[i + 2],
                            t.advance();
                            continue e
                        }
                        c = o + 1
                    }
                }
                break
            }
            a = e[n + 3 * u - 1]
        }
    }
    function OU(e, t, n) {
        for (let r, o = t; 65535 != (r = e[o]); o++)
            if (r == n)
                return o - t;
        return -1
    }
    function vU(e, t, n, r) {
        let o = OU(n, r, t);
        return o < 0 || OU(n, r, e) < o
    }
    const yU = "undefined" != typeof process && process.env && /\bparse\b/.test(process.env.LOG);
    let wU = null;
    function _U(e, t, n) {
        let r = e.cursor(vM.IncludeAnonymous);
        for (r.moveTo(t); ; )
            if (!(n < 0 ? r.childBefore(t) : r.childAfter(t)))
                for (; ; ) {
                    if ((n < 0 ? r.to < t : r.from > t) && !r.type.isError)
                        return n < 0 ? Math.max(0, Math.min(r.to - 1, t - 25)) : Math.min(e.length, Math.max(r.from + 1, t + 25));
                    if (n < 0 ? r.prevSibling() : r.nextSibling())
                        break;
                    if (!r.parent())
                        return n < 0 ? 0 : e.length
                }
    }
    class kU {
        constructor(e, t) {
            this.fragments = e,
            this.nodeSet = t,
            this.i = 0,
            this.fragment = null,
            this.safeFrom = -1,
            this.safeTo = -1,
            this.trees = [],
            this.start = [],
            this.index = [],
            this.nextFragment()
        }
        nextFragment() {
            let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
            if (e) {
                for (this.safeFrom = e.openStart ? _U(e.tree, e.from + e.offset, 1) - e.offset : e.from,
                this.safeTo = e.openEnd ? _U(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
                    this.trees.pop(),
                    this.start.pop(),
                    this.index.pop();
                this.trees.push(e.tree),
                this.start.push(-e.offset),
                this.index.push(0),
                this.nextStart = this.safeFrom
            } else
                this.nextStart = 1e9
        }
        nodeAt(e) {
            if (e < this.nextStart)
                return null;
            for (; this.fragment && this.safeTo <= e; )
                this.nextFragment();
            if (!this.fragment)
                return null;
            for (; ; ) {
                let t = this.trees.length - 1;
                if (t < 0)
                    return this.nextFragment(),
                    null;
                let n = this.trees[t]
                  , r = this.index[t];
                if (r == n.children.length) {
                    this.trees.pop(),
                    this.start.pop(),
                    this.index.pop();
                    continue
                }
                let o = n.children[r]
                  , i = this.start[t] + n.positions[r];
                if (i > e)
                    return this.nextStart = i,
                    null;
                if (o instanceof wM) {
                    if (i == e) {
                        if (i < this.safeFrom)
                            return null;
                        let e = i + o.length;
                        if (e <= this.safeTo) {
                            let t = o.prop(pM.lookAhead);
                            if (!t || e + t < this.fragment.to)
                                return o
                        }
                    }
                    this.index[t]++,
                    i + o.length >= Math.max(this.safeFrom, e) && (this.trees.push(o),
                    this.start.push(i),
                    this.index.push(0))
                } else
                    this.index[t]++,
                    this.nextStart = i + o.length
            }
        }
    }
    class SU {
        constructor(e, t) {
            this.stream = t,
            this.tokens = [],
            this.mainToken = null,
            this.actions = [],
            this.tokens = e.tokenizers.map((e=>new dU))
        }
        getActions(e) {
            let t = 0
              , n = null
              , {parser: r} = e.p
              , {tokenizers: o} = r
              , i = r.stateSlot(e.state, 3)
              , a = e.curContext ? e.curContext.hash : 0
              , s = 0;
            for (let l = 0; l < o.length; l++) {
                if (!(1 << l & i))
                    continue;
                let r = o[l]
                  , c = this.tokens[l];
                if ((!n || r.fallback) && ((r.contextual || c.start != e.pos || c.mask != i || c.context != a) && (this.updateCachedToken(c, r, e),
                c.mask = i,
                c.context = a),
                c.lookAhead > c.end + 25 && (s = Math.max(c.lookAhead, s)),
                0 != c.value)) {
                    let o = t;
                    if (c.extended > -1 && (t = this.addActions(e, c.extended, c.end, t)),
                    t = this.addActions(e, c.value, c.end, t),
                    !r.extend && (n = c,
                    t > o))
                        break
                }
            }
            for (; this.actions.length > t; )
                this.actions.pop();
            return s && e.setLookAhead(s),
            n || e.pos != this.stream.end || (n = new dU,
            n.value = e.p.parser.eofTerm,
            n.start = n.end = e.pos,
            t = this.addActions(e, n.value, n.end, t)),
            this.mainToken = n,
            this.actions
        }
        getMainToken(e) {
            if (this.mainToken)
                return this.mainToken;
            let t = new dU
              , {pos: n, p: r} = e;
            return t.start = n,
            t.end = Math.min(n + 1, r.stream.end),
            t.value = n == r.stream.end ? r.parser.eofTerm : 0,
            t
        }
        updateCachedToken(e, t, n) {
            let r = this.stream.clipPos(n.pos);
            if (t.token(this.stream.reset(r, e), n),
            e.value > -1) {
                let {parser: t} = n.p;
                for (let r = 0; r < t.specialized.length; r++)
                    if (t.specialized[r] == e.value) {
                        let o = t.specializers[r](this.stream.read(e.start, e.end), n);
                        if (o >= 0 && n.p.parser.dialect.allows(o >> 1)) {
                            1 & o ? e.extended = o >> 1 : e.value = o >> 1;
                            break
                        }
                    }
            } else
                e.value = 0,
                e.end = this.stream.clipPos(r + 1)
        }
        putAction(e, t, n, r) {
            for (let o = 0; o < r; o += 3)
                if (this.actions[o] == e)
                    return r;
            return this.actions[r++] = e,
            this.actions[r++] = t,
            this.actions[r++] = n,
            r
        }
        addActions(e, t, n, r) {
            let {state: o} = e
              , {parser: i} = e.p
              , {data: a} = i;
            for (let s = 0; s < 2; s++)
                for (let e = i.stateSlot(o, s ? 2 : 1); ; e += 3) {
                    if (65535 == a[e]) {
                        if (1 != a[e + 1]) {
                            0 == r && 2 == a[e + 1] && (r = this.putAction(DU(a, e + 2), t, n, r));
                            break
                        }
                        e = DU(a, e + 2)
                    }
                    a[e] == t && (r = this.putAction(DU(a, e + 1), t, n, r))
                }
            return r
        }
    }
    class EU {
        constructor(e, t, n, r) {
            this.parser = e,
            this.input = t,
            this.ranges = r,
            this.recovering = 0,
            this.nextStackID = 9812,
            this.minStackPos = 0,
            this.reused = [],
            this.stoppedAt = null,
            this.lastBigReductionStart = -1,
            this.lastBigReductionSize = 0,
            this.bigReductionCount = 0,
            this.stream = new hU(t,r),
            this.tokens = new SU(e,this.stream),
            this.topTerm = e.top[1];
            let {from: o} = r[0];
            this.stacks = [aU.start(this, e.top[0], o)],
            this.fragments = n.length && this.stream.end - o > 4 * e.bufferLength ? new kU(n,e.nodeSet) : null
        }
        get parsedPos() {
            return this.minStackPos
        }
        advance() {
            let e, t, n = this.stacks, r = this.minStackPos, o = this.stacks = [];
            if (this.bigReductionCount > 300 && 1 == n.length) {
                let[e] = n;
                for (; e.forceReduce() && e.stack.length && e.stack[e.stack.length - 2] >= this.lastBigReductionStart; )
                    ;
                this.bigReductionCount = this.lastBigReductionSize = 0
            }
            for (let i = 0; i < n.length; i++) {
                let a = n[i];
                for (; ; ) {
                    if (this.tokens.mainToken = null,
                    a.pos > r)
                        o.push(a);
                    else {
                        if (this.advanceStack(a, o, n))
                            continue;
                        {
                            e || (e = [],
                            t = []),
                            e.push(a);
                            let n = this.tokens.getMainToken(a);
                            t.push(n.value, n.end)
                        }
                    }
                    break
                }
            }
            if (!o.length) {
                let t = e && function(e) {
                    let t = null;
                    for (let n of e) {
                        let e = n.p.stoppedAt;
                        (n.pos == n.p.stream.end || null != e && n.pos > e) && n.p.parser.stateFlag(n.state, 2) && (!t || t.score < n.score) && (t = n)
                    }
                    return t
                }(e);
                if (t)
                    return yU && console.log("Finish with " + this.stackID(t)),
                    this.stackToTree(t);
                if (this.parser.strict)
                    throw yU && e && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")),
                    new SyntaxError("No parse at " + r);
                this.recovering || (this.recovering = 5)
            }
            if (this.recovering && e) {
                let n = null != this.stoppedAt && e[0].pos > this.stoppedAt ? e[0] : this.runRecovery(e, t, o);
                if (n)
                    return yU && console.log("Force-finish " + this.stackID(n)),
                    this.stackToTree(n.forceAll())
            }
            if (this.recovering) {
                let e = 1 == this.recovering ? 1 : 3 * this.recovering;
                if (o.length > e)
                    for (o.sort(((e,t)=>t.score - e.score)); o.length > e; )
                        o.pop();
                o.some((e=>e.reducePos > r)) && this.recovering--
            } else if (o.length > 1) {
                e: for (let e = 0; e < o.length - 1; e++) {
                    let t = o[e];
                    for (let n = e + 1; n < o.length; n++) {
                        let r = o[n];
                        if (t.sameState(r) || t.buffer.length > 500 && r.buffer.length > 500) {
                            if (!((t.score - r.score || t.buffer.length - r.buffer.length) > 0)) {
                                o.splice(e--, 1);
                                continue e
                            }
                            o.splice(n--, 1)
                        }
                    }
                }
                o.length > 12 && o.splice(12, o.length - 12)
            }
            this.minStackPos = o[0].pos;
            for (let i = 1; i < o.length; i++)
                o[i].pos < this.minStackPos && (this.minStackPos = o[i].pos);
            return null
        }
        stopAt(e) {
            if (null != this.stoppedAt && this.stoppedAt < e)
                throw new RangeError("Can't move stoppedAt forward");
            this.stoppedAt = e
        }
        advanceStack(e, t, n) {
            let r = e.pos
              , {parser: o} = this
              , i = yU ? this.stackID(e) + " -> " : "";
            if (null != this.stoppedAt && r > this.stoppedAt)
                return e.forceReduce() ? e : null;
            if (this.fragments) {
                let t = e.curContext && e.curContext.tracker.strict
                  , n = t ? e.curContext.hash : 0;
                for (let a = this.fragments.nodeAt(r); a; ) {
                    let r = this.parser.nodeSet.types[a.type.id] == a.type ? o.getGoto(e.state, a.type.id) : -1;
                    if (r > -1 && a.length && (!t || (a.prop(pM.contextHash) || 0) == n))
                        return e.useNode(a, r),
                        yU && console.log(i + this.stackID(e) + ` (via reuse of ${o.getName(a.type.id)})`),
                        !0;
                    if (!(a instanceof wM) || 0 == a.children.length || a.positions[0] > 0)
                        break;
                    let s = a.children[0];
                    if (!(s instanceof wM && 0 == a.positions[0]))
                        break;
                    a = s
                }
            }
            let a = o.stateSlot(e.state, 4);
            if (a > 0)
                return e.reduce(a),
                yU && console.log(i + this.stackID(e) + ` (via always-reduce ${o.getName(65535 & a)})`),
                !0;
            if (e.stack.length >= 8400)
                for (; e.stack.length > 6e3 && e.forceReduce(); )
                    ;
            let s = this.tokens.getActions(e);
            for (let l = 0; l < s.length; ) {
                let a = s[l++]
                  , c = s[l++]
                  , u = s[l++]
                  , d = l == s.length || !n
                  , p = d ? e : e.split()
                  , h = this.tokens.mainToken;
                if (p.apply(a, c, h ? h.start : p.pos, u),
                yU && console.log(i + this.stackID(p) + ` (via ${65536 & a ? `reduce of ${o.getName(65535 & a)}` : "shift"} for ${o.getName(c)} @ ${r}${p == e ? "" : ", split"})`),
                d)
                    return !0;
                p.pos > r ? t.push(p) : n.push(p)
            }
            return !1
        }
        advanceFully(e, t) {
            let n = e.pos;
            for (; ; ) {
                if (!this.advanceStack(e, null, null))
                    return !1;
                if (e.pos > n)
                    return xU(e, t),
                    !0
            }
        }
        runRecovery(e, t, n) {
            let r = null
              , o = !1;
            for (let i = 0; i < e.length; i++) {
                let a = e[i]
                  , s = t[i << 1]
                  , l = t[1 + (i << 1)]
                  , c = yU ? this.stackID(a) + " -> " : "";
                if (a.deadEnd) {
                    if (o)
                        continue;
                    if (o = !0,
                    a.restart(),
                    yU && console.log(c + this.stackID(a) + " (restarted)"),
                    this.advanceFully(a, n))
                        continue
                }
                let u = a.split()
                  , d = c;
                for (let e = 0; u.forceReduce() && e < 10; e++) {
                    if (yU && console.log(d + this.stackID(u) + " (via force-reduce)"),
                    this.advanceFully(u, n))
                        break;
                    yU && (d = this.stackID(u) + " -> ")
                }
                for (let e of a.recoverByInsert(s))
                    yU && console.log(c + this.stackID(e) + " (via recover-insert)"),
                    this.advanceFully(e, n);
                this.stream.end > a.pos ? (l == a.pos && (l++,
                s = 0),
                a.recoverByDelete(s, l),
                yU && console.log(c + this.stackID(a) + ` (via recover-delete ${this.parser.getName(s)})`),
                xU(a, n)) : (!r || r.score < a.score) && (r = a)
            }
            return r
        }
        stackToTree(e) {
            return e.close(),
            wM.build({
                buffer: cU.create(e),
                nodeSet: this.parser.nodeSet,
                topID: this.topTerm,
                maxBufferLength: this.parser.bufferLength,
                reused: this.reused,
                start: this.ranges[0].from,
                length: e.pos - this.ranges[0].from,
                minRepeatType: this.parser.minRepeatTerm
            })
        }
        stackID(e) {
            let t = (wU || (wU = new WeakMap)).get(e);
            return t || wU.set(e, t = String.fromCodePoint(this.nextStackID++)),
            t + e
        }
    }
    function xU(e, t) {
        for (let n = 0; n < t.length; n++) {
            let r = t[n];
            if (r.pos == e.pos && r.sameState(e))
                return void (t[n].score < e.score && (t[n] = e))
        }
        t.push(e)
    }
    class TU {
        constructor(e, t, n) {
            this.source = e,
            this.flags = t,
            this.disabled = n
        }
        allows(e) {
            return !this.disabled || 0 == this.disabled[e]
        }
    }
    const AU = e=>e;
    class CU {
        constructor(e) {
            this.start = e.start,
            this.shift = e.shift || AU,
            this.reduce = e.reduce || AU,
            this.reuse = e.reuse || AU,
            this.hash = e.hash || (()=>0),
            this.strict = !1 !== e.strict
        }
    }
    class PU extends FM {
        constructor(e) {
            if (super(),
            this.wrappers = [],
            14 != e.version)
                throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
            let t = e.nodeNames.split(" ");
            this.minRepeatTerm = t.length;
            for (let a = 0; a < e.repeatNodeCount; a++)
                t.push("");
            let n = Object.keys(e.topRules).map((t=>e.topRules[t][1]))
              , r = [];
            for (let a = 0; a < t.length; a++)
                r.push([]);
            function o(e, t, n) {
                r[e].push([t, t.deserialize(String(n))])
            }
            if (e.nodeProps)
                for (let a of e.nodeProps) {
                    let e = a[0];
                    "string" == typeof e && (e = pM[e]);
                    for (let t = 1; t < a.length; ) {
                        let n = a[t++];
                        if (n >= 0)
                            o(n, e, a[t++]);
                        else {
                            let r = a[t + -n];
                            for (let i = -n; i > 0; i--)
                                o(a[t++], e, r);
                            t++
                        }
                    }
                }
            this.nodeSet = new gM(t.map(((t,o)=>mM.define({
                name: o >= this.minRepeatTerm ? void 0 : t,
                id: o,
                props: r[o],
                top: n.indexOf(o) > -1,
                error: 0 == o,
                skipped: e.skippedNodes && e.skippedNodes.indexOf(o) > -1
            })))),
            e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)),
            this.strict = !1,
            this.bufferLength = cM;
            let i = uU(e.tokenData);
            this.context = e.context,
            this.specializerSpecs = e.specialized || [],
            this.specialized = new Uint16Array(this.specializerSpecs.length);
            for (let a = 0; a < this.specializerSpecs.length; a++)
                this.specialized[a] = this.specializerSpecs[a].term;
            this.specializers = this.specializerSpecs.map(RU),
            this.states = uU(e.states, Uint32Array),
            this.data = uU(e.stateData),
            this.goto = uU(e.goto),
            this.maxTerm = e.maxTerm,
            this.tokenizers = e.tokenizers.map((e=>"number" == typeof e ? new fU(i,e) : e)),
            this.topRules = e.topRules,
            this.dialects = e.dialects || {},
            this.dynamicPrecedences = e.dynamicPrecedences || null,
            this.tokenPrecTable = e.tokenPrec,
            this.termNames = e.termNames || null,
            this.maxNode = this.nodeSet.types.length - 1,
            this.dialect = this.parseDialect(),
            this.top = this.topRules[Object.keys(this.topRules)[0]]
        }
        createParse(e, t, n) {
            let r = new EU(this,e,t,n);
            for (let o of this.wrappers)
                r = o(r, e, t, n);
            return r
        }
        getGoto(e, t, n=!1) {
            let r = this.goto;
            if (t >= r[0])
                return -1;
            for (let o = r[t + 1]; ; ) {
                let t = r[o++]
                  , i = 1 & t
                  , a = r[o++];
                if (i && n)
                    return a;
                for (let n = o + (t >> 1); o < n; o++)
                    if (r[o] == e)
                        return a;
                if (i)
                    return -1
            }
        }
        hasAction(e, t) {
            let n = this.data;
            for (let r = 0; r < 2; r++)
                for (let o, i = this.stateSlot(e, r ? 2 : 1); ; i += 3) {
                    if (65535 == (o = n[i])) {
                        if (1 != n[i + 1]) {
                            if (2 == n[i + 1])
                                return DU(n, i + 2);
                            break
                        }
                        o = n[i = DU(n, i + 2)]
                    }
                    if (o == t || 0 == o)
                        return DU(n, i + 1)
                }
            return 0
        }
        stateSlot(e, t) {
            return this.states[6 * e + t]
        }
        stateFlag(e, t) {
            return (this.stateSlot(e, 0) & t) > 0
        }
        validAction(e, t) {
            return !!this.allActions(e, (e=>e == t || null))
        }
        allActions(e, t) {
            let n = this.stateSlot(e, 4)
              , r = n ? t(n) : void 0;
            for (let o = this.stateSlot(e, 1); null == r; o += 3) {
                if (65535 == this.data[o]) {
                    if (1 != this.data[o + 1])
                        break;
                    o = DU(this.data, o + 2)
                }
                r = t(DU(this.data, o + 1))
            }
            return r
        }
        nextStates(e) {
            let t = [];
            for (let n = this.stateSlot(e, 1); ; n += 3) {
                if (65535 == this.data[n]) {
                    if (1 != this.data[n + 1])
                        break;
                    n = DU(this.data, n + 2)
                }
                if (!(1 & this.data[n + 2])) {
                    let e = this.data[n + 1];
                    t.some(((t,n)=>1 & n && t == e)) || t.push(this.data[n], e)
                }
            }
            return t
        }
        configure(e) {
            let t = Object.assign(Object.create(PU.prototype), this);
            if (e.props && (t.nodeSet = this.nodeSet.extend(...e.props)),
            e.top) {
                let n = this.topRules[e.top];
                if (!n)
                    throw new RangeError(`Invalid top rule name ${e.top}`);
                t.top = n
            }
            return e.tokenizers && (t.tokenizers = this.tokenizers.map((t=>{
                let n = e.tokenizers.find((e=>e.from == t));
                return n ? n.to : t
            }
            ))),
            e.specializers && (t.specializers = this.specializers.slice(),
            t.specializerSpecs = this.specializerSpecs.map(((n,r)=>{
                let o = e.specializers.find((e=>e.from == n.external));
                if (!o)
                    return n;
                let i = Object.assign(Object.assign({}, n), {
                    external: o.to
                });
                return t.specializers[r] = RU(i),
                i
            }
            ))),
            e.contextTracker && (t.context = e.contextTracker),
            e.dialect && (t.dialect = this.parseDialect(e.dialect)),
            null != e.strict && (t.strict = e.strict),
            e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)),
            null != e.bufferLength && (t.bufferLength = e.bufferLength),
            t
        }
        hasWrappers() {
            return this.wrappers.length > 0
        }
        getName(e) {
            return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e)
        }
        get eofTerm() {
            return this.maxNode + 1
        }
        get topNode() {
            return this.nodeSet.types[this.top[1]]
        }
        dynamicPrecedence(e) {
            let t = this.dynamicPrecedences;
            return null == t ? 0 : t[e] || 0
        }
        parseDialect(e) {
            let t = Object.keys(this.dialects)
              , n = t.map((()=>!1));
            if (e)
                for (let o of e.split(" ")) {
                    let e = t.indexOf(o);
                    e >= 0 && (n[e] = !0)
                }
            let r = null;
            for (let o = 0; o < t.length; o++)
                if (!n[o])
                    for (let e, n = this.dialects[t[o]]; 65535 != (e = this.data[n++]); )
                        (r || (r = new Uint8Array(this.maxTerm + 1)))[e] = 1;
            return new TU(e,n,r)
        }
        static deserialize(e) {
            return new PU(e)
        }
    }
    function DU(e, t) {
        return e[t] | e[t + 1] << 16
    }
    function RU(e) {
        if (e.external) {
            let t = e.extend ? 1 : 0;
            return (n,r)=>e.external(n, r) << 1 | t
        }
        return e.get
    }
    const NU = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288];
    function $U(e) {
        return e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 161
    }
    function IU(e) {
        return e >= 48 && e <= 57
    }
    const MU = new gU(((e,t)=>{
        for (let n = !1, r = 0, o = 0; ; o++) {
            let {next: i} = e;
            if ($U(i) || 45 == i || 95 == i || n && IU(i))
                !n && (45 != i || o > 0) && (n = !0),
                r === o && 45 == i && r++,
                e.advance();
            else {
                if (92 != i || 10 == e.peek(1)) {
                    n && e.acceptToken(40 == i ? 100 : 2 == r && t.canShift(2) ? 2 : 101);
                    break
                }
                e.advance(),
                e.next > -1 && e.advance(),
                n = !0
            }
        }
    }
    ))
      , LU = new gU((e=>{
        if (NU.includes(e.peek(-1))) {
            let {next: t} = e;
            ($U(t) || 95 == t || 35 == t || 46 == t || 91 == t || 58 == t && $U(e.peek(1)) || 45 == t || 38 == t) && e.acceptToken(99)
        }
    }
    ))
      , QU = new gU((e=>{
        if (!NU.includes(e.peek(-1))) {
            let {next: t} = e;
            if (37 == t && (e.advance(),
            e.acceptToken(1)),
            $U(t)) {
                do {
                    e.advance()
                } while ($U(e.next) || IU(e.next));
                e.acceptToken(1)
            }
        }
    }
    ))
      , BU = aL({
        "AtKeyword import charset namespace keyframes media supports": TL.definitionKeyword,
        "from to selector": TL.keyword,
        NamespaceName: TL.namespace,
        KeyframeName: TL.labelName,
        KeyframeRangeName: TL.operatorKeyword,
        TagName: TL.tagName,
        ClassName: TL.className,
        PseudoClassName: TL.constant(TL.className),
        IdName: TL.labelName,
        "FeatureName PropertyName": TL.propertyName,
        AttributeName: TL.attributeName,
        NumberLiteral: TL.number,
        KeywordQuery: TL.keyword,
        UnaryQueryOp: TL.operatorKeyword,
        "CallTag ValueName": TL.atom,
        VariableName: TL.variableName,
        Callee: TL.operatorKeyword,
        Unit: TL.unit,
        "UniversalSelector NestingSelector": TL.definitionOperator,
        MatchOp: TL.compareOperator,
        "ChildOp SiblingOp, LogicOp": TL.logicOperator,
        BinOp: TL.arithmeticOperator,
        Important: TL.modifier,
        Comment: TL.blockComment,
        ColorLiteral: TL.color,
        "ParenthesizedContent StringLiteral": TL.string,
        ":": TL.punctuation,
        "PseudoOp #": TL.derefOperator,
        "; ,": TL.separator,
        "( )": TL.paren,
        "[ ]": TL.squareBracket,
        "{ }": TL.brace
    })
      , UU = {
        __proto__: null,
        lang: 32,
        "nth-child": 32,
        "nth-last-child": 32,
        "nth-of-type": 32,
        "nth-last-of-type": 32,
        dir: 32,
        "host-context": 32,
        url: 60,
        "url-prefix": 60,
        domain: 60,
        regexp: 60,
        selector: 138
    }
      , FU = {
        __proto__: null,
        "@import": 118,
        "@media": 142,
        "@charset": 146,
        "@namespace": 150,
        "@keyframes": 156,
        "@supports": 168
    }
      , jU = {
        __proto__: null,
        not: 132,
        only: 132
    }
      , zU = PU.deserialize({
        version: 14,
        states: ":^QYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DTO$vQ[O'#DWOOQP'#Em'#EmO${QdO'#DgO%jQ[O'#DtO${QdO'#DvO%{Q[O'#DxO&WQ[O'#D{O&`Q[O'#ERO&nQ[O'#ETOOQS'#El'#ElOOQS'#EW'#EWQYQ[OOO&uQXO'#CdO'jQWO'#DcO'oQWO'#EsO'zQ[O'#EsQOQWOOP(UO#tO'#C_POOO)C@[)C@[OOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(aQ[O'#E[O({QWO,58{O)TQ[O,59SO$qQ[O,59oO$vQ[O,59rO(aQ[O,59uO(aQ[O,59wO(aQ[O,59xO)`Q[O'#DbOOQS,58{,58{OOQP'#Ck'#CkOOQO'#DR'#DROOQP,59S,59SO)gQWO,59SO)lQWO,59SOOQP'#DV'#DVOOQP,59o,59oOOQO'#DX'#DXO)qQ`O,59rOOQS'#Cp'#CpO${QdO'#CqO)yQvO'#CsO+ZQtO,5:ROOQO'#Cx'#CxO)lQWO'#CwO+oQWO'#CyO+tQ[O'#DOOOQS'#Ep'#EpOOQO'#Dj'#DjO+|Q[O'#DqO,[QWO'#EtO&`Q[O'#DoO,jQWO'#DrOOQO'#Eu'#EuO)OQWO,5:`O,oQpO,5:bOOQS'#Dz'#DzO,wQWO,5:dO,|Q[O,5:dOOQO'#D}'#D}O-UQWO,5:gO-ZQWO,5:mO-cQWO,5:oOOQS-E8U-E8UO${QdO,59}O-kQ[O'#E^O-xQWO,5;_O-xQWO,5;_POOO'#EV'#EVP.TO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.zQXO,5:vOOQO-E8Y-E8YOOQS1G.g1G.gOOQP1G.n1G.nO)gQWO1G.nO)lQWO1G.nOOQP1G/Z1G/ZO/XQ`O1G/^O/rQXO1G/aO0YQXO1G/cO0pQXO1G/dO1WQWO,59|O1]Q[O'#DSO1dQdO'#CoOOQP1G/^1G/^O${QdO1G/^O1kQpO,59]OOQS,59_,59_O${QdO,59aO1sQWO1G/mOOQS,59c,59cO1xQ!bO,59eOOQS'#DP'#DPOOQS'#EY'#EYO2QQ[O,59jOOQS,59j,59jO2YQWO'#DjO2eQWO,5:VO2jQWO,5:]O&`Q[O,5:XO&`Q[O'#E_O2rQWO,5;`O2}QWO,5:ZO(aQ[O,5:^OOQS1G/z1G/zOOQS1G/|1G/|OOQS1G0O1G0OO3`QWO1G0OO3eQdO'#EOOOQS1G0R1G0ROOQS1G0X1G0XOOQS1G0Z1G0ZO3pQtO1G/iOOQO,5:x,5:xO4WQ[O,5:xOOQO-E8[-E8[O4eQWO1G0yPOOO-E8T-E8TPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$x7+$xO${QdO7+$xOOQS1G/h1G/hO4pQXO'#ErO4wQWO,59nO4|QtO'#EXO5tQdO'#EoO6OQWO,59ZO6TQpO7+$xOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%X7+%XO6]QWO1G/POOQS-E8W-E8WOOQS1G/U1G/UO${QdO1G/qOOQO1G/w1G/wOOQO1G/s1G/sO6bQWO,5:yOOQO-E8]-E8]O6pQXO1G/xOOQS7+%j7+%jO6wQYO'#CsOOQO'#EQ'#EQO7SQ`O'#EPOOQO'#EP'#EPO7_QWO'#E`O7gQdO,5:jOOQS,5:j,5:jO7rQtO'#E]O${QdO'#E]O8sQdO7+%TOOQO7+%T7+%TOOQO1G0d1G0dO9WQpO<<HdO9`QWO,5;^OOQP1G/Y1G/YOOQS-E8V-E8VO${QdO'#EZO9hQWO,5;ZOOQT1G.u1G.uOOQP<<Hd<<HdOOQS7+$k7+$kO9pQdO7+%]OOQO7+%d7+%dOOQO,5:k,5:kO3hQdO'#EaO7_QWO,5:zOOQS,5:z,5:zOOQS-E8^-E8^OOQS1G0U1G0UO9wQtO,5:wOOQS-E8Z-E8ZOOQO<<Ho<<HoOOQPAN>OAN>OO:xQdO,5:uOOQO-E8X-E8XOOQO<<Hw<<HwOOQO,5:{,5:{OOQO-E8_-E8_OOQS1G0f1G0f",
        stateData: ";[~O#ZOS#[QQ~OUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XRO#bTO~OQfOUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XeO#bTO~O#U#gP~P!ZO#[jO~O#XlO~O]qO^qOqsOtoOxrO!OtO!RvO#VuO#bnO~O!TwO~P#pO`}O#WzO#XyO~O#X!OO~O#X!QO~OQ![Ob!TOf![Oh![On!YOq!ZO#W!WO#X!SO#e!UO~Ob!^O!d!`O!g!aO#X!]O!T#hP~Oh!fOn!YO#X!eO~Oh!hO#X!hO~Ob!^O!d!`O!g!aO#X!]O~O!Y#hP~P%jO]WX]!WX^WXqWXtWXxWX!OWX!RWX!TWX#VWX#bWX~O]!mO~O!Y!nO#U#gX!S#gX~O#U#gX!S#gX~P!ZO#]!qO#^!qO#_!sO~OUYOXYO]VO^VOqXOxWO#XRO#bTO~OtoO!TwO~O`!zO#WzO#XyO~O!S#gP~P!ZOb#RO~Ob#SO~Op#TO|#UO~OP#WObgXjgX!YgX!dgX!ggX#XgXagXQgXfgXhgXngXqgXtgX!XgX#UgX#WgX#egXpgX!SgX~Ob!^Oj#XO!d!`O!g!aO#X!]O!Y#hP~Ob#[O~Op#`O#X#]O~Ob!^O!d!`O!g!aO#X#aO~Ot#eO!b#dO!T#hX!Y#hX~Ob#hO~Oj#XO!Y#jO~O!Y#kO~Oh#lOn!YO~O!T#mO~O!TwO!b#dO~O!TwO!Y#pO~O!Y#QX#U#QX!S#QX~P!ZO!Y!nO#U#ga!S#ga~O#]!qO#^!qO#_#wO~O]qO^qOqsOxrO!OtO!RvO#VuO#bnO~Ot#Oa!T#Oaa#Oa~P.`Op#yO|#zO~O]qO^qOqsOxrO#bnO~Ot}i!O}i!R}i!T}i#V}ia}i~P/aOt!Pi!O!Pi!R!Pi!T!Pi#V!Pia!Pi~P/aOt!Qi!O!Qi!R!Qi!T!Qi#V!Qia!Qi~P/aO!S#{O~Oa#fP~P(aOa#cP~P${Oa$SOj#XO~O!Y$UO~Oh$VOo$VO~Op$XO#X#]O~O]!`Xa!^X!b!^X~O]$YO~Oa$ZO!b#dO~Ot#eO!T#ha!Y#ha~O!b#dOt!ca!T!ca!Y!caa!ca~O!Y$`O~O!S$gO#X$bO#e$aO~Oj#XOt$iO!X$kO!Y!Vi#U!Vi!S!Vi~P${O!Y#Qa#U#Qa!S#Qa~P!ZO!Y!nO#U#gi!S#gi~Oa#fX~P#pOa$oO~Oj#XOQ!{Xa!{Xb!{Xf!{Xh!{Xn!{Xq!{Xt!{X#W!{X#X!{X#e!{X~Ot$qOa#cX~P${Oa$sO~Oj#XOp$tO~Oa$uO~O!b#dOt#Ra!T#Ra!Y#Ra~Oa$wO~P.`OP#WOtgX!TgX~O#e$aOt!sX!T!sX~Ot$yO!TwO~O!S$}O#X$bO#e$aO~Oj#XOQ#PXb#PXf#PXh#PXn#PXq#PXt#PX!X#PX!Y#PX#U#PX#W#PX#X#PX#e#PX!S#PX~Ot$iO!X%QO!Y!Vq#U!Vq!S!Vq~P${Oj#XOp%RO~OtoOa#fa~Ot$qOa#ca~Oa%UO~P${Oj#XOQ#Pab#Paf#Pah#Pan#Paq#Pat#Pa!X#Pa!Y#Pa#U#Pa#W#Pa#X#Pa#e#Pa!S#Pa~Oa!}at!}a~P${O#Zo#[#ej!R#e~",
        goto: "-g#jPPP#kP#nP#w$WP#w$g#wPP$mPPP$s$|$|P%`P$|P$|%z&^PPPP$|&vP&z'Q#wP'W#w'^P#wP#w#wPPP'd'y(WPP#nPP(_(_(i(_P(_P(_(_P#nP#nP#nP(l#nP(o(r(u(|#nP#nP)R)X)h)v)|*S*^*d*n*t*zPPPPPPPPPP+Q+ZP+v+yP,o,r,x-RRkQ_bOPdhw!n#skYOPdhotuvw!n#R#h#skSOPdhotuvw!n#R#h#sQmTR!tnQ{VR!xqQ!x}Q#Z!XR#x!zq![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SU$d#m$f$yR$x$cq!XZ]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SQ!f^R#l!gT#^!Z#_Q|VR!yqQ!x|R#x!yQ!PWR!{rQ!RXR!|sQxUQ!wpQ#i!cQ#o!jQ#p!kQ${$eR%X$zSgPwQ!phQ#r!nR$l#sZfPhw!n#sa!b[`a!V!^!`#d#eR#b!^R!g^R!i_R#n!iS$e#m$fR%V$yV$c#m$f$yQ!rjR#v!rQdOShPwU!ldh#sR#s!nQ$P#SU$p$P$v%SQ$v$YR%S$qQ#_!ZR$W#_Q$r$PR%T$rQpUS!vp$nR$n#|Q$j#qR%P$jQ!ogS#t!o#uR#u!pQ#f!_R$^#fQ$f#mR$|$fQ$z$eR%W$z_cOPdhw!n#s^UOPdhw!n#sQ!uoQ!}tQ#OuQ#PvQ#|#RR$_#hR$Q#SQ!VZQ!d]Q#V!TQ#q!m[$O#S$P$Y$q$v%SQ$R#UQ$T#XS$h#q$jQ$m#zR%O$iR#}#RQiPR#QwQ!c[Q!kaR#Y!VU!_[a!VQ!j`Q#c!^Q#g!`Q$[#dR$]#e",
        nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
        maxTerm: 117,
        nodeProps: [["isolate", -2, 3, 24, ""], ["openedBy", 17, "(", 32, "[", 50, "{"], ["closedBy", 18, ")", 33, "]", 51, "}"]],
        propSources: [BU],
        skippedNodes: [0, 3, 87],
        repeatNodeCount: 11,
        tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#Z~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#Z~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!X[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYxQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS|So`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!RQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#e[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#e[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSt^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#bQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#[~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Y^Oy%^z;'S%^;'S;=`%o<%lO%^dCoS|SOy%^z;'S%^;'S;=`%o<%lO%^bDQU!OQOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS!OQo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[![Qo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^nFfSq^Oy%^z;'S%^;'S;=`%o<%lO%^nFwSp^Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!bQo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!TUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!S^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!RQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
        tokenizers: [LU, QU, MU, 1, 2, 3, 4, new mU("m~RRYZ[z{a~~g~aO#^~~dP!P!Qg~lO#_~~",28,105)],
        topRules: {
            StyleSheet: [0, 4],
            Styles: [1, 86]
        },
        specialized: [{
            term: 100,
            get: e=>UU[e] || -1
        }, {
            term: 58,
            get: e=>FU[e] || -1
        }, {
            term: 101,
            get: e=>jU[e] || -1
        }],
        tokenPrec: 1200
    });
    let qU = null;
    function HU() {
        if (!qU && "object" == typeof document && document.body) {
            let {style: e} = document.body
              , t = []
              , n = new Set;
            for (let r in e)
                "cssText" != r && "cssFloat" != r && "string" == typeof e[r] && (/[A-Z]/.test(r) && (r = r.replace(/[A-Z]/g, (e=>"-" + e.toLowerCase()))),
                n.has(r) || (t.push(r),
                n.add(r)));
            qU = t.sort().map((e=>({
                type: "property",
                label: e
            })))
        }
        return qU || []
    }
    const ZU = ["active", "after", "any-link", "autofill", "backdrop", "before", "checked", "cue", "default", "defined", "disabled", "empty", "enabled", "file-selector-button", "first", "first-child", "first-letter", "first-line", "first-of-type", "focus", "focus-visible", "focus-within", "fullscreen", "has", "host", "host-context", "hover", "in-range", "indeterminate", "invalid", "is", "lang", "last-child", "last-of-type", "left", "link", "marker", "modal", "not", "nth-child", "nth-last-child", "nth-last-of-type", "nth-of-type", "only-child", "only-of-type", "optional", "out-of-range", "part", "placeholder", "placeholder-shown", "read-only", "read-write", "required", "right", "root", "scope", "selection", "slotted", "target", "target-text", "valid", "visited", "where"].map((e=>({
        type: "class",
        label: e
    })))
      , WU = ["above", "absolute", "activeborder", "additive", "activecaption", "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate", "always", "antialiased", "appworkspace", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page", "avoid-region", "axis-pan", "background", "backwards", "baseline", "below", "bidi-override", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-decimal", "clear", "clip", "close-quote", "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse", "compact", "condensed", "contain", "content", "contents", "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "dense", "destination-atop", "destination-in", "destination-out", "destination-over", "difference", "disc", "discard", "disclosure-closed", "disclosure-open", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic-abegede-gez", "ethiopic-halehame-aa-er", "ethiopic-halehame-gez", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fill-box", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes", "forwards", "from", "geometricPrecision", "graytext", "grid", "groove", "hand", "hard-light", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "horizontal", "hsl", "hsla", "hue", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "justify", "keep-all", "landscape", "large", "larger", "left", "level", "lighter", "lighten", "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lowercase", "ltr", "luminosity", "manipulation", "match", "matrix", "matrix3d", "medium", "menu", "menutext", "message-box", "middle", "min-intrinsic", "mix", "monospace", "move", "multiple", "multiple_mask_images", "multiply", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "opacity", "open-quote", "optimizeLegibility", "optimizeSpeed", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "perspective", "pinch-zoom", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radial-gradient", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeating-linear-gradient", "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY", "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running", "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen", "scroll", "scrollbar", "scroll-position", "se-resize", "self-start", "self-end", "semi-condensed", "semi-expanded", "separate", "serif", "show", "single", "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square", "start", "static", "status-bar", "stretch", "stroke", "stroke-box", "sub", "subpixel-antialiased", "svg_masks", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "text", "text-bottom", "text-top", "textarea", "textfield", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "to", "top", "transform", "translate", "translate3d", "translateX", "translateY", "translateZ", "transparent", "ultra-condensed", "ultra-expanded", "underline", "unidirectional-pan", "unset", "up", "upper-latin", "uppercase", "url", "var", "vertical", "vertical-text", "view-box", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor", "xx-large", "xx-small"].map((e=>({
        type: "keyword",
        label: e
    }))).concat(["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"].map((e=>({
        type: "constant",
        label: e
    }))))
      , XU = ["a", "abbr", "address", "article", "aside", "b", "bdi", "bdo", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "figcaption", "figure", "footer", "form", "header", "hgroup", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "meter", "nav", "ol", "output", "p", "pre", "ruby", "section", "select", "small", "source", "span", "strong", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "tr", "u", "ul"].map((e=>({
        type: "type",
        label: e
    })))
      , VU = /^(\w[\w-]*|-\w[\w-]*|)$/
      , GU = /^-(-[\w-]*)?$/;
    const YU = new BM
      , KU = ["Declaration"];
    function JU(e) {
        for (let t = e; ; ) {
            if (t.type.isTop)
                return t;
            if (!(t = t.parent))
                return e
        }
    }
    function eF(e, t, n) {
        if (t.to - t.from > 4096) {
            let r = YU.get(t);
            if (r)
                return r;
            let o = []
              , i = new Set
              , a = t.cursor(vM.IncludeAnonymous);
            if (a.firstChild())
                do {
                    for (let t of eF(e, a.node, n))
                        i.has(t.label) || (i.add(t.label),
                        o.push(t))
                } while (a.nextSibling());
            return YU.set(t, o),
            o
        }
        {
            let r = []
              , o = new Set;
            return t.cursor().iterate((t=>{
                var i;
                if (n(t) && t.matchContext(KU) && ":" == (null === (i = t.node.nextSibling) || void 0 === i ? void 0 : i.name)) {
                    let n = e.sliceString(t.from, t.to);
                    o.has(n) || (o.add(n),
                    r.push({
                        label: n,
                        type: "variable"
                    }))
                }
            }
            )),
            r
        }
    }
    const tF = (e=>t=>{
        let {state: n, pos: r} = t
          , o = IL(n).resolveInner(r, -1)
          , i = o.type.isError && o.from == o.to - 1 && "-" == n.doc.sliceString(o.from, o.to);
        if ("PropertyName" == o.name || (i || "TagName" == o.name) && /^(Block|Styles)$/.test(o.resolve(o.to).name))
            return {
                from: o.from,
                options: HU(),
                validFor: VU
            };
        if ("ValueName" == o.name)
            return {
                from: o.from,
                options: WU,
                validFor: VU
            };
        if ("PseudoClassName" == o.name)
            return {
                from: o.from,
                options: ZU,
                validFor: VU
            };
        if (e(o) || (t.explicit || i) && function(e, t) {
            var n;
            if (("(" == e.name || e.type.isError) && (e = e.parent || e),
            "ArgList" != e.name)
                return !1;
            let r = null === (n = e.parent) || void 0 === n ? void 0 : n.firstChild;
            return "Callee" == (null == r ? void 0 : r.name) && "var" == t.sliceString(r.from, r.to)
        }(o, n.doc))
            return {
                from: e(o) || i ? o.from : r,
                options: eF(n.doc, JU(o), e),
                validFor: GU
            };
        if ("TagName" == o.name) {
            for (let {parent: e} = o; e; e = e.parent)
                if ("Block" == e.name)
                    return {
                        from: o.from,
                        options: HU(),
                        validFor: VU
                    };
            return {
                from: o.from,
                options: XU,
                validFor: VU
            }
        }
        if (!t.explicit)
            return null;
        let a = o.resolve(r)
          , s = a.childBefore(r);
        return s && ":" == s.name && "PseudoClassSelector" == a.name ? {
            from: r,
            options: ZU,
            validFor: VU
        } : s && ":" == s.name && "Declaration" == a.name || "ArgList" == a.name ? {
            from: r,
            options: WU,
            validFor: VU
        } : "Block" == a.name || "Styles" == a.name ? {
            from: r,
            options: HU(),
            validFor: VU
        } : null
    }
    )((e=>"VariableName" == e.name))
      , nF = $L.define({
        name: "css",
        parser: zU.configure({
            props: [KL.add({
                Declaration: aQ()
            }), lQ.add({
                "Block KeyframeList": cQ
            })]
        }),
        languageData: {
            commentTokens: {
                block: {
                    open: "/*",
                    close: "*/"
                }
            },
            indentOnInput: /^\s*\}$/,
            wordChars: "-"
        }
    });
    function rF() {
        return new HL(nF,nF.data.of({
            autocomplete: tF
        }))
    }
    const oF = 20
      , iF = 22
      , aF = 23
      , sF = 24
      , lF = 26
      , cF = 27
      , uF = 28
      , dF = 31
      , pF = 34
      , hF = 37
      , fF = {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        command: !0,
        embed: !0,
        frame: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0,
        menuitem: !0
    }
      , mF = {
        dd: !0,
        li: !0,
        optgroup: !0,
        option: !0,
        p: !0,
        rp: !0,
        rt: !0,
        tbody: !0,
        td: !0,
        tfoot: !0,
        th: !0,
        tr: !0
    }
      , gF = {
        dd: {
            dd: !0,
            dt: !0
        },
        dt: {
            dd: !0,
            dt: !0
        },
        li: {
            li: !0
        },
        option: {
            option: !0,
            optgroup: !0
        },
        optgroup: {
            optgroup: !0
        },
        p: {
            address: !0,
            article: !0,
            aside: !0,
            blockquote: !0,
            dir: !0,
            div: !0,
            dl: !0,
            fieldset: !0,
            footer: !0,
            form: !0,
            h1: !0,
            h2: !0,
            h3: !0,
            h4: !0,
            h5: !0,
            h6: !0,
            header: !0,
            hgroup: !0,
            hr: !0,
            menu: !0,
            nav: !0,
            ol: !0,
            p: !0,
            pre: !0,
            section: !0,
            table: !0,
            ul: !0
        },
        rp: {
            rp: !0,
            rt: !0
        },
        rt: {
            rp: !0,
            rt: !0
        },
        tbody: {
            tbody: !0,
            tfoot: !0
        },
        td: {
            td: !0,
            th: !0
        },
        tfoot: {
            tbody: !0
        },
        th: {
            td: !0,
            th: !0
        },
        thead: {
            tbody: !0,
            tfoot: !0
        },
        tr: {
            tr: !0
        }
    };
    function bF(e) {
        return 9 == e || 10 == e || 13 == e || 32 == e
    }
    let OF = null
      , vF = null
      , yF = 0;
    function wF(e, t) {
        let n = e.pos + t;
        if (yF == n && vF == e)
            return OF;
        let r = e.peek(t);
        for (; bF(r); )
            r = e.peek(++t);
        let o = "";
        for (; 45 == (i = r) || 46 == i || 58 == i || i >= 65 && i <= 90 || 95 == i || i >= 97 && i <= 122 || i >= 161; )
            o += String.fromCharCode(r),
            r = e.peek(++t);
        var i;
        return vF = e,
        yF = n,
        OF = o ? o.toLowerCase() : r == _F || r == kF ? void 0 : null
    }
    const _F = 63
      , kF = 33;
    function SF(e, t) {
        this.name = e,
        this.parent = t
    }
    const EF = [6, 10, 7, 8, 9]
      , xF = new CU({
        start: null,
        shift: (e,t,n,r)=>EF.indexOf(t) > -1 ? new SF(wF(r, 1) || "",e) : e,
        reduce: (e,t)=>t == oF && e ? e.parent : e,
        reuse(e, t, n, r) {
            let o = t.type.id;
            return 6 == o || 36 == o ? new SF(wF(r, 1) || "",e) : e
        },
        strict: !1
    })
      , TF = new gU(((e,t)=>{
        if (60 != e.next)
            return void (e.next < 0 && t.context && e.acceptToken(57));
        e.advance();
        let n = 47 == e.next;
        n && e.advance();
        let r = wF(e, 0);
        if (void 0 === r)
            return;
        if (!r)
            return e.acceptToken(n ? 14 : 6);
        let o = t.context ? t.context.name : null;
        if (n) {
            if (r == o)
                return e.acceptToken(11);
            if (o && mF[o])
                return e.acceptToken(57, -2);
            if (t.dialectEnabled(0))
                return e.acceptToken(12);
            for (let e = t.context; e; e = e.parent)
                if (e.name == r)
                    return;
            e.acceptToken(13)
        } else {
            if ("script" == r)
                return e.acceptToken(7);
            if ("style" == r)
                return e.acceptToken(8);
            if ("textarea" == r)
                return e.acceptToken(9);
            if (fF.hasOwnProperty(r))
                return e.acceptToken(10);
            o && gF[o] && gF[o][r] ? e.acceptToken(57, -1) : e.acceptToken(6)
        }
    }
    ),{
        contextual: !0
    })
      , AF = new gU((e=>{
        for (let t = 0, n = 0; ; n++) {
            if (e.next < 0) {
                n && e.acceptToken(58);
                break
            }
            if (45 == e.next)
                t++;
            else {
                if (62 == e.next && t >= 2) {
                    n >= 3 && e.acceptToken(58, -2);
                    break
                }
                t = 0
            }
            e.advance()
        }
    }
    ));
    const CF = new gU(((e,t)=>{
        if (47 == e.next && 62 == e.peek(1)) {
            let n = t.dialectEnabled(1) || function(e) {
                for (; e; e = e.parent)
                    if ("svg" == e.name || "math" == e.name)
                        return !0;
                return !1
            }(t.context);
            e.acceptToken(n ? 5 : 4, 2)
        } else
            62 == e.next && e.acceptToken(4, 1)
    }
    ));
    function PF(e, t, n) {
        let r = 2 + e.length;
        return new gU((o=>{
            for (let i = 0, a = 0, s = 0; ; s++) {
                if (o.next < 0) {
                    s && o.acceptToken(t);
                    break
                }
                if (0 == i && 60 == o.next || 1 == i && 47 == o.next || i >= 2 && i < r && o.next == e.charCodeAt(i - 2))
                    i++,
                    a++;
                else if (2 != i && i != r || !bF(o.next)) {
                    if (i == r && 62 == o.next) {
                        s > a ? o.acceptToken(t, -a) : o.acceptToken(n, -(a - 2));
                        break
                    }
                    if ((10 == o.next || 13 == o.next) && s) {
                        o.acceptToken(t, 1);
                        break
                    }
                    i = a = 0
                } else
                    a++;
                o.advance()
            }
        }
        ))
    }
    const DF = PF("script", 54, 1)
      , RF = PF("style", 55, 2)
      , NF = PF("textarea", 56, 3)
      , $F = aL({
        "Text RawText": TL.content,
        "StartTag StartCloseTag SelfClosingEndTag EndTag": TL.angleBracket,
        TagName: TL.tagName,
        "MismatchedCloseTag/TagName": [TL.tagName, TL.invalid],
        AttributeName: TL.attributeName,
        "AttributeValue UnquotedAttributeValue": TL.attributeValue,
        Is: TL.definitionOperator,
        "EntityReference CharacterReference": TL.character,
        Comment: TL.blockComment,
        ProcessingInst: TL.processingInstruction,
        DoctypeDecl: TL.documentMeta
    })
      , IF = PU.deserialize({
        version: 14,
        states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
        stateData: ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
        goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
        nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
        maxTerm: 67,
        context: xF,
        nodeProps: [["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"], ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"], ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"], ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""]],
        propSources: [$F],
        skippedNodes: [0],
        repeatNodeCount: 9,
        tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
        tokenizers: [DF, RF, NF, CF, TF, AF, 0, 1, 2, 3, 4, 5],
        topRules: {
            Document: [0, 15]
        },
        dialects: {
            noMatch: 0,
            selfClosing: 509
        },
        tokenPrec: 511
    });
    function MF(e, t) {
        let n = Object.create(null);
        for (let r of e.getChildren(aF)) {
            let e = r.getChild(sF)
              , o = r.getChild(lF) || r.getChild(cF);
            e && (n[t.read(e.from, e.to)] = o ? o.type.id == lF ? t.read(o.from + 1, o.to - 1) : t.read(o.from, o.to) : "")
        }
        return n
    }
    function LF(e, t) {
        let n = e.getChild(iF);
        return n ? t.read(n.from, n.to) : " "
    }
    function QF(e, t, n) {
        let r;
        for (let o of n)
            if (!o.attrs || o.attrs(r || (r = MF(e.node.parent.firstChild, t))))
                return {
                    parser: o.parser
                };
        return null
    }
    function BF(e=[], t=[]) {
        let n = []
          , r = []
          , o = []
          , i = [];
        for (let l of e) {
            ("script" == l.tag ? n : "style" == l.tag ? r : "textarea" == l.tag ? o : i).push(l)
        }
        let a = t.length ? Object.create(null) : null;
        for (let l of t)
            (a[l.name] || (a[l.name] = [])).push(l);
        return s = (e,t)=>{
            let s = e.type.id;
            if (s == uF)
                return QF(e, t, n);
            if (s == dF)
                return QF(e, t, r);
            if (s == pF)
                return QF(e, t, o);
            if (s == oF && i.length) {
                let n, r = e.node, o = r.firstChild, a = o && LF(o, t);
                if (a)
                    for (let e of i)
                        if (e.tag == a && (!e.attrs || e.attrs(n || (n = MF(o, t))))) {
                            let t = r.lastChild
                              , n = t.type.id == hF ? t.from : r.to;
                            if (n > o.to)
                                return {
                                    parser: e.parser,
                                    overlay: [{
                                        from: o.to,
                                        to: n
                                    }]
                                }
                        }
            }
            if (a && s == aF) {
                let n, r = e.node;
                if (n = r.firstChild) {
                    let e = a[t.read(n.from, n.to)];
                    if (e)
                        for (let n of e) {
                            if (n.tagName && n.tagName != LF(r.parent, t))
                                continue;
                            let e = r.lastChild;
                            if (e.type.id == lF) {
                                let t = e.from + 1
                                  , r = e.lastChild
                                  , o = e.to - (r && r.isError ? 0 : 1);
                                if (o > t)
                                    return {
                                        parser: n.parser,
                                        overlay: [{
                                            from: t,
                                            to: o
                                        }]
                                    }
                            } else if (e.type.id == cF)
                                return {
                                    parser: n.parser,
                                    overlay: [{
                                        from: e.from,
                                        to: e.to
                                    }]
                                }
                        }
                }
            }
            return null
        }
        ,
        (e,t,n,r)=>new WM(e,s,t,n,r);
        var s
    }
    const UF = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288]
      , FF = new CU({
        start: !1,
        shift: (e,t)=>5 == t || 6 == t || 315 == t ? e : 316 == t,
        strict: !1
    })
      , jF = new gU(((e,t)=>{
        let {next: n} = e;
        (125 == n || -1 == n || t.context) && e.acceptToken(313)
    }
    ),{
        contextual: !0,
        fallback: !0
    })
      , zF = new gU(((e,t)=>{
        let n, {next: r} = e;
        UF.indexOf(r) > -1 || (47 != r || 47 != (n = e.peek(1)) && 42 != n) && (125 == r || 59 == r || -1 == r || t.context || e.acceptToken(312))
    }
    ),{
        contextual: !0
    })
      , qF = new gU(((e,t)=>{
        let {next: n} = e;
        if (43 == n || 45 == n) {
            if (e.advance(),
            n == e.next) {
                e.advance();
                let n = !t.context && t.canShift(1);
                e.acceptToken(n ? 1 : 2)
            }
        } else
            63 == n && 46 == e.peek(1) && (e.advance(),
            e.advance(),
            (e.next < 48 || e.next > 57) && e.acceptToken(3))
    }
    ),{
        contextual: !0
    });
    function HF(e, t) {
        return e >= 65 && e <= 90 || e >= 97 && e <= 122 || 95 == e || e >= 192 || !t && e >= 48 && e <= 57
    }
    const ZF = new gU(((e,t)=>{
        if (60 != e.next || !t.dialectEnabled(0))
            return;
        if (e.advance(),
        47 == e.next)
            return;
        let n = 0;
        for (; UF.indexOf(e.next) > -1; )
            e.advance(),
            n++;
        if (HF(e.next, !0)) {
            for (e.advance(),
            n++; HF(e.next, !1); )
                e.advance(),
                n++;
            for (; UF.indexOf(e.next) > -1; )
                e.advance(),
                n++;
            if (44 == e.next)
                return;
            for (let t = 0; ; t++) {
                if (7 == t) {
                    if (!HF(e.next, !0))
                        return;
                    break
                }
                if (e.next != "extends".charCodeAt(t))
                    break;
                e.advance(),
                n++
            }
        }
        e.acceptToken(4, -n)
    }
    ))
      , WF = aL({
        "get set async static": TL.modifier,
        "for while do if else switch try catch finally return throw break continue default case": TL.controlKeyword,
        "in of await yield void typeof delete instanceof": TL.operatorKeyword,
        "let var const using function class extends": TL.definitionKeyword,
        "import export from": TL.moduleKeyword,
        "with debugger as new": TL.keyword,
        TemplateString: TL.special(TL.string),
        super: TL.atom,
        BooleanLiteral: TL.bool,
        this: TL.self,
        null: TL.null,
        Star: TL.modifier,
        VariableName: TL.variableName,
        "CallExpression/VariableName TaggedTemplateExpression/VariableName": TL.function(TL.variableName),
        VariableDefinition: TL.definition(TL.variableName),
        Label: TL.labelName,
        PropertyName: TL.propertyName,
        PrivatePropertyName: TL.special(TL.propertyName),
        "CallExpression/MemberExpression/PropertyName": TL.function(TL.propertyName),
        "FunctionDeclaration/VariableDefinition": TL.function(TL.definition(TL.variableName)),
        "ClassDeclaration/VariableDefinition": TL.definition(TL.className),
        PropertyDefinition: TL.definition(TL.propertyName),
        PrivatePropertyDefinition: TL.definition(TL.special(TL.propertyName)),
        UpdateOp: TL.updateOperator,
        "LineComment Hashbang": TL.lineComment,
        BlockComment: TL.blockComment,
        Number: TL.number,
        String: TL.string,
        Escape: TL.escape,
        ArithOp: TL.arithmeticOperator,
        LogicOp: TL.logicOperator,
        BitOp: TL.bitwiseOperator,
        CompareOp: TL.compareOperator,
        RegExp: TL.regexp,
        Equals: TL.definitionOperator,
        Arrow: TL.function(TL.punctuation),
        ": Spread": TL.punctuation,
        "( )": TL.paren,
        "[ ]": TL.squareBracket,
        "{ }": TL.brace,
        "InterpolationStart InterpolationEnd": TL.special(TL.brace),
        ".": TL.derefOperator,
        ", ;": TL.separator,
        "@": TL.meta,
        TypeName: TL.typeName,
        TypeDefinition: TL.definition(TL.typeName),
        "type enum interface implements namespace module declare": TL.definitionKeyword,
        "abstract global Privacy readonly override": TL.modifier,
        "is keyof unique infer": TL.operatorKeyword,
        JSXAttributeValue: TL.attributeValue,
        JSXText: TL.content,
        "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": TL.angleBracket,
        "JSXIdentifier JSXNameSpacedName": TL.tagName,
        "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": TL.attributeName,
        "JSXBuiltin/JSXIdentifier": TL.standard(TL.tagName)
    })
      , XF = {
        __proto__: null,
        export: 20,
        as: 25,
        from: 33,
        default: 36,
        async: 41,
        function: 42,
        extends: 54,
        this: 58,
        true: 66,
        false: 66,
        null: 78,
        void: 82,
        typeof: 86,
        super: 102,
        new: 136,
        delete: 148,
        yield: 157,
        await: 161,
        class: 166,
        public: 229,
        private: 229,
        protected: 229,
        readonly: 231,
        instanceof: 250,
        satisfies: 253,
        in: 254,
        const: 256,
        import: 290,
        keyof: 345,
        unique: 349,
        infer: 355,
        is: 391,
        abstract: 411,
        implements: 413,
        type: 415,
        let: 418,
        var: 420,
        using: 423,
        interface: 429,
        enum: 433,
        namespace: 439,
        module: 441,
        declare: 445,
        global: 449,
        for: 468,
        of: 477,
        while: 480,
        with: 484,
        do: 488,
        if: 492,
        else: 494,
        switch: 498,
        case: 504,
        try: 510,
        catch: 514,
        finally: 518,
        return: 522,
        throw: 526,
        break: 530,
        continue: 534,
        debugger: 538
    }
      , VF = {
        __proto__: null,
        async: 123,
        get: 125,
        set: 127,
        declare: 189,
        public: 191,
        private: 191,
        protected: 191,
        static: 193,
        abstract: 195,
        override: 197,
        readonly: 203,
        accessor: 205,
        new: 395
    }
      , GF = {
        __proto__: null,
        "<": 187
    }
      , YF = PU.deserialize({
        version: 14,
        states: "$@QO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ?NdO'#CiO+RO!bO'#CjO+aO#tO'#CjO+oO!0LbO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DwO0fQ^O'#EPOOQ?Mr'#EX'#EXO1PQWO'#EUOOQO'#Em'#EmOOQO'#Ih'#IhO1XQWO'#GpO1dQWO'#ElO1iQWO'#ElO3hQ?NdO'#JmO6[Q?NdO'#JnO6uQWO'#F[O6zQ&jO'#FsOOQ?Mr'#Fe'#FeO7VO,YO'#FeO7eQ7[O'#FzO9RQWO'#FyOOQ?Mr'#Jn'#JnOOQ?Mp'#Jm'#JmO9WQWO'#GtOOQU'#KZ'#KZO9cQWO'#IUO9hQ?MxO'#IVOOQU'#JZ'#JZOOQU'#IZ'#IZQ`Q^OOO`Q^OOO9pQMnO'#DsO9wQ^O'#D{O:OQ^O'#D}O9^QWO'#GpO:VQ7[O'#CoO:eQWO'#EkO:pQWO'#EvO:uQ7[O'#FdO;dQWO'#GpOOQO'#K['#K[O;iQWO'#K[O;wQWO'#GxO;wQWO'#GyO;wQWO'#G{O9^QWO'#HOO<nQWO'#HRO>VQWO'#CeO>gQWO'#H_O>oQWO'#HeO>oQWO'#HgO`Q^O'#HiO>oQWO'#HkO>oQWO'#HnO>tQWO'#HtO>yQ?MyO'#HzO%[Q^O'#H|O?UQ?MyO'#IOO?aQ?MyO'#IQO9hQ?MxO'#ISO?lQ?NdO'#CiO@nQ`O'#DiQOQWOOO%[Q^O'#D}OAUQWO'#EQO:VQ7[O'#EkOAaQWO'#EkOAlQpO'#FdOOQU'#Cg'#CgOOQ?Mp'#Dn'#DnOOQ?Mp'#Jq'#JqO%[Q^O'#JqOOQO'#Jt'#JtOOQO'#Id'#IdOBlQ`O'#EdOOQ?Mp'#Ec'#EcOOQ?Mp'#Jx'#JxOChQ?NQO'#EdOCrQ`O'#ETOOQO'#Js'#JsODWQ`O'#JtOEeQ`O'#ETOCrQ`O'#EdPErO#@ItO'#CbPOOO)CDx)CDxOOOO'#I['#I[OE}O!bO,59UOOQ?Mr,59U,59UOOOO'#I]'#I]OF]O#tO,59UO%[Q^O'#D`OOOO'#I_'#I_OFkO!0LbO,59xOOQ?Mr,59x,59xOFyQ^O'#I`OG^QWO'#JoOI]QrO'#JoO+}Q^O'#JoOIdQWO,5:OOIzQWO'#EmOJXQWO'#KOOJdQWO'#J}OJdQWO'#J}OJlQWO,5;ZOJqQWO'#J|OOQ?Mv,5:Z,5:ZOJxQ^O,5:ZOLvQ?NdO,5:cOMgQWO,5:kONQQ?MxO'#J{ONXQWO'#JzO9WQWO'#JzONmQWO'#JzONuQWO,5;YONzQWO'#JzO!#PQrO'#JnOOQ?Mr'#Ci'#CiO%[Q^O'#EPO!#oQrO,5:pOOQQ'#Ju'#JuOOQO-E<f-E<fO9^QWO,5=[O!$VQWO,5=[O!$[Q^O,5;WO!&_Q7[O'#EhO!'xQWO,5;WO!'}Q^O'#DvO!(XQ`O,5;aO!(aQ`O,5;aO%[Q^O,5;aOOQU'#FS'#FSOOQU'#FU'#FUO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bOOQU'#FY'#FYO!(oQ^O,5;sOOQ?Mr,5;x,5;xOOQ?Mr,5;y,5;yOOQ?Mr,5;{,5;{O%[Q^O'#IlO!*rQ?MxO,5<gO%[Q^O,5;bO!&_Q7[O,5;bO!+aQ7[O,5;bO!-RQ7[O'#EZO%[Q^O,5;vOOQ?Mr,5;z,5;zO!-YQ&jO'#FiO!.VQ&jO'#KSO!-qQ&jO'#KSO!.^Q&jO'#KSOOQO'#KS'#KSO!.rQ&jO,5<ROOOS,5<_,5<_O!/TQ^O'#FuOOOS'#Ik'#IkO7VO,YO,5<PO!/[Q&jO'#FwOOQ?Mr,5<P,5<PO!/{Q!LQO'#CvOOQ?Mr'#Cz'#CzO!0`O!0LbO'#DOO!0|Q7[O,5<dO!1TQWO,5<fO!2pQ$ISO'#GVO!2}QWO'#GWO!3SQWO'#GWO!4rQ$ISO'#G[O!5nQ`O'#G`OOQO'#Gk'#GkO!+hQ7[O'#GjOOQO'#Gm'#GmO!+hQ7[O'#GlO!6aQ!LQO'#JgOOQ?Mr'#Jg'#JgO!6kQWO'#JfO!6yQWO'#JeO!7RQWO'#CuOOQ?Mr'#Cx'#CxO!7ZQWO'#CzOOQ?Mr'#DS'#DSOOQ?Mr'#DU'#DUO1SQWO'#DWO!+hQ7[O'#F}O!+hQ7[O'#GPO!7`QWO'#GRO!7eQWO'#GSO!3SQWO'#GYO!+hQ7[O'#G_O!7jQWO'#EnO!8XQWO,5<eOOQ?Mp'#Cr'#CrO!8aQWO'#EoO!9ZQ`O'#EpOOQ?Mp'#J|'#J|O!9bQ?MxO'#K]O9hQ?MxO,5=`O`Q^O,5>pOOQU'#Jc'#JcOOQU,5>q,5>qOOQU-E<X-E<XO!;aQ?NdO,5:_O!9UQ`O,5:]O!=zQ?NdO,5:gO%[Q^O,5:gO!@bQ?NdO,5:iOOQO,5@v,5@vO!ARQ7[O,5=[O!AaQ?MxO'#JdO9RQWO'#JdO!ArQ?MxO,59ZO!A}Q`O,59ZO!BVQ7[O,59ZO:VQ7[O,59ZO!BbQWO,5;WO!BjQWO'#H^O!COQWO'#K`O%[Q^O,5;|O!9UQ`O,5<OO!CWQWO,5=wO!C]QWO,5=wO!CbQWO,5=wO9hQ?MxO,5=wO;wQWO,5=gOOQO'#Cv'#CvO!CpQ`O,5=dO!CxQ7[O,5=eO!DTQWO,5=gO!DYQpO,5=jO!DbQWO'#K[O>tQWO'#HTO9^QWO'#HVO!DgQWO'#HVO:VQ7[O'#HXO!DlQWO'#HXOOQU,5=m,5=mO!DqQWO'#HYO!ESQWO'#CoO!EXQWO,59PO!EcQWO,59PO!GhQ^O,59POOQU,59P,59PO!GxQ?MxO,59PO%[Q^O,59PO!JTQ^O'#HaOOQU'#Hb'#HbOOQU'#Hc'#HcO`Q^O,5=yO!JkQWO,5=yO`Q^O,5>PO`Q^O,5>RO!JpQWO,5>TO`Q^O,5>VO!JuQWO,5>YO!JzQ^O,5>`OOQU,5>f,5>fO%[Q^O,5>fO9hQ?MxO,5>hOOQU,5>j,5>jO# UQWO,5>jOOQU,5>l,5>lO# UQWO,5>lOOQU,5>n,5>nO# rQ`O'#D[O%[Q^O'#JqO# |Q`O'#JqO#!kQ`O'#DjO#!|Q`O'#DjO#%_Q^O'#DjO#%fQWO'#JpO#%nQWO,5:TO#%sQWO'#EqO#&RQWO'#KPO#&ZQWO,5;[O#&`Q`O'#DjO#&mQ`O'#ESOOQ?Mr,5:l,5:lO%[Q^O,5:lO#&tQWO,5:lO>tQWO,5;VO!A}Q`O,5;VO!BVQ7[O,5;VO:VQ7[O,5;VO#&|QWO,5@]O#'RQ(CYO,5:pOOQO-E<b-E<bO#(XQ?NQO,5;OOCrQ`O,5:oO#(cQ`O,5:oOCrQ`O,5;OO!ArQ?MxO,5:oOOQ?Mp'#Eg'#EgOOQO,5;O,5;OO%[Q^O,5;OO#(pQ?MxO,5;OO#({Q?MxO,5;OO!A}Q`O,5:oOOQO,5;U,5;UO#)ZQ?MxO,5;OPOOO'#IY'#IYP#)oO#@ItO,58|POOO,58|,58|OOOO-E<Y-E<YOOQ?Mr1G.p1G.pOOOO-E<Z-E<ZO#)zQpO,59zOOOO-E<]-E<]OOQ?Mr1G/d1G/dO#*PQrO,5>zO+}Q^O,5>zOOQO,5?Q,5?QO#*ZQ^O'#I`OOQO-E<^-E<^O#*hQWO,5@ZO#*pQrO,5@ZO#*wQWO,5@iOOQ?Mr1G/j1G/jO%[Q^O,5@jO#+PQWO'#IfOOQO-E<d-E<dO#*wQWO,5@iOOQ?Mp1G0u1G0uOOQ?Mv1G/u1G/uOOQ?Mv1G0V1G0VO%[Q^O,5@gO#+eQ?MxO,5@gO#+vQ?MxO,5@gO#+}QWO,5@fO9WQWO,5@fO#,VQWO,5@fO#,eQWO'#IiO#+}QWO,5@fOOQ?Mp1G0t1G0tO!(XQ`O,5:rO!(dQ`O,5:rOOQQ,5:t,5:tO#-VQYO,5:tO#-_Q7[O1G2vO9^QWO1G2vOOQ?Mr1G0r1G0rO#-mQ?NdO1G0rO#.rQ?NbO,5;SOOQ?Mr'#GU'#GUO#/`Q?NdO'#JgO!$[Q^O1G0rO#1hQrO'#JrO%[Q^O'#JrO#1rQWO,5:bOOQ?Mr'#D['#D[OOQ?Mr1G0{1G0{O%[Q^O1G0{OOQ?Mr1G1e1G1eO#1wQWO1G0{O#4]Q?NdO1G0|O#4dQ?NdO1G0|O#6zQ?NdO1G0|O#7RQ?NdO1G0|O#9iQ?NdO1G0|O#<PQ?NdO1G0|O#<WQ?NdO1G0|O#<_Q?NdO1G0|O#>uQ?NdO1G0|O#>|Q?NdO1G0|O#AZQ07bO'#CiO#CUQ07bO1G1_O#C]Q07bO'#JnO#CpQ?NdO,5?WOOQ?Mp-E<j-E<jO#E}Q?NdO1G0|O#FzQ?NdO1G0|OOQ?Mr1G0|1G0|O#GzQ7[O'#JwO#HUQWO,5:uO#HZQ?NdO1G1bO#H}Q&jO,5<VO#IVQ&jO,5<WO#I_Q&jO'#FnO#IvQWO'#FmOOQO'#KT'#KTOOQO'#Ij'#IjO#I{Q&jO1G1mOOQ?Mr1G1m1G1mOOOS1G1x1G1xO#J^Q07bO'#JmO#JhQWO,5<aO!(oQ^O,5<aOOOS-E<i-E<iOOQ?Mr1G1k1G1kO#JmQ`O'#KSOOQ?Mr,5<c,5<cO#JuQ`O,5<cO!&_Q7[O'#DQOOOO'#I^'#I^O#JzO!0LbO,59jOOQ?Mr,59j,59jO%[Q^O1G2OO!7eQWO'#InO#KVQ7[O,5<xOOQ?Mr,5<u,5<uO!+hQ7[O'#IqO#KuQ7[O,5=UO!+hQ7[O'#IsO#LhQ7[O,5=WO!&_Q7[O,5=YOOQO1G2Q1G2QO#LrQpO'#CrO#MVQ$ISO'#EoO#NUQ`O'#G`O#NrQpO,5<qO#NyQWO'#KWO9WQWO'#KWO$ XQWO,5<sO!+hQ7[O,5<rO$ ^QWO'#GXO$ oQWO,5<rO$ tQpO'#GUO$!RQpO'#KXO$!]QWO'#KXO!&_Q7[O'#KXO$!bQWO,5<vO$!gQ`O'#GaO!5iQ`O'#GaO$!xQWO'#GcO$!}QWO'#GeO!3SQWO'#GhO$#SQ?MxO'#IpO$#_Q`O,5<zOOQ?Mv,5<z,5<zO$#fQ`O'#GaO$#tQ`O'#GbO$#|Q`O'#GbO$$RQ7[O,5=UO$$cQ7[O,5=WOOQ?Mr,5=Z,5=ZO!+hQ7[O,5@QO!+hQ7[O,5@QO$$sQWO'#IuO$%OQWO,5@PO$%WQWO,59aOOQ?Mr,59f,59fO$%zQ!LSO,59rOOQ?Mr'#Jk'#JkO$&mQ7[O,5<iO$'`Q7[O,5<kO@fQWO,5<mOOQ?Mr,5<n,5<nO$'jQWO,5<tO$'oQ7[O,5<yO$(PQWO'#JzO!$[Q^O1G2PO$(UQWO1G2PO9WQWO'#J}O9WQWO'#EqO%[Q^O'#EqO9WQWO'#IwO$(ZQ?MxO,5@wOOQU1G2z1G2zOOQU1G4[1G4[OOQ?Mr1G/y1G/yOOQ?Mr1G/w1G/wO$*]Q?NdO1G0ROOQU1G2v1G2vO!&_Q7[O1G2vO%[Q^O1G2vO#-bQWO1G2vO$,aQ7[O'#EhOOQ?Mp,5@O,5@OO$,kQ?MxO,5@OOOQU1G.u1G.uO!ArQ?MxO1G.uO!A}Q`O1G.uO!BVQ7[O1G.uO$,|QWO1G0rO$-RQWO'#CiO$-^QWO'#KaO$-fQWO,5=xO$-kQWO'#KaO$-pQWO'#KaO$.OQWO'#I}O$.^QWO,5@zO$.fQrO1G1hOOQ?Mr1G1j1G1jO9^QWO1G3cO@fQWO1G3cO$.mQWO1G3cO$.rQWO1G3cOOQU1G3c1G3cO!DTQWO1G3RO!&_Q7[O1G3OO$.wQWO1G3OOOQU1G3P1G3PO!&_Q7[O1G3PO$.|QWO1G3PO$/UQ`O'#G}OOQU1G3R1G3RO!5iQ`O'#IyO!DYQpO1G3UOOQU1G3U1G3UOOQU,5=o,5=oO$/^Q7[O,5=qO9^QWO,5=qO$!}QWO,5=sO9RQWO,5=sO!A}Q`O,5=sO!BVQ7[O,5=sO:VQ7[O,5=sO$/lQWO'#K_O$/wQWO,5=tOOQU1G.k1G.kO$/|Q?MxO1G.kO@fQWO1G.kO$0XQWO1G.kO9hQ?MxO1G.kO$2aQrO,5@|O$2nQWO,5@|O9WQWO,5@|O$2yQ^O,5={O$3QQWO,5={OOQU1G3e1G3eO`Q^O1G3eOOQU1G3k1G3kOOQU1G3m1G3mO>oQWO1G3oO$3VQ^O1G3qO$7ZQ^O'#HpOOQU1G3t1G3tO$7hQWO'#HvO>tQWO'#HxOOQU1G3z1G3zO$7pQ^O1G3zO9hQ?MxO1G4QOOQU1G4S1G4SOOQ?Mp'#G]'#G]O9hQ?MxO1G4UO9hQ?MxO1G4WO$;wQWO,5@]O!(oQ^O,5;]O9WQWO,5;]O>tQWO,5:UO!(oQ^O,5:UO!A}Q`O,5:UO$;|Q07bO,5:UOOQO,5;],5;]O$<WQ`O'#IaO$<nQWO,5@[OOQ?Mr1G/o1G/oO$<vQ`O'#IgO$=QQWO,5@kOOQ?Mp1G0v1G0vO#!|Q`O,5:UOOQO'#Ic'#IcO$=YQ`O,5:nOOQ?Mv,5:n,5:nO#&wQWO1G0WOOQ?Mr1G0W1G0WO%[Q^O1G0WOOQ?Mr1G0q1G0qO>tQWO1G0qO!A}Q`O1G0qO!BVQ7[O1G0qOOQ?Mp1G5w1G5wO!ArQ?MxO1G0ZOOQO1G0j1G0jO%[Q^O1G0jO$=aQ?MxO1G0jO$=lQ?MxO1G0jO!A}Q`O1G0ZOCrQ`O1G0ZO$=zQ?MxO1G0jOOQO1G0Z1G0ZO$>`Q?NdO1G0jPOOO-E<W-E<WPOOO1G.h1G.hOOOO1G/f1G/fO$>jQpO,5<gO$>rQrO1G4fOOQO1G4l1G4lO%[Q^O,5>zO$>|QWO1G5uO$?UQWO1G6TO$?^QrO1G6UO9WQWO,5?QO$?hQ?NdO1G6RO%[Q^O1G6RO$?xQ?MxO1G6RO$@ZQWO1G6QO$@ZQWO1G6QO9WQWO1G6QO$@cQWO,5?TO9WQWO,5?TOOQO,5?T,5?TO$@wQWO,5?TO$(PQWO,5?TOOQO-E<g-E<gOOQQ1G0^1G0^OOQQ1G0`1G0`O#-YQWO1G0`OOQU7+(b7+(bO!&_Q7[O7+(bO%[Q^O7+(bO$AVQWO7+(bO$AbQ7[O7+(bO$ApQ?NdO,5=UO$CxQ?NdO,5=WO$FQQ?NdO,5=UO$H`Q?NdO,5=WO$JnQ?NdO,59rO$LsQ?NdO,5<iO$N{Q?NdO,5<kO%#TQ?NdO,5<yOOQ?Mr7+&^7+&^O%%cQ?NdO7+&^O%&VQ^O'#IbO%&dQWO,5@^O%&lQrO,5@^OOQ?Mr1G/|1G/|O%&vQWO7+&gOOQ?Mr7+&g7+&gO%&{Q07bO,5:cO%[Q^O7+&yO%'VQ07bO,5:_O%'dQ07bO,5:gO%'nQ07bO,5:iO%'xQ7[O'#IeO%(SQWO,5@cOOQ?Mr1G0a1G0aOOQO1G1q1G1qOOQO1G1r1G1rO%([QtO,5<YO!(oQ^O,5<XOOQO-E<h-E<hOOQ?Mr7+'X7+'XOOOS7+'d7+'dOOOS1G1{1G1{O%(gQWO1G1{OOQ?Mr1G1}1G1}O%(lQpO,59lOOOO-E<[-E<[OOQ?Mr1G/U1G/UO%(sQ?NdO7+'jOOQ?Mr,5?Y,5?YO%)gQpO,5?YOOQ?Mr1G2d1G2dP!&_Q7[O'#InPOQ?Mr-E<l-E<lO%*VQ7[O,5?]OOQ?Mr-E<o-E<oO%*xQ7[O,5?_OOQ?Mr-E<q-E<qO%+SQpO1G2tO%+ZQpO'#CrO%+qQ7[O'#J}O%+xQ^O'#EqOOQ?Mr1G2]1G2]O%,SQWO'#ImO%,hQWO,5@rO%,hQWO,5@rO%,pQWO,5@rO%,{QWO,5@rOOQO1G2_1G2_O%-ZQ7[O1G2^O!+hQ7[O1G2^O%-kQ$ISO'#IoO%-xQWO,5@sO!&_Q7[O,5@sO%.QQpO,5@sOOQ?Mr1G2b1G2bOOQ?Mp,5<{,5<{OOQ?Mp,5<|,5<|O$(PQWO,5<|OCcQWO,5<|O!A}Q`O,5<{OOQO'#Gd'#GdO%.[QWO,5<}OOQ?Mp,5=P,5=PO$(PQWO,5=SOOQO,5?[,5?[OOQO-E<n-E<nOOQ?Mv1G2f1G2fO!5iQ`O,5<{O%.dQWO,5<|O$!xQWO,5<}O%.oQ`O,5<|O!+hQ7[O'#IqO%/`Q7[O1G2pO!+hQ7[O'#IsO%0RQ7[O1G2rO%0]Q7[O1G5lO%0gQ7[O1G5lOOQO,5?a,5?aOOQO-E<s-E<sOOQO1G.{1G.{O!9UQ`O,59tO%[Q^O,59tOOQ?Mr,5<h,5<hO%0tQWO1G2XO!+hQ7[O1G2`O%0yQ?NdO7+'kOOQ?Mr7+'k7+'kO!$[Q^O7+'kO%1mQWO,5;]OOQ?Mp,5?c,5?cOOQ?Mp-E<u-E<uO%1rQpO'#KYO#&wQWO7+(bO4UQrO7+(bO$AYQWO7+(bO%1|Q?NbO'#CiO%2aQ?NbO,5=QO%3RQWO,5=QOOQ?Mp1G5j1G5jOOQU7+$a7+$aO!ArQ?MxO7+$aO!A}Q`O7+$aO!$[Q^O7+&^O%3WQWO'#I|O%3oQWO,5@{OOQO1G3d1G3dO9^QWO,5@{O%3oQWO,5@{O%3wQWO,5@{OOQO,5?i,5?iOOQO-E<{-E<{OOQ?Mr7+'S7+'SO%3|QWO7+(}O9hQ?MxO7+(}O9^QWO7+(}O@fQWO7+(}OOQU7+(m7+(mO%4RQ?NbO7+(jO!&_Q7[O7+(jO%4]QpO7+(kOOQU7+(k7+(kO!&_Q7[O7+(kO%4dQWO'#K^O%4oQWO,5=iOOQO,5?e,5?eOOQO-E<w-E<wOOQU7+(p7+(pO%6RQ`O'#HWOOQU1G3]1G3]O!&_Q7[O1G3]O%[Q^O1G3]O%6YQWO1G3]O%6eQ7[O1G3]O9hQ?MxO1G3_O$!}QWO1G3_O9RQWO1G3_O!A}Q`O1G3_O!BVQ7[O1G3_O%6sQWO'#I{O%7XQWO,5@yO%7aQ`O,5@yOOQ?Mp1G3`1G3`OOQU7+$V7+$VO@fQWO7+$VO9hQ?MxO7+$VO%7lQWO7+$VO%[Q^O1G6hO%[Q^O1G6iO%7qQ?MxO1G6hO%7{Q^O1G3gO%8SQWO1G3gO%8XQ^O1G3gOOQU7+)P7+)PO9hQ?MxO7+)ZO`Q^O7+)]OOQU'#Kd'#KdOOQU'#JO'#JOO%8`Q^O,5>[OOQU,5>[,5>[O%[Q^O'#HqO%8mQWO'#HsOOQU,5>b,5>bO9WQWO,5>bOOQU,5>d,5>dOOQU7+)f7+)fOOQU7+)l7+)lOOQU7+)p7+)pOOQU7+)r7+)rO%8rQ`O1G5wO%9WQ07bO1G0wO%9bQWO1G0wOOQO1G/p1G/pO%9mQ07bO1G/pO>tQWO1G/pO!(oQ^O'#DjOOQO,5>{,5>{OOQO-E<_-E<_OOQO,5?R,5?ROOQO-E<e-E<eO!A}Q`O1G/pOOQO-E<a-E<aOOQ?Mv1G0Y1G0YOOQ?Mr7+%r7+%rO#&wQWO7+%rOOQ?Mr7+&]7+&]O>tQWO7+&]O!A}Q`O7+&]OOQO7+%u7+%uO$>`Q?NdO7+&UOOQO7+&U7+&UO%[Q^O7+&UO%9wQ?MxO7+&UO!ArQ?MxO7+%uO!A}Q`O7+%uO%:SQ?MxO7+&UO%:bQ?NdO7++mO%[Q^O7++mO%:rQWO7++lO%:rQWO7++lOOQO1G4o1G4oO9WQWO1G4oO%:zQWO1G4oOOQQ7+%z7+%zO#&wQWO<<K|O4UQrO<<K|O%;YQWO<<K|OOQU<<K|<<K|O!&_Q7[O<<K|O%[Q^O<<K|O%;bQWO<<K|O%;mQ?NdO,5?]O%=uQ?NdO,5?_O%?}Q?NdO1G2^O%B]Q?NdO1G2pO%DeQ?NdO1G2rO%FmQrO,5>|O%[Q^O,5>|OOQO-E<`-E<`O%FwQWO1G5xOOQ?Mr<<JR<<JRO%GPQ07bO1G0rO%IWQ07bO1G0|O%I_Q07bO1G0|O%K`Q07bO1G0|O%KgQ07bO1G0|O%MhQ07bO1G0|O& iQ07bO1G0|O& pQ07bO1G0|O& wQ07bO1G0|O&#xQ07bO1G0|O&$PQ07bO1G0|O&$WQ?NdO<<JeO&&OQ07bO1G0|O&&{Q07bO1G0|O&'{Q07bO'#JgO&*OQ07bO1G1bO&*]Q07bO1G0RO&*gQ7[O,5?POOQO-E<c-E<cO!(oQ^O'#FpOOQO'#KU'#KUOOQO1G1t1G1tO&*qQWO1G1sO&*vQ07bO,5?WOOOS7+'g7+'gOOOO1G/W1G/WOOQ?Mr1G4t1G4tO!+hQ7[O7+(`O&-WQrO'#CiO&-bQWO,5?XO9WQWO,5?XOOQO-E<k-E<kO&-pQWO1G6^O&-pQWO1G6^O&-xQWO1G6^O&.TQ7[O7+'xO&.eQpO,5?ZO&.oQWO,5?ZO!&_Q7[O,5?ZOOQO-E<m-E<mO&.tQpO1G6_O&/OQWO1G6_OOQ?Mp1G2h1G2hO$(PQWO1G2hOOQ?Mp1G2g1G2gO&/WQWO1G2iO!&_Q7[O1G2iOOQ?Mp1G2n1G2nO!A}Q`O1G2gOCcQWO1G2hO&/]QWO1G2iO&/eQWO1G2hO$!xQWO1G2iO&0XQ7[O,5?]OOQ?Mr-E<p-E<pO&0zQ7[O,5?_OOQ?Mr-E<r-E<rO!+hQ7[O7++WOOQ?Mr1G/`1G/`O&1UQWO1G/`OOQ?Mr7+'s7+'sO&1ZQ7[O7+'zO&1kQ?NdO<<KVOOQ?Mr<<KV<<KVO&2_QWO1G0wO!&_Q7[O'#IvO&2dQWO,5@tO&4fQrO<<K|O!&_Q7[O1G2lOOQU<<G{<<G{O!ArQ?MxO<<G{O&4mQ?NdO<<IxOOQ?Mr<<Ix<<IxOOQO,5?h,5?hO&5aQWO,5?hO&5fQWO,5?hOOQO-E<z-E<zO&5tQWO1G6gO&5tQWO1G6gO9^QWO1G6gO@fQWO<<LiOOQU<<Li<<LiO&5|QWO<<LiO9hQ?MxO<<LiOOQU<<LU<<LUO%4RQ?NbO<<LUOOQU<<LV<<LVO%4]QpO<<LVO&6RQ`O'#IxO&6^QWO,5@xO!(oQ^O,5@xOOQU1G3T1G3TO%+xQ^O'#JqOOQO'#Iz'#IzO9hQ?MxO'#IzO&6fQ`O,5=rOOQU,5=r,5=rO&6mQ`O'#EdO&7RQ`O'#GcO&7WQWO7+(wO&7]QWO7+(wOOQU7+(w7+(wO!&_Q7[O7+(wO%[Q^O7+(wO&7eQWO7+(wOOQU7+(y7+(yO9hQ?MxO7+(yO$!}QWO7+(yO9RQWO7+(yO!A}Q`O7+(yO&7pQWO,5?gOOQO-E<y-E<yOOQO'#HZ'#HZO&7{QWO1G6eO9hQ?MxO<<GqOOQU<<Gq<<GqO@fQWO<<GqO&8TQWO7+,SO&8YQWO7+,TO%[Q^O7+,SO%[Q^O7+,TOOQU7+)R7+)RO&8_QWO7+)RO&8dQ^O7+)RO&8kQWO7+)ROOQU<<Lu<<LuOOQU<<Lw<<LwOOQU-E<|-E<|OOQU1G3v1G3vO&8pQWO,5>]OOQU,5>_,5>_O&8uQWO1G3|O9WQWO7+&cO!(oQ^O7+&cOOQO7+%[7+%[O&8zQ07bO1G6UO>tQWO7+%[OOQ?Mr<<I^<<I^OOQ?Mr<<Iw<<IwO>tQWO<<IwOOQO<<Ip<<IpO$>`Q?NdO<<IpO%[Q^O<<IpOOQO<<Ia<<IaO!ArQ?MxO<<IaO&9UQ?MxO<<IpO&9aQ?NdO<= XO&9qQWO<= WOOQO7+*Z7+*ZO9WQWO7+*ZOOQUANAhANAhO&9yQrOANAhO!&_Q7[OANAhO#&wQWOANAhO4UQrOANAhO&:QQWOANAhO%[Q^OANAhO&:YQ?NdO7+'xO&<hQ?NdO,5?]O&>pQ?NdO,5?_O&@xQ?NdO7+'zO&CWQrO1G4hO&CbQ07bO7+&^O&EcQ07bO,5=UO&GgQ07bO,5=WO&GwQ07bO,5=UO&HXQ07bO,5=WO&HiQ07bO,59rO&JlQ07bO,5<iO&LlQ07bO,5<kO&N}Q07bO,5<yO'!pQ07bO7+'jO'!}Q07bO7+'kO'#[QWO,5<[OOQO7+'_7+'_O'#aQ7[O<<KzOOQO1G4s1G4sO'#hQWO1G4sO'#sQWO1G4sO'$RQWO7++xO'$RQWO7++xO!&_Q7[O1G4uO'$ZQpO1G4uO'$eQWO7++yOOQ?Mp7+(S7+(SO'$mQWO7+(TO'$xQpO7+(TOOQ?Mp7+(R7+(RO$(PQWO7+(SO'%PQWO7+(TO!&_Q7[O7+(TOCcQWO7+(SO'%UQWO7+(TO'%^Q7[O<<NrOOQ?Mr7+$z7+$zO'%hQpO,5?bOOQO-E<t-E<tO'%rQ?NbO7+(WOOQUAN=gAN=gO9^QWO1G5SOOQO1G5S1G5SO'&SQWO1G5SO'&XQWO7+,RO'&XQWO7+,RO9hQ?MxOANBTO@fQWOANBTOOQUANBTANBTOOQUANApANApOOQUANAqANAqO'&aQWO,5?dOOQO-E<v-E<vO'&lQ07bO1G6dOOQO,5?f,5?fOOQO-E<x-E<xOOQU1G3^1G3^O%+xQ^O,5<}O'&vQWO,5<}OOQU<<Lc<<LcO!&_Q7[O<<LcO&7WQWO<<LcO'&{QWO<<LcO%[Q^O<<LcOOQU<<Le<<LeO9hQ?MxO<<LeO$!}QWO<<LeO9RQWO<<LeO''TQ`O1G5RO''`QWO7+,POOQUAN=]AN=]O9hQ?MxOAN=]OOQU<= n<= nOOQU<= o<= oO''hQWO<= nO''mQWO<= oOOQU<<Lm<<LmO''rQWO<<LmO''wQ^O<<LmOOQU1G3w1G3wO>tQWO7+)hO'(OQWO<<I}O'(ZQ07bO<<I}OOQO<<Hv<<HvOOQ?MrAN?cAN?cOOQOAN?[AN?[O$>`Q?NdOAN?[OOQOAN>{AN>{O%[Q^OAN?[OOQO<<Mu<<MuOOQUG27SG27SO!&_Q7[OG27SO#&wQWOG27SO'(eQrOG27SO4UQrOG27SO'(lQWOG27SO'(tQ07bO<<JeO')RQ07bO1G2^O'*tQ07bO,5?]O',tQ07bO,5?_O'.tQ07bO1G2pO'0tQ07bO1G2rO'2tQ07bO<<KVO'3RQ07bO<<IxOOQO1G1v1G1vO!+hQ7[OANAfOOQO7+*_7+*_O'3`QWO7+*_O'3kQWO<= dO'3sQpO7+*aOOQ?Mp<<Ko<<KoO$(PQWO<<KoOCcQWO<<KoO'3}QWO<<KoOOQ?Mp<<Kn<<KnO'4YQpO<<KoO$(PQWO<<KnO'4aQWO<<KoO!&_Q7[O<<KoOOQO7+*n7+*nO9^QWO7+*nO'4fQWO<= mOOQUG27oG27oO9hQ?MxOG27oO!(oQ^O1G5OO'4nQWO7+,OO&7WQWOANA}OOQUANA}ANA}O!&_Q7[OANA}O'4vQWOANA}OOQUANBPANBPO9hQ?MxOANBPO$!}QWOANBPOOQO'#H['#H[OOQO7+*m7+*mOOQUG22wG22wOOQUANEYANEYOOQUANEZANEZOOQUANBXANBXO'5OQWOANBXOOQU<<MS<<MSO!(oQ^OAN?iOOQOG24vG24vO$>`Q?NdOG24vO#&wQWOLD,nOOQULD,nLD,nO!&_Q7[OLD,nO'5TQrOLD,nO'5[Q07bO7+'xO'6}Q07bO,5?]O'8}Q07bO,5?_O':}Q07bO7+'zO'<pQ7[OG27QOOQO<<My<<MyOOQ?MpANAZANAZO$(PQWOANAZOCcQWOANAZO'=QQWOANAZOOQ?MpANAYANAYO'=]QpOANAZOOQO<<NY<<NYOOQULD-ZLD-ZO'=dQ07bO7+*jOOQUG27iG27iO&7WQWOG27iO!&_Q7[OG27iOOQUG27kG27kO9hQ?MxOG27kOOQUG27sG27sO'=nQ07bOG25TOOQOLD*bLD*bOOQU!$(!Y!$(!YO#&wQWO!$(!YO!&_Q7[O!$(!YO'=xQ?NdOG27QOOQ?MpG26uG26uO$(PQWOG26uOCcQWOG26uO'@WQWOG26uOOQULD-TLD-TO&7WQWOLD-TOOQULD-VLD-VOOQU!)9Et!)9EtO#&wQWO!)9EtOOQ?MpLD,aLD,aO$(PQWOLD,aOCcQWOLD,aOOQU!$(!o!$(!oOOQU!.K;`!.K;`O'@cQ07bOG27QOOQ?Mp!$( {!$( {O$(PQWO!$( {OOQ?Mp!)9Eg!)9EgO!(oQ^O'#DwO1PQWO'#EUO'BUQrO'#JmO'B]QMnO'#DsO'BdQ^O'#D{O'BkQrO'#CiO'ERQrO'#CiO!(oQ^O'#D}O'EcQ^O,5;WO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O'#IlO'GfQWO,5<gO!(oQ^O,5;bO'GnQ7[O,5;bO'IXQ7[O,5;bO!(oQ^O,5;vO!&_Q7[O'#GjO'GnQ7[O'#GjO!&_Q7[O'#GlO'GnQ7[O'#GlO1SQWO'#DWO1SQWO'#DWO!&_Q7[O'#F}O'GnQ7[O'#F}O!&_Q7[O'#GPO'GnQ7[O'#GPO!&_Q7[O'#G_O'GnQ7[O'#G_O!(oQ^O,5:gO'I`Q`O'#D[O!(oQ^O,5@jO'EcQ^O1G0rO'IjQ07bO'#CiO!(oQ^O1G2OO!&_Q7[O'#IqO'GnQ7[O'#IqO!&_Q7[O'#IsO'GnQ7[O'#IsO'ItQpO'#CrO!&_Q7[O,5<rO'GnQ7[O,5<rO'EcQ^O1G2PO!(oQ^O7+&yO!&_Q7[O1G2^O'GnQ7[O1G2^O!&_Q7[O'#IqO'GnQ7[O'#IqO!&_Q7[O'#IsO'GnQ7[O'#IsO!&_Q7[O1G2`O'GnQ7[O1G2`O'EcQ^O7+'kO'EcQ^O7+&^O!&_Q7[OANAfO'GnQ7[OANAfO'JXQWO'#ElO'J^QWO'#ElO'JfQWO'#F[O'JkQWO'#EvO'JpQWO'#KOO'J{QWO'#J|O'KWQWO,5;WO'K]Q7[O,5<dO'KdQWO'#GWO'KiQWO'#GWO'KnQWO,5<eO'KvQWO,5;WO'LOQ07bO1G1_O'LVQWO,5<rO'L[QWO,5<rO'LaQWO,5<tO'LfQWO,5<tO'LkQWO1G2PO'LpQWO1G0rO'LuQ7[O<<KzO'L|Q7[O<<KzO7eQ7[O'#FzO9RQWO'#FyOAaQWO'#EkO!(oQ^O,5;sO!3SQWO'#GWO!3SQWO'#GWO!3SQWO'#GYO!3SQWO'#GYO!+hQ7[O7+(`O!+hQ7[O7+(`O%+SQpO1G2tO%+SQpO1G2tO!&_Q7[O,5=YO!&_Q7[O,5=Y",
        stateData: "'NQ~O'wOS'xOSTOS'yRQ~OPYOQYOSfOY!VOaqOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!rwO!uxO!y]O#t!PO$V|O%e}O%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO&S!WO&Y!XO&[!YO&^!ZO&`![O&c!]O&i!^O&o!_O&q!`O&s!aO&u!bO&w!cO(OSO(QTO(TUO([VO(j[O(yiO~OWtO~P`OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(O!dO(QTO(TUO([VO(j[O(yiO~Oa!wOp!nO!P!oO!_!yO!`!vO!a!vO!y;QO#Q!pO#R!pO#S!xO#T!pO#U!pO#X!zO#Y!zO(P!lO(QTO(TUO(`!mO(j!sO~O'y!{O~OP]XR]X[]Xa]Xo]X}]X!P]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X'u]X([]X(m]X(t]X(u]X~O!d%PX~P(qO_!}O(Q#PO(R!}O(S#PO~O_#QO(S#PO(T#PO(U#QO~Ou#SO!R#TO(]#TO(^#VO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(O;UO(QTO(TUO([VO(j[O(yiO~O!X#ZO!Y#WO!V(cP!V(qP~P+}O!Z#cO~P`OPYOQYOSfOd!jOe!iOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(QTO(TUO([VO(j[O(yiO~Om#mO!X#iO!y]O#f#lO#g#iO(O;VO!h(nP~P.iO!i#oO(O#nO~O!u#sO!y]O%e#tO~O#h#uO~O!d#vO#h#uO~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y$_O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO([VO(m$YO(t#|O(u#}O~Oa(aX'u(aX's(aX!h(aX!V(aX![(aX%f(aX!d(aX~P1qO#P$dO#]$eO$P$eOP(bXR(bX[(bXo(bX}(bX!P(bX!Y(bX!i(bX!m(bX#O(bX#k(bX#l(bX#m(bX#n(bX#o(bX#p(bX#q(bX#r(bX#s(bX#u(bX#w(bX#y(bX#z(bX([(bX(m(bX(t(bX(u(bX![(bX%f(bX~Oa(bX'u(bX's(bX!V(bX!h(bXs(bX!d(bX~P4UO#]$eO~O$[$hO$^$gO$e$mO~OSfO![$nO$h$oO$j$qO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(O$sO(QTO(TUO([$uO(t$}O(u%POg(XP~O!i%cO~O!P%fO![%gO(O%eO~O!d%kO~Oa%lO'u%lO~O}%pO~P%[O(P!lO~P%[O%k%tO~P%[Oh%VO!i%cO(O%eO(P!lO~Oe%{O!i%cO(O%eO~O#s$RO~O}&QO![%}O!i&PO%g&TO(O%eO(P!lO(QTO(TUO`)SP~O!u#sO~O%p&VO!P)OX![)OX(O)OX~O(O&WO~O!r&]O#t!PO%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO~Od&bOe&aO!u&_O%e&`O%x&^O~P;|Od&eOeyO![&dO!r&]O!uxO!y]O#t!PO%e}O%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO~Ob&hO#]&kO%g&fO(P!lO~P=RO!i&lO!r&pO~O!i#oO~O![XO~Oa%lO't&xO'u%lO~Oa%lO't&{O'u%lO~Oa%lO't&}O'u%lO~O's]X!V]Xs]X!h]X&W]X![]X%f]X!d]X~P(qO!_'[O!`'TO!a'TO(P!lO(QTO(TUO~Op'RO!P'QO!X'UO(`'PO!Z(dP!Z(sP~P@YOk'_O![']O(O%eO~Oe'dO!i%cO(O%eO~O}&QO!i&PO~Op!nO!P!oO!y;QO#Q!pO#R!pO#T!pO#U!pO(P!lO(QTO(TUO(`!mO(j!sO~O!_'jO!`'iO!a'iO#S!pO#X'kO#Y'kO~PAtOa%lOh%VO!d#vO!i%cO'u%lO(m'mO~O!m'qO#]'oO~PCSOp!nO!P!oO(QTO(TUO(`!mO(j!sO~O![XOp(hX!P(hX!_(hX!`(hX!a(hX!y(hX#Q(hX#R(hX#S(hX#T(hX#U(hX#X(hX#Y(hX(P(hX(Q(hX(T(hX(`(hX(j(hX~O!`'iO!a'iO(P!lO~PCrO'z'uO'{'uO'|'wO~O_!}O(Q'yO(R!}O(S'yO~O_#QO(S'yO(T'yO(U#QO~Ou#SO!R#TO(]#TO(^'}O~O!X(PO!V'SX!V'YX!Y'SX!Y'YX~P+}O!Y(RO!V(cX~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y(RO!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO([VO(m$YO(t#|O(u#}O~O!V(cX~PGfO!V(WO~O!V(pX!Y(pX!d(pX!h(pX(m(pX~O#](pX#h#aX!Z(pX~PIiO#](XO!V(rX!Y(rX~O!Y(YO!V(qX~O!V(]O~O#]$eO~PIiO!Z(^O~P`OR#zO}#yO!P#{O!i#xO([VOP!ka[!kao!ka!Y!ka!m!ka#O!ka#k!ka#l!ka#m!ka#n!ka#o!ka#p!ka#q!ka#r!ka#s!ka#u!ka#w!ka#y!ka#z!ka(m!ka(t!ka(u!ka~Oa!ka'u!ka's!ka!V!ka!h!kas!ka![!ka%f!ka!d!ka~PKPO!h(_O~O!d#vO#](`O(m'mO!Y(oXa(oX'u(oX~O!h(oX~PMlO!P%fO![%gO!y]O#f(eO#g(dO(O%eO~O!Y(fO!h(nX~O!h(hO~O!P%fO![%gO#g(dO(O%eO~OP(bXR(bX[(bXo(bX}(bX!P(bX!Y(bX!i(bX!m(bX#O(bX#k(bX#l(bX#m(bX#n(bX#o(bX#p(bX#q(bX#r(bX#s(bX#u(bX#w(bX#y(bX#z(bX([(bX(m(bX(t(bX(u(bX~O!d#vO!h(bX~P! YOR(jO}(iO!i#xO#P$dO!y!xa!P!xa~O!u!xa%e!xa![!xa#f!xa#g!xa(O!xa~P!#ZO!u(nO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(O!dO(QTO(TUO([VO(j[O(yiO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;nO!P${O![$|O!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(O(rO(QTO(TUO([$uO(t$}O(u%PO~O#h(tO~O!X(vO!h(fP~P%[O(`(xO(j[O~O!P(zO!i#xO(`(xO(j[O~OP;POQ;POSfOd<zOe!iOmkOo;POpkOqkOwkOy;PO{;PO!PWO!TkO!UkO![!eO!f;SO!iZO!l;PO!m;PO!n;PO!p;TO!r;WO!u!hO$V!kO(O)XO(QTO(TUO([VO(j[O(y<xO~O!Y$_Oa$oa'u$oa's$oa!h$oa!V$oa![$oa%f$oa!d$oa~O#t)`O~P!&_Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(O(rO(QTO(TUO([$uO(t$}O(u%PO~Og(kP~P!+hO})eO!d)dO![$]X$Y$]X$[$]X$^$]X$e$]X~O!d)dO![(vX$Y(vX$[(vX$^(vX$e(vX~O})eO~P!-qO})eO![(vX$Y(vX$[(vX$^(vX$e(vX~O![)gO$Y)kO$[)fO$^)fO$e)lO~O!X)oO~P!(oO$[$hO$^$gO$e)sO~Ok$xX}$xX!P$xX#P$xX(t$xX(u$xX~OgjXg$xXkjX!YjX#]jX~P!/gOu)uO(])vO(^)xO~Ok*RO})zO!P){O(t$}O(u%PO~Og)yO~P!0kOg*SO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;nO!P*UO![*VO!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(QTO(TUO([$uO(t$}O(u%PO~O!X*YO(O*TO!h(zP~P!1YO#h*[O~O!i*]O~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;nO!P${O![$|O!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(O*_O(QTO(TUO([$uO(t$}O(u%PO~O!X*bO!V({P~P!3XOo*nO!P*fO!_*lO!`*eO!a*eO!i*]O#X*mO%]*hO(P!lO(`!mO~O!Z*kO~P!4|O#P$dOk(ZX}(ZX!P(ZX(t(ZX(u(ZX!Y(ZX#](ZX~Og(ZX#}(ZX~P!5uOk*sO#]*rOg(YX!Y(YX~O!Y*tOg(XX~O(O&WOg(XP~Op*wO~O!i*|O~O(O(rO~Om+QO!P%fO!X#iO![%gO!y]O#f#lO#g#iO(O%eO!h(nP~O!d#vO#h+RO~O!P%fO!X+TO!Y(YO![%gO(O%eO!V(qP~Op'XO!P+VO!X+UO(QTO(TUO(`(xO~O!Z(sP~P!8uO!Y+WOa)PX'u)PX~OP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO([VO(m$YO(t#|O(u#}O~Oa!ga!Y!ga'u!ga's!ga!V!ga!h!gas!ga![!ga%f!ga!d!ga~P!9mOR#zO}#yO!P#{O!i#xO([VOP!oa[!oao!oa!Y!oa!m!oa#O!oa#k!oa#l!oa#m!oa#n!oa#o!oa#p!oa#q!oa#r!oa#s!oa#u!oa#w!oa#y!oa#z!oa(m!oa(t!oa(u!oa~Oa!oa'u!oa's!oa!V!oa!h!oas!oa![!oa%f!oa!d!oa~P!<TOR#zO}#yO!P#{O!i#xO([VOP!qa[!qao!qa!Y!qa!m!qa#O!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#s!qa#u!qa#w!qa#y!qa#z!qa(m!qa(t!qa(u!qa~Oa!qa'u!qa's!qa!V!qa!h!qas!qa![!qa%f!qa!d!qa~P!>kOh%VOk+aO![']O%f+`O~O!d+cOa(WX![(WX'u(WX!Y(WX~Oa%lO![XO'u%lO~Oh%VO!i%cO~Oh%VO!i%cO(O%eO~O!d#vO#h(tO~Ob+nO%g+oO(O+kO(QTO(TUO!Z)TP~O!Y+pO`)SX~O[+tO~O`+uO~O![%}O(O%eO(P!lO`)SP~Oh%VO#]+zO~Oh%VOk+}O![$|O~O![,PO~O},RO![XO~O%k%tO~O!u,WO~Oe,]O~Ob,^O(O#nO(QTO(TUO!Z)RP~Oe%{O~O%g!QO(O&WO~P=RO[,cO`,bO~OPYOQYOSfOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO!fuO!iZO!lYO!mYO!nYO!pvO!uxO!y]O%e}O(QTO(TUO([VO(j[O(yiO~O![!eO!r!gO$V!kO(O!dO~P!EkO`,bOa%lO'u%lO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!u!hO$V!kO(O!dO(QTO(TUO([VO(j[O(yiO~Oa,hO!rwO#t!OO%i!OO%j!OO%k!OO~P!HTO!i&lO~O&Y,nO~O![,pO~O&k,rO&m,sOP&haQ&haS&haY&haa&had&hae&ham&hao&hap&haq&haw&hay&ha{&ha!P&ha!T&ha!U&ha![&ha!f&ha!i&ha!l&ha!m&ha!n&ha!p&ha!r&ha!u&ha!y&ha#t&ha$V&ha%e&ha%g&ha%i&ha%j&ha%k&ha%n&ha%p&ha%s&ha%t&ha%v&ha&S&ha&Y&ha&[&ha&^&ha&`&ha&c&ha&i&ha&o&ha&q&ha&s&ha&u&ha&w&ha's&ha(O&ha(Q&ha(T&ha([&ha(j&ha(y&ha!Z&ha&a&hab&ha&f&ha~O(O,xO~Oh!bX!Y!OX!Z!OX!d!OX!d!bX!i!bX#]!OX~O!Y!bX!Z!bX~P# ZO!d,}O#],|Oh(eX!Y#eX!Y(eX!Z#eX!Z(eX!d(eX!i(eX~Oh%VO!d-PO!i%cO!Y!^X!Z!^X~Op!nO!P!oO(QTO(TUO(`!mO~OP;POQ;POSfOd<zOe!iOmkOo;POpkOqkOwkOy;PO{;PO!PWO!TkO!UkO![!eO!f;SO!iZO!l;PO!m;PO!n;PO!p;TO!r;WO!u!hO$V!kO(QTO(TUO([VO(j[O(y<xO~O(O;zO~P##_O!Y-TO!Z(dX~O!Z-VO~O!d,}O#],|O!Y#eX!Z#eX~O!Y-WO!Z(sX~O!Z-YO~O!`-ZO!a-ZO(P!lO~P#!|O!Z-^O~P'_Ok-aO![']O~O!V-fO~Op!xa!_!xa!`!xa!a!xa#Q!xa#R!xa#S!xa#T!xa#U!xa#X!xa#Y!xa(P!xa(Q!xa(T!xa(`!xa(j!xa~P!#ZO!m-kO#]-iO~PCSO!`-mO!a-mO(P!lO~PCrOa%lO#]-iO'u%lO~Oa%lO!d#vO#]-iO'u%lO~Oa%lO!d#vO!m-kO#]-iO'u%lO(m'mO~O'z'uO'{'uO'|-rO~Os-sO~O!V'Sa!Y'Sa~P!9mO!X-wO!V'SX!Y'SX~P%[O!Y(RO!V(ca~O!V(ca~PGfO!Y(YO!V(qa~O!P%fO!X-{O![%gO(O%eO!V'YX!Y'YX~O#]-}O!Y(oa!h(oaa(oa'u(oa~O!d#vO~P#+eO!Y(fO!h(na~O!P%fO![%gO#g.RO(O%eO~Om.WO!P%fO!X.TO![%gO!y]O#f.VO#g.TO(O%eO!Y']X!h']X~OR.[O!i#xO~Oh%VOk._O![']O%f.^O~Oa#`i!Y#`i'u#`i's#`i!V#`i!h#`is#`i![#`i%f#`i!d#`i~P!9mOk=UO})zO!P){O(t$}O(u%PO~O#h#[aa#[a#]#[a'u#[a!Y#[a!h#[a![#[a!V#[a~P#.aO#h(ZXP(ZXR(ZX[(ZXa(ZXo(ZX!i(ZX!m(ZX#O(ZX#k(ZX#l(ZX#m(ZX#n(ZX#o(ZX#p(ZX#q(ZX#r(ZX#s(ZX#u(ZX#w(ZX#y(ZX#z(ZX'u(ZX([(ZX(m(ZX!h(ZX!V(ZX's(ZXs(ZX![(ZX%f(ZX!d(ZX~P!5uO!Y.lO!h(fX~P!9mO!h.oO~O!V.qO~OP$[OR#zO}#yO!P#{O!i#xO!m$[O([VO[#jia#jio#ji!Y#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'u#ji(m#ji(t#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#k#ji~P#1|O#k$OO~P#1|OP$[OR#zOo$aO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO([VO[#jia#ji!Y#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'u#ji(m#ji(t#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#o#ji~P#4kO#o$QO~P#4kOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO([VOa#ji!Y#ji#w#ji#y#ji#z#ji'u#ji(m#ji(t#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#u#ji~P#7YOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO([VO(u#}Oa#ji!Y#ji#y#ji#z#ji'u#ji(m#ji(t#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#w$UO~P#9pO#w#ji~P#9pO#u$SO~P#7YOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO([VO(t#|O(u#}Oa#ji!Y#ji#z#ji'u#ji(m#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#y#ji~P#<fO#y$WO~P#<fOP]XR]X[]Xo]X}]X!P]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X([]X(m]X(t]X(u]X!Y]X!Z]X~O#}]X~P#?TOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O#u;^O#w;`O#y;bO#z;cO([VO(m$YO(t#|O(u#}O~O#}.sO~P#AbO#P$dO#];iO$P;iO#}(bX!Z(bX~P! YOa'`a!Y'`a'u'`a's'`a!h'`a!V'`as'`a!['`a%f'`a!d'`a~P!9mO[#jia#jio#ji!Y#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'u#ji(m#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO([VO(t#ji(u#ji~P#DdOk=UO})zO!P){O(t$}O(u%POP#jiR#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji([#ji~P#DdO!Y.wOg(kX~P!0kOg.yO~Oa$Oi!Y$Oi'u$Oi's$Oi!V$Oi!h$Ois$Oi![$Oi%f$Oi!d$Oi~P!9mO$[.zO$^.zO~O$[.{O$^.{O~O!d)dO#].|O![$bX$Y$bX$[$bX$^$bX$e$bX~O!X.}O~O![)gO$Y/PO$[)fO$^)fO$e/QO~O!Y;dO!Z(aX~P#AbO!Z/RO~O!d)dO$e(vX~O$e/TO~Ou)uO(])vO(^/WO~O!V/[O~P!&_O(t$}Ok%^a}%^a!P%^a(u%^a!Y%^a#]%^a~Og%^a#}%^a~P#K^O(u%POk%`a}%`a!P%`a(t%`a!Y%`a#]%`a~Og%`a#}%`a~P#LPO!YfX!dfX!hfX!h$xX(mfX~P!/gO!X/eO!Y(YO(O/dO!V(qP!V({P~P!1YOo*nO!_*lO!`*eO!a*eO!i*]O#X*mO%]*hO(P!lO~Op'XO!P/fO!X+UO!Z*kO(QTO(TUO(`;wO!Z(sP~P#MjO!h/gO~P#.aO!Y/hO!d#vO(m'mO!h(zX~O!h/mO~O!P%fO!X*YO![%gO(O%eO!h(zP~O#h/oO~O!V$xX!Y$xX!d%PX~P!/gO!Y/pO!V({X~P#.aO!d/rO~O!V/tO~Oh%VOo/xO!d#vO!i%cO(m'mO~O(O/zO~O!d+cO~Oa%lO!Y0OO'u%lO~O!Z0QO~P!4|O!`0RO!a0RO(P!lO(`!mO~O!P0TO(`!mO~O#X0UO~Og%^a!Y%^a#]%^a#}%^a~P!0kOg%`a!Y%`a#]%`a#}%`a~P!0kO(O&WOg'iX!Y'iX~O!Y*tOg(Xa~Og0_O~OR0`O}0`O!P0aO#P$dOkza(tza(uza!Yza#]za~Ogza#}za~P$%]O})zO!P){Ok$qa(t$qa(u$qa!Y$qa#]$qa~Og$qa#}$qa~P$&UO})zO!P){Ok$sa(t$sa(u$sa!Y$sa#]$sa~Og$sa#}$sa~P$&wO#h0dO~Og%Ra!Y%Ra#]%Ra#}%Ra~P!0kO!d#vO~O#h0gO~O!Y+WOa)Pa'u)Pa~OR#zO}#yO!P#{O!i#xO([VOP!oi[!oio!oi!Y!oi!m!oi#O!oi#k!oi#l!oi#m!oi#n!oi#o!oi#p!oi#q!oi#r!oi#s!oi#u!oi#w!oi#y!oi#z!oi(m!oi(t!oi(u!oi~Oa!oi'u!oi's!oi!V!oi!h!ois!oi![!oi%f!oi!d!oi~P$(fOh%VOo%XOp$tOq$tOw%YOy%ZO{;nO!P${O![$|O!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(QTO(TUO([$uO(t$}O(u%PO~Om0pO(O0oO~P$*|O!d+cOa(Wa![(Wa'u(Wa!Y(Wa~O#h0vO~O[]X!YfX!ZfX~O!Y0wO!Z)TX~O!Z0yO~O[0zO~Ob0|O(O+kO(QTO(TUO~O![%}O(O%eO`'qX!Y'qX~O!Y+pO`)Sa~O!h1PO~P!9mO[1SO~O`1TO~O#]1WO~Ok1ZO![$|O~O(`(xO!Z)QP~Oh%VOk1dO![1aO%f1cO~O[1nO!Y1lO!Z)RX~O!Z1oO~O`1qOa%lO'u%lO~O(O#nO(QTO(TUO~O#P$dO#]$eO$P$eOP(bXR(bX[(bXo(bX}(bX!P(bX!Y(bX!i(bX!m(bX#O(bX#k(bX#l(bX#m(bX#n(bX#o(bX#p(bX#q(bX#r(bX#u(bX#w(bX#y(bX#z(bX([(bX(m(bX(t(bX(u(bX~O#s1tO&W1uOa(bX~P$0dO#]$eO#s1tO&W1uO~Oa1wO~P%[Oa1yO~O&a1|OP&_iQ&_iS&_iY&_ia&_id&_ie&_im&_io&_ip&_iq&_iw&_iy&_i{&_i!P&_i!T&_i!U&_i![&_i!f&_i!i&_i!l&_i!m&_i!n&_i!p&_i!r&_i!u&_i!y&_i#t&_i$V&_i%e&_i%g&_i%i&_i%j&_i%k&_i%n&_i%p&_i%s&_i%t&_i%v&_i&S&_i&Y&_i&[&_i&^&_i&`&_i&c&_i&i&_i&o&_i&q&_i&s&_i&u&_i&w&_i's&_i(O&_i(Q&_i(T&_i([&_i(j&_i(y&_i!Z&_ib&_i&f&_i~Ob2SO!Z2QO&f2RO~P`O![XO!i2UO~O&m,sOP&hiQ&hiS&hiY&hia&hid&hie&him&hio&hip&hiq&hiw&hiy&hi{&hi!P&hi!T&hi!U&hi![&hi!f&hi!i&hi!l&hi!m&hi!n&hi!p&hi!r&hi!u&hi!y&hi#t&hi$V&hi%e&hi%g&hi%i&hi%j&hi%k&hi%n&hi%p&hi%s&hi%t&hi%v&hi&S&hi&Y&hi&[&hi&^&hi&`&hi&c&hi&i&hi&o&hi&q&hi&s&hi&u&hi&w&hi's&hi(O&hi(Q&hi(T&hi([&hi(j&hi(y&hi!Z&hi&a&hib&hi&f&hi~O!V2[O~O!Y!^a!Z!^a~P#AbOp!nO!P!oO!X2bO(`!mO!Y'TX!Z'TX~P@YO!Y-TO!Z(da~O!Y'ZX!Z'ZX~P!8uO!Y-WO!Z(sa~O!Z2iO~P'_Oa%lO#]2rO'u%lO~Oa%lO!d#vO#]2rO'u%lO~Oa%lO!d#vO!m2vO#]2rO'u%lO(m'mO~Oa%lO'u%lO~P!9mO!Y$_Os$oa~O!V'Si!Y'Si~P!9mO!Y(RO!V(ci~O!Y(YO!V(qi~O!V(ri!Y(ri~P!9mO!Y(oi!h(oia(oi'u(oi~P!9mO#]2xO!Y(oi!h(oia(oi'u(oi~O!Y(fO!h(ni~O!P%fO![%gO!y]O#f2}O#g2|O(O%eO~O!P%fO![%gO#g2|O(O%eO~Ok3UO![']O%f3TO~Oh%VOk3UO![']O%f3TO~O#h%^aP%^aR%^a[%^aa%^ao%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'u%^a([%^a(m%^a!h%^a!V%^a's%^as%^a![%^a%f%^a!d%^a~P#K^O#h%`aP%`aR%`a[%`aa%`ao%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'u%`a([%`a(m%`a!h%`a!V%`a's%`as%`a![%`a%f%`a!d%`a~P#LPO#h%^aP%^aR%^a[%^aa%^ao%^a!Y%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'u%^a([%^a(m%^a!h%^a!V%^a's%^a#]%^as%^a![%^a%f%^a!d%^a~P#.aO#h%`aP%`aR%`a[%`aa%`ao%`a!Y%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'u%`a([%`a(m%`a!h%`a!V%`a's%`a#]%`as%`a![%`a%f%`a!d%`a~P#.aO#hzaPza[zaazaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza'uza([za(mza!hza!Vza'szasza![za%fza!dza~P$%]O#h$qaP$qaR$qa[$qaa$qao$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa'u$qa([$qa(m$qa!h$qa!V$qa's$qas$qa![$qa%f$qa!d$qa~P$&UO#h$saP$saR$sa[$saa$sao$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa'u$sa([$sa(m$sa!h$sa!V$sa's$sas$sa![$sa%f$sa!d$sa~P$&wO#h%RaP%RaR%Ra[%Raa%Rao%Ra!Y%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra'u%Ra([%Ra(m%Ra!h%Ra!V%Ra's%Ra#]%Ras%Ra![%Ra%f%Ra!d%Ra~P#.aOa#`q!Y#`q'u#`q's#`q!V#`q!h#`qs#`q![#`q%f#`q!d#`q~P!9mO!X3^O!Y'UX!h'UX~P%[O!Y.lO!h(fa~O!Y.lO!h(fa~P!9mO!V3aO~O#}!ka!Z!ka~PKPO#}!ga!Y!ga!Z!ga~P#AbO#}!oa!Z!oa~P!<TO#}!qa!Z!qa~P!>kOg'XX!Y'XX~P!+hO!Y.wOg(ka~OSfO![3uO$c3vO~O!Z3zO~Os3{O~P#.aOa$lq!Y$lq'u$lq's$lq!V$lq!h$lqs$lq![$lq%f$lq!d$lq~P!9mO!V3|O~P#.aO})zO!P){O(u%POk'ea(t'ea!Y'ea#]'ea~Og'ea#}'ea~P%)nO})zO!P){Ok'ga(t'ga(u'ga!Y'ga#]'ga~Og'ga#}'ga~P%*aO(m$YO~P#.aO!VfX!V$xX!YfX!Y$xX!d%PX#]fX~P!/gO(O<QO~P!1YOmkO(O4OO~P.iO!P%fO!X4QO![%gO(O%eO!Y'aX!h'aX~O!Y/hO!h(za~O!Y/hO!d#vO!h(za~O!Y/hO!d#vO(m'mO!h(za~Og$zi!Y$zi#]$zi#}$zi~P!0kO!X4YO!V'cX!Y'cX~P!3XO!Y/pO!V({a~O!Y/pO!V({a~P#.aO!d#vO#s4bO~Oo4eO!d#vO(m'mO~O!P4hO(`!mO~O(t$}Ok%^i}%^i!P%^i(u%^i!Y%^i#]%^i~Og%^i#}%^i~P%.wO(u%POk%`i}%`i!P%`i(t%`i!Y%`i#]%`i~Og%`i#}%`i~P%/jOg(Yi!Y(Yi~P!0kO#]4mOg(Yi!Y(Yi~P!0kO!h4pO~Oa$mq!Y$mq'u$mq's$mq!V$mq!h$mqs$mq![$mq%f$mq!d$mq~P!9mO!V4tO~O!Y4uO![(|X~P#.aOa$xX![$xX%Z]X'u$xX!Y$xX~P!/gO%Z4xOalXklX}lX!PlX![lX'ulX(tlX(ulX!YlX~O%Z4xO~Ob5OO%g5PO(O+kO(QTO(TUO!Y'pX!Z'pX~O!Y0wO!Z)Ta~O[5TO~O`5UO~Oa%lO'u%lO~P#.aO![$|O~P#.aO!Y5^O#]5`O!Z)QX~O!Z5aO~Oo5hOp!nO!P5bO!_!yO!`!vO!a!vO!y;QO#Q!pO#R!pO#S!pO#T!pO#U!pO#X5gO#Y!zO(P!lO(QTO(TUO(`!mO(j!sO~O!Z5fO~P%4tOk5mO![1aO%f5lO~Oh%VOk5mO![1aO%f5lO~Ob5tO(O#nO(QTO(TUO!Y'oX!Z'oX~O!Y1lO!Z)Ra~O(QTO(TUO(`5vO~O`5zO~O#s5}O&W6OO~PMlO!h6PO~P%[Oa6RO~Oa6RO~P%[Ob2SO!Z6WO&f2RO~P`O!d6YO~O!d6[Oh(ei!Y(ei!Z(ei!d(ei!i(ei~O!Y#ei!Z#ei~P#AbO#]6]O!Y#ei!Z#ei~O!Y!^i!Z!^i~P#AbOa%lO#]6fO'u%lO~Oa%lO!d#vO#]6fO'u%lO~O!Y(oq!h(oqa(oq'u(oq~P!9mO!Y(fO!h(nq~O!P%fO![%gO#g6mO(O%eO~O![']O%f6pO~Ok6tO![']O%f6pO~O#h'eaP'eaR'ea['eaa'eao'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea'u'ea(['ea(m'ea!h'ea!V'ea's'eas'ea!['ea%f'ea!d'ea~P%)nO#h'gaP'gaR'ga['gaa'gao'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga'u'ga(['ga(m'ga!h'ga!V'ga's'gas'ga!['ga%f'ga!d'ga~P%*aO#h$ziP$ziR$zi[$zia$zio$zi!Y$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi'u$zi([$zi(m$zi!h$zi!V$zi's$zi#]$zis$zi![$zi%f$zi!d$zi~P#.aO#h%^iP%^iR%^i[%^ia%^io%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i'u%^i([%^i(m%^i!h%^i!V%^i's%^is%^i![%^i%f%^i!d%^i~P%.wO#h%`iP%`iR%`i[%`ia%`io%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i'u%`i([%`i(m%`i!h%`i!V%`i's%`is%`i![%`i%f%`i!d%`i~P%/jO!Y'Ua!h'Ua~P!9mO!Y.lO!h(fi~O#}#`i!Y#`i!Z#`i~P#AbOP$[OR#zO}#yO!P#{O!i#xO!m$[O([VO[#jio#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(m#ji(t#ji(u#ji!Y#ji!Z#ji~O#k#ji~P%G^O#k;YO~P%G^OP$[OR#zOo;fO}#yO!P#{O!i#xO!m$[O#k;YO#l;ZO#m;ZO#n;ZO([VO[#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(m#ji(t#ji(u#ji!Y#ji!Z#ji~O#o#ji~P%IfO#o;[O~P%IfOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O([VO#w#ji#y#ji#z#ji#}#ji(m#ji(t#ji(u#ji!Y#ji!Z#ji~O#u#ji~P%KnOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O#u;^O([VO(u#}O#y#ji#z#ji#}#ji(m#ji(t#ji!Y#ji!Z#ji~O#w;`O~P%MoO#w#ji~P%MoO#u;^O~P%KnOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O#u;^O#w;`O([VO(t#|O(u#}O#z#ji#}#ji(m#ji!Y#ji!Z#ji~O#y#ji~P&!OO#y;bO~P&!OOa#{y!Y#{y'u#{y's#{y!V#{y!h#{ys#{y![#{y%f#{y!d#{y~P!9mO[#jio#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(m#ji!Y#ji!Z#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k;YO#l;ZO#m;ZO#n;ZO([VO(t#ji(u#ji~P&$zOk=VO})zO!P){O(t$}O(u%POP#jiR#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji([#ji~P&$zO#P$dOP(ZXR(ZX[(ZXk(ZXo(ZX}(ZX!P(ZX!i(ZX!m(ZX#O(ZX#k(ZX#l(ZX#m(ZX#n(ZX#o(ZX#p(ZX#q(ZX#r(ZX#s(ZX#u(ZX#w(ZX#y(ZX#z(ZX#}(ZX([(ZX(m(ZX(t(ZX(u(ZX!Y(ZX!Z(ZX~O#}$Oi!Y$Oi!Z$Oi~P#AbO#}!oi!Z!oi~P$(fOg'Xa!Y'Xa~P!0kO!Z7WO~O!Y'`a!Z'`a~P#AbOP]XR]X[]Xo]X}]X!P]X!V]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X([]X(m]X(t]X(u]X~O!d%WX#s%WX~P&+QO!d#vO(m'mO!Y'aa!h'aa~O!Y/hO!h(zi~O!Y/hO!d#vO!h(zi~Og$zq!Y$zq#]$zq#}$zq~P!0kO!V'ca!Y'ca~P#.aO!d7_O~O!Y/pO!V({i~P#.aO!Y/pO!V({i~O!V7cO~O!d#vO#s7hO~Oo7iO!d#vO(m'mO~O})zO!P){O(u%POk'fa(t'fa!Y'fa#]'fa~Og'fa#}'fa~P&/pO})zO!P){Ok'ha(t'ha(u'ha!Y'ha#]'ha~Og'ha#}'ha~P&0cO!V7lO~Og$|q!Y$|q#]$|q#}$|q~P!0kOa$my!Y$my'u$my's$my!V$my!h$mys$my![$my%f$my!d$my~P!9mO!d6[O~O!Y4uO![(|a~O![']OP$SaR$Sa[$Sao$Sa}$Sa!P$Sa!Y$Sa!i$Sa!m$Sa#O$Sa#k$Sa#l$Sa#m$Sa#n$Sa#o$Sa#p$Sa#q$Sa#r$Sa#s$Sa#u$Sa#w$Sa#y$Sa#z$Sa([$Sa(m$Sa(t$Sa(u$Sa~O%f6pO~P&2lOa#`y!Y#`y'u#`y's#`y!V#`y!h#`ys#`y![#`y%f#`y!d#`y~P!9mO[7qO~Ob7sO(O+kO(QTO(TUO~O!Y0wO!Z)Ti~O`7wO~O(`(xO!Y'lX!Z'lX~O!Y5^O!Z)Qa~O!Z8QO~P%4tOp!nO!P8RO(QTO(TUO(`!mO(j!sO~O#X8SO~O![1aO~O![1aO%f8UO~Ok8XO![1aO%f8UO~O[8^O!Y'oa!Z'oa~O!Y1lO!Z)Ri~O!h8bO~O!h8cO~O!h8fO~O!h8fO~P%[Oa8hO~O!d8iO~O!h8jO~O!Y(ri!Z(ri~P#AbOa%lO#]8rO'u%lO~O!Y(oy!h(oya(oy'u(oy~P!9mO!Y(fO!h(ny~O%f8uO~P&2lO![']O%f8uO~O#h$zqP$zqR$zq[$zqa$zqo$zq!Y$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq'u$zq([$zq(m$zq!h$zq!V$zq's$zq#]$zqs$zq![$zq%f$zq!d$zq~P#.aO#h'faP'faR'fa['faa'fao'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa'u'fa(['fa(m'fa!h'fa!V'fa's'fas'fa!['fa%f'fa!d'fa~P&/pO#h'haP'haR'ha['haa'hao'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha'u'ha(['ha(m'ha!h'ha!V'ha's'has'ha!['ha%f'ha!d'ha~P&0cO#h$|qP$|qR$|q[$|qa$|qo$|q!Y$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q'u$|q([$|q(m$|q!h$|q!V$|q's$|q#]$|qs$|q![$|q%f$|q!d$|q~P#.aO!Y'Ui!h'Ui~P!9mO#}#`q!Y#`q!Z#`q~P#AbO(t$}OP%^aR%^a[%^ao%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a#}%^a([%^a(m%^a!Y%^a!Z%^a~Ok%^a}%^a!P%^a(u%^a~P&CoO(u%POP%`aR%`a[%`ao%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a#}%`a([%`a(m%`a!Y%`a!Z%`a~Ok%`a}%`a!P%`a(t%`a~P&EsOk=VO})zO!P){O(u%PO~P&CoOk=VO})zO!P){O(t$}O~P&EsOR0`O}0`O!P0aO#P$dOPza[zakzaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza#}za([za(mza(tza(uza!Yza!Zza~O})zO!P){OP$qaR$qa[$qak$qao$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa#}$qa([$qa(m$qa(t$qa(u$qa!Y$qa!Z$qa~O})zO!P){OP$saR$sa[$sak$sao$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa#}$sa([$sa(m$sa(t$sa(u$sa!Y$sa!Z$sa~Ok=VO})zO!P){O(t$}O(u%PO~OP%RaR%Ra[%Rao%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra#}%Ra([%Ra(m%Ra!Y%Ra!Z%Ra~P&NlO#}$lq!Y$lq!Z$lq~P#AbO#}$mq!Y$mq!Z$mq~P#AbO!Z9SO~O#}9TO~P!0kO!d#vO!Y'ai!h'ai~O!d#vO(m'mO!Y'ai!h'ai~O!Y/hO!h(zq~O!V'ci!Y'ci~P#.aO!Y/pO!V({q~Oo9[O!d#vO(m'mO~O!V9]O~P#.aO!V9]O~O!d#vO#s9bO~Og(Yy!Y(Yy~P!0kO!Y'ja!['ja~P#.aOa%Yq![%Yq'u%Yq!Y%Yq~P#.aO[9dO~O!Y0wO!Z)Tq~O#]9hO!Y'la!Z'la~O!Y5^O!Z)Qi~P#AbO!P4hO~O![1aO%f9lO~O(QTO(TUO(`9qO~O!Y1lO!Z)Rq~O!h9tO~O!h9uO~O!h9vO~O!h9vO~P%[O#]9yO!Y#ey!Z#ey~O!Y#ey!Z#ey~P#AbO%f:OO~P&2lO![']O%f:OO~O#}#{y!Y#{y!Z#{y~P#AbOP$ziR$zi[$zio$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi#}$zi([$zi(m$zi!Y$zi!Z$zi~P&NlO})zO!P){O(u%POP'eaR'ea['eak'eao'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea#}'ea(['ea(m'ea(t'ea!Y'ea!Z'ea~O})zO!P){OP'gaR'ga['gak'gao'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga#}'ga(['ga(m'ga(t'ga(u'ga!Y'ga!Z'ga~O(t$}OP%^iR%^i[%^ik%^io%^i}%^i!P%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i#}%^i([%^i(m%^i(u%^i!Y%^i!Z%^i~O(u%POP%`iR%`i[%`ik%`io%`i}%`i!P%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i#}%`i([%`i(m%`i(t%`i!Y%`i!Z%`i~O#}$my!Y$my!Z$my~P#AbO#}#`y!Y#`y!Z#`y~P#AbO!d#vO!Y'aq!h'aq~O!Y/hO!h(zy~O!V'cq!Y'cq~P#.aOo:YO!d#vO(m'mO~O!V:ZO~P#.aO!V:ZO~O!Y0wO!Z)Ty~O!Y5^O!Z)Qq~O![1aO%f:cO~O!h:fO~O%f:kO~P&2lOP$zqR$zq[$zqo$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq#}$zq([$zq(m$zq!Y$zq!Z$zq~P&NlO})zO!P){O(u%POP'faR'fa['fak'fao'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa#}'fa(['fa(m'fa(t'fa!Y'fa!Z'fa~O})zO!P){OP'haR'ha['hak'hao'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha#}'ha(['ha(m'ha(t'ha(u'ha!Y'ha!Z'ha~OP$|qR$|q[$|qo$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q#}$|q([$|q(m$|q!Y$|q!Z$|q~P&NlOg%b!Z!Y%b!Z#]%b!Z#}%b!Z~P!0kOo:oO!d#vO(m'mO~O!V:pO~P#.aO!Y'lq!Z'lq~P#AbO!Y#e!Z!Z#e!Z~P#AbO#h%b!ZP%b!ZR%b!Z[%b!Za%b!Zo%b!Z!Y%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z'u%b!Z([%b!Z(m%b!Z!h%b!Z!V%b!Z's%b!Z#]%b!Zs%b!Z![%b!Z%f%b!Z!d%b!Z~P#.aOo:xO!d#vO(m'mO~OP%b!ZR%b!Z[%b!Zo%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z#}%b!Z([%b!Z(m%b!Z!Y%b!Z!Z%b!Z~P&NlOs(aX~P1qO}%pO~P!(oO(P!lO~P!(oO!VfX!YfX#]fX~P&+QOP]XR]X[]Xo]X}]X!P]X!Y]X!YfX!i]X!m]X#O]X#P]X#]]X#]fX#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X([]X(m]X(t]X(u]X~O!dfX!h]X!hfX(mfX~P'BxOP;POQ;POSfOd<zOe!iOmkOo;POpkOqkOwkOy;PO{;PO!PWO!TkO!UkO![XO!f;SO!iZO!l;PO!m;PO!n;PO!p;TO!r;WO!u!hO$V!kO(O)XO(QTO(TUO([VO(j[O(y<xO~O!Y;dO!Z$oa~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;oO!P${O![$|O!f=PO!i$xO#g;uO$V%_O$r;qO$t;sO$w%`O(O(rO(QTO(TUO([$uO(t$}O(u%PO~O#t)`O~P'GnOo!bX(m!bX~P# ZO!Z]X!ZfX~P'BxO!VfX!V$xX!YfX!Y$xX#]fX~P!/gO#h;XO~O!d#vO#h;XO~O#];iO~O#s;]O~O#];xO!Y(rX!Z(rX~O#];iO!Y(pX!Z(pX~O#h;yO~Og;{O~P!0kO#h<RO~O#h<SO~O!d#vO#h<TO~O!d#vO#h;yO~O#}<UO~P#AbO#h<VO~O#h<WO~O#h<]O~O#h<^O~O#h<_O~O#h<`O~O#}<aO~P!0kO#}<bO~P!0kO#P#Q#R#T#U#X#f#g#r(y$r$t$w%Z%e%f%g%n%p%s%t%v%x~'yT#l!U'w(P#mp#k#no}'x$['x(O$^(`~",
        goto: "$4Q)XPPPPPP)YPP)]P)nP+O/PPPPP5xPP6`PP<V?mP@QP@QPPP@QPBRP@QP@QP@QPBVPB[PByPGrPPPGvPPPPGvJxPPPKOKzPGvPGvPPNYGvPPPGvPGvP!!aGvP!%v!&{!'UP!'x!'|!'x!+YPPPPPPP!+y!&{PP!,Z!-gP!0jGvGv!0o!3z!8b!8b!<`PPP!<hGvPPPPPPPPPPP!?vP!ATPPGv!BfPGvPGvGvGvGvGvPGv!CxP!GRP!JWP!J[!Jf!Jj!JjP!GOP!Jn!JnP!MsP!MwGvGv!M}##RBV@QP@QP@Q@QP#$_@Q@Q#&j@Q#)Z@Q#+`@Q@Q#,O#.]#.]#.b#.k#.]#.wP#.]P@Q#/a@Q#3S@Q@Q5xPPP#6{PPP#7f#7fP#7fP#7|#7fPP#8SP#7yP#7y#8g#7y#9R#9X5u)]#9[)]P#9c#9c#9cP)]P)]P)]P)]PP)]P#9i#9lP#9l)]P#9pP#9sP)]P)]P)]P)]P)]P)])]PP#9y#:P#:[#:b#:h#:n#:t#;S#;Y#;d#;j#;t#;z#<[#<b#=S#=f#=l#=r#>Q#>g#@V#@e#@l#BR#Ba#C|#D[#Db#Dh#Dn#Dx#EO#EU#E`#Er#ExPPPPPPPPPP#FOPPPPPPP#Fs#Iz#KZ#Kb#KjPPP$!sP$!|$%t$,^$,a$,d$-P$-S$-Z$-cP$-i$-lP$.Y$.^$/U$0d$0i$1PPP$1U$1[$1`P$1c$1g$1k$2a$2x$3a$3e$3h$3k$3q$3t$3x$3|R!|RoqOXst!Z#d%k&o&q&r&t,k,p1|2PY!vQ']-]1a5eQ%rvQ%zyQ&R|Q&g!VS'T!e-TQ'c!iS'i!r!yU*e$|*V*jQ+i%{Q+v&TQ,[&aQ-Z'[Q-e'dQ-m'jQ0R*lQ1k,]R;v;T%QdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V,h,k,p-a-i-w-}.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3^5b5m5}6O6R6f8R8X8h8rS#q];Q!r)Z$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{U*y%[;n;oQ+n%}Q,^&dQ,e&lQ0m+aQ0q+cQ0|+oQ1s,cQ3Q._Q5O0wQ5t1lQ6r3UQ7s5PR8x6t'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{t!nQ!r!v!y!z'T'[']'i'j'k-T-Z-]-m1a5e5g$|$ti#v$b$c$d$x${%O%Q%]%^%b)u){)}*P*R*U*[*b*r*s+`+c+z+}.^.w/]/e/o/p/r0V0X0d1W1Z1c3T3}4Y4b4m4u4x5l6p7_7h8U8u9T9b9l:O:c:k;g;h;j;k;l;m;p;q;r;s;t;u;|;}<O<P<R<S<V<W<X<Y<Z<[<]<^<a<b<x=Q=R=U=VQ&U|Q'R!eU'X%g*V-WQ+n%}Q,^&dQ0c*|Q0|+oQ1R+uQ1r,bQ1s,cQ5O0wQ5X1TQ5t1lQ5w1nQ5x1qQ7s5PQ7v5UQ8a5zQ9g7wR9r8^rnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PR,`&h&x^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<z<{[#]WZ#W#Z'U(P!b%hm#h#i#l$x%c%f(Y(d(e(f*U*Y*]+T+U+W,g,}-{.R.S.T.V/e/h2U2|2}4Q6[6mQ%uxQ%yyS&O|&TQ&[!TQ'`!hQ'b!iQ(m#sS+h%z%{Q+l%}Q,V&_Q,Z&aS-d'c'dQ.a(nQ0u+iQ0{+oQ0}+pQ1Q+tQ1f,WS1j,[,]Q2n-eQ4}0wQ5R0zQ5W1SQ5s1kQ7r5PQ7u5TQ9c7qR:^9d!O$zi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=R!S%wy!i!u%y%z%{'S'b'c'd'h'r*d+h+i-Q-d-e-l/y0u2g2n2u4dQ+b%uQ+{&XQ,O&YQ,Y&aQ.`(mQ1e,VU1i,Z,[,]Q3V.aQ5n1fS5r1j1kQ8]5s#^<|#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vo<};g;h;k;m;q;s;u;}<P<S<W<Y<[<^<bW%Ti%V*t<xS&X!Q&fQ&Y!RQ&Z!SR+y&V$}%Si#v$b$c$d$x${%O%Q%]%^%b)u){)}*P*R*U*[*b*r*s+`+c+z+}.^.w/]/e/o/p/r0V0X0d1W1Z1c3T3}4Y4b4m4u4x5l6p7_7h8U8u9T9b9l:O:c:k;g;h;j;k;l;m;p;q;r;s;t;u;|;}<O<P<R<S<V<W<X<Y<Z<[<]<^<a<b<x=Q=R=U=VT)v$u)wV*y%[;n;oW'X!e%g*V-WS(y#y#zQ+]%pQ+s&QS.Y(i(jQ1[,PQ4n0`R7{5^'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{$i$^c#Y#e%o%q%s(O(U(p(u(})O)P)Q)R)S)T)U)V)W)Y)[)^)c)m+^+r-R-p-u-z-|.k.n.r.t.u.v/X0e2]2`2p2w3]3b3c3d3e3f3g3h3i3j3k3l3m3n3q3r3y4r4{6_6e6j6y6z7T7U7}8l8p8z9Q9R9{:`:g;R<oT#TV#U'PkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{Q'V!eR2c-Tv!nQ!e!r!v!y!z'T'[']'i'j'k-T-Z-]-m1a5e5gU*d$|*V*jS/y*e*lQ0S*mQ1^,RQ4d0RR4g0UnqOXst!Z#d%k&o&q&r&t,k,p1|2PQ&v!^Q's!xS(o#u;XQ+f%xQ,T&[Q,U&^Q-b'aQ-o'lS.j(t;yS0f+R<TQ0s+gQ1`,SQ2T,rQ2V,sQ2_-OQ2l-cQ2o-gS4s0g<_Q4y0tS4|0v<`Q6^2aQ6b2mQ6g2tQ7p4zQ8m6`Q8n6cQ8q6hR9x8j$d$]c#Y#e%q%s(O(U(p(u(})O)P)Q)R)S)T)U)V)W)Y)[)^)c)m+^+r-R-p-u-z-|.k.n.r.u.v/X0e2]2`2p2w3]3b3c3d3e3f3g3h3i3j3k3l3m3n3q3r3y4r4{6_6e6j6y6z7T7U7}8l8p8z9Q9R9{:`:g;R<oS(k#p'fQ({#zS+[%o.tS.Z(j(lR3O.['OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{S#q];QQ&q!XQ&r!YQ&t![Q&u!]R1{,nQ'^!hQ+_%uQ-`'`S.](m+bQ2j-_W3S.`.a0l0nQ6a2kW6n3P3R3V4wU8t6o6q6sU9}8v8w8yS:i9|:PQ:t:jR:z:uU!wQ']-]T5c1a5e!Q_OXZ`st!V!Z#d#h%c%k&f&h&o&q&r&t(f,k,p.S1|2P]!pQ!r']-]1a5eT#q];Q%[{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rS(y#y#zS.Y(i(j!s<f$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{U$fd)Z,eS(l#p'fU*q%R(s3pU0b*x.f7PQ4w0mQ6o3QQ8w6rR:P8xm!tQ!r!v!y!z']'i'j'k-]-m1a5e5gQ'q!uS(b#g1vS-k'h'tQ/k*XQ/w*dQ2v-nQ4U/lS4_/x0SQ7Z4PS7f4e4gQ9V7[Q9Z7cQ9`7iS:X9[9]S:n:Y:ZS:w:o:pR:}:xQ#wbQ'p!uS(a#g1vS(c#m+QQ+S%dQ+d%vQ+j%|U-j'h'q'tQ.O(bQ/j*XQ/v*dQ/|*gQ0r+eQ1g,XS2s-k-nQ2{.WS4T/k/lS4^/w0SQ4a/{Q4c/}Q5p1hQ6i2vQ7Y4PQ7^4US7b4_4gQ7g4fQ8Z5qS9U7Z7[Q9Y7cQ9^7fQ9a7jQ9o8[Q:V9VS:W9Z9]Q:[9`Q:e9pS:m:X:ZS:v:n:pQ:|:wQ;O:}Q<i<dQ<t<mR<u<nV!wQ']-]%[aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rS#wz!j!r<c$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{R<i<z%[bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rQ%dj!S%vy!i!u%y%z%{'S'b'c'd'h'r*d+h+i-Q-d-e-l/y0u2g2n2u4dS%|z!jQ+e%wQ,X&aW1h,Y,Z,[,]U5q1i1j1kS8[5r5sQ9p8]!r<d$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{Q<m<yR<n<z%OeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rY#bWZ#W#Z(P!b%hm#h#i#l$x%c%f(Y(d(e(f*U*Y*]+T+U+W,g,}-{.R.S.T.V/e/h2U2|2}4Q6[6mQ,f&l!p<e$Z$n)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{R<h'UU'Y!e%g*VR2e-W%QdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V,h,k,p-a-i-w-}.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3^5b5m5}6O6R6f8R8X8h8r!r)Z$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{Q,e&lQ0m+aQ3Q._Q6r3UR8x6t!b$Tc#Y%o(O(U(p(u)V)W)[)c+r-p-u-z-|.k.n/X0e2p2w3]3m4r4{6e6j6y8p9{;R!P;_)Y)m-R.t2]2`3b3k3l3q3y6_6z7T7U7}8l8z9Q9R:`:g<o!f$Vc#Y%o(O(U(p(u)S)T)V)W)[)c+r-p-u-z-|.k.n/X0e2p2w3]3m4r4{6e6j6y8p9{;R!T;a)Y)m-R.t2]2`3b3h3i3k3l3q3y6_6z7T7U7}8l8z9Q9R:`:g<o!^$Zc#Y%o(O(U(p(u)[)c+r-p-u-z-|.k.n/X0e2p2w3]3m4r4{6e6j6y8p9{;RQ3}/cz<{)Y)m-R.t2]2`3b3q3y6_6z7T7U7}8l8z9Q9R:`:g<oQ=Q=SR=R=T'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{S$oh$pR3v.|'VgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.|.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{T$kf$qQ$ifS)f$l)jR)r$qT$jf$qT)h$l)j'VhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.|.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{T$oh$pQ$rhR)q$p%[jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8r!s<y$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{#elOPXZst!Z!`!o#S#d#o#{$n%k&h&k&l&o&q&r&t&x'Q'_(z)o+V+a,h,k,p-a._.}/f0a1d1t1u1w1y1|2P2R3U3u5b5m5}6O6R6t8R8X8h!O%Ri$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=R#^(s#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=VQ*}%`Q/Y)zo3p;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<b!O$yi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=RQ*^$zU*g$|*V*jQ+O%aQ/}*h#^<k#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vn<l;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<bQ<p<|Q<q<}Q<r=OR<s=P!O%Ri$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=R#^(s#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vo3p;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<bnoOXst!Z#d%k&o&q&r&t,k,p1|2PS*a${*UQ,y&{Q,z&}R4X/p$|%Si#v$b$c$d$x${%O%Q%]%^%b)u){)}*P*R*U*[*b*r*s+`+c+z+}.^.w/]/e/o/p/r0V0X0d1W1Z1c3T3}4Y4b4m4u4x5l6p7_7h8U8u9T9b9l:O:c:k;g;h;j;k;l;m;p;q;r;s;t;u;|;}<O<P<R<S<V<W<X<Y<Z<[<]<^<a<b<x=Q=R=U=VQ+|&YQ1Y,OQ5[1XR7z5]V*i$|*V*jU*i$|*V*jT5d1a5eU/{*f/f5bS4f0T8RR7j4hQ+d%vQ/|*gQ0r+eQ1g,XQ5p1hQ8Z5qQ9o8[R:e9p!O%Oi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=Rr)}$v)a*O*p+P/n0Z0[3s4V4q7X7k:U<j<v<wS0V*o0W#^;j#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vn;k;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<b!`;|(q)_*W*`.b.e.i/U/Z/c/s0k1V1X3Y4W4[5Z5]6u6x7`7d7m7o9X9_:]:l=S=T`;}3o6{7O7S8{:Q:T:{S<X.d3ZT<Y6}9O!O%Qi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=Rv*P$v)a*Q*o+P/_/n0Z0[3s4V4i4q7X7k:U<j<v<wS0X*p0Y#^;l#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vn;m;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<b!d<O(q)_*W*`.c.d.i/U/Z/c/s0k1V1X3W3Y4W4[5Z5]6u6v6x7`7d7m7o9X9_:]:l=S=Td<P3o6|6}7S8{8|:Q:R:T:{S<Z.e3[T<[7O9PrnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PQ&c!UR,h&lrnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PR&c!UQ,Q&ZR1U+ysnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PQ1b,VS5k1e1fU8T5i5j5nS9k8V8WS:a9j9mQ:q:bR:y:rQ&j!VR,a&fR5w1nS&O|&TR0}+pQ&o!WR,k&pR,q&uT1},p2PR,u&vQ,t&vR2W,uQ'v!{R-q'vSsOtQ#dXT%ns#dQ#OTR'x#OQ#RUR'z#RQ)w$uR/V)wQ#UVR'|#UQ#XWU(S#X(T-xQ(T#YR-x(UQ-U'VR2d-UQ.m(uS3_.m3`R3`.nQ-]']R2h-]Y!rQ']-]1a5eR'g!rQ.x)aR3t.xU#_W%f*UU(Z#_([-yQ([#`R-y(VQ-X'YR2f-Xt`OXst!V!Z#d%k&f&h&o&q&r&t,k,p1|2PS#hZ%cU#r`#h.SR.S(fQ(g#jQ.P(cW.X(g.P2y6kQ2y.QR6k2zQ)j$lR/O)jQ$phR)p$pQ$`cU)]$`-t;eQ-t;RR;e)mQ/i*XW4R/i4S7]9WU4S/j/k/lS7]4T4UR9W7^$Z)|$v(q)_)a*W*`*o*p*z*{+P.d.e.g.h.i/U/Z/_/a/c/n/s0Z0[0k1V1X3W3X3Y3o3s4V4W4[4i4k4q5Z5]6u6v6w6x6}7O7Q7R7S7X7`7d7k7m7o8{8|8}9X9_:Q:R:S:T:U:]:l:{<j<v<w=S=TQ/q*`U4Z/q4]7aQ4]/sR7a4[S*j$|*VR0P*jr*O$v)a*o*p+P/n0Z0[3s4V4q7X7k:U<j<v<w!`.b(q)_*W*`.d.e.i/U/Z/c/s0k1V1X3Y4W4[5Z5]6u6x7`7d7m7o9X9_:]:l=S=TU/`*O.b6{a6{3o6}7O7S8{:Q:T:{Q0W*oQ3Z.dU4j0W3Z9OR9O6}v*Q$v)a*o*p+P/_/n0Z0[3s4V4i4q7X7k:U<j<v<w!d.c(q)_*W*`.d.e.i/U/Z/c/s0k1V1X3W3Y4W4[5Z5]6u6v6x7`7d7m7o9X9_:]:l=S=TU/b*Q.c6|e6|3o6}7O7S8{8|:Q:R:T:{Q0Y*pQ3[.eU4l0Y3[9PR9P7OQ*u%UR0^*uQ4v0kR7n4vQ+X%iR0j+XQ5_1[S7|5_9iR9i7}Q,S&[R1_,SQ5e1aR8P5eQ1m,^S5u1m8_R8_5wQ0x+lW5Q0x5S7t9eQ5S0{Q7t5RR9e7uQ+q&OR1O+qQ2P,pR6V2PYrOXst#dQ&s!ZQ+Z%kQ,j&oQ,l&qQ,m&rQ,o&tQ1z,kS1},p2PR6U1|Q%mpQ&w!_Q&z!aQ&|!bQ'O!cQ'n!uQ+Y%jQ+f%xQ+x&UQ,`&jQ,w&yW-h'h'p'q'tQ-o'lQ0O*iQ0s+gS1p,a,dQ2X,vQ2Y,yQ2Z,zQ2o-gW2q-j-k-n-pQ4y0tQ5V1RQ5Y1VQ5o1gQ5y1rQ6T1{U6d2p2s2vQ6g2tQ7p4zQ7x5XQ7y5ZQ8O5dQ8Y5pQ8`5xS8o6e6iQ8q6hQ9f7vQ9n8ZQ9s8aQ9z8pQ:_9gQ:d9oQ:h9{R:s:eQ%xyQ'a!iQ'l!uU+g%y%z%{Q-O'SU-c'b'c'dS-g'h'rQ/u*dS0t+h+iQ2a-QS2m-d-eQ2t-lQ4`/yQ4z0uQ6`2gQ6c2nQ6h2uR7e4dS$wi<xR*v%VU%Ui%V<xR0]*tQ$viS(q#v+cS)_$b$cQ)a$dQ*W$xS*`${*UQ*o%OQ*p%QQ*z%]Q*{%^Q+P%bQ.d;jQ.e;lQ.g;pQ.h;rQ.i;tQ/U)uS/Z){/]Q/_)}Q/a*PQ/c*RQ/n*[S/s*b/eQ0Z*rQ0[*sh0k+`.^1c3T5l6p8U8u9l:O:c:kQ1V+zQ1X+}Q3W;|Q3X<OQ3Y<RS3o;g;hQ3s.wQ4V/oQ4W/pQ4[/rQ4i0VQ4k0XQ4q0dQ5Z1WQ5]1ZQ6u<VQ6v<XQ6w<ZQ6x<]Q6};kQ7O;mQ7Q;qQ7R;sQ7S;uQ7X3}Q7`4YQ7d4bQ7k4mQ7m4uQ7o4xQ8{<SQ8|;}Q8}<PQ9X7_Q9_7hQ:Q<WQ:R<YQ:S<[Q:T<^Q:U9TQ:]9bQ:l<aQ:{<bQ<j<xQ<v=QQ<w=RQ=S=UR=T=VQ*x%[Q.f;nR7P;onpOXst!Z#d%k&o&q&r&t,k,p1|2PQ!fPS#fZ#oQ&y!`U'e!o5b8RQ'{#SQ(|#{Q)n$nS,d&h&kQ,i&lQ,v&xQ,{'QQ-_'_Q.p(zQ/S)oS0h+V/fQ0n+aQ1x,hQ2k-aQ3R._Q3x.}Q4o0aQ5j1dQ5{1tQ5|1uQ6Q1wQ6S1yQ6X2RQ6s3UQ7V3uQ8W5mQ8d5}Q8e6OQ8g6RQ8y6tQ9m8XR9w8h#YcOPXZst!Z!`!o#d#o#{%k&h&k&l&o&q&r&t&x'Q'_(z+V+a,h,k,p-a._/f0a1d1t1u1w1y1|2P2R3U5b5m5}6O6R6t8R8X8hQ#YWQ#eYQ%ouQ%qvS%sw!gS(O#W(RQ(U#ZQ(p#uQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)Y$ZQ)[$_Q)^$aQ)c$eW)m$n)o.}3uQ+^%rQ+r&PS-R'U2bQ-p'oS-u(P-wQ-z(XQ-|(`Q.k(tQ.n(vQ.r;PQ.t;SQ.u;TQ.v;WQ/X)yQ0e+RQ2],|Q2`-PQ2p-iQ2w-}Q3].lQ3b;XQ3c;YQ3d;ZQ3e;[Q3f;]Q3g;^Q3h;_Q3i;`Q3j;aQ3k;bQ3l;cQ3m.sQ3n;fQ3q;iQ3r;vQ3y;dQ4r0gQ4{0vQ6_;xQ6e2rQ6j2xQ6y3^Q6z;yQ7T;{Q7U<TQ7}5`Q8l6]Q8p6fQ8z<UQ9Q<_Q9R<`Q9{8rQ:`9hQ:g9yQ;R#SR<o<{R#[WR'W!el!tQ!r!v!y!z']'i'j'k-]-m1a5e5gS'S!e-TS-Q'T'[R2g-ZR(w#xQ!fQT-[']-]]!qQ!r']-]1a5eQ#p]R'f;QR)b$dY!uQ']-]1a5eQ'h!rS'r!v!yS't!z5gS-l'i'jQ-n'kR2u-mT#kZ%cS#jZ%cS%im,gU(c#h#i#lS.Q(d(eQ.U(fQ0i+WQ2z.RU2{.S.T.VS6l2|2}R8s6md#^W#W#Z%f(P(Y*U+T-{/er#gZm#h#i#l%c(d(e(f+W.R.S.T.V2|2}6mS*X$x*]Q/l*YQ1v,gQ2^,}Q4P/hQ6Z2UQ7[4QQ8k6[T<g'U+UV#aW%f*UU#`W%f*US(Q#W(YU(V#Z+T/eS-S'U+UT-v(P-{V'Z!e%g*VQ$lfR)t$qT)i$l)jR3w.|T*Z$x*]T*c${*UQ0l+`Q3P.^Q5i1cQ6q3TQ8V5lQ8v6pQ9j8UQ9|8uQ:b9lQ:j:OQ:r:cR:u:knqOXst!Z#d%k&o&q&r&t,k,p1|2PQ&i!VR,`&ftmOXst!U!V!Z#d%k&f&o&q&r&t,k,p1|2PR,g&lT%jm,gR1],PR,_&dQ&S|R+w&TR+m%}T&m!W&pT&n!W&pT2O,p2P",
        nodeNames: "⚠ ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
        maxTerm: 376,
        context: FF,
        nodeProps: [["isolate", -8, 5, 6, 14, 34, 36, 48, 50, 52, ""], ["group", -26, 9, 17, 19, 65, 204, 208, 212, 213, 215, 218, 221, 231, 233, 239, 241, 243, 245, 248, 254, 260, 262, 264, 266, 268, 270, 271, "Statement", -34, 13, 14, 29, 32, 33, 39, 48, 51, 52, 54, 59, 67, 69, 73, 77, 79, 81, 82, 107, 108, 117, 118, 135, 138, 140, 141, 142, 143, 144, 146, 147, 166, 167, 169, "Expression", -23, 28, 30, 34, 38, 40, 42, 171, 173, 175, 176, 178, 179, 180, 182, 183, 184, 186, 187, 188, 198, 200, 202, 203, "Type", -3, 85, 100, 106, "ClassItem"], ["openedBy", 23, "<", 35, "InterpolationStart", 53, "[", 57, "{", 70, "(", 159, "JSXStartCloseTag"], ["closedBy", 24, ">", 37, "InterpolationEnd", 47, "]", 58, "}", 71, ")", 164, "JSXEndTag"]],
        propSources: [WF],
        skippedNodes: [0, 5, 6, 274],
        repeatNodeCount: 37,
        tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$h&j(U!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(U!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$h&j(RpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(RpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$h&j(Rp(U!b'w0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(S#S$h&j'x0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$h&j(Rp(U!b'x0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$h&j!m),Q(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#u(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#u(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(Q':f$h&j(U!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$h&j(U!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$h&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$c`$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$c``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$c`$h&j(U!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(U!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$c`(U!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$h&j(Rp(U!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$h&j(Rp(U!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$h&j(U!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$h&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(U!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$h&j(RpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(RpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Rp(U!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$h&j(j%1l(Rp(U!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$h&j(Rp(U!b$[#t(O,2j(`$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$h&j(Rp(U!b$[#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$h&j(Rp(U!b#m(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$h&j$P(Ch(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(u+JY$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$h&j#y(Ch(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(T';W$h&j(RpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$h&j(RpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$h&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$c`$h&j(RpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(RpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$c`(RpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!i/.^$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!h!Lf$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$h&j(Rp(U!b(P%&f#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$h&j(Rp(U!b#k(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$h&j(Rp(U!bo+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!Y+Jf$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$h&j(Rp(U!b}.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_!X!L^$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$h&j(Rp(U!b#l(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$h&j(Rp(U!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$h&j(U!b!U7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$h&j!U7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$h&j!U7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!U7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!U7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$h&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$h&j(U!b!U7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(U!b!U7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(U!b!U7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(U!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$h&j(U!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$h&j(Rp!U7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$h&j(Rp!U7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Rp!U7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Rp!U7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(RpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$h&j(RpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$h&j(Rp(U!b!U7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Rp(U!b!U7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Rp(U!b!U7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Rp(U!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$h&j(Rp(U!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$h&j(Rp(U!b'y0/l!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$h&j(Rp(U!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$h&j(U!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$h&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(U!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$h&j(RpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(RpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Rp(U!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$h&j$P(Ch(Rp(U!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Y#t$h&j(Rp(U!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!d$b$h&j#})Lv(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#O-<U(Rp(U!b(y7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$j&j(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#o(Ch(Rp(U!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$P(Ch(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#p(Ch(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#]*!Y$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#h(Cl$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#p(Ch$e#|$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#p(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#o(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#o(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(m(Ct$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$h&j#z(Ch(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!y$Ip$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!P0,v$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$h&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$h&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$h&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$h&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$h&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!V#)l$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#w(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$h&j(Rp(U!b([+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$h&j(Rp(U!b(O,2j$^#t(`$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$h&j(Rp(U!b$^#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X![#Hb(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(t+JY$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z(Kd$?V_!Z(Cds`$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!n7`$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$h&j(Rp(U!b'w0/l$[#t(O,2j(`$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$h&j(Rp(U!b'x0/l$[#t(O,2j(`$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
        tokenizers: [zF, qF, ZF, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, jF, new mU("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOu~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(^~~",141,335), new mU("j~RQYZXz{^~^O'{~~aP!P!Qd~iO'|~~",25,318)],
        topRules: {
            Script: [0, 7],
            SingleExpression: [1, 272],
            SingleClassItem: [2, 273]
        },
        dialects: {
            jsx: 0,
            ts: 14725
        },
        dynamicPrecedences: {
            77: 1,
            79: 1,
            91: 1,
            167: 1,
            196: 1
        },
        specialized: [{
            term: 322,
            get: e=>XF[e] || -1
        }, {
            term: 338,
            get: e=>VF[e] || -1
        }, {
            term: 92,
            get: e=>GF[e] || -1
        }],
        tokenPrec: 14749
    })
      , KF = [LB("function ${name}(${params}) {\n\t${}\n}", {
        label: "function",
        detail: "definition",
        type: "keyword"
    }), LB("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n\t${}\n}", {
        label: "for",
        detail: "loop",
        type: "keyword"
    }), LB("for (let ${name} of ${collection}) {\n\t${}\n}", {
        label: "for",
        detail: "of loop",
        type: "keyword"
    }), LB("do {\n\t${}\n} while (${})", {
        label: "do",
        detail: "loop",
        type: "keyword"
    }), LB("while (${}) {\n\t${}\n}", {
        label: "while",
        detail: "loop",
        type: "keyword"
    }), LB("try {\n\t${}\n} catch (${error}) {\n\t${}\n}", {
        label: "try",
        detail: "/ catch block",
        type: "keyword"
    }), LB("if (${}) {\n\t${}\n}", {
        label: "if",
        detail: "block",
        type: "keyword"
    }), LB("if (${}) {\n\t${}\n} else {\n\t${}\n}", {
        label: "if",
        detail: "/ else block",
        type: "keyword"
    }), LB("class ${name} {\n\tconstructor(${params}) {\n\t\t${}\n\t}\n}", {
        label: "class",
        detail: "definition",
        type: "keyword"
    }), LB('import {${names}} from "${module}"\n${}', {
        label: "import",
        detail: "named",
        type: "keyword"
    }), LB('import ${name} from "${module}"\n${}', {
        label: "import",
        detail: "default",
        type: "keyword"
    })]
      , JF = KF.concat([LB("interface ${name} {\n\t${}\n}", {
        label: "interface",
        detail: "definition",
        type: "keyword"
    }), LB("type ${name} = ${type}", {
        label: "type",
        detail: "definition",
        type: "keyword"
    }), LB("enum ${name} {\n\t${}\n}", {
        label: "enum",
        detail: "definition",
        type: "keyword"
    })])
      , ej = new BM
      , tj = new Set(["Script", "Block", "FunctionExpression", "FunctionDeclaration", "ArrowFunction", "MethodDeclaration", "ForStatement"]);
    function nj(e) {
        return (t,n)=>{
            let r = t.node.getChild("VariableDefinition");
            return r && n(r, e),
            !0
        }
    }
    const rj = ["FunctionDeclaration"]
      , oj = {
        FunctionDeclaration: nj("function"),
        ClassDeclaration: nj("class"),
        ClassExpression: ()=>!0,
        EnumDeclaration: nj("constant"),
        TypeAliasDeclaration: nj("type"),
        NamespaceDeclaration: nj("namespace"),
        VariableDefinition(e, t) {
            e.matchContext(rj) || t(e, "variable")
        },
        TypeDefinition(e, t) {
            t(e, "type")
        },
        __proto__: null
    };
    function ij(e, t) {
        let n = ej.get(t);
        if (n)
            return n;
        let r = []
          , o = !0;
        function i(t, n) {
            let o = e.sliceString(t.from, t.to);
            r.push({
                label: o,
                type: n
            })
        }
        return t.cursor(vM.IncludeAnonymous).iterate((t=>{
            if (o)
                o = !1;
            else if (t.name) {
                let e = oj[t.name];
                if (e && e(t, i) || tj.has(t.name))
                    return !1
            } else if (t.to - t.from > 8192) {
                for (let n of ij(e, t.node))
                    r.push(n);
                return !1
            }
        }
        )),
        ej.set(t, r),
        r
    }
    const aj = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/
      , sj = ["TemplateString", "String", "RegExp", "LineComment", "BlockComment", "VariableDefinition", "TypeDefinition", "Label", "PropertyDefinition", "PropertyName", "PrivatePropertyDefinition", "PrivatePropertyName", ".", "?."];
    function lj(e) {
        let t = IL(e.state).resolveInner(e.pos, -1);
        if (sj.indexOf(t.name) > -1)
            return null;
        let n = "VariableName" == t.name || t.to - t.from < 20 && aj.test(e.state.sliceDoc(t.from, t.to));
        if (!n && !e.explicit)
            return null;
        let r = [];
        for (let o = t; o; o = o.parent)
            tj.has(o.name) && (r = r.concat(ij(e.state.doc, o)));
        return {
            options: r,
            from: n ? t.from : e.pos,
            validFor: aj
        }
    }
    const cj = $L.define({
        name: "javascript",
        parser: YF.configure({
            props: [KL.add({
                IfStatement: aQ({
                    except: /^\s*({|else\b)/
                }),
                TryStatement: aQ({
                    except: /^\s*({|catch\b|finally\b)/
                }),
                LabeledStatement: e=>e.baseIndent,
                SwitchBody: e=>{
                    let t = e.textAfter
                      , n = /^\s*\}/.test(t)
                      , r = /^\s*(case|default)\b/.test(t);
                    return e.baseIndent + (n ? 0 : r ? 1 : 2) * e.unit
                }
                ,
                Block: oQ({
                    closing: "}"
                }),
                ArrowFunction: e=>e.baseIndent + e.unit,
                "TemplateString BlockComment": ()=>null,
                "Statement Property": aQ({
                    except: /^{/
                }),
                JSXElement(e) {
                    let t = /^\s*<\//.test(e.textAfter);
                    return e.lineIndent(e.node.from) + (t ? 0 : e.unit)
                },
                JSXEscape(e) {
                    let t = /\s*\}/.test(e.textAfter);
                    return e.lineIndent(e.node.from) + (t ? 0 : e.unit)
                },
                "JSXOpenTag JSXSelfClosingTag": e=>e.column(e.node.from) + e.unit
            }), lQ.add({
                "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": cQ,
                BlockComment: e=>({
                    from: e.from + 2,
                    to: e.to - 2
                })
            })]
        }),
        languageData: {
            closeBrackets: {
                brackets: ["(", "[", "{", "'", '"', "`"]
            },
            commentTokens: {
                line: "//",
                block: {
                    open: "/*",
                    close: "*/"
                }
            },
            indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
            wordChars: "$"
        }
    })
      , uj = {
        test: e=>/^JSX/.test(e.name),
        facet: PL({
            commentTokens: {
                block: {
                    open: "{/*",
                    close: "*/}"
                }
            }
        })
    }
      , dj = cj.configure({
        dialect: "ts"
    }, "typescript")
      , pj = cj.configure({
        dialect: "jsx",
        props: [DL.add((e=>e.isTop ? [uj] : void 0))]
    })
      , hj = cj.configure({
        dialect: "jsx ts",
        props: [DL.add((e=>e.isTop ? [uj] : void 0))]
    }, "typescript");
    let fj = e=>({
        label: e,
        type: "keyword"
    });
    const mj = "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(fj)
      , gj = mj.concat(["declare", "implements", "private", "protected", "public"].map(fj));
    function bj(e={}) {
        let t = e.jsx ? e.typescript ? hj : pj : e.typescript ? dj : cj
          , n = e.typescript ? JF.concat(gj) : KF.concat(mj);
        return new HL(t,[cj.data.of({
            autocomplete: (r = sj,
            o = BQ(n),
            e=>{
                for (let t = IL(e.state).resolveInner(e.pos, -1); t; t = t.parent) {
                    if (r.indexOf(t.name) > -1)
                        return null;
                    if (t.type.isTop)
                        break
                }
                return o(e)
            }
            )
        }), cj.data.of({
            autocomplete: lj
        }), e.jsx ? yj : []]);
        var r, o
    }
    function Oj(e, t, n=e.length) {
        for (let r = null == t ? void 0 : t.firstChild; r; r = r.nextSibling)
            if ("JSXIdentifier" == r.name || "JSXBuiltin" == r.name || "JSXNamespacedName" == r.name || "JSXMemberExpression" == r.name)
                return e.sliceString(r.from, Math.min(r.to, n));
        return ""
    }
    const vj = "object" == typeof navigator && /Android\b/.test(navigator.userAgent)
      , yj = pI.inputHandler.of(((e,t,n,r,o)=>{
        if ((vj ? e.composing : e.compositionStarted) || e.state.readOnly || t != n || ">" != r && "/" != r || !cj.isActiveAt(e.state, t, -1))
            return !1;
        let i = o()
          , {state: a} = i
          , s = a.changeByRange((e=>{
            var t;
            let n, {head: o} = e, i = IL(a).resolveInner(o - 1, -1);
            if ("JSXStartTag" == i.name && (i = i.parent),
            a.doc.sliceString(o - 1, o) != r || "JSXAttributeValue" == i.name && i.to > o)
                ;
            else {
                if (">" == r && "JSXFragmentTag" == i.name)
                    return {
                        range: e,
                        changes: {
                            from: o,
                            insert: "</>"
                        }
                    };
                if ("/" == r && "JSXStartCloseTag" == i.name) {
                    let e = i.parent
                      , r = e.parent;
                    if (r && e.from == o - 2 && ((n = Oj(a.doc, r.firstChild, o)) || "JSXFragmentTag" == (null === (t = r.firstChild) || void 0 === t ? void 0 : t.name))) {
                        let e = `${n}>`;
                        return {
                            range: eP.cursor(o + e.length, -1),
                            changes: {
                                from: o,
                                insert: e
                            }
                        }
                    }
                } else if (">" == r) {
                    let t = function(e) {
                        for (; ; ) {
                            if ("JSXOpenTag" == e.name || "JSXSelfClosingTag" == e.name || "JSXFragmentTag" == e.name)
                                return e;
                            if ("JSXEscape" == e.name || !e.parent)
                                return null;
                            e = e.parent
                        }
                    }(i);
                    if (t && "JSXOpenTag" == t.name && !/^\/?>|^<\//.test(a.doc.sliceString(o, o + 2)) && (n = Oj(a.doc, t, o)))
                        return {
                            range: e,
                            changes: {
                                from: o,
                                insert: `</${n}>`
                            }
                        }
                }
            }
            return {
                range: e
            }
        }
        ));
        return !s.changes.empty && (e.dispatch([i, a.update(s, {
            userEvent: "input.complete",
            scrollIntoView: !0
        })]),
        !0)
    }
    ))
      , wj = ["_blank", "_self", "_top", "_parent"]
      , _j = ["ascii", "utf-8", "utf-16", "latin1", "latin1"]
      , kj = ["get", "post", "put", "delete"]
      , Sj = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]
      , Ej = ["true", "false"]
      , xj = {}
      , Tj = {
        a: {
            attrs: {
                href: null,
                ping: null,
                type: null,
                media: null,
                target: wj,
                hreflang: null
            }
        },
        abbr: xj,
        address: xj,
        area: {
            attrs: {
                alt: null,
                coords: null,
                href: null,
                target: null,
                ping: null,
                media: null,
                hreflang: null,
                type: null,
                shape: ["default", "rect", "circle", "poly"]
            }
        },
        article: xj,
        aside: xj,
        audio: {
            attrs: {
                src: null,
                mediagroup: null,
                crossorigin: ["anonymous", "use-credentials"],
                preload: ["none", "metadata", "auto"],
                autoplay: ["autoplay"],
                loop: ["loop"],
                controls: ["controls"]
            }
        },
        b: xj,
        base: {
            attrs: {
                href: null,
                target: wj
            }
        },
        bdi: xj,
        bdo: xj,
        blockquote: {
            attrs: {
                cite: null
            }
        },
        body: xj,
        br: xj,
        button: {
            attrs: {
                form: null,
                formaction: null,
                name: null,
                value: null,
                autofocus: ["autofocus"],
                disabled: ["autofocus"],
                formenctype: Sj,
                formmethod: kj,
                formnovalidate: ["novalidate"],
                formtarget: wj,
                type: ["submit", "reset", "button"]
            }
        },
        canvas: {
            attrs: {
                width: null,
                height: null
            }
        },
        caption: xj,
        center: xj,
        cite: xj,
        code: xj,
        col: {
            attrs: {
                span: null
            }
        },
        colgroup: {
            attrs: {
                span: null
            }
        },
        command: {
            attrs: {
                type: ["command", "checkbox", "radio"],
                label: null,
                icon: null,
                radiogroup: null,
                command: null,
                title: null,
                disabled: ["disabled"],
                checked: ["checked"]
            }
        },
        data: {
            attrs: {
                value: null
            }
        },
        datagrid: {
            attrs: {
                disabled: ["disabled"],
                multiple: ["multiple"]
            }
        },
        datalist: {
            attrs: {
                data: null
            }
        },
        dd: xj,
        del: {
            attrs: {
                cite: null,
                datetime: null
            }
        },
        details: {
            attrs: {
                open: ["open"]
            }
        },
        dfn: xj,
        div: xj,
        dl: xj,
        dt: xj,
        em: xj,
        embed: {
            attrs: {
                src: null,
                type: null,
                width: null,
                height: null
            }
        },
        eventsource: {
            attrs: {
                src: null
            }
        },
        fieldset: {
            attrs: {
                disabled: ["disabled"],
                form: null,
                name: null
            }
        },
        figcaption: xj,
        figure: xj,
        footer: xj,
        form: {
            attrs: {
                action: null,
                name: null,
                "accept-charset": _j,
                autocomplete: ["on", "off"],
                enctype: Sj,
                method: kj,
                novalidate: ["novalidate"],
                target: wj
            }
        },
        h1: xj,
        h2: xj,
        h3: xj,
        h4: xj,
        h5: xj,
        h6: xj,
        head: {
            children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
        },
        header: xj,
        hgroup: xj,
        hr: xj,
        html: {
            attrs: {
                manifest: null
            }
        },
        i: xj,
        iframe: {
            attrs: {
                src: null,
                srcdoc: null,
                name: null,
                width: null,
                height: null,
                sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
                seamless: ["seamless"]
            }
        },
        img: {
            attrs: {
                alt: null,
                src: null,
                ismap: null,
                usemap: null,
                width: null,
                height: null,
                crossorigin: ["anonymous", "use-credentials"]
            }
        },
        input: {
            attrs: {
                alt: null,
                dirname: null,
                form: null,
                formaction: null,
                height: null,
                list: null,
                max: null,
                maxlength: null,
                min: null,
                name: null,
                pattern: null,
                placeholder: null,
                size: null,
                src: null,
                step: null,
                value: null,
                width: null,
                accept: ["audio/*", "video/*", "image/*"],
                autocomplete: ["on", "off"],
                autofocus: ["autofocus"],
                checked: ["checked"],
                disabled: ["disabled"],
                formenctype: Sj,
                formmethod: kj,
                formnovalidate: ["novalidate"],
                formtarget: wj,
                multiple: ["multiple"],
                readonly: ["readonly"],
                required: ["required"],
                type: ["hidden", "text", "search", "tel", "url", "email", "password", "datetime", "date", "month", "week", "time", "datetime-local", "number", "range", "color", "checkbox", "radio", "file", "submit", "image", "reset", "button"]
            }
        },
        ins: {
            attrs: {
                cite: null,
                datetime: null
            }
        },
        kbd: xj,
        keygen: {
            attrs: {
                challenge: null,
                form: null,
                name: null,
                autofocus: ["autofocus"],
                disabled: ["disabled"],
                keytype: ["RSA"]
            }
        },
        label: {
            attrs: {
                for: null,
                form: null
            }
        },
        legend: xj,
        li: {
            attrs: {
                value: null
            }
        },
        link: {
            attrs: {
                href: null,
                type: null,
                hreflang: null,
                media: null,
                sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
            }
        },
        map: {
            attrs: {
                name: null
            }
        },
        mark: xj,
        menu: {
            attrs: {
                label: null,
                type: ["list", "context", "toolbar"]
            }
        },
        meta: {
            attrs: {
                content: null,
                charset: _j,
                name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
                "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
            }
        },
        meter: {
            attrs: {
                value: null,
                min: null,
                low: null,
                high: null,
                max: null,
                optimum: null
            }
        },
        nav: xj,
        noscript: xj,
        object: {
            attrs: {
                data: null,
                type: null,
                name: null,
                usemap: null,
                form: null,
                width: null,
                height: null,
                typemustmatch: ["typemustmatch"]
            }
        },
        ol: {
            attrs: {
                reversed: ["reversed"],
                start: null,
                type: ["1", "a", "A", "i", "I"]
            },
            children: ["li", "script", "template", "ul", "ol"]
        },
        optgroup: {
            attrs: {
                disabled: ["disabled"],
                label: null
            }
        },
        option: {
            attrs: {
                disabled: ["disabled"],
                label: null,
                selected: ["selected"],
                value: null
            }
        },
        output: {
            attrs: {
                for: null,
                form: null,
                name: null
            }
        },
        p: xj,
        param: {
            attrs: {
                name: null,
                value: null
            }
        },
        pre: xj,
        progress: {
            attrs: {
                value: null,
                max: null
            }
        },
        q: {
            attrs: {
                cite: null
            }
        },
        rp: xj,
        rt: xj,
        ruby: xj,
        samp: xj,
        script: {
            attrs: {
                type: ["text/javascript"],
                src: null,
                async: ["async"],
                defer: ["defer"],
                charset: _j
            }
        },
        section: xj,
        select: {
            attrs: {
                form: null,
                name: null,
                size: null,
                autofocus: ["autofocus"],
                disabled: ["disabled"],
                multiple: ["multiple"]
            }
        },
        slot: {
            attrs: {
                name: null
            }
        },
        small: xj,
        source: {
            attrs: {
                src: null,
                type: null,
                media: null
            }
        },
        span: xj,
        strong: xj,
        style: {
            attrs: {
                type: ["text/css"],
                media: null,
                scoped: null
            }
        },
        sub: xj,
        summary: xj,
        sup: xj,
        table: xj,
        tbody: xj,
        td: {
            attrs: {
                colspan: null,
                rowspan: null,
                headers: null
            }
        },
        template: xj,
        textarea: {
            attrs: {
                dirname: null,
                form: null,
                maxlength: null,
                name: null,
                placeholder: null,
                rows: null,
                cols: null,
                autofocus: ["autofocus"],
                disabled: ["disabled"],
                readonly: ["readonly"],
                required: ["required"],
                wrap: ["soft", "hard"]
            }
        },
        tfoot: xj,
        th: {
            attrs: {
                colspan: null,
                rowspan: null,
                headers: null,
                scope: ["row", "col", "rowgroup", "colgroup"]
            }
        },
        thead: xj,
        time: {
            attrs: {
                datetime: null
            }
        },
        title: xj,
        tr: xj,
        track: {
            attrs: {
                src: null,
                label: null,
                default: null,
                kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
                srclang: null
            }
        },
        ul: {
            children: ["li", "script", "template", "ul", "ol"]
        },
        var: xj,
        video: {
            attrs: {
                src: null,
                poster: null,
                width: null,
                height: null,
                crossorigin: ["anonymous", "use-credentials"],
                preload: ["auto", "metadata", "none"],
                autoplay: ["autoplay"],
                mediagroup: ["movie"],
                muted: ["muted"],
                controls: ["controls"]
            }
        },
        wbr: xj
    }
      , Aj = {
        accesskey: null,
        class: null,
        contenteditable: Ej,
        contextmenu: null,
        dir: ["ltr", "rtl", "auto"],
        draggable: ["true", "false", "auto"],
        dropzone: ["copy", "move", "link", "string:", "file:"],
        hidden: ["hidden"],
        id: null,
        inert: ["inert"],
        itemid: null,
        itemprop: null,
        itemref: null,
        itemscope: ["itemscope"],
        itemtype: null,
        lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
        spellcheck: Ej,
        autocorrect: Ej,
        autocapitalize: Ej,
        style: null,
        tabindex: null,
        title: null,
        translate: ["yes", "no"],
        rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
        role: "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
        "aria-activedescendant": null,
        "aria-atomic": Ej,
        "aria-autocomplete": ["inline", "list", "both", "none"],
        "aria-busy": Ej,
        "aria-checked": ["true", "false", "mixed", "undefined"],
        "aria-controls": null,
        "aria-describedby": null,
        "aria-disabled": Ej,
        "aria-dropeffect": null,
        "aria-expanded": ["true", "false", "undefined"],
        "aria-flowto": null,
        "aria-grabbed": ["true", "false", "undefined"],
        "aria-haspopup": Ej,
        "aria-hidden": Ej,
        "aria-invalid": ["true", "false", "grammar", "spelling"],
        "aria-label": null,
        "aria-labelledby": null,
        "aria-level": null,
        "aria-live": ["off", "polite", "assertive"],
        "aria-multiline": Ej,
        "aria-multiselectable": Ej,
        "aria-owns": null,
        "aria-posinset": null,
        "aria-pressed": ["true", "false", "mixed", "undefined"],
        "aria-readonly": Ej,
        "aria-relevant": null,
        "aria-required": Ej,
        "aria-selected": ["true", "false", "undefined"],
        "aria-setsize": null,
        "aria-sort": ["ascending", "descending", "none", "other"],
        "aria-valuemax": null,
        "aria-valuemin": null,
        "aria-valuenow": null,
        "aria-valuetext": null
    }
      , Cj = "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((e=>"on" + e));
    for (let Rie of Cj)
        Aj[Rie] = null;
    let Pj = class {
        constructor(e, t) {
            this.tags = Object.assign(Object.assign({}, Tj), e),
            this.globalAttrs = Object.assign(Object.assign({}, Aj), t),
            this.allTags = Object.keys(this.tags),
            this.globalAttrNames = Object.keys(this.globalAttrs)
        }
    }
    ;
    function Dj(e, t, n=e.length) {
        if (!t)
            return "";
        let r = t.firstChild
          , o = r && r.getChild("TagName");
        return o ? e.sliceString(o.from, Math.min(o.to, n)) : ""
    }
    function Rj(e, t=!1) {
        for (; e; e = e.parent)
            if ("Element" == e.name) {
                if (!t)
                    return e;
                t = !1
            }
        return null
    }
    function Nj(e, t, n) {
        let r = n.tags[Dj(e, Rj(t))];
        return (null == r ? void 0 : r.children) || n.allTags
    }
    function $j(e, t) {
        let n = [];
        for (let r = Rj(t); r && !r.type.isTop; r = Rj(r.parent)) {
            let o = Dj(e, r);
            if (o && "CloseTag" == r.lastChild.name)
                break;
            o && n.indexOf(o) < 0 && ("EndTag" == t.name || t.from >= r.firstChild.to) && n.push(o)
        }
        return n
    }
    Pj.default = new Pj;
    const Ij = /^[:\-\.\w\u00b7-\uffff]*$/;
    function Mj(e, t, n, r, o) {
        let i = /\s*>/.test(e.sliceDoc(o, o + 5)) ? "" : ">"
          , a = Rj(n, !0);
        return {
            from: r,
            to: o,
            options: Nj(e.doc, a, t).map((e=>({
                label: e,
                type: "type"
            }))).concat($j(e.doc, n).map(((e,t)=>({
                label: "/" + e,
                apply: "/" + e + i,
                type: "type",
                boost: 99 - t
            })))),
            validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
        }
    }
    function Lj(e, t, n, r) {
        let o = /\s*>/.test(e.sliceDoc(r, r + 5)) ? "" : ">";
        return {
            from: n,
            to: r,
            options: $j(e.doc, t).map(((e,t)=>({
                label: e,
                apply: e + o,
                type: "type",
                boost: 99 - t
            }))),
            validFor: Ij
        }
    }
    function Qj(e, t) {
        let {state: n, pos: r} = t
          , o = IL(n).resolveInner(r, -1)
          , i = o.resolve(r);
        for (let a, s = r; i == o && (a = o.childBefore(s)); ) {
            let e = a.lastChild;
            if (!e || !e.type.isError || e.from < e.to)
                break;
            i = o = a,
            s = e.from
        }
        return "TagName" == o.name ? o.parent && /CloseTag$/.test(o.parent.name) ? Lj(n, o, o.from, r) : Mj(n, e, o, o.from, r) : "StartTag" == o.name ? Mj(n, e, o, r, r) : "StartCloseTag" == o.name || "IncompleteCloseTag" == o.name ? Lj(n, o, r, r) : "OpenTag" == o.name || "SelfClosingTag" == o.name || "AttributeName" == o.name ? function(e, t, n, r, o) {
            let i = Rj(n)
              , a = i ? t.tags[Dj(e.doc, i)] : null
              , s = a && a.attrs ? Object.keys(a.attrs) : [];
            return {
                from: r,
                to: o,
                options: (a && !1 === a.globalAttrs ? s : s.length ? s.concat(t.globalAttrNames) : t.globalAttrNames).map((e=>({
                    label: e,
                    type: "property"
                }))),
                validFor: Ij
            }
        }(n, e, o, "AttributeName" == o.name ? o.from : r, r) : "Is" == o.name || "AttributeValue" == o.name || "UnquotedAttributeValue" == o.name ? function(e, t, n, r, o) {
            var i;
            let a, s = null === (i = n.parent) || void 0 === i ? void 0 : i.getChild("AttributeName"), l = [];
            if (s) {
                let i = e.sliceDoc(s.from, s.to)
                  , c = t.globalAttrs[i];
                if (!c) {
                    let r = Rj(n)
                      , o = r ? t.tags[Dj(e.doc, r)] : null;
                    c = (null == o ? void 0 : o.attrs) && o.attrs[i]
                }
                if (c) {
                    let t = e.sliceDoc(r, o).toLowerCase()
                      , n = '"'
                      , i = '"';
                    /^['"]/.test(t) ? (a = '"' == t[0] ? /^[^"]*$/ : /^[^']*$/,
                    n = "",
                    i = e.sliceDoc(o, o + 1) == t[0] ? "" : t[0],
                    t = t.slice(1),
                    r++) : a = /^[^\s<>='"]*$/;
                    for (let e of c)
                        l.push({
                            label: e,
                            apply: n + e + i,
                            type: "constant"
                        })
                }
            }
            return {
                from: r,
                to: o,
                options: l,
                validFor: a
            }
        }(n, e, o, "Is" == o.name ? r : o.from, r) : !t.explicit || "Element" != i.name && "Text" != i.name && "Document" != i.name ? null : function(e, t, n, r) {
            let o = []
              , i = 0;
            for (let a of Nj(e.doc, n, t))
                o.push({
                    label: "<" + a,
                    type: "type"
                });
            for (let a of $j(e.doc, n))
                o.push({
                    label: "</" + a + ">",
                    type: "type",
                    boost: 99 - i++
                });
            return {
                from: r,
                to: r,
                options: o,
                validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
            }
        }(n, e, o, r)
    }
    function Bj(e) {
        let {extraTags: t, extraGlobalAttributes: n} = e
          , r = n || t ? new Pj(t,n) : Pj.default;
        return e=>Qj(r, e)
    }
    const Uj = cj.parser.configure({
        top: "SingleExpression"
    })
      , Fj = [{
        tag: "script",
        attrs: e=>"text/typescript" == e.type || "ts" == e.lang,
        parser: dj.parser
    }, {
        tag: "script",
        attrs: e=>"text/babel" == e.type || "text/jsx" == e.type,
        parser: pj.parser
    }, {
        tag: "script",
        attrs: e=>"text/typescript-jsx" == e.type,
        parser: hj.parser
    }, {
        tag: "script",
        attrs: e=>/^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(e.type),
        parser: Uj
    }, {
        tag: "script",
        attrs: e=>!e.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(e.type),
        parser: cj.parser
    }, {
        tag: "style",
        attrs: e=>(!e.lang || "css" == e.lang) && (!e.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(e.type)),
        parser: nF.parser
    }]
      , jj = [{
        name: "style",
        parser: nF.parser.configure({
            top: "Styles"
        })
    }].concat(Cj.map((e=>({
        name: e,
        parser: cj.parser
    }))))
      , zj = $L.define({
        name: "html",
        parser: IF.configure({
            props: [KL.add({
                Element(e) {
                    let t = /^(\s*)(<\/)?/.exec(e.textAfter);
                    return e.node.to <= e.pos + t[0].length ? e.continue() : e.lineIndent(e.node.from) + (t[2] ? 0 : e.unit)
                },
                "OpenTag CloseTag SelfClosingTag": e=>e.column(e.node.from) + e.unit,
                Document(e) {
                    if (e.pos + /\s*/.exec(e.textAfter)[0].length < e.node.to)
                        return e.continue();
                    let t, n = null;
                    for (let r = e.node; ; ) {
                        let e = r.lastChild;
                        if (!e || "Element" != e.name || e.to != r.to)
                            break;
                        n = r = e
                    }
                    return n && (!(t = n.lastChild) || "CloseTag" != t.name && "SelfClosingTag" != t.name) ? e.lineIndent(n.from) + e.unit : null
                }
            }), lQ.add({
                Element(e) {
                    let t = e.firstChild
                      , n = e.lastChild;
                    return t && "OpenTag" == t.name ? {
                        from: t.to,
                        to: "CloseTag" == n.name ? n.from : e.to
                    } : null
                }
            }), EQ.add({
                "OpenTag CloseTag": e=>e.getChild("TagName")
            })]
        }),
        languageData: {
            commentTokens: {
                block: {
                    open: "\x3c!--",
                    close: "--\x3e"
                }
            },
            indentOnInput: /^\s*<\/\w+\W$/,
            wordChars: "-._"
        }
    })
      , qj = zj.configure({
        wrap: BF(Fj, jj)
    });
    const Hj = new Set("area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" "))
      , Zj = pI.inputHandler.of(((e,t,n,r,o)=>{
        if (e.composing || e.state.readOnly || t != n || ">" != r && "/" != r || !qj.isActiveAt(e.state, t, -1))
            return !1;
        let i = o()
          , {state: a} = i
          , s = a.changeByRange((e=>{
            var t, n, o;
            let i, s = a.doc.sliceString(e.from - 1, e.to) == r, {head: l} = e, c = IL(a).resolveInner(l, -1);
            if (s && ">" == r && "EndTag" == c.name) {
                let r = c.parent;
                if ("CloseTag" != (null === (n = null === (t = r.parent) || void 0 === t ? void 0 : t.lastChild) || void 0 === n ? void 0 : n.name) && (i = Dj(a.doc, r.parent, l)) && !Hj.has(i)) {
                    return {
                        range: e,
                        changes: {
                            from: l,
                            to: l + (">" === a.doc.sliceString(l, l + 1) ? 1 : 0),
                            insert: `</${i}>`
                        }
                    }
                }
            } else if (s && "/" == r && "IncompleteCloseTag" == c.name) {
                let e = c.parent;
                if (c.from == l - 2 && "CloseTag" != (null === (o = e.lastChild) || void 0 === o ? void 0 : o.name) && (i = Dj(a.doc, e, l)) && !Hj.has(i)) {
                    let e = l + (">" === a.doc.sliceString(l, l + 1) ? 1 : 0)
                      , t = `${i}>`;
                    return {
                        range: eP.cursor(l + t.length, -1),
                        changes: {
                            from: l,
                            to: e,
                            insert: t
                        }
                    }
                }
            }
            return {
                range: e
            }
        }
        ));
        return !s.changes.empty && (e.dispatch([i, a.update(s, {
            userEvent: "input.complete",
            scrollIntoView: !0
        })]),
        !0)
    }
    ))
      , Wj = aL({
        String: TL.string,
        Number: TL.number,
        "True False": TL.bool,
        PropertyName: TL.propertyName,
        Null: TL.null,
        ",": TL.separator,
        "[ ]": TL.squareBracket,
        "{ }": TL.brace
    })
      , Xj = PU.deserialize({
        version: 14,
        states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
        stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
        goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
        nodeNames: "⚠ JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
        maxTerm: 25,
        nodeProps: [["isolate", -2, 6, 11, ""], ["openedBy", 7, "{", 12, "["], ["closedBy", 8, "}", 13, "]"]],
        propSources: [Wj],
        skippedNodes: [0],
        repeatNodeCount: 2,
        tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
        tokenizers: [0],
        topRules: {
            JsonText: [0, 1]
        },
        tokenPrec: 0
    })
      , Vj = $L.define({
        name: "json",
        parser: Xj.configure({
            props: [KL.add({
                Object: aQ({
                    except: /^\s*\}/
                }),
                Array: aQ({
                    except: /^\s*\]/
                })
            }), lQ.add({
                "Object Array": cQ
            })]
        }),
        languageData: {
            closeBrackets: {
                brackets: ["[", "{", '"']
            },
            indentOnInput: /^\s*[\}\]]$/
        }
    });
    const Gj = 63;
    class Yj {
        constructor(e, t, n) {
            this.parent = e,
            this.depth = t,
            this.type = n,
            this.hash = (e ? e.hash + e.hash << 8 : 0) + t + (t << 4) + n
        }
    }
    function Kj(e, t) {
        for (let n = 0, r = t - e.pos - 1; ; r--,
        n++) {
            let t = e.peek(r);
            if (ez(t) || -1 == t)
                return n
        }
    }
    function Jj(e) {
        return 32 == e || 9 == e
    }
    function ez(e) {
        return 10 == e || 13 == e
    }
    function tz(e) {
        return Jj(e) || ez(e)
    }
    function nz(e) {
        return e < 0 || tz(e)
    }
    Yj.top = new Yj(null,-1,0);
    const rz = new CU({
        start: Yj.top,
        reduce: (e,t)=>3 != e.type || 20 != t && 34 != t ? e : e.parent,
        shift(e, t, n, r) {
            if (3 == t)
                return new Yj(e,Kj(r, r.pos),1);
            if (65 == t || 5 == t)
                return new Yj(e,Kj(r, r.pos),2);
            if (t == Gj)
                return e.parent;
            if (19 == t || 33 == t)
                return new Yj(e,0,3);
            if (13 == t && 4 == e.type)
                return e.parent;
            if (47 == t) {
                let t = /[1-9]/.exec(r.read(r.pos, n.pos));
                if (t)
                    return new Yj(e,e.depth + +t[0],4)
            }
            return e
        },
        hash: e=>e.hash
    });
    function oz(e, t, n=0) {
        return e.peek(n) == t && e.peek(n + 1) == t && e.peek(n + 2) == t && nz(e.peek(n + 3))
    }
    const iz = new gU(((e,t)=>{
        if (-1 == e.next && t.canShift(64))
            return e.acceptToken(64);
        let n = e.peek(-1);
        if ((ez(n) || n < 0) && 3 != t.context.type) {
            if (oz(e, 45)) {
                if (!t.canShift(Gj))
                    return e.acceptToken(1, 3);
                e.acceptToken(Gj)
            }
            if (oz(e, 46)) {
                if (!t.canShift(Gj))
                    return e.acceptToken(2, 3);
                e.acceptToken(Gj)
            }
            let n = 0;
            for (; 32 == e.next; )
                n++,
                e.advance();
            !(n < t.context.depth) && (n != t.context.depth || 1 != t.context.type || 45 == e.next && nz(e.peek(1))) || -1 == e.next || ez(e.next) || 35 == e.next || e.acceptToken(Gj, -n)
        }
    }
    ),{
        contextual: !0
    })
      , az = new gU(((e,t)=>{
        if (3 != t.context.type)
            if (45 == e.next)
                e.advance(),
                nz(e.next) && e.acceptToken(1 == t.context.type && t.context.depth == Kj(e, e.pos - 1) ? 4 : 3);
            else if (63 == e.next)
                e.advance(),
                nz(e.next) && e.acceptToken(2 == t.context.type && t.context.depth == Kj(e, e.pos - 1) ? 6 : 5);
            else {
                let n = e.pos;
                for (; ; )
                    if (Jj(e.next)) {
                        if (e.pos == n)
                            return;
                        e.advance()
                    } else if (33 == e.next)
                        cz(e);
                    else {
                        if (38 != e.next) {
                            if (42 == e.next) {
                                uz(e);
                                break
                            }
                            if (39 == e.next || 34 == e.next) {
                                if (dz(e, !0))
                                    break;
                                return
                            }
                            if (91 == e.next || 123 == e.next) {
                                if (!pz(e))
                                    return;
                                break
                            }
                            gz(e, !0, !1, 0);
                            break
                        }
                        uz(e)
                    }
                for (; Jj(e.next); )
                    e.advance();
                if (58 == e.next) {
                    if (e.pos == n && t.canShift(29))
                        return;
                    nz(e.peek(1)) && e.acceptTokenTo(2 == t.context.type && t.context.depth == Kj(e, n) ? 66 : 65, n)
                }
            }
        else
            63 == e.next && (e.advance(),
            nz(e.next) && e.acceptToken(7))
    }
    ),{
        contextual: !0
    });
    function sz(e) {
        return e >= 48 && e <= 57 || e >= 97 && e <= 102 || e >= 65 && e <= 70
    }
    function lz(e, t) {
        return 37 == e.next ? (e.advance(),
        sz(e.next) && e.advance(),
        sz(e.next) && e.advance(),
        !0) : !!((n = e.next) > 32 && n < 127 && 34 != n && 37 != n && 44 != n && 60 != n && 62 != n && 92 != n && 94 != n && 96 != n && 123 != n && 124 != n && 125 != n || t && 44 == e.next) && (e.advance(),
        !0);
        var n
    }
    function cz(e) {
        if (e.advance(),
        60 == e.next) {
            for (e.advance(); ; )
                if (!lz(e, !0)) {
                    62 == e.next && e.advance();
                    break
                }
        } else
            for (; lz(e, !1); )
                ;
    }
    function uz(e) {
        for (e.advance(); !nz(e.next) && "f" != fz(e.tag); )
            e.advance()
    }
    function dz(e, t) {
        let n = e.next
          , r = !1
          , o = e.pos;
        for (e.advance(); ; ) {
            let i = e.next;
            if (i < 0)
                break;
            if (e.advance(),
            i == n) {
                if (39 != i)
                    break;
                if (39 != e.next)
                    break;
                e.advance()
            } else if (92 == i && 34 == n)
                e.next >= 0 && e.advance();
            else if (ez(i)) {
                if (t)
                    return !1;
                r = !0
            } else if (t && e.pos >= o + 1024)
                return !1
        }
        return !r
    }
    function pz(e) {
        for (let t = [], n = e.pos + 1024; ; )
            if (91 == e.next || 123 == e.next)
                t.push(e.next),
                e.advance();
            else if (39 == e.next || 34 == e.next) {
                if (!dz(e, !0))
                    return !1
            } else if (93 == e.next || 125 == e.next) {
                if (t[t.length - 1] != e.next - 2)
                    return !1;
                if (t.pop(),
                e.advance(),
                !t.length)
                    return !0
            } else {
                if (e.next < 0 || e.pos > n || ez(e.next))
                    return !1;
                e.advance()
            }
    }
    const hz = "iiisiiissisfissssssssssssisssiiissssssssssssssssssssssssssfsfssissssssssssssssssssssssssssfif";
    function fz(e) {
        return e < 33 ? "u" : e > 125 ? "s" : hz[e - 33]
    }
    function mz(e, t) {
        let n = fz(e);
        return "u" != n && !(t && "f" == n)
    }
    function gz(e, t, n, r) {
        if ("s" != fz(e.next) && (63 != e.next && 58 != e.next && 45 != e.next || !mz(e.peek(1), n)))
            return !1;
        e.advance();
        let o = e.pos;
        for (; ; ) {
            let i = e.next
              , a = 0
              , s = r + 1;
            for (; tz(i); ) {
                if (ez(i)) {
                    if (t)
                        return !1;
                    s = 0
                } else
                    s++;
                i = e.peek(++a)
            }
            if (!(i >= 0 && (58 == i ? mz(e.peek(a + 1), n) : 35 == i ? 32 != e.peek(a - 1) : mz(i, n))) || !n && s <= r || 0 == s && !n && (oz(e, 45, a) || oz(e, 46, a)))
                break;
            if (t && "f" == fz(i))
                return !1;
            for (let t = a; t >= 0; t--)
                e.advance();
            if (t && e.pos > o + 1024)
                return !1
        }
        return !0
    }
    const bz = new gU(((e,t)=>{
        if (33 == e.next)
            cz(e),
            e.acceptToken(12);
        else if (38 == e.next || 42 == e.next) {
            let t = 38 == e.next ? 10 : 11;
            uz(e),
            e.acceptToken(t)
        } else
            39 == e.next || 34 == e.next ? (dz(e, !1),
            e.acceptToken(9)) : gz(e, !1, 3 == t.context.type, t.context.depth) && e.acceptToken(8)
    }
    ))
      , Oz = new gU(((e,t)=>{
        let n = 4 == t.context.type ? t.context.depth : -1
          , r = e.pos;
        e: for (; ; ) {
            let o = 0
              , i = e.next;
            for (; 32 == i; )
                i = e.peek(++o);
            if (!o && (oz(e, 45, o) || oz(e, 46, o)))
                break;
            if (!ez(i) && (n < 0 && (n = Math.max(t.context.depth + 1, o)),
            o < n))
                break;
            for (; ; ) {
                if (e.next < 0)
                    break e;
                let t = ez(e.next);
                if (e.advance(),
                t)
                    continue e;
                r = e.pos
            }
        }
        e.acceptTokenTo(13, r)
    }
    ))
      , vz = aL({
        DirectiveName: TL.keyword,
        DirectiveContent: TL.attributeValue,
        "DirectiveEnd DocEnd": TL.meta,
        QuotedLiteral: TL.string,
        BlockLiteralHeader: TL.special(TL.string),
        BlockLiteralContent: TL.content,
        Literal: TL.content,
        "Key/Literal Key/QuotedLiteral": TL.definition(TL.propertyName),
        "Anchor Alias": TL.labelName,
        Tag: TL.typeName,
        Comment: TL.lineComment,
        ": , -": TL.separator,
        "?": TL.punctuation,
        "[ ]": TL.squareBracket,
        "{ }": TL.brace
    })
      , yz = PU.deserialize({
        version: 14,
        states: "5lQ!ZQgOOO#PQfO'#CpO#uQfO'#DOOOQR'#Dv'#DvO$qQgO'#DRO%gQdO'#DUO%nQgO'#DUO&ROaO'#D[OOQR'#Du'#DuO&{QgO'#D^O'rQgO'#D`OOQR'#Dt'#DtO(iOqO'#DbOOQP'#Dj'#DjO(zQaO'#CmO)YQgO'#CmOOQP'#Cm'#CmQ)jQaOOQ)uQgOOQ]QgOOO*PQdO'#CrO*nQdO'#CtOOQO'#Dw'#DwO+]Q`O'#CxO+hQdO'#CwO+rQ`O'#CwOOQO'#Cv'#CvO+wQdO'#CvOOQO'#Cq'#CqO,UQ`O,59[O,^QfO,59[OOQR,59[,59[OOQO'#Cx'#CxO,eQ`O'#DPO,pQdO'#DPOOQO'#Dx'#DxO,zQdO'#DxO-XQ`O,59jO-aQfO,59jOOQR,59j,59jOOQR'#DS'#DSO-hQcO,59mO-sQgO'#DVO.TQ`O'#DVO.YQcO,59pOOQR'#DX'#DXO#|QfO'#DWO.hQcO'#DWOOQR,59v,59vO.yOWO,59vO/OOaO,59vO/WOaO,59vO/cQgO'#D_OOQR,59x,59xO0VQgO'#DaOOQR,59z,59zOOQP,59|,59|O0yOaO,59|O1ROaO,59|O1aOqO,59|OOQP-E7h-E7hO1oQgO,59XOOQP,59X,59XO2PQaO'#DeO2_QgO'#DeO2oQgO'#DkOOQP'#Dk'#DkQ)jQaOOO3PQdO'#CsOOQO,59^,59^O3kQdO'#CuOOQO,59`,59`OOQO,59c,59cO4VQdO,59cO4aQdO'#CzO4kQ`O'#CzOOQO,59b,59bOOQU,5:Q,5:QOOQR1G.v1G.vO4pQ`O1G.vOOQU-E7d-E7dO4xQdO,59kOOQO,59k,59kO5SQdO'#DQO5^Q`O'#DQOOQO,5:d,5:dOOQU,5:R,5:ROOQR1G/U1G/UO5cQ`O1G/UOOQU-E7e-E7eO5kQgO'#DhO5xQcO1G/XOOQR1G/X1G/XOOQR,59q,59qO6TQgO,59qO6eQdO'#DiO6lQgO'#DiO7PQcO1G/[OOQR1G/[1G/[OOQR,59r,59rO#|QfO,59rOOQR1G/b1G/bO7_OWO1G/bO7dOaO1G/bOOQR,59y,59yOOQR,59{,59{OOQP1G/h1G/hO7lOaO1G/hO7tOaO1G/hO8POaO1G/hOOQP1G.s1G.sO8_QgO,5:POOQP,5:P,5:POOQP,5:V,5:VOOQP-E7i-E7iOOQO,59_,59_OOQO,59a,59aOOQO1G.}1G.}OOQO,59f,59fO8oQdO,59fOOQR7+$b7+$bP,XQ`O'#DfOOQO1G/V1G/VOOQO,59l,59lO8yQdO,59lOOQR7+$p7+$pP9TQ`O'#DgOOQR'#DT'#DTOOQR,5:S,5:SOOQR-E7f-E7fOOQR7+$s7+$sOOQR1G/]1G/]O9YQgO'#DYO9jQ`O'#DYOOQR,5:T,5:TO#|QfO'#DZO9oQcO'#DZOOQR-E7g-E7gOOQR7+$v7+$vOOQR1G/^1G/^OOQR7+$|7+$|O:QOWO7+$|OOQP7+%S7+%SO:VOaO7+%SO:_OaO7+%SOOQP1G/k1G/kOOQO1G/Q1G/QOOQO1G/W1G/WOOQR,59t,59tO:jQgO,59tOOQR,59u,59uO#|QfO,59uOOQR<<Hh<<HhOOQP<<Hn<<HnO:zOaO<<HnOOQR1G/`1G/`OOQR1G/a1G/aOOQPAN>YAN>Y",
        stateData: ";S~O!fOS!gOS^OS~OP_OQbORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!V[O!cTO~O`cO~P]OVkOWROXROYeOZfO[dOcPOmhOqQO~OboO~P!bOVtOWROXROYeOZfO[dOcPOmrOqQO~OpwO~P#WORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!cTO~OSvP!avP!bvP~P#|OWROXROYeOZfO[dOcPOqQO~OmzO~P%OOm!OOUzP!azP!bzP!dzP~P#|O^!SO!b!QO!f!TO!g!RO~ORSOTUOWROXROcPOqQO!PVO!cTO~OY!UOP!QXQ!QX!V!QX!`!QXS!QX!a!QX!b!QXU!QXm!QX!d!QX~P&aO[!WOP!SXQ!SX!V!SX!`!SXS!SX!a!SX!b!SXU!SXm!SX!d!SX~P&aO^!ZO!W![O!b!YO!f!]O!g!YO~OP!_O!V[OQaX!`aX~OPaXQaX!VaX!`aX~P#|OP!bOQ!cO!V[O~OP_O!V[O~P#|OWROXROY!fOcPOqQObfXmfXofXpfX~OWROXRO[!hOcPOqQObhXmhXohXphX~ObeXmlXoeX~ObkXokX~P%OOm!kO~Om!lObnPonP~P%OOb!pOo!oO~Ob!pO~P!bOm!sOosXpsX~OosXpsX~P%OOm!uOotPptP~P%OOo!xOp!yO~Op!yO~P#WOS!|O!a#OO!b#OO~OUyX!ayX!byX!dyX~P#|Om#QO~OU#SO!a#UO!b#UO!d#RO~Om#WOUzX!azX!bzX!dzX~O]#XO~O!b#XO!g#YO~O^#ZO!b#XO!g#YO~OP!RXQ!RX!V!RX!`!RXS!RX!a!RX!b!RXU!RXm!RX!d!RX~P&aOP!TXQ!TX!V!TX!`!TXS!TX!a!TX!b!TXU!TXm!TX!d!TX~P&aO!b#^O!g#^O~O^#_O!b#^O!f#`O!g#^O~O^#_O!W#aO!b#^O!g#^O~OPaaQaa!Vaa!`aa~P#|OP#cO!V[OQ!XX!`!XX~OP!XXQ!XX!V!XX!`!XX~P#|OP_O!V[OQ!_X!`!_X~P#|OWROXROcPOqQObgXmgXogXpgX~OWROXROcPOqQObiXmiXoiXpiX~Obkaoka~P%OObnXonX~P%OOm#kO~Ob#lOo!oO~Oosapsa~P%OOotXptX~P%OOm#pO~Oo!xOp#qO~OSwP!awP!bwP~P#|OS!|O!a#vO!b#vO~OUya!aya!bya!dya~P#|Om#xO~P%OOm#{OU}P!a}P!b}P!d}P~P#|OU#SO!a$OO!b$OO!d#RO~O]$QO~O!b$QO!g$RO~O!b$SO!g$SO~O^$TO!b$SO!g$SO~O^$TO!b$SO!f$UO!g$SO~OP!XaQ!Xa!V!Xa!`!Xa~P#|Obnaona~P%OOotapta~P%OOo!xO~OU|X!a|X!b|X!d|X~P#|Om$ZO~Om$]OU}X!a}X!b}X!d}X~O]$^O~O!b$_O!g$_O~O^$`O!b$_O!g$_O~OU|a!a|a!b|a!d|a~P#|O!b$cO!g$cO~O",
        goto: ",]!mPPPPPPPPPPPPPPPPP!nPP!v#v#|$`#|$c$f$j$nP%VPPP!v%Y%^%a%{&O%a&R&U&X&_&b%aP&e&{&e'O'RPP']'a'g'm's'y(XPPPPPPPP(_)e*X+c,VUaObcR#e!c!{ROPQSTUXY_bcdehknrtvz!O!U!W!_!b!c!f!h!k!l!s!u!|#Q#R#S#W#c#k#p#x#{$Z$]QmPR!qnqfPQThknrtv!k!l!s!u#R#k#pR!gdR!ieTlPnTjPnSiPnSqQvQ{TQ!mkQ!trQ!vtR#y#RR!nkTsQvR!wt!RWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]RySR#t!|R|TR|UQ!PUR#|#SR#z#RR#z#SyZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]R!VXR!XYa]O^abc!a!c!eT!da!eQnPR!rnQvQR!{vQ!}yR#u!}Q#T|R#}#TW^Obc!cS!^^!aT!aa!eQ!eaR#f!eW`Obc!cQxSS}U#SQ!`_Q#PzQ#V!OQ#b!_Q#d!bQ#s!|Q#w#QQ$P#WQ$V#cQ$Y#xQ$[#{Q$a$ZR$b$]xZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]Q!VXQ!XYQ#[!UR#]!W!QWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]pfPQThknrtv!k!l!s!u#R#k#pQ!gdQ!ieQ#g!fR#h!hSgPn^pQTkrtv#RQ!jhQ#i!kQ#j!lQ#n!sQ#o!uQ$W#kR$X#pQuQR!zv",
        nodeNames: "⚠ DirectiveEnd DocEnd - - ? ? ? Literal QuotedLiteral Anchor Alias Tag BlockLiteralContent Comment Stream BOM Document ] [ FlowSequence Item Tagged Anchored Anchored Tagged FlowMapping Pair Key : Pair , } { FlowMapping Pair Pair BlockSequence Item Item BlockMapping Pair Pair Key Pair Pair BlockLiteral BlockLiteralHeader Tagged Anchored Anchored Tagged Directive DirectiveName DirectiveContent Document",
        maxTerm: 74,
        context: rz,
        nodeProps: [["isolate", -3, 8, 9, 14, ""], ["openedBy", 18, "[", 32, "{"], ["closedBy", 19, "]", 33, "}"]],
        propSources: [vz],
        skippedNodes: [0],
        repeatNodeCount: 6,
        tokenData: "-Y~RnOX#PXY$QYZ$]Z]#P]^$]^p#Ppq$Qqs#Pst$btu#Puv$yv|#P|}&e}![#P![!]'O!]!`#P!`!a'i!a!}#P!}#O*g#O#P#P#P#Q+Q#Q#o#P#o#p+k#p#q'i#q#r,U#r;'S#P;'S;=`#z<%l?HT#P?HT?HU,o?HUO#PQ#UU!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PQ#kTOY#PZs#Pt;'S#P;'S;=`#z<%lO#PQ#}P;=`<%l#P~$VQ!f~XY$Qpq$Q~$bO!g~~$gS^~OY$bZ;'S$b;'S;=`$s<%lO$b~$vP;=`<%l$bR%OX!WQOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR%rX!WQ!VPOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR&bP;=`<%l%kR&lUoP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'VUmP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'p[!PP!WQOY#PZp#Ppq#hq{#P{|(f|}#P}!O(f!O!R#P!R![)p![;'S#P;'S;=`#z<%lO#PR(mW!PP!WQOY#PZp#Ppq#hq!R#P!R![)V![;'S#P;'S;=`#z<%lO#PR)^U!PP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR)wY!PP!WQOY#PZp#Ppq#hq{#P{|)V|}#P}!O)V!O;'S#P;'S;=`#z<%lO#PR*nUcP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+XUbP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+rUqP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,]UpP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,vU`P!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#P",
        tokenizers: [iz, az, bz, Oz, 0, 1],
        topRules: {
            Stream: [0, 15]
        },
        tokenPrec: 0
    })
      , wz = $L.define({
        name: "yaml",
        parser: yz.configure({
            props: [KL.add({
                Stream: e=>{
                    for (let t = e.node.resolve(e.pos, -1); t && t.to >= e.pos; t = t.parent) {
                        if ("BlockLiteralContent" == t.name && t.from < t.to)
                            return e.baseIndentFor(t);
                        if ("BlockLiteral" == t.name)
                            return e.baseIndentFor(t) + e.unit;
                        if ("BlockSequence" == t.name || "BlockMapping" == t.name)
                            return e.column(t.from, 1);
                        if ("QuotedLiteral" == t.name)
                            return null;
                        if ("Literal" == t.name) {
                            let n = e.column(t.from, 1);
                            if (n == e.lineIndent(t.from, 1))
                                return n;
                            if (t.to > e.pos)
                                return null
                        }
                    }
                    return null
                }
                ,
                FlowMapping: oQ({
                    closing: "}"
                }),
                FlowSequence: oQ({
                    closing: "]"
                })
            }), lQ.add({
                "FlowMapping FlowSequence": cQ,
                "BlockSequence Pair BlockLiteral": (e,t)=>({
                    from: t.doc.lineAt(e.from).to,
                    to: e.to
                })
            })]
        }),
        languageData: {
            commentTokens: {
                line: "#"
            },
            indentOnInput: /^\s*[\]\}]$/
        }
    });
    const _z = (e=>{
        var {theme: t, settings: n={}, styles: r=[]} = e
          , o = {
            ".cm-gutters": {}
        }
          , i = {};
        n.background && (i.backgroundColor = n.background),
        n.backgroundImage && (i.backgroundImage = n.backgroundImage),
        n.foreground && (i.color = n.foreground),
        n.fontSize && (i.fontSize = n.fontSize),
        (n.background || n.foreground) && (o["&"] = i),
        n.fontFamily && (o["&.cm-editor .cm-scroller"] = {
            fontFamily: n.fontFamily
        }),
        n.gutterBackground && (o[".cm-gutters"].backgroundColor = n.gutterBackground),
        n.gutterForeground && (o[".cm-gutters"].color = n.gutterForeground),
        n.gutterBorder && (o[".cm-gutters"].borderRightColor = n.gutterBorder),
        n.caret && (o[".cm-content"] = {
            caretColor: n.caret
        },
        o[".cm-cursor, .cm-dropCursor"] = {
            borderLeftColor: n.caret
        });
        var a = {};
        return n.gutterActiveForeground && (a.color = n.gutterActiveForeground),
        n.lineHighlight && (o[".cm-activeLine"] = {
            backgroundColor: n.lineHighlight
        },
        a.backgroundColor = n.lineHighlight),
        o[".cm-activeLineGutter"] = a,
        n.selection && (o["&.cm-focused .cm-selectionBackground, & .cm-line::selection, & .cm-selectionLayer .cm-selectionBackground, .cm-content ::selection"] = {
            background: n.selection + " !important"
        }),
        n.selectionMatch && (o["& .cm-selectionMatch"] = {
            backgroundColor: n.selectionMatch
        }),
        [pI.theme(o, {
            dark: "dark" === t
        }), fQ(uQ.define(r))]
    }
    )({
        theme: "light",
        settings: {
            background: "var(--scalar-background-2)",
            foreground: "var(--scalar-color-1)",
            caret: "var(--scalar-color-1)",
            selection: "rgba(151, 183, 205, 0.2)",
            selectionMatch: "#e3dcce",
            gutterBackground: "var(--scalar-background-2)",
            gutterForeground: "var(--scalar-color-3)",
            gutterBorder: "transparent",
            lineHighlight: "var(--scalar-background-3)",
            fontFamily: "var(--scalar-font-code)"
        },
        styles: [{
            tag: [TL.standard(TL.tagName), TL.tagName],
            color: "var(--scalar-color-purple)"
        }, {
            tag: [TL.comment],
            color: "var(--scalar-color-3)"
        }, {
            tag: [TL.className],
            color: "var(--scalar-color-orange)"
        }, {
            tag: [TL.variableName, TL.propertyName, TL.attributeName],
            color: "var(--scalar-color-1)"
        }, {
            tag: [TL.operator],
            color: "var(--scalar-color-2)"
        }, {
            tag: [TL.keyword, TL.typeName, TL.typeOperator],
            color: "var(--scalar-color-green)"
        }, {
            tag: [TL.string],
            color: "var(--scalar-color-blue)"
        }, {
            tag: [TL.bracket, TL.regexp, TL.meta],
            color: "var(--scalar-color-3)"
        }, {
            tag: [TL.number],
            color: "var(--scalar-color-blue)"
        }, {
            tag: [TL.name, TL.quote],
            color: "var(--scalar-color-3)"
        }, {
            tag: [TL.heading],
            color: "var(--scalar-color-3)",
            fontWeight: "bold"
        }, {
            tag: [TL.emphasis],
            color: "var(--scalar-color-3)",
            fontStyle: "italic"
        }, {
            tag: [TL.deleted],
            color: "var(--scalar-color-3)",
            backgroundColor: "transparent"
        }, {
            tag: [TL.atom, TL.bool, TL.special(TL.variableName)],
            color: "var(--scalar-color-3)"
        }, {
            tag: [TL.url, TL.escape, TL.regexp, TL.link],
            color: "var(--scalar-color-1)"
        }, {
            tag: TL.link,
            textDecoration: "underline"
        }, {
            tag: TL.strikethrough,
            textDecoration: "line-through"
        }, {
            tag: TL.invalid,
            color: "var(--scalar-color-3)"
        }]
    });
    var kz = Object.defineProperty
      , Sz = (e,t,n)=>((e,t,n)=>t in e ? kz(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : e[t] = n)(e, t + "", n);
    const Ez = new TI({
        regexp: /(\{[^}]+\})/g,
        decoration: ()=>ER.mark({
            attributes: {
                class: "api-client-url-variable"
            }
        })
    })
      , xz = ()=>gN.fromClass(class {
        constructor(e) {
            Sz(this, "variables"),
            this.variables = Ez.createDeco(e)
        }
        update(e) {
            this.variables = Ez.updateDeco(e, this.variables)
        }
    }
    , {
        decorations: e=>e.variables,
        provide: e=>pI.atomicRanges.of((t=>{
            var n;
            return (null == (n = t.plugin(e)) ? void 0 : n.variables) || ER.none
        }
        ))
    })
      , Tz = e=>"provider"in e && !!Pt(e.provider)
      , Az = {
        key: "Mod-a",
        run: e=>(e.dispatch({
            selection: {
                anchor: 0,
                head: e.state.doc.length
            },
            scrollIntoView: !1
        }),
        !0)
    }
      , Cz = {
        html: function(e={}) {
            let t, n = "";
            !1 === e.matchClosingTags && (n = "noMatch"),
            !0 === e.selfClosingTags && (n = (n ? n + " " : "") + "selfClosing"),
            (e.nestedLanguages && e.nestedLanguages.length || e.nestedAttributes && e.nestedAttributes.length) && (t = BF((e.nestedLanguages || []).concat(Fj), (e.nestedAttributes || []).concat(jj)));
            let r = t ? zj.configure({
                wrap: t,
                dialect: n
            }) : n ? qj.configure({
                dialect: n
            }) : qj;
            return new HL(r,[qj.data.of({
                autocomplete: Bj(e)
            }), !1 !== e.autoCloseTags ? Zj : [], bj().support, rF().support])
        },
        json: function() {
            return new HL(Vj)
        },
        yaml: function() {
            return new HL(wz)
        },
        css: rF
    };
    function Pz({onChange: e, onBlur: t, onFocus: n, provider: r, language: o, classes: i=[], readOnly: a=!1, lineNumbers: s=!1, withVariables: l=!1, disableEnter: c=!1, withoutTheme: u=!1, additionalExtensions: d=[]}) {
        const p = [NI(), fQ(bQ, {
            fallback: !0
        }), pI.theme({
            ".cm-line": {
                lineHeight: "20px"
            },
            ".cm-gutterElement": {
                lineHeight: "20px"
            }
        }), pI.updateListener.of((t=>{
            t.docChanged && (null == e || e(t.state.doc.toString()))
        }
        )), pI.domEventHandlers({
            blur: (e,n)=>{
                null == t || t(n.state.doc.toString())
            }
            ,
            focus: (e,t)=>{
                null == n || n(t.state.doc.toString())
            }
        }), pI.editorAttributes.of({
            class: i.join(" ")
        }), ...d];
        return r && p.push(r),
        u || p.push(_z),
        a ? p.push(pI.editable.of(!1)) : p.push(HP.transactionFilter.of((e=>{
            if (!e.docChanged || !e.isUserEvent("input.type") && !e.isUserEvent("input.complete"))
                return e;
            let t = e.startState.languageDataAt("indentOnInput", e.startState.selection.main.head);
            if (!t.length)
                return e;
            let n = e.newDoc
              , {head: r} = e.newSelection.main
              , o = n.lineAt(r);
            if (r > o.from + sQ)
                return e;
            let i = n.sliceString(o.from, r);
            if (!t.some((e=>e.test(i))))
                return e;
            let {state: a} = e
              , s = -1
              , l = [];
            for (let {head: c} of a.selection.ranges) {
                let e = a.doc.lineAt(c);
                if (e.from == s)
                    continue;
                s = e.from;
                let t = GL(a, e.from);
                if (null == t)
                    continue;
                let n = /^\s*/.exec(e.text)[0]
                  , r = VL(a, t);
                n != r && l.push({
                    from: e.from,
                    to: e.from + n.length,
                    insert: r
                })
            }
            return l.length ? [e, {
                changes: l,
                sequential: !0
            }] : e
        }
        )), function(e={}) {
            return [yQ.of(e), SQ]
        }(), function(e={}) {
            return [yB, hB, GQ.of(e), OB, rU, wB]
        }(), [WB, jB], yI.of([...nU, ...XB, iU, Az])),
        o && Cz[o] && p.push(Cz[o]()),
        s && p.push(function(e={}) {
            return [oM.of(e), [YI], sM]
        }()),
        l && p.push(xz()),
        c && p.push(yI.of([{
            key: "Enter",
            run: ()=>!0
        }, {
            key: "Ctrl-Enter",
            mac: "Cmd-Enter",
            run: ()=>!0
        }, {
            key: "Shift-Enter",
            run: ()=>!0
        }])),
        p
    }
    const Dz = Ln({
        __name: "CodeMirror",
        props: {
            content: {},
            readOnly: {
                type: Boolean
            },
            language: {},
            withVariables: {
                type: Boolean
            },
            lineNumbers: {
                type: Boolean
            },
            withoutTheme: {
                type: Boolean
            },
            disableEnter: {
                type: Boolean,
                default: !1
            }
        },
        emits: ["change"],
        setup(e, {emit: t}) {
            const n = e
              , r = t
              , o = Et(null);
            return (e=>{
                const t = Et(null);
                function n() {
                    if (e.codeMirrorRef.value) {
                        const n = Tz(e) ? Pt(e.provider) : null
                          , i = Pz({
                            ...r.value,
                            provider: n
                        });
                        t.value = new pI({
                            parent: e.codeMirrorRef.value,
                            extensions: i
                        }),
                        Tz(e) || o(Pt(e.content))
                    }
                }
                zr(e.codeMirrorRef, (()=>{
                    var e;
                    null == (e = t.value) || e.destroy(),
                    n()
                }
                ), {
                    immediate: !0
                }),
                Tn((()=>{
                    var e;
                    return null == (e = t.value) ? void 0 : e.destroy()
                }
                ));
                const r = ei((()=>({
                    onChange: e.onChange,
                    onBlur: e.onBlur,
                    onFocus: e.onFocus,
                    language: Pt(e.language),
                    classes: Pt(e.classes),
                    readOnly: Pt(e.readOnly),
                    lineNumbers: Pt(e.lineNumbers),
                    withVariables: Pt(e.withVariables),
                    disableEnter: Pt(e.withVariables),
                    withoutTheme: Pt(e.withoutTheme),
                    additionalExtensions: Pt(e.extensions)
                })));
                zr((()=>Tz(e) ? Pt(e.provider) : null), (()=>{
                    var r;
                    Tz(e) && (null == (r = t.value) || r.destroy(),
                    n())
                }
                )),
                zr(r, (()=>{
                    if (t.value) {
                        const n = Tz(e) ? Pt(e.provider) : null
                          , o = Pz({
                            ...r.value,
                            provider: n
                        });
                        t.value.dispatch({
                            effects: NP.reconfigure.of(o)
                        })
                    }
                }
                ), {
                    immediate: !0
                });
                const o = (e="")=>{
                    t.value && t.value.state.doc.toString() !== e && t.value.dispatch({
                        changes: {
                            from: 0,
                            to: t.value.state.doc.length,
                            insert: e
                        },
                        selection: {
                            anchor: Math.min(t.value.state.selection.main.anchor, e.length)
                        }
                    })
                }
                ;
                zr((()=>Pt(e.content)), (()=>{
                    Tz(e) || o(Pt(e.content))
                }
                ), {
                    immediate: !0
                })
            }
            )({
                content: It((()=>n.content)),
                readOnly: It((()=>n.readOnly)),
                language: It((()=>n.language)),
                withVariables: It((()=>n.withVariables)),
                lineNumbers: It((()=>n.lineNumbers)),
                withoutTheme: It((()=>n.withoutTheme)),
                disableEnter: It((()=>n.disableEnter)),
                onChange: e=>r("change", e || ""),
                codeMirrorRef: o,
                classes: ["codemirror"]
            }),
            (e,t)=>(mo(),
            vo("div", {
                ref_key: "codeMirrorRef",
                ref: o,
                class: "codemirror-container"
            }, null, 512))
        }
    })
      , Rz = (e,t)=>{
        const n = e.__vccOpts || e;
        for (const [r,o] of t)
            n[r] = o;
        return n
    }
      , Nz = Rz(Dz, [["__scopeId", "data-v-f74951d5"]]);
    function $z() {
        return typeof navigator < "u" && /Mac/.test(navigator.platform)
    }
    const Iz = ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
      , Mz = ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
      , Lz = ["b", "kbit", "Mbit", "Gbit", "Tbit", "Pbit", "Ebit", "Zbit", "Ybit"]
      , Qz = ["b", "kibit", "Mibit", "Gibit", "Tibit", "Pibit", "Eibit", "Zibit", "Yibit"]
      , Bz = (e,t,n)=>{
        let r = e;
        return "string" == typeof t || Array.isArray(t) ? r = e.toLocaleString(t, n) : !0 !== t && void 0 === n || (r = e.toLocaleString(void 0, n)),
        r
    }
    ;
    function Uz(e, t) {
        if (!Number.isFinite(e))
            throw new TypeError(`Expected a finite number, got ${typeof e}: ${e}`);
        const n = (t = {
            bits: !1,
            binary: !1,
            space: !0,
            ...t
        }).bits ? t.binary ? Qz : Lz : t.binary ? Mz : Iz
          , r = t.space ? " " : "";
        if (t.signed && 0 === e)
            return ` 0${r}${n[0]}`;
        const o = e < 0
          , i = o ? "-" : t.signed ? "+" : "";
        let a;
        if (o && (e = -e),
        void 0 !== t.minimumFractionDigits && (a = {
            minimumFractionDigits: t.minimumFractionDigits
        }),
        void 0 !== t.maximumFractionDigits && (a = {
            maximumFractionDigits: t.maximumFractionDigits,
            ...a
        }),
        e < 1) {
            return i + Bz(e, t.locale, a) + r + n[0]
        }
        const s = Math.min(Math.floor(t.binary ? Math.log(e) / Math.log(1024) : Math.log10(e) / 3), n.length - 1);
        e /= (t.binary ? 1024 : 1e3) ** s,
        a || (e = e.toPrecision(3));
        return i + Bz(Number(e), t.locale, a) + r + n[s]
    }
    function Fz(e, t={}) {
        if (!Number.isFinite(e))
            throw new TypeError("Expected a finite number");
        t.colonNotation && (t.compact = !1,
        t.formatSubMilliseconds = !1,
        t.separateMilliseconds = !1,
        t.verbose = !1),
        t.compact && (t.secondsDecimalDigits = 0,
        t.millisecondsDecimalDigits = 0);
        const n = []
          , r = (e,r,o,i)=>{
            if (!(0 !== n.length && t.colonNotation || 0 !== e || t.colonNotation && "m" === o))
                return;
            let a, s;
            if (i = (i || e || "0").toString(),
            t.colonNotation) {
                a = n.length > 0 ? ":" : "",
                s = "";
                const e = i.includes(".") ? i.split(".")[0].length : i.length
                  , t = n.length > 0 ? 2 : 1;
                i = "0".repeat(Math.max(0, t - e)) + i
            } else
                a = "",
                s = t.verbose ? " " + (l = r,
                1 === e ? l : `${l}s`) : o;
            var l;
            n.push(a + i + s)
        }
          , o = function(e) {
            if ("number" != typeof e)
                throw new TypeError("Expected a number");
            const t = e > 0 ? Math.floor : Math.ceil;
            return {
                days: t(e / 864e5),
                hours: t(e / 36e5) % 24,
                minutes: t(e / 6e4) % 60,
                seconds: t(e / 1e3) % 60,
                milliseconds: t(e) % 1e3,
                microseconds: t(1e3 * e) % 1e3,
                nanoseconds: t(1e6 * e) % 1e3
            }
        }(e);
        if (r(Math.trunc(o.days / 365), "year", "y"),
        r(o.days % 365, "day", "d"),
        r(o.hours, "hour", "h"),
        r(o.minutes, "minute", "m"),
        t.separateMilliseconds || t.formatSubMilliseconds || !t.colonNotation && e < 1e3)
            if (r(o.seconds, "second", "s"),
            t.formatSubMilliseconds)
                r(o.milliseconds, "millisecond", "ms"),
                r(o.microseconds, "microsecond", "µs"),
                r(o.nanoseconds, "nanosecond", "ns");
            else {
                const e = o.milliseconds + o.microseconds / 1e3 + o.nanoseconds / 1e6
                  , n = "number" == typeof t.millisecondsDecimalDigits ? t.millisecondsDecimalDigits : 0
                  , i = e >= 1 ? Math.round(e) : Math.ceil(e)
                  , a = n ? e.toFixed(n) : i;
                r(Number.parseFloat(a), "millisecond", "ms", a)
            }
        else {
            const n = ((e,t)=>{
                const n = Math.floor(e * 10 ** t + 1e-7);
                return (Math.round(n) / 10 ** t).toFixed(t)
            }
            )(e / 1e3 % 60, "number" == typeof t.secondsDecimalDigits ? t.secondsDecimalDigits : 1)
              , o = t.keepDecimalsOnWholeSeconds ? n : n.replace(/\.0+$/, "");
            r(Number.parseFloat(o), "second", "s", o)
        }
        if (0 === n.length)
            return "0" + (t.verbose ? " milliseconds" : "ms");
        if (t.compact)
            return n[0];
        if ("number" == typeof t.unitCount) {
            const e = t.colonNotation ? "" : " ";
            return n.slice(0, Math.max(t.unitCount, 1)).join(e)
        }
        return t.colonNotation ? n.join("") : n.join(" ")
    }
    function jz(e) {
        const t = Math.floor(((new Date).getTime() - e) / 1e3);
        if (t < 45)
            return "just now";
        if (t < 60)
            return `${t} seconds ago`;
        const n = Math.floor(t / 60);
        if (n < 60)
            return `${n} minute${1 === n ? "" : "s"} ago`;
        const r = Math.floor(n / 60);
        if (r < 24)
            return `${r} hour${1 === r ? "" : "s"} ago`;
        const o = Math.floor(r / 24);
        if (o < 30)
            return `${o} day${1 === o ? "" : "s"} ago`;
        const i = Math.floor(o / 30);
        return i < 12 ? `${i} month${1 === i ? "" : "s"} ago` : "more than a year ago"
    }
    const zz = ()=>({
        name: "",
        url: "",
        type: "GET",
        path: "",
        variables: [],
        headers: [],
        query: [],
        body: "",
        formData: []
    })
      , qz = ut({})
      , Hz = Et([])
      , Zz = Et("")
      , Wz = ut({
        name: "",
        url: "",
        type: "GET",
        path: "",
        variables: [],
        headers: [],
        query: [],
        body: "",
        formData: []
    })
      , Xz = e=>{
        qz[e.responseId] = e,
        Zz.value = e.responseId,
        Hz.value.unshift(e.responseId)
    }
      , Vz = e=>{
        Zz.value = e;
        const {request: t} = qz[e]
          , n = JSON.parse(JSON.stringify(t));
        n.body = JSON.stringify(t.body, null, 2),
        Object.assign(Wz, n)
    }
      , Gz = ei((()=>Zz.value ? qz[Zz.value].response : null))
      , Yz = e=>{
        Object.assign(Wz, e)
    }
      , Kz = ()=>{
        Zz.value = ""
    }
      , Jz = Et(!0)
      , eq = ()=>({
        readOnly: Jz,
        activeRequest: Wz,
        activeResponse: Gz,
        requestHistory: qz,
        requestHistoryOrder: Hz,
        activeRequestId: Zz,
        setActiveResponse: Vz,
        resetActiveResponse: Kz,
        addRequestToHistory: Xz,
        setActiveRequest: Yz
    })
      , tq = {
        class: "navtable-item-40 navtable-item-request"
    }
      , nq = {
        class: "navtable-item-40 navtable-item-response"
    }
      , rq = {
        class: "navtable-item-20 navtable-item-time"
    }
      , oq = Ln({
        __name: "RequestHistoryItem",
        props: {
            history: {}
        },
        setup(e) {
            const {requestHistory: t, activeRequestId: n, setActiveResponse: r} = eq()
              , o = e=>{
                var t;
                return null != (t = null == e ? void 0 : e.headers) && t["X-API-Client-Content-Length"] ? Uz(parseFloat(e.headers["X-API-Client-Content-Length"])) : Uz(0)
            }
            ;
            return (e,i)=>(mo(),
            vo("div", {
                class: Z(["navtable-item", {
                    "navtable-item__active": Ct(n) === e.history
                }]),
                onClick: i[0] || (i[0] = t=>Ct(r)(e.history))
            }, [Eo("div", tq, [Eo("button", {
                class: Z(["radio", Ct(t)[e.history].request.type.toLowerCase()]),
                type: "button"
            }, null, 2), Eo("span", null, [Eo("em", null, K(Ct(t)[e.history].request.type), 1), Co(" " + K(Ct(t)[e.history].request.url), 1)])]), Eo("div", nq, [Eo("span", null, K(Ct(Fz)(Ct(t)[e.history].response.duration)), 1), Eo("span", {
                class: Z(`scalar-api-client__status--${String(Ct(t)[e.history].response.statusCode).charAt(0)}xx`)
            }, K(Ct(t)[e.history].response.statusCode), 3), Eo("span", null, K(o(Ct(t)[e.history].response)), 1)]), Eo("div", rq, [Eo("span", null, K(Ct(jz)(Ct(t)[e.history].sentTime)), 1)])], 2))
        }
    })
      , iq = (e,t)=>{
        const n = e.__vccOpts || e;
        for (const [r,o] of t)
            n[r] = o;
        return n
    }
      , aq = iq(oq, [["__scopeId", "data-v-353c6d86"]])
      , sq = {
        class: "navigation-content-item"
    }
      , lq = {
        class: "navtable"
    }
      , cq = {
        class: "navtable-table"
    }
      , uq = Po('<div class="navtable-item navtable-item__top"><div class="navtable-item-40"><label for="">Request</label></div><div class="navtable-item-40"><label for="">Response</label></div><div class="navtable-item-20"><label for="">TIME</label></div></div>', 1)
      , dq = {
        class: "navtable-radios"
    }
      , pq = Po('<div class="navtable-mock"><div class="navtable-item"><div class="navtable-item-40"></div><div class="navtable-item-40"></div><div class="navtable-item-20"></div></div></div>', 1)
      , hq = Ln({
        __name: "RequestHistory",
        emits: ["toggle"],
        setup(e) {
            const {requestHistoryOrder: t} = eq();
            return (e,n)=>(mo(),
            vo("div", sq, [Eo("div", lq, [Eo("div", cq, [uq, Eo("div", dq, [(mo(!0),
            vo(lo, null, In(Ct(t), (e=>(mo(),
            yo(aq, {
                key: e,
                history: e
            }, null, 8, ["history"])))), 128))]), pq])])]))
        }
    })
      , fq = {
        class: "request-method-select"
    }
      , mq = ["disabled", "value"]
      , gq = ["value"]
      , bq = Ln({
        __name: "RequestMethodSelect",
        props: {
            requestMethod: {},
            readOnly: {
                type: Boolean,
                default: !0
            }
        },
        emits: ["change"],
        setup(e) {
            const t = ["GET", "POST", "PUT", "DELETE", "PATCH"];
            return (e,n)=>(mo(),
            vo("div", fq, [Eo("span", {
                class: Z(["request-method", {
                    "request-method--disabled": e.readOnly
                }])
            }, [Eo("span", null, K(e.requestMethod), 1)], 2), Eo("select", {
                disabled: e.readOnly,
                value: e.requestMethod.toLowerCase(),
                onInput: n[0] || (n[0] = t=>e.$emit("change", t.target.value))
            }, [(mo(),
            vo(lo, null, In(t, (e=>Eo("option", {
                key: e,
                value: e.toLocaleLowerCase()
            }, K(e), 9, gq))), 64))], 40, mq)]))
        }
    })
      , Oq = iq(bq, [["__scopeId", "data-v-0f1e5bdc"]]);
    function vq(e) {
        return typeof window > "u" ? Buffer.from(e).toString("base64") : btoa(e)
    }
    function yq(e, t) {
        var n, r;
        const o = []
          , i = []
          , a = [];
        if (!(e.customSecurity || e.preferredSecurityScheme && function(e) {
            return !(!e || Array.isArray(e) && !e.length || (e ?? []).some((e=>!Object.keys(e).length)))
        }(t)))
            return {
                headers: o,
                queryString: i,
                cookies: a
            };
        const s = (null == t ? void 0 : t.some((t=>e.preferredSecurityScheme && Object.keys(t).includes(e.preferredSecurityScheme)))) || e.customSecurity ? e.preferredSecurityScheme : Object.keys((null == t ? void 0 : t[0]) ?? {}).pop()
          , l = null == (n = e.securitySchemes) ? void 0 : n[s ?? ""];
        if (l)
            if ("type"in l && "apiKey" === l.type) {
                if ("in"in l && "header" === l.in) {
                    const t = null != (r = e.apiKey.token) && r.length ? e.apiKey.token : "YOUR_TOKEN";
                    o.push({
                        name: "name"in l ? l.name : "",
                        value: t
                    })
                } else if ("in"in l && "cookie" === l.in) {
                    const t = e.apiKey.token.length ? e.apiKey.token : "YOUR_TOKEN";
                    a.push({
                        name: l.name,
                        value: t
                    })
                } else if ("in"in l && "query" === l.in) {
                    const t = e.apiKey.token.length ? e.apiKey.token : "YOUR_TOKEN";
                    i.push({
                        name: l.name,
                        value: t
                    })
                }
            } else if (!("type"in l) || "http" !== l.type && "basic" !== l.type) {
                if ("type"in l && "oauth2" === l.type.toLowerCase()) {
                    const t = e.oAuth2.accessToken || "YOUR_SECRET_TOKEN";
                    o.push({
                        name: "Authorization",
                        value: `Bearer ${t}`
                    })
                }
            } else if ("type"in l && ("basic" === l.type || "http" === l.type && "basic" === l.scheme)) {
                const {username: t, password: n} = e.http.basic
                  , r = wq(t, n);
                o.push({
                    name: "Authorization",
                    value: `Basic ${r}`.trim()
                })
            } else if ("type"in l && "http" === l.type && "bearer" === l.scheme) {
                const t = e.http.bearer.token.length ? e.http.bearer.token : "YOUR_SECRET_TOKEN";
                o.push({
                    name: "Authorization",
                    value: `Bearer ${t}`
                })
            }
        return {
            headers: o,
            queryString: i,
            cookies: a
        }
    }
    function wq(e, t) {
        return null != e && e.length || null != t && t.length ? vq(`${e}:${t}`) : ""
    }
    function _q(e) {
        return [e.apiKey.token, e.http.bearer.token, e.oAuth2.accessToken, wq(e.http.basic.username, e.http.basic.password), e.http.basic.password].filter(Boolean)
    }
    const kq = ()=>({
        preferredSecurityScheme: null,
        customSecurity: !1,
        http: {
            basic: {
                username: "",
                password: ""
            },
            bearer: {
                token: ""
            }
        },
        apiKey: {
            token: ""
        },
        oAuth2: {
            username: "",
            password: "",
            clientId: "",
            scopes: [],
            accessToken: "",
            state: ""
        }
    })
      , Sq = ut(qT["useGlobalStore-authentication"] ?? {
        preferredSecurityScheme: null,
        customSecurity: !1,
        http: {
            basic: {
                username: "",
                password: ""
            },
            bearer: {
                token: ""
            }
        },
        apiKey: {
            token: ""
        },
        oAuth2: {
            username: "",
            password: "",
            clientId: "",
            scopes: [],
            accessToken: "",
            state: ""
        }
    })
      , Eq = e=>Object.assign(Sq, e)
      , xq = ()=>({
        authentication: Sq,
        setAuthentication: Eq
    })
      , Tq = ()=>({
        operation: {},
        globalSecurity: []
    })
      , Aq = ut({
        operation: {},
        globalSecurity: []
    })
      , Cq = e=>{
        Object.assign(Aq, {
            ...Aq,
            operation: e
        })
    }
      , Pq = e=>{
        Object.assign(Aq, {
            ...Aq,
            globalSecurity: e
        })
    }
      , Dq = ()=>({
        openApi: Aq,
        setOperation: Cq,
        setGlobalSecurity: Pq
    });
    function Rq(e) {
        return (e ?? []).map((e=>({
            ...e,
            enabled: !0
        })))
    }
    const Nq = e=>{
        var t, n;
        const {request: r} = e
          , {authentication: o} = xq()
          , {openApi: {operation: i, globalSecurity: a}} = Dq()
          , s = yq(o, (null == (t = null == i ? void 0 : i.information) ? void 0 : t.security) ?? a);
        return r.headers = [...r.headers ?? [], ...Rq(s.headers)],
        r.cookies = [...r.cookies ?? [], ...Rq(s.cookies)],
        r.query = [...r.query ?? [], ...Rq(s.queryString)],
        r.body && LT(r.body) && (null != (n = r.headers) && n.some((e=>"content-type" === e.name.toLowerCase())) || (r.headers = [...r.headers ?? [], ...Rq([{
            name: "Content-Type",
            value: "application/json; charset=utf-8"
        }])]),
        r.body = JSON.parse(r.body)),
        {
            ...r
        }
    }
    ;
    function $q(e, t) {
        return function() {
            return e.apply(t, arguments)
        }
    }
    const {toString: Iq} = Object.prototype
      , {getPrototypeOf: Mq} = Object
      , Lq = (e=>t=>{
        const n = Iq.call(t);
        return e[n] || (e[n] = n.slice(8, -1).toLowerCase())
    }
    )(Object.create(null))
      , Qq = e=>(e = e.toLowerCase(),
    t=>Lq(t) === e)
      , Bq = e=>t=>typeof t === e
      , {isArray: Uq} = Array
      , Fq = Bq("undefined");
    const jq = Qq("ArrayBuffer");
    const zq = Bq("string")
      , qq = Bq("function")
      , Hq = Bq("number")
      , Zq = e=>null !== e && "object" == typeof e
      , Wq = e=>{
        if ("object" !== Lq(e))
            return !1;
        const t = Mq(e);
        return !(null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t) || Symbol.toStringTag in e || Symbol.iterator in e)
    }
      , Xq = Qq("Date")
      , Vq = Qq("File")
      , Gq = Qq("Blob")
      , Yq = Qq("FileList")
      , Kq = Qq("URLSearchParams")
      , [Jq,eH,tH,nH] = ["ReadableStream", "Request", "Response", "Headers"].map(Qq);
    function rH(e, t, {allOwnKeys: n=!1}={}) {
        if (null == e)
            return;
        let r, o;
        if ("object" != typeof e && (e = [e]),
        Uq(e))
            for (r = 0,
            o = e.length; r < o; r++)
                t.call(null, e[r], r, e);
        else {
            const o = n ? Object.getOwnPropertyNames(e) : Object.keys(e)
              , i = o.length;
            let a;
            for (r = 0; r < i; r++)
                a = o[r],
                t.call(null, e[a], a, e)
        }
    }
    function oH(e, t) {
        t = t.toLowerCase();
        const n = Object.keys(e);
        let r, o = n.length;
        for (; o-- > 0; )
            if (r = n[o],
            t === r.toLowerCase())
                return r;
        return null
    }
    const iH = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global
      , aH = e=>!Fq(e) && e !== iH;
    const sH = (e=>t=>e && t instanceof e)("undefined" != typeof Uint8Array && Mq(Uint8Array))
      , lH = Qq("HTMLFormElement")
      , cH = (({hasOwnProperty: e})=>(t,n)=>e.call(t, n))(Object.prototype)
      , uH = Qq("RegExp")
      , dH = (e,t)=>{
        const n = Object.getOwnPropertyDescriptors(e)
          , r = {};
        rH(n, ((n,o)=>{
            let i;
            !1 !== (i = t(n, o, e)) && (r[o] = i || n)
        }
        )),
        Object.defineProperties(e, r)
    }
      , pH = "abcdefghijklmnopqrstuvwxyz"
      , hH = "0123456789"
      , fH = {
        DIGIT: hH,
        ALPHA: pH,
        ALPHA_DIGIT: pH + pH.toUpperCase() + hH
    };
    const mH = Qq("AsyncFunction")
      , gH = {
        isArray: Uq,
        isArrayBuffer: jq,
        isBuffer: function(e) {
            return null !== e && !Fq(e) && null !== e.constructor && !Fq(e.constructor) && qq(e.constructor.isBuffer) && e.constructor.isBuffer(e)
        },
        isFormData: e=>{
            let t;
            return e && ("function" == typeof FormData && e instanceof FormData || qq(e.append) && ("formdata" === (t = Lq(e)) || "object" === t && qq(e.toString) && "[object FormData]" === e.toString()))
        }
        ,
        isArrayBufferView: function(e) {
            let t;
            return t = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && jq(e.buffer),
            t
        },
        isString: zq,
        isNumber: Hq,
        isBoolean: e=>!0 === e || !1 === e,
        isObject: Zq,
        isPlainObject: Wq,
        isReadableStream: Jq,
        isRequest: eH,
        isResponse: tH,
        isHeaders: nH,
        isUndefined: Fq,
        isDate: Xq,
        isFile: Vq,
        isBlob: Gq,
        isRegExp: uH,
        isFunction: qq,
        isStream: e=>Zq(e) && qq(e.pipe),
        isURLSearchParams: Kq,
        isTypedArray: sH,
        isFileList: Yq,
        forEach: rH,
        merge: function e() {
            const {caseless: t} = aH(this) && this || {}
              , n = {}
              , r = (r,o)=>{
                const i = t && oH(n, o) || o;
                Wq(n[i]) && Wq(r) ? n[i] = e(n[i], r) : Wq(r) ? n[i] = e({}, r) : Uq(r) ? n[i] = r.slice() : n[i] = r
            }
            ;
            for (let o = 0, i = arguments.length; o < i; o++)
                arguments[o] && rH(arguments[o], r);
            return n
        },
        extend: (e,t,n,{allOwnKeys: r}={})=>(rH(t, ((t,r)=>{
            n && qq(t) ? e[r] = $q(t, n) : e[r] = t
        }
        ), {
            allOwnKeys: r
        }),
        e),
        trim: e=>e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
        stripBOM: e=>(65279 === e.charCodeAt(0) && (e = e.slice(1)),
        e),
        inherits: (e,t,n,r)=>{
            e.prototype = Object.create(t.prototype, r),
            e.prototype.constructor = e,
            Object.defineProperty(e, "super", {
                value: t.prototype
            }),
            n && Object.assign(e.prototype, n)
        }
        ,
        toFlatObject: (e,t,n,r)=>{
            let o, i, a;
            const s = {};
            if (t = t || {},
            null == e)
                return t;
            do {
                for (o = Object.getOwnPropertyNames(e),
                i = o.length; i-- > 0; )
                    a = o[i],
                    r && !r(a, e, t) || s[a] || (t[a] = e[a],
                    s[a] = !0);
                e = !1 !== n && Mq(e)
            } while (e && (!n || n(e, t)) && e !== Object.prototype);
            return t
        }
        ,
        kindOf: Lq,
        kindOfTest: Qq,
        endsWith: (e,t,n)=>{
            e = String(e),
            (void 0 === n || n > e.length) && (n = e.length),
            n -= t.length;
            const r = e.indexOf(t, n);
            return -1 !== r && r === n
        }
        ,
        toArray: e=>{
            if (!e)
                return null;
            if (Uq(e))
                return e;
            let t = e.length;
            if (!Hq(t))
                return null;
            const n = new Array(t);
            for (; t-- > 0; )
                n[t] = e[t];
            return n
        }
        ,
        forEachEntry: (e,t)=>{
            const n = (e && e[Symbol.iterator]).call(e);
            let r;
            for (; (r = n.next()) && !r.done; ) {
                const n = r.value;
                t.call(e, n[0], n[1])
            }
        }
        ,
        matchAll: (e,t)=>{
            let n;
            const r = [];
            for (; null !== (n = e.exec(t)); )
                r.push(n);
            return r
        }
        ,
        isHTMLForm: lH,
        hasOwnProperty: cH,
        hasOwnProp: cH,
        reduceDescriptors: dH,
        freezeMethods: e=>{
            dH(e, ((t,n)=>{
                if (qq(e) && -1 !== ["arguments", "caller", "callee"].indexOf(n))
                    return !1;
                const r = e[n];
                qq(r) && (t.enumerable = !1,
                "writable"in t ? t.writable = !1 : t.set || (t.set = ()=>{
                    throw Error("Can not rewrite read-only method '" + n + "'")
                }
                ))
            }
            ))
        }
        ,
        toObjectSet: (e,t)=>{
            const n = {}
              , r = e=>{
                e.forEach((e=>{
                    n[e] = !0
                }
                ))
            }
            ;
            return Uq(e) ? r(e) : r(String(e).split(t)),
            n
        }
        ,
        toCamelCase: e=>e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function(e, t, n) {
            return t.toUpperCase() + n
        }
        )),
        noop: ()=>{}
        ,
        toFiniteNumber: (e,t)=>null != e && Number.isFinite(e = +e) ? e : t,
        findKey: oH,
        global: iH,
        isContextDefined: aH,
        ALPHABET: fH,
        generateString: (e=16,t=fH.ALPHA_DIGIT)=>{
            let n = "";
            const {length: r} = t;
            for (; e--; )
                n += t[Math.random() * r | 0];
            return n
        }
        ,
        isSpecCompliantForm: function(e) {
            return !!(e && qq(e.append) && "FormData" === e[Symbol.toStringTag] && e[Symbol.iterator])
        },
        toJSONObject: e=>{
            const t = new Array(10)
              , n = (e,r)=>{
                if (Zq(e)) {
                    if (t.indexOf(e) >= 0)
                        return;
                    if (!("toJSON"in e)) {
                        t[r] = e;
                        const o = Uq(e) ? [] : {};
                        return rH(e, ((e,t)=>{
                            const i = n(e, r + 1);
                            !Fq(i) && (o[t] = i)
                        }
                        )),
                        t[r] = void 0,
                        o
                    }
                }
                return e
            }
            ;
            return n(e, 0)
        }
        ,
        isAsyncFn: mH,
        isThenable: e=>e && (Zq(e) || qq(e)) && qq(e.then) && qq(e.catch)
    };
    function bH(e, t, n, r, o) {
        Error.call(this),
        Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack,
        this.message = e,
        this.name = "AxiosError",
        t && (this.code = t),
        n && (this.config = n),
        r && (this.request = r),
        o && (this.response = o)
    }
    gH.inherits(bH, Error, {
        toJSON: function() {
            return {
                message: this.message,
                name: this.name,
                description: this.description,
                number: this.number,
                fileName: this.fileName,
                lineNumber: this.lineNumber,
                columnNumber: this.columnNumber,
                stack: this.stack,
                config: gH.toJSONObject(this.config),
                code: this.code,
                status: this.response && this.response.status ? this.response.status : null
            }
        }
    });
    const OH = bH.prototype
      , vH = {};
    ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((e=>{
        vH[e] = {
            value: e
        }
    }
    )),
    Object.defineProperties(bH, vH),
    Object.defineProperty(OH, "isAxiosError", {
        value: !0
    }),
    bH.from = (e,t,n,r,o,i)=>{
        const a = Object.create(OH);
        return gH.toFlatObject(e, a, (function(e) {
            return e !== Error.prototype
        }
        ), (e=>"isAxiosError" !== e)),
        bH.call(a, e.message, t, n, r, o),
        a.cause = e,
        a.name = e.name,
        i && Object.assign(a, i),
        a
    }
    ;
    function yH(e) {
        return gH.isPlainObject(e) || gH.isArray(e)
    }
    function wH(e) {
        return gH.endsWith(e, "[]") ? e.slice(0, -2) : e
    }
    function _H(e, t, n) {
        return e ? e.concat(t).map((function(e, t) {
            return e = wH(e),
            !n && t ? "[" + e + "]" : e
        }
        )).join(n ? "." : "") : t
    }
    const kH = gH.toFlatObject(gH, {}, null, (function(e) {
        return /^is[A-Z]/.test(e)
    }
    ));
    function SH(e, t, n) {
        if (!gH.isObject(e))
            throw new TypeError("target must be an object");
        t = t || new FormData;
        const r = (n = gH.toFlatObject(n, {
            metaTokens: !0,
            dots: !1,
            indexes: !1
        }, !1, (function(e, t) {
            return !gH.isUndefined(t[e])
        }
        ))).metaTokens
          , o = n.visitor || c
          , i = n.dots
          , a = n.indexes
          , s = (n.Blob || "undefined" != typeof Blob && Blob) && gH.isSpecCompliantForm(t);
        if (!gH.isFunction(o))
            throw new TypeError("visitor must be a function");
        function l(e) {
            if (null === e)
                return "";
            if (gH.isDate(e))
                return e.toISOString();
            if (!s && gH.isBlob(e))
                throw new bH("Blob is not supported. Use a Buffer instead.");
            return gH.isArrayBuffer(e) || gH.isTypedArray(e) ? s && "function" == typeof Blob ? new Blob([e]) : Buffer.from(e) : e
        }
        function c(e, n, o) {
            let s = e;
            if (e && !o && "object" == typeof e)
                if (gH.endsWith(n, "{}"))
                    n = r ? n : n.slice(0, -2),
                    e = JSON.stringify(e);
                else if (gH.isArray(e) && function(e) {
                    return gH.isArray(e) && !e.some(yH)
                }(e) || (gH.isFileList(e) || gH.endsWith(n, "[]")) && (s = gH.toArray(e)))
                    return n = wH(n),
                    s.forEach((function(e, r) {
                        !gH.isUndefined(e) && null !== e && t.append(!0 === a ? _H([n], r, i) : null === a ? n : n + "[]", l(e))
                    }
                    )),
                    !1;
            return !!yH(e) || (t.append(_H(o, n, i), l(e)),
            !1)
        }
        const u = []
          , d = Object.assign(kH, {
            defaultVisitor: c,
            convertValue: l,
            isVisitable: yH
        });
        if (!gH.isObject(e))
            throw new TypeError("data must be an object");
        return function e(n, r) {
            if (!gH.isUndefined(n)) {
                if (-1 !== u.indexOf(n))
                    throw Error("Circular reference detected in " + r.join("."));
                u.push(n),
                gH.forEach(n, (function(n, i) {
                    !0 === (!(gH.isUndefined(n) || null === n) && o.call(t, n, gH.isString(i) ? i.trim() : i, r, d)) && e(n, r ? r.concat(i) : [i])
                }
                )),
                u.pop()
            }
        }(e),
        t
    }
    function EH(e) {
        const t = {
            "!": "%21",
            "'": "%27",
            "(": "%28",
            ")": "%29",
            "~": "%7E",
            "%20": "+",
            "%00": "\0"
        };
        return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, (function(e) {
            return t[e]
        }
        ))
    }
    function xH(e, t) {
        this._pairs = [],
        e && SH(e, this, t)
    }
    const TH = xH.prototype;
    function AH(e) {
        return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
    }
    function CH(e, t, n) {
        if (!t)
            return e;
        const r = n && n.encode || AH
          , o = n && n.serialize;
        let i;
        if (i = o ? o(t, n) : gH.isURLSearchParams(t) ? t.toString() : new xH(t,n).toString(r),
        i) {
            const t = e.indexOf("#");
            -1 !== t && (e = e.slice(0, t)),
            e += (-1 === e.indexOf("?") ? "?" : "&") + i
        }
        return e
    }
    TH.append = function(e, t) {
        this._pairs.push([e, t])
    }
    ,
    TH.toString = function(e) {
        const t = e ? function(t) {
            return e.call(this, t, EH)
        }
        : EH;
        return this._pairs.map((function(e) {
            return t(e[0]) + "=" + t(e[1])
        }
        ), "").join("&")
    }
    ;
    class PH {
        constructor() {
            this.handlers = []
        }
        use(e, t, n) {
            return this.handlers.push({
                fulfilled: e,
                rejected: t,
                synchronous: !!n && n.synchronous,
                runWhen: n ? n.runWhen : null
            }),
            this.handlers.length - 1
        }
        eject(e) {
            this.handlers[e] && (this.handlers[e] = null)
        }
        clear() {
            this.handlers && (this.handlers = [])
        }
        forEach(e) {
            gH.forEach(this.handlers, (function(t) {
                null !== t && e(t)
            }
            ))
        }
    }
    const DH = {
        silentJSONParsing: !0,
        forcedJSONParsing: !0,
        clarifyTimeoutError: !1
    }
      , RH = {
        isBrowser: !0,
        classes: {
            URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : xH,
            FormData: "undefined" != typeof FormData ? FormData : null,
            Blob: "undefined" != typeof Blob ? Blob : null
        },
        protocols: ["http", "https", "file", "blob", "url", "data"]
    }
      , NH = "undefined" != typeof window && "undefined" != typeof document
      , $H = (IH = "undefined" != typeof navigator && navigator.product,
    NH && ["ReactNative", "NativeScript", "NS"].indexOf(IH) < 0);
    var IH;
    const MH = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts
      , LH = NH && window.location.href || "http://localhost"
      , QH = {
        ...Object.freeze(Object.defineProperty({
            __proto__: null,
            hasBrowserEnv: NH,
            hasStandardBrowserEnv: $H,
            hasStandardBrowserWebWorkerEnv: MH,
            origin: LH
        }, Symbol.toStringTag, {
            value: "Module"
        })),
        ...RH
    };
    function BH(e) {
        function t(e, n, r, o) {
            let i = e[o++];
            if ("__proto__" === i)
                return !0;
            const a = Number.isFinite(+i)
              , s = o >= e.length;
            if (i = !i && gH.isArray(r) ? r.length : i,
            s)
                return gH.hasOwnProp(r, i) ? r[i] = [r[i], n] : r[i] = n,
                !a;
            r[i] && gH.isObject(r[i]) || (r[i] = []);
            return t(e, n, r[i], o) && gH.isArray(r[i]) && (r[i] = function(e) {
                const t = {}
                  , n = Object.keys(e);
                let r;
                const o = n.length;
                let i;
                for (r = 0; r < o; r++)
                    i = n[r],
                    t[i] = e[i];
                return t
            }(r[i])),
            !a
        }
        if (gH.isFormData(e) && gH.isFunction(e.entries)) {
            const n = {};
            return gH.forEachEntry(e, ((e,r)=>{
                t(function(e) {
                    return gH.matchAll(/\w+|\[(\w*)]/g, e).map((e=>"[]" === e[0] ? "" : e[1] || e[0]))
                }(e), r, n, 0)
            }
            )),
            n
        }
        return null
    }
    const UH = {
        transitional: DH,
        adapter: ["xhr", "http", "fetch"],
        transformRequest: [function(e, t) {
            const n = t.getContentType() || ""
              , r = n.indexOf("application/json") > -1
              , o = gH.isObject(e);
            o && gH.isHTMLForm(e) && (e = new FormData(e));
            if (gH.isFormData(e))
                return r ? JSON.stringify(BH(e)) : e;
            if (gH.isArrayBuffer(e) || gH.isBuffer(e) || gH.isStream(e) || gH.isFile(e) || gH.isBlob(e) || gH.isReadableStream(e))
                return e;
            if (gH.isArrayBufferView(e))
                return e.buffer;
            if (gH.isURLSearchParams(e))
                return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
                e.toString();
            let i;
            if (o) {
                if (n.indexOf("application/x-www-form-urlencoded") > -1)
                    return function(e, t) {
                        return SH(e, new QH.classes.URLSearchParams, Object.assign({
                            visitor: function(e, t, n, r) {
                                return QH.isNode && gH.isBuffer(e) ? (this.append(t, e.toString("base64")),
                                !1) : r.defaultVisitor.apply(this, arguments)
                            }
                        }, t))
                    }(e, this.formSerializer).toString();
                if ((i = gH.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
                    const t = this.env && this.env.FormData;
                    return SH(i ? {
                        "files[]": e
                    } : e, t && new t, this.formSerializer)
                }
            }
            return o || r ? (t.setContentType("application/json", !1),
            function(e, t, n) {
                if (gH.isString(e))
                    try {
                        return (t || JSON.parse)(e),
                        gH.trim(e)
                    } catch (Aa) {
                        if ("SyntaxError" !== Aa.name)
                            throw Aa
                    }
                return (n || JSON.stringify)(e)
            }(e)) : e
        }
        ],
        transformResponse: [function(e) {
            const t = this.transitional || UH.transitional
              , n = t && t.forcedJSONParsing
              , r = "json" === this.responseType;
            if (gH.isResponse(e) || gH.isReadableStream(e))
                return e;
            if (e && gH.isString(e) && (n && !this.responseType || r)) {
                const n = !(t && t.silentJSONParsing) && r;
                try {
                    return JSON.parse(e)
                } catch (Aa) {
                    if (n) {
                        if ("SyntaxError" === Aa.name)
                            throw bH.from(Aa, bH.ERR_BAD_RESPONSE, this, null, this.response);
                        throw Aa
                    }
                }
            }
            return e
        }
        ],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        env: {
            FormData: QH.classes.FormData,
            Blob: QH.classes.Blob
        },
        validateStatus: function(e) {
            return e >= 200 && e < 300
        },
        headers: {
            common: {
                Accept: "application/json, text/plain, */*",
                "Content-Type": void 0
            }
        }
    };
    gH.forEach(["delete", "get", "head", "post", "put", "patch"], (e=>{
        UH.headers[e] = {}
    }
    ));
    const FH = gH.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"])
      , jH = Symbol("internals");
    function zH(e) {
        return e && String(e).trim().toLowerCase()
    }
    function qH(e) {
        return !1 === e || null == e ? e : gH.isArray(e) ? e.map(qH) : String(e)
    }
    function HH(e, t, n, r, o) {
        return gH.isFunction(r) ? r.call(this, t, n) : (o && (t = n),
        gH.isString(t) ? gH.isString(r) ? -1 !== t.indexOf(r) : gH.isRegExp(r) ? r.test(t) : void 0 : void 0)
    }
    let ZH = class {
        constructor(e) {
            e && this.set(e)
        }
        set(e, t, n) {
            const r = this;
            function o(e, t, n) {
                const o = zH(t);
                if (!o)
                    throw new Error("header name must be a non-empty string");
                const i = gH.findKey(r, o);
                (!i || void 0 === r[i] || !0 === n || void 0 === n && !1 !== r[i]) && (r[i || t] = qH(e))
            }
            const i = (e,t)=>gH.forEach(e, ((e,n)=>o(e, n, t)));
            if (gH.isPlainObject(e) || e instanceof this.constructor)
                i(e, t);
            else if (gH.isString(e) && (e = e.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()))
                i((e=>{
                    const t = {};
                    let n, r, o;
                    return e && e.split("\n").forEach((function(e) {
                        o = e.indexOf(":"),
                        n = e.substring(0, o).trim().toLowerCase(),
                        r = e.substring(o + 1).trim(),
                        !n || t[n] && FH[n] || ("set-cookie" === n ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r)
                    }
                    )),
                    t
                }
                )(e), t);
            else if (gH.isHeaders(e))
                for (const [a,s] of e.entries())
                    o(s, a, n);
            else
                null != e && o(t, e, n);
            return this
        }
        get(e, t) {
            if (e = zH(e)) {
                const n = gH.findKey(this, e);
                if (n) {
                    const e = this[n];
                    if (!t)
                        return e;
                    if (!0 === t)
                        return function(e) {
                            const t = Object.create(null)
                              , n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                            let r;
                            for (; r = n.exec(e); )
                                t[r[1]] = r[2];
                            return t
                        }(e);
                    if (gH.isFunction(t))
                        return t.call(this, e, n);
                    if (gH.isRegExp(t))
                        return t.exec(e);
                    throw new TypeError("parser must be boolean|regexp|function")
                }
            }
        }
        has(e, t) {
            if (e = zH(e)) {
                const n = gH.findKey(this, e);
                return !(!n || void 0 === this[n] || t && !HH(0, this[n], n, t))
            }
            return !1
        }
        delete(e, t) {
            const n = this;
            let r = !1;
            function o(e) {
                if (e = zH(e)) {
                    const o = gH.findKey(n, e);
                    !o || t && !HH(0, n[o], o, t) || (delete n[o],
                    r = !0)
                }
            }
            return gH.isArray(e) ? e.forEach(o) : o(e),
            r
        }
        clear(e) {
            const t = Object.keys(this);
            let n = t.length
              , r = !1;
            for (; n--; ) {
                const o = t[n];
                e && !HH(0, this[o], o, e, !0) || (delete this[o],
                r = !0)
            }
            return r
        }
        normalize(e) {
            const t = this
              , n = {};
            return gH.forEach(this, ((r,o)=>{
                const i = gH.findKey(n, o);
                if (i)
                    return t[i] = qH(r),
                    void delete t[o];
                const a = e ? function(e) {
                    return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ((e,t,n)=>t.toUpperCase() + n))
                }(o) : String(o).trim();
                a !== o && delete t[o],
                t[a] = qH(r),
                n[a] = !0
            }
            )),
            this
        }
        concat(...e) {
            return this.constructor.concat(this, ...e)
        }
        toJSON(e) {
            const t = Object.create(null);
            return gH.forEach(this, ((n,r)=>{
                null != n && !1 !== n && (t[r] = e && gH.isArray(n) ? n.join(", ") : n)
            }
            )),
            t
        }
        [Symbol.iterator]() {
            return Object.entries(this.toJSON())[Symbol.iterator]()
        }
        toString() {
            return Object.entries(this.toJSON()).map((([e,t])=>e + ": " + t)).join("\n")
        }
        get[Symbol.toStringTag]() {
            return "AxiosHeaders"
        }
        static from(e) {
            return e instanceof this ? e : new this(e)
        }
        static concat(e, ...t) {
            const n = new this(e);
            return t.forEach((e=>n.set(e))),
            n
        }
        static accessor(e) {
            const t = (this[jH] = this[jH] = {
                accessors: {}
            }).accessors
              , n = this.prototype;
            function r(e) {
                const r = zH(e);
                t[r] || (!function(e, t) {
                    const n = gH.toCamelCase(" " + t);
                    ["get", "set", "has"].forEach((r=>{
                        Object.defineProperty(e, r + n, {
                            value: function(e, n, o) {
                                return this[r].call(this, t, e, n, o)
                            },
                            configurable: !0
                        })
                    }
                    ))
                }(n, e),
                t[r] = !0)
            }
            return gH.isArray(e) ? e.forEach(r) : r(e),
            this
        }
    }
    ;
    function WH(e, t) {
        const n = this || UH
          , r = t || n
          , o = ZH.from(r.headers);
        let i = r.data;
        return gH.forEach(e, (function(e) {
            i = e.call(n, i, o.normalize(), t ? t.status : void 0)
        }
        )),
        o.normalize(),
        i
    }
    function XH(e) {
        return !(!e || !e.__CANCEL__)
    }
    function VH(e, t, n) {
        bH.call(this, null == e ? "canceled" : e, bH.ERR_CANCELED, t, n),
        this.name = "CanceledError"
    }
    function GH(e, t, n) {
        const r = n.config.validateStatus;
        n.status && r && !r(n.status) ? t(new bH("Request failed with status code " + n.status,[bH.ERR_BAD_REQUEST, bH.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],n.config,n.request,n)) : e(n)
    }
    ZH.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]),
    gH.reduceDescriptors(ZH.prototype, (({value: e},t)=>{
        let n = t[0].toUpperCase() + t.slice(1);
        return {
            get: ()=>e,
            set(e) {
                this[n] = e
            }
        }
    }
    )),
    gH.freezeMethods(ZH),
    gH.inherits(VH, bH, {
        __CANCEL__: !0
    });
    const YH = (e,t,n=3)=>{
        let r = 0;
        const o = function(e, t) {
            e = e || 10;
            const n = new Array(e)
              , r = new Array(e);
            let o, i = 0, a = 0;
            return t = void 0 !== t ? t : 1e3,
            function(s) {
                const l = Date.now()
                  , c = r[a];
                o || (o = l),
                n[i] = s,
                r[i] = l;
                let u = a
                  , d = 0;
                for (; u !== i; )
                    d += n[u++],
                    u %= e;
                if (i = (i + 1) % e,
                i === a && (a = (a + 1) % e),
                l - o < t)
                    return;
                const p = c && l - c;
                return p ? Math.round(1e3 * d / p) : void 0
            }
        }(50, 250);
        return function(e, t) {
            let n = 0;
            const r = 1e3 / t;
            let o = null;
            return function() {
                const t = !0 === this
                  , i = Date.now();
                if (t || i - n > r)
                    return o && (clearTimeout(o),
                    o = null),
                    n = i,
                    e.apply(null, arguments);
                o || (o = setTimeout((()=>(o = null,
                n = Date.now(),
                e.apply(null, arguments))), r - (i - n)))
            }
        }((n=>{
            const i = n.loaded
              , a = n.lengthComputable ? n.total : void 0
              , s = i - r
              , l = o(s);
            r = i;
            const c = {
                loaded: i,
                total: a,
                progress: a ? i / a : void 0,
                bytes: s,
                rate: l || void 0,
                estimated: l && a && i <= a ? (a - i) / l : void 0,
                event: n,
                lengthComputable: null != a
            };
            c[t ? "download" : "upload"] = !0,
            e(c)
        }
        ), n)
    }
      , KH = QH.hasStandardBrowserEnv ? function() {
        const e = /(msie|trident)/i.test(navigator.userAgent)
          , t = document.createElement("a");
        let n;
        function r(n) {
            let r = n;
            return e && (t.setAttribute("href", r),
            r = t.href),
            t.setAttribute("href", r),
            {
                href: t.href,
                protocol: t.protocol ? t.protocol.replace(/:$/, "") : "",
                host: t.host,
                search: t.search ? t.search.replace(/^\?/, "") : "",
                hash: t.hash ? t.hash.replace(/^#/, "") : "",
                hostname: t.hostname,
                port: t.port,
                pathname: "/" === t.pathname.charAt(0) ? t.pathname : "/" + t.pathname
            }
        }
        return n = r(window.location.href),
        function(e) {
            const t = gH.isString(e) ? r(e) : e;
            return t.protocol === n.protocol && t.host === n.host
        }
    }() : function() {
        return function() {
            return !0
        }
    }()
      , JH = QH.hasStandardBrowserEnv ? {
        write(e, t, n, r, o, i) {
            const a = [e + "=" + encodeURIComponent(t)];
            gH.isNumber(n) && a.push("expires=" + new Date(n).toGMTString()),
            gH.isString(r) && a.push("path=" + r),
            gH.isString(o) && a.push("domain=" + o),
            !0 === i && a.push("secure"),
            document.cookie = a.join("; ")
        },
        read(e) {
            const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
            return t ? decodeURIComponent(t[3]) : null
        },
        remove(e) {
            this.write(e, "", Date.now() - 864e5)
        }
    } : {
        write() {},
        read: ()=>null,
        remove() {}
    };
    function eZ(e, t) {
        return e && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t) ? function(e, t) {
            return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e
        }(e, t) : t
    }
    const tZ = e=>e instanceof ZH ? {
        ...e
    } : e;
    function nZ(e, t) {
        t = t || {};
        const n = {};
        function r(e, t, n) {
            return gH.isPlainObject(e) && gH.isPlainObject(t) ? gH.merge.call({
                caseless: n
            }, e, t) : gH.isPlainObject(t) ? gH.merge({}, t) : gH.isArray(t) ? t.slice() : t
        }
        function o(e, t, n) {
            return gH.isUndefined(t) ? gH.isUndefined(e) ? void 0 : r(void 0, e, n) : r(e, t, n)
        }
        function i(e, t) {
            if (!gH.isUndefined(t))
                return r(void 0, t)
        }
        function a(e, t) {
            return gH.isUndefined(t) ? gH.isUndefined(e) ? void 0 : r(void 0, e) : r(void 0, t)
        }
        function s(n, o, i) {
            return i in t ? r(n, o) : i in e ? r(void 0, n) : void 0
        }
        const l = {
            url: i,
            method: i,
            data: i,
            baseURL: a,
            transformRequest: a,
            transformResponse: a,
            paramsSerializer: a,
            timeout: a,
            timeoutMessage: a,
            withCredentials: a,
            withXSRFToken: a,
            adapter: a,
            responseType: a,
            xsrfCookieName: a,
            xsrfHeaderName: a,
            onUploadProgress: a,
            onDownloadProgress: a,
            decompress: a,
            maxContentLength: a,
            maxBodyLength: a,
            beforeRedirect: a,
            transport: a,
            httpAgent: a,
            httpsAgent: a,
            cancelToken: a,
            socketPath: a,
            responseEncoding: a,
            validateStatus: s,
            headers: (e,t)=>o(tZ(e), tZ(t), !0)
        };
        return gH.forEach(Object.keys(Object.assign({}, e, t)), (function(r) {
            const i = l[r] || o
              , a = i(e[r], t[r], r);
            gH.isUndefined(a) && i !== s || (n[r] = a)
        }
        )),
        n
    }
    const rZ = e=>{
        const t = nZ({}, e);
        let n, {data: r, withXSRFToken: o, xsrfHeaderName: i, xsrfCookieName: a, headers: s, auth: l} = t;
        if (t.headers = s = ZH.from(s),
        t.url = CH(eZ(t.baseURL, t.url), e.params, e.paramsSerializer),
        l && s.set("Authorization", "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : ""))),
        gH.isFormData(r))
            if (QH.hasStandardBrowserEnv || QH.hasStandardBrowserWebWorkerEnv)
                s.setContentType(void 0);
            else if (!1 !== (n = s.getContentType())) {
                const [e,...t] = n ? n.split(";").map((e=>e.trim())).filter(Boolean) : [];
                s.setContentType([e || "multipart/form-data", ...t].join("; "))
            }
        if (QH.hasStandardBrowserEnv && (o && gH.isFunction(o) && (o = o(t)),
        o || !1 !== o && KH(t.url))) {
            const e = i && a && JH.read(a);
            e && s.set(i, e)
        }
        return t
    }
      , oZ = "undefined" != typeof XMLHttpRequest && function(e) {
        return new Promise((function(t, n) {
            const r = rZ(e);
            let o = r.data;
            const i = ZH.from(r.headers).normalize();
            let a, {responseType: s} = r;
            function l() {
                r.cancelToken && r.cancelToken.unsubscribe(a),
                r.signal && r.signal.removeEventListener("abort", a)
            }
            let c = new XMLHttpRequest;
            function u() {
                if (!c)
                    return;
                const r = ZH.from("getAllResponseHeaders"in c && c.getAllResponseHeaders());
                GH((function(e) {
                    t(e),
                    l()
                }
                ), (function(e) {
                    n(e),
                    l()
                }
                ), {
                    data: s && "text" !== s && "json" !== s ? c.response : c.responseText,
                    status: c.status,
                    statusText: c.statusText,
                    headers: r,
                    config: e,
                    request: c
                }),
                c = null
            }
            c.open(r.method.toUpperCase(), r.url, !0),
            c.timeout = r.timeout,
            "onloadend"in c ? c.onloadend = u : c.onreadystatechange = function() {
                c && 4 === c.readyState && (0 !== c.status || c.responseURL && 0 === c.responseURL.indexOf("file:")) && setTimeout(u)
            }
            ,
            c.onabort = function() {
                c && (n(new bH("Request aborted",bH.ECONNABORTED,r,c)),
                c = null)
            }
            ,
            c.onerror = function() {
                n(new bH("Network Error",bH.ERR_NETWORK,r,c)),
                c = null
            }
            ,
            c.ontimeout = function() {
                let e = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded";
                const t = r.transitional || DH;
                r.timeoutErrorMessage && (e = r.timeoutErrorMessage),
                n(new bH(e,t.clarifyTimeoutError ? bH.ETIMEDOUT : bH.ECONNABORTED,r,c)),
                c = null
            }
            ,
            void 0 === o && i.setContentType(null),
            "setRequestHeader"in c && gH.forEach(i.toJSON(), (function(e, t) {
                c.setRequestHeader(t, e)
            }
            )),
            gH.isUndefined(r.withCredentials) || (c.withCredentials = !!r.withCredentials),
            s && "json" !== s && (c.responseType = r.responseType),
            "function" == typeof r.onDownloadProgress && c.addEventListener("progress", YH(r.onDownloadProgress, !0)),
            "function" == typeof r.onUploadProgress && c.upload && c.upload.addEventListener("progress", YH(r.onUploadProgress)),
            (r.cancelToken || r.signal) && (a = t=>{
                c && (n(!t || t.type ? new VH(null,e,c) : t),
                c.abort(),
                c = null)
            }
            ,
            r.cancelToken && r.cancelToken.subscribe(a),
            r.signal && (r.signal.aborted ? a() : r.signal.addEventListener("abort", a)));
            const d = function(e) {
                const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
                return t && t[1] || ""
            }(r.url);
            d && -1 === QH.protocols.indexOf(d) ? n(new bH("Unsupported protocol " + d + ":",bH.ERR_BAD_REQUEST,e)) : c.send(o || null)
        }
        ))
    }
      , iZ = (e,t)=>{
        let n, r = new AbortController;
        const o = function(e) {
            if (!n) {
                n = !0,
                a();
                const t = e instanceof Error ? e : this.reason;
                r.abort(t instanceof bH ? t : new VH(t instanceof Error ? t.message : t))
            }
        };
        let i = t && setTimeout((()=>{
            o(new bH(`timeout ${t} of ms exceeded`,bH.ETIMEDOUT))
        }
        ), t);
        const a = ()=>{
            e && (i && clearTimeout(i),
            i = null,
            e.forEach((e=>{
                e && (e.removeEventListener ? e.removeEventListener("abort", o) : e.unsubscribe(o))
            }
            )),
            e = null)
        }
        ;
        e.forEach((e=>e && e.addEventListener && e.addEventListener("abort", o)));
        const {signal: s} = r;
        return s.unsubscribe = a,
        [s, ()=>{
            i && clearTimeout(i),
            i = null
        }
        ]
    }
      , aZ = function*(e, t) {
        let n = e.byteLength;
        if (!t || n < t)
            return void (yield e);
        let r, o = 0;
        for (; o < n; )
            r = o + t,
            yield e.slice(o, r),
            o = r
    }
      , sZ = (e,t,n,r,o)=>{
        const i = async function*(e, t, n) {
            for await(const r of e)
                yield*aZ(ArrayBuffer.isView(r) ? r : await n(String(r)), t)
        }(e, t, o);
        let a = 0;
        return new ReadableStream({
            type: "bytes",
            async pull(e) {
                const {done: t, value: o} = await i.next();
                if (t)
                    return e.close(),
                    void r();
                let s = o.byteLength;
                n && n(a += s),
                e.enqueue(new Uint8Array(o))
            },
            cancel: e=>(r(e),
            i.return())
        },{
            highWaterMark: 2
        })
    }
      , lZ = (e,t)=>{
        const n = null != e;
        return r=>setTimeout((()=>t({
            lengthComputable: n,
            total: e,
            loaded: r
        })))
    }
      , cZ = "function" == typeof fetch && "function" == typeof Request && "function" == typeof Response
      , uZ = cZ && "function" == typeof ReadableStream
      , dZ = cZ && ("function" == typeof TextEncoder ? (e=>t=>e.encode(t))(new TextEncoder) : async e=>new Uint8Array(await new Response(e).arrayBuffer()))
      , pZ = uZ && (()=>{
        let e = !1;
        const t = new Request(QH.origin,{
            body: new ReadableStream,
            method: "POST",
            get duplex() {
                return e = !0,
                "half"
            }
        }).headers.has("Content-Type");
        return e && !t
    }
    )()
      , hZ = uZ && !!(()=>{
        try {
            return gH.isReadableStream(new Response("").body)
        } catch (e) {}
    }
    )()
      , fZ = {
        stream: hZ && (e=>e.body)
    };
    var mZ;
    cZ && (mZ = new Response,
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e=>{
        !fZ[e] && (fZ[e] = gH.isFunction(mZ[e]) ? t=>t[e]() : (t,n)=>{
            throw new bH(`Response type '${e}' is not supported`,bH.ERR_NOT_SUPPORT,n)
        }
        )
    }
    )));
    const gZ = async(e,t)=>{
        const n = gH.toFiniteNumber(e.getContentLength());
        return null == n ? (async e=>null == e ? 0 : gH.isBlob(e) ? e.size : gH.isSpecCompliantForm(e) ? (await new Request(e).arrayBuffer()).byteLength : gH.isArrayBufferView(e) ? e.byteLength : (gH.isURLSearchParams(e) && (e += ""),
        gH.isString(e) ? (await dZ(e)).byteLength : void 0))(t) : n
    }
      , bZ = {
        http: null,
        xhr: oZ,
        fetch: cZ && (async e=>{
            let {url: t, method: n, data: r, signal: o, cancelToken: i, timeout: a, onDownloadProgress: s, onUploadProgress: l, responseType: c, headers: u, withCredentials: d="same-origin", fetchOptions: p} = rZ(e);
            c = c ? (c + "").toLowerCase() : "text";
            let h, f, [m,g] = o || i || a ? iZ([o, i], a) : [];
            const b = ()=>{
                !h && setTimeout((()=>{
                    m && m.unsubscribe()
                }
                )),
                h = !0
            }
            ;
            let O;
            try {
                if (l && pZ && "get" !== n && "head" !== n && 0 !== (O = await gZ(u, r))) {
                    let e, n = new Request(t,{
                        method: "POST",
                        body: r,
                        duplex: "half"
                    });
                    gH.isFormData(r) && (e = n.headers.get("content-type")) && u.setContentType(e),
                    n.body && (r = sZ(n.body, 65536, lZ(O, YH(l)), null, dZ))
                }
                gH.isString(d) || (d = d ? "cors" : "omit"),
                f = new Request(t,{
                    ...p,
                    signal: m,
                    method: n.toUpperCase(),
                    headers: u.normalize().toJSON(),
                    body: r,
                    duplex: "half",
                    withCredentials: d
                });
                let o = await fetch(f);
                const i = hZ && ("stream" === c || "response" === c);
                if (hZ && (s || i)) {
                    const e = {};
                    ["status", "statusText", "headers"].forEach((t=>{
                        e[t] = o[t]
                    }
                    ));
                    const t = gH.toFiniteNumber(o.headers.get("content-length"));
                    o = new Response(sZ(o.body, 65536, s && lZ(t, YH(s, !0)), i && b, dZ),e)
                }
                c = c || "text";
                let a = await fZ[gH.findKey(fZ, c) || "text"](o, e);
                return !i && b(),
                g && g(),
                await new Promise(((t,n)=>{
                    GH(t, n, {
                        data: a,
                        headers: ZH.from(o.headers),
                        status: o.status,
                        statusText: o.statusText,
                        config: e,
                        request: f
                    })
                }
                ))
            } catch (v) {
                if (b(),
                v && "TypeError" === v.name && /fetch/i.test(v.message))
                    throw Object.assign(new bH("Network Error",bH.ERR_NETWORK,e,f), {
                        cause: v.cause || v
                    });
                throw bH.from(v, v && v.code, e, f)
            }
        }
        )
    };
    gH.forEach(bZ, ((e,t)=>{
        if (e) {
            try {
                Object.defineProperty(e, "name", {
                    value: t
                })
            } catch (Aa) {}
            Object.defineProperty(e, "adapterName", {
                value: t
            })
        }
    }
    ));
    const OZ = e=>`- ${e}`
      , vZ = e=>gH.isFunction(e) || null === e || !1 === e
      , yZ = e=>{
        e = gH.isArray(e) ? e : [e];
        const {length: t} = e;
        let n, r;
        const o = {};
        for (let i = 0; i < t; i++) {
            let t;
            if (n = e[i],
            r = n,
            !vZ(n) && (r = bZ[(t = String(n)).toLowerCase()],
            void 0 === r))
                throw new bH(`Unknown adapter '${t}'`);
            if (r)
                break;
            o[t || "#" + i] = r
        }
        if (!r) {
            const e = Object.entries(o).map((([e,t])=>`adapter ${e} ` + (!1 === t ? "is not supported by the environment" : "is not available in the build")));
            throw new bH("There is no suitable adapter to dispatch the request " + (t ? e.length > 1 ? "since :\n" + e.map(OZ).join("\n") : " " + OZ(e[0]) : "as no adapter specified"),"ERR_NOT_SUPPORT")
        }
        return r
    }
    ;
    function wZ(e) {
        if (e.cancelToken && e.cancelToken.throwIfRequested(),
        e.signal && e.signal.aborted)
            throw new VH(null,e)
    }
    function _Z(e) {
        wZ(e),
        e.headers = ZH.from(e.headers),
        e.data = WH.call(e, e.transformRequest),
        -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1);
        return yZ(e.adapter || UH.adapter)(e).then((function(t) {
            return wZ(e),
            t.data = WH.call(e, e.transformResponse, t),
            t.headers = ZH.from(t.headers),
            t
        }
        ), (function(t) {
            return XH(t) || (wZ(e),
            t && t.response && (t.response.data = WH.call(e, e.transformResponse, t.response),
            t.response.headers = ZH.from(t.response.headers))),
            Promise.reject(t)
        }
        ))
    }
    const kZ = "1.7.2"
      , SZ = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(((e,t)=>{
        SZ[e] = function(n) {
            return typeof n === e || "a" + (t < 1 ? "n " : " ") + e
        }
    }
    ));
    const EZ = {};
    SZ.transitional = function(e, t, n) {
        function r(e, t) {
            return "[Axios v1.7.2] Transitional option '" + e + "'" + t + (n ? ". " + n : "")
        }
        return (n,o,i)=>{
            if (!1 === e)
                throw new bH(r(o, " has been removed" + (t ? " in " + t : "")),bH.ERR_DEPRECATED);
            return t && !EZ[o] && (EZ[o] = !0,
            console.warn(r(o, " has been deprecated since v" + t + " and will be removed in the near future"))),
            !e || e(n, o, i)
        }
    }
    ;
    const xZ = {
        assertOptions: function(e, t, n) {
            if ("object" != typeof e)
                throw new bH("options must be an object",bH.ERR_BAD_OPTION_VALUE);
            const r = Object.keys(e);
            let o = r.length;
            for (; o-- > 0; ) {
                const i = r[o]
                  , a = t[i];
                if (a) {
                    const t = e[i]
                      , n = void 0 === t || a(t, i, e);
                    if (!0 !== n)
                        throw new bH("option " + i + " must be " + n,bH.ERR_BAD_OPTION_VALUE)
                } else if (!0 !== n)
                    throw new bH("Unknown option " + i,bH.ERR_BAD_OPTION)
            }
        },
        validators: SZ
    }
      , TZ = xZ.validators;
    let AZ = class {
        constructor(e) {
            this.defaults = e,
            this.interceptors = {
                request: new PH,
                response: new PH
            }
        }
        async request(e, t) {
            try {
                return await this._request(e, t)
            } catch (n) {
                if (n instanceof Error) {
                    let e;
                    Error.captureStackTrace ? Error.captureStackTrace(e = {}) : e = new Error;
                    const t = e.stack ? e.stack.replace(/^.+\n/, "") : "";
                    try {
                        n.stack ? t && !String(n.stack).endsWith(t.replace(/^.+\n.+\n/, "")) && (n.stack += "\n" + t) : n.stack = t
                    } catch (Aa) {}
                }
                throw n
            }
        }
        _request(e, t) {
            "string" == typeof e ? (t = t || {}).url = e : t = e || {},
            t = nZ(this.defaults, t);
            const {transitional: n, paramsSerializer: r, headers: o} = t;
            void 0 !== n && xZ.assertOptions(n, {
                silentJSONParsing: TZ.transitional(TZ.boolean),
                forcedJSONParsing: TZ.transitional(TZ.boolean),
                clarifyTimeoutError: TZ.transitional(TZ.boolean)
            }, !1),
            null != r && (gH.isFunction(r) ? t.paramsSerializer = {
                serialize: r
            } : xZ.assertOptions(r, {
                encode: TZ.function,
                serialize: TZ.function
            }, !0)),
            t.method = (t.method || this.defaults.method || "get").toLowerCase();
            let i = o && gH.merge(o.common, o[t.method]);
            o && gH.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (e=>{
                delete o[e]
            }
            )),
            t.headers = ZH.concat(i, o);
            const a = [];
            let s = !0;
            this.interceptors.request.forEach((function(e) {
                "function" == typeof e.runWhen && !1 === e.runWhen(t) || (s = s && e.synchronous,
                a.unshift(e.fulfilled, e.rejected))
            }
            ));
            const l = [];
            let c;
            this.interceptors.response.forEach((function(e) {
                l.push(e.fulfilled, e.rejected)
            }
            ));
            let u, d = 0;
            if (!s) {
                const e = [_Z.bind(this), void 0];
                for (e.unshift.apply(e, a),
                e.push.apply(e, l),
                u = e.length,
                c = Promise.resolve(t); d < u; )
                    c = c.then(e[d++], e[d++]);
                return c
            }
            u = a.length;
            let p = t;
            for (d = 0; d < u; ) {
                const e = a[d++]
                  , t = a[d++];
                try {
                    p = e(p)
                } catch (h) {
                    t.call(this, h);
                    break
                }
            }
            try {
                c = _Z.call(this, p)
            } catch (h) {
                return Promise.reject(h)
            }
            for (d = 0,
            u = l.length; d < u; )
                c = c.then(l[d++], l[d++]);
            return c
        }
        getUri(e) {
            return CH(eZ((e = nZ(this.defaults, e)).baseURL, e.url), e.params, e.paramsSerializer)
        }
    }
    ;
    gH.forEach(["delete", "get", "head", "options"], (function(e) {
        AZ.prototype[e] = function(t, n) {
            return this.request(nZ(n || {}, {
                method: e,
                url: t,
                data: (n || {}).data
            }))
        }
    }
    )),
    gH.forEach(["post", "put", "patch"], (function(e) {
        function t(t) {
            return function(n, r, o) {
                return this.request(nZ(o || {}, {
                    method: e,
                    headers: t ? {
                        "Content-Type": "multipart/form-data"
                    } : {},
                    url: n,
                    data: r
                }))
            }
        }
        AZ.prototype[e] = t(),
        AZ.prototype[e + "Form"] = t(!0)
    }
    ));
    const CZ = {
        Continue: 100,
        SwitchingProtocols: 101,
        Processing: 102,
        EarlyHints: 103,
        Ok: 200,
        Created: 201,
        Accepted: 202,
        NonAuthoritativeInformation: 203,
        NoContent: 204,
        ResetContent: 205,
        PartialContent: 206,
        MultiStatus: 207,
        AlreadyReported: 208,
        ImUsed: 226,
        MultipleChoices: 300,
        MovedPermanently: 301,
        Found: 302,
        SeeOther: 303,
        NotModified: 304,
        UseProxy: 305,
        Unused: 306,
        TemporaryRedirect: 307,
        PermanentRedirect: 308,
        BadRequest: 400,
        Unauthorized: 401,
        PaymentRequired: 402,
        Forbidden: 403,
        NotFound: 404,
        MethodNotAllowed: 405,
        NotAcceptable: 406,
        ProxyAuthenticationRequired: 407,
        RequestTimeout: 408,
        Conflict: 409,
        Gone: 410,
        LengthRequired: 411,
        PreconditionFailed: 412,
        PayloadTooLarge: 413,
        UriTooLong: 414,
        UnsupportedMediaType: 415,
        RangeNotSatisfiable: 416,
        ExpectationFailed: 417,
        ImATeapot: 418,
        MisdirectedRequest: 421,
        UnprocessableEntity: 422,
        Locked: 423,
        FailedDependency: 424,
        TooEarly: 425,
        UpgradeRequired: 426,
        PreconditionRequired: 428,
        TooManyRequests: 429,
        RequestHeaderFieldsTooLarge: 431,
        UnavailableForLegalReasons: 451,
        InternalServerError: 500,
        NotImplemented: 501,
        BadGateway: 502,
        ServiceUnavailable: 503,
        GatewayTimeout: 504,
        HttpVersionNotSupported: 505,
        VariantAlsoNegotiates: 506,
        InsufficientStorage: 507,
        LoopDetected: 508,
        NotExtended: 510,
        NetworkAuthenticationRequired: 511
    };
    Object.entries(CZ).forEach((([e,t])=>{
        CZ[t] = e
    }
    ));
    const PZ = function e(t) {
        const n = new AZ(t)
          , r = $q(AZ.prototype.request, n);
        return gH.extend(r, AZ.prototype, n, {
            allOwnKeys: !0
        }),
        gH.extend(r, n, null, {
            allOwnKeys: !0
        }),
        r.create = function(n) {
            return e(nZ(t, n))
        }
        ,
        r
    }(UH);
    PZ.Axios = AZ,
    PZ.CanceledError = VH,
    PZ.CancelToken = class e {
        constructor(e) {
            if ("function" != typeof e)
                throw new TypeError("executor must be a function.");
            let t;
            this.promise = new Promise((function(e) {
                t = e
            }
            ));
            const n = this;
            this.promise.then((e=>{
                if (!n._listeners)
                    return;
                let t = n._listeners.length;
                for (; t-- > 0; )
                    n._listeners[t](e);
                n._listeners = null
            }
            )),
            this.promise.then = e=>{
                let t;
                const r = new Promise((e=>{
                    n.subscribe(e),
                    t = e
                }
                )).then(e);
                return r.cancel = function() {
                    n.unsubscribe(t)
                }
                ,
                r
            }
            ,
            e((function(e, r, o) {
                n.reason || (n.reason = new VH(e,r,o),
                t(n.reason))
            }
            ))
        }
        throwIfRequested() {
            if (this.reason)
                throw this.reason
        }
        subscribe(e) {
            this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e]
        }
        unsubscribe(e) {
            if (!this._listeners)
                return;
            const t = this._listeners.indexOf(e);
            -1 !== t && this._listeners.splice(t, 1)
        }
        static source() {
            let t;
            return {
                token: new e((function(e) {
                    t = e
                }
                )),
                cancel: t
            }
        }
    }
    ,
    PZ.isCancel = XH,
    PZ.VERSION = kZ,
    PZ.toFormData = SH,
    PZ.AxiosError = bH,
    PZ.Cancel = PZ.CanceledError,
    PZ.all = function(e) {
        return Promise.all(e)
    }
    ,
    PZ.spread = function(e) {
        return function(t) {
            return e.apply(null, t)
        }
    }
    ,
    PZ.isAxiosError = function(e) {
        return gH.isObject(e) && !0 === e.isAxiosError
    }
    ,
    PZ.mergeConfig = nZ,
    PZ.AxiosHeaders = ZH,
    PZ.formToJSON = e=>BH(gH.isHTMLForm(e) ? new FormData(e) : e),
    PZ.getAdapter = yZ,
    PZ.HttpStatusCode = CZ,
    PZ.default = PZ;
    const {Axios: DZ, AxiosError: RZ, CanceledError: NZ, isCancel: $Z, CancelToken: IZ, VERSION: MZ, all: LZ, Cancel: QZ, isAxiosError: BZ, spread: UZ, toFormData: FZ, AxiosHeaders: jZ, HttpStatusCode: zZ, formToJSON: qZ, getAdapter: HZ, mergeConfig: ZZ} = PZ;
    function WZ(e, t) {
        const n = new URL(t);
        return n.href = e,
        n.searchParams.append("scalar_url", encodeURI(t)),
        n.toString()
    }
    const XZ = "GET"
      , VZ = e=>{
        if ("string" != typeof e)
            return console.warn(`Request method is not a string. Using ${XZ} as the default.`),
            XZ;
        const t = e.trim().toUpperCase();
        return Ql(t) ? t : (console.warn(`${e} is not a valid request method. Using ${XZ} as the default.`),
        XZ)
    }
    ;
    function GZ(e, t, n) {
        const r = {};
        return e.forEach((e=>{
            r[e[t]] = e[n]
        }
        )),
        r
    }
    const YZ = e=>{
        if ("string" != typeof e)
            return console.warn("[sendRequest] URL is not a string. Using an empty string as the default."),
            "";
        let t = e;
        return t.startsWith("http") || (console.warn("[sendRequest] URL does not start with http. Adding http:// as the default prefix."),
        t = `http://${t}`),
        t.trim()
    }
      , KZ = e=>{
        if ("string" != typeof e)
            return "";
        let t = e.trim();
        return t.length > 1 && t.startsWith("/") && (t = t.slice(1)),
        t
    }
      , JZ = (e,t)=>{
        if ("string" != typeof t || !t.length)
            return e;
        const n = e.trim()
          , r = t.trim();
        return [n.endsWith("/") ? n : `${n}/`, r.startsWith("/") ? r.slice(1) : r].join("")
    }
    ;
    function eW(e, t) {
        const n = (e,n)=>{
            var r;
            return "function" == typeof t ? t(n) : null == (r = t[n]) ? void 0 : r.toString()
        }
        ;
        return e.replace(/{{\s*([\w.-]+)\s*}}/g, n).replace(/{\s*([\w.-]+)\s*}/g, n)
    }
    async function tW(e, t) {
        var n;
        const r = VZ(e.type)
          , o = GZ((e.headers ?? []).filter((e=>e.enabled)), "name", "value")
          , i = YZ(e.url)
          , a = KZ(e.path)
          , [s,...l] = JZ(i, a).split("?")
          , c = eW(s, GZ((e.variables ?? []).filter((e=>e.enabled)), "name", "value"))
          , u = [];
        l.forEach((e=>{
            new URLSearchParams(e ?? "").forEach(((e,t)=>{
                u.push({
                    name: t,
                    value: e,
                    enabled: !0
                })
            }
            ))
        }
        ));
        const d = new URLSearchParams(GZ([...(e.query ?? []).filter((e=>e.enabled)), ...u], "name", "value")).toString()
          , p = `${c}${d ? "?" + d : ""}`
          , h = Date.now();
        if (e.cookies && (null == (n = e.cookies) ? void 0 : n.length) > 0) {
            const t = GZ((e.cookies ?? []).filter((e=>e.enabled)), "name", "value");
            o.Cookie = Object.keys(t).map((e=>`${e}=${t[e]}`)).join("; ")
        }
        const f = {
            method: r,
            url: p,
            auth: {
                type: "none"
            },
            headers: o,
            data: e.body
        }
          , m = t && !function(e) {
            const {hostname: t} = new URL(e);
            return ["localhost", "127.0.0.1", "[::1]"].includes(t)
        }(f.url)
          , g = {
            method: f.method,
            url: m ? WZ(t, f.url) : f.url,
            headers: f.headers,
            data: f.data
        };
        o.cookies && (g.withCredentials = !0),
        console.info(m ? `${f.method} ${f.url} (proxy: ${t})` : `${f.method} ${f.url}`);
        const b = await PZ(g).then((e=>({
            ...e,
            statusCode: e.status,
            data: e.data,
            error: !1
        }))).catch((e=>{
            var t, n;
            const {response: r} = e;
            return console.error("ERROR", e),
            {
                data: e.code ?? e.message,
                ...r,
                statusCode: (null == r ? void 0 : r.status) ?? 0,
                error: {
                    message: (null == (t = null == r ? void 0 : r.data) ? void 0 : t.message) ?? e.message,
                    stack: (null == (n = null == r ? void 0 : r.data) ? void 0 : n.stack) ?? e.stack
                }
            }
        }
        ));
        return {
            sentTime: Date.now(),
            request: {
                ...e,
                type: r,
                url: i,
                path: a
            },
            response: {
                ...b,
                duration: Date.now() - h
            },
            responseId: yC()
        }
    }
    const nW = e=>(cn("data-v-c2ef499b"),
    e = e(),
    un(),
    e)
      , rW = {
        key: 0,
        class: "loader"
    }
      , oW = {
        class: "url-form"
    }
      , iW = {
        class: "url-form-field"
    }
      , aW = {
        class: "url-form-input-wrapper cm-scroller"
    }
      , sW = nW((()=>Eo("div", {
        class: "url-form-input-fade__left"
    }, null, -1)))
      , lW = nW((()=>Eo("div", {
        class: "url-form-input-fade__right"
    }, null, -1)))
      , cW = {
        key: 0,
        class: "history"
    }
      , uW = [nW((()=>Eo("svg", {
        fill: "none",
        height: "48",
        viewBox: "0 0 14 14",
        width: "48",
        xmlns: "http://www.w3.org/2000/svg"
    }, [Eo("g", {
        id: "rewind-clock--back-return-clock-timer-countdown"
    }, [Eo("path", {
        id: "Vector 1561 (Stroke)",
        "clip-rule": "evenodd",
        d: "M6.99999 2.75C7.4142 2.75 7.74999 3.08579 7.74999 3.5V7.5C7.74999 7.76345 7.61177 8.00758 7.38586 8.14312L4.88586 9.64312C4.53068 9.85623 4.06998 9.74106 3.85687 9.38587C3.64376 9.03069 3.75893 8.56999 4.11412 8.35688L6.24999 7.07536V3.5C6.24999 3.08579 6.58578 2.75 6.99999 2.75Z",
        fill: "currentColor",
        "fill-rule": "evenodd"
    }), Eo("path", {
        id: "Union",
        "clip-rule": "evenodd",
        d: "M12.5 7C12.5 3.96243 10.0376 1.5 7 1.5C5.24916 1.5 3.68853 2.31796 2.68066 3.59456L3.64645 4.56034C3.96143 4.87533 3.73835 5.4139 3.29289 5.4139H0.5C0.223857 5.4139 0 5.19004 0 4.9139V2.121C0 1.67555 0.53857 1.45247 0.853553 1.76745L1.61439 2.52829C2.89781 0.984301 4.83356 0 7 0C10.866 0 14 3.13401 14 7C14 10.866 10.866 14 7 14C3.68902 14 0.916591 11.702 0.187329 8.61473C0.0921059 8.21161 0.341704 7.80762 0.744824 7.7124C1.14794 7.61717 1.55193 7.86677 1.64715 8.26989C2.22013 10.6955 4.40025 12.5 7 12.5C10.0376 12.5 12.5 10.0376 12.5 7Z",
        fill: "currentColor",
        "fill-rule": "evenodd"
    })])], -1)))]
      , dW = ["disabled"]
      , pW = [nW((()=>Eo("svg", {
        fill: "none",
        height: "48",
        viewBox: "0 0 14 14",
        width: "48",
        xmlns: "http://www.w3.org/2000/svg"
    }, [Eo("g", {
        id: "send-email--mail-send-email-paper-airplane"
    }, [Eo("path", {
        id: "Subtract",
        "clip-rule": "evenodd",
        d: "M11.8215 0.0977331C12.1097 -0.0075178 12.422 -0.0287134 12.7219 0.0367172C13.0248 0.102803 13.3024 0.254481 13.5216 0.473719C13.7409 0.692957 13.8926 0.970537 13.9586 1.27346C14.0241 1.57338 14.0029 1.88566 13.8976 2.17389L10.3236 12.8859L10.3234 12.8866C10.2363 13.15 10.083 13.3867 9.87813 13.5739C9.67383 13.7606 9.42512 13.8917 9.15575 13.9549C8.88633 14.0206 8.60444 14.015 8.33777 13.9388C8.07134 13.8627 7.82929 13.7187 7.63532 13.5209L5.71798 11.6123L3.70392 12.6538C3.54687 12.735 3.3586 12.7272 3.20877 12.6333C3.05895 12.5395 2.96984 12.3734 2.97443 12.1967L3.057 9.01294L10.102 3.89553C10.3812 3.69267 10.4432 3.30182 10.2403 3.02255C10.0375 2.74327 9.64662 2.68133 9.36734 2.88419L2.20286 8.0884L0.473156 6.35869L0.473098 6.35864L0.472971 6.35851C0.285648 6.17132 0.147746 5.94054 0.0716498 5.68688C-0.00390565 5.43503 -0.016181 5.16847 0.0358684 4.91079C0.087985 4.62928 0.213827 4.36658 0.400607 4.14951C0.588668 3.93095 0.831681 3.76658 1.10453 3.67339L1.1079 3.67224L1.1079 3.67225L11.8215 0.0977331Z",
        fill: "currentColor",
        "fill-rule": "evenodd"
    })])], -1))), nW((()=>Eo("span", null, "Send", -1)))]
      , hW = {
        class: "address-bar-content"
    }
      , fW = Ln({
        __name: "AddressBar",
        props: {
            proxyUrl: {}
        },
        emits: ["onSend"],
        setup(e, {emit: t}) {
            const n = e
              , r = t
              , o = Ml();
            xl($z() ? o.meta_enter : o.ctrl_enter, b);
            const i = Et(!1)
              , a = Et(!1)
              , {activeRequest: s, addRequestToHistory: l, requestHistoryOrder: c, readOnly: u, setActiveRequest: d} = eq()
              , p = Fc()
              , h = ei((()=>s.url))
              , f = ei((()=>s.type))
              , m = ei((()=>s.path))
              , g = ei((()=>`${h.value}${m.value}`));
            async function b() {
                const e = Nq({
                    request: {
                        ...s
                    }
                });
                a.value = !0,
                r("onSend");
                const t = await tW(e, n.proxyUrl);
                t && l(t),
                a.value = !1
            }
            const O = e=>{
                u.value || s.url + s.path !== e && d({
                    ...s,
                    url: e,
                    path: ""
                })
            }
              , v = e=>{
                e && d({
                    ...s,
                    type: e.toLocaleLowerCase()
                })
            }
            ;
            return (e,t)=>(mo(),
            vo(lo, null, [a.value ? (mo(),
            vo("div", rW)) : Do("", !0), Eo("div", {
                class: Z(["address-bar", {
                    "address-bar--with-history": i.value
                }])
            }, [Eo("div", oW, [Eo("div", iW, [xo(Oq, {
                readOnly: Ct(u),
                requestMethod: f.value,
                onChange: v
            }, null, 8, ["readOnly", "requestMethod"]), Eo("div", aW, [sW, xo(Ct(Nz), {
                class: "url-form-input",
                content: g.value,
                disableEnter: "",
                readOnly: Ct(u),
                withoutTheme: "",
                withVariables: "",
                onChange: O
            }, null, 8, ["content", "readOnly"]), lW]), Ct(c).length ? (mo(),
            vo("div", cW, [Eo("div", {
                class: "history-toggle",
                onClick: t[0] || (t[0] = e=>Ct(p).show())
            }, uW)])) : Do("", !0), Eo("button", {
                class: "send-button",
                disabled: !g.value.trim().length,
                type: "submit",
                onClick: b
            }, pW, 8, dW)])]), Eo("div", {
                class: "address-bar-close",
                onClick: t[1] || (t[1] = e=>i.value = !1)
            }), Eo("div", hW, [xo(Ct(qc), {
                state: Ct(p),
                title: "Request History",
                variant: "history"
            }, {
                default: dn((()=>[xo(hq, {
                    showHistory: i.value,
                    onToggle: t[2] || (t[2] = e=>i.value = !i.value)
                }, null, 8, ["showHistory"])])),
                _: 1
            }, 8, ["state"])])], 2)], 64))
        }
    })
      , mW = iq(fW, [["__scopeId", "data-v-c2ef499b"]]);
    const gW = iq({}, [["render", function(e, t) {
        return mo(),
        yo(On("style"), null, {
            default: dn((()=>[Fn(e.$slots, "default")])),
            _: 3
        })
    }
    ]])
      , bW = {
        class: "scalar-api-client-item-topbar"
    }
      , OW = {
        class: "scalar-api-client__toggle-container"
    }
      , vW = Eo("svg", {
        class: "scalar-api-client__toggle__icon",
        fill: "none",
        viewBox: "0 0 12 12",
        xmlns: "http://www.w3.org/2000/svg"
    }, [Eo("path", {
        d: "M2.2 4.1 6 7.9l3.8-3.8",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    })], -1)
      , yW = {
        class: "scalar-api-client__item__title"
    }
      , wW = {
        key: 0,
        class: "scalar-api-client__item__options"
    }
      , _W = {
        class: "scalar-api-client__item__content"
    }
      , kW = Ln({
        __name: "CollapsibleSection",
        props: {
            title: {},
            defaultOpen: {
                type: Boolean,
                default: !0
            }
        },
        setup(e) {
            const t = e
              , n = Et(null)
              , r = Et(null)
              , o = Et(t.defaultOpen);
            return zr((()=>t.defaultOpen), ((e,t)=>{
                var r;
                e !== t && e !== o.value && (null == (r = n.value) || r.el.click())
            }
            )),
            (e,t)=>(mo(),
            yo(Ct(Ms), {
                ref_key: "disclosureButton",
                ref: r,
                defaultOpen: e.defaultOpen
            }, {
                default: dn((({open: r})=>[Eo("div", {
                    class: Z(["scalar-api-client__item", {
                        "scalar-api-client__item--open": r
                    }])
                }, [Eo("div", bW, [xo(Ct(Ls), {
                    ref_key: "collapseButton",
                    ref: n,
                    class: "scalar-api-client__toggle",
                    onClick: t[0] || (t[0] = e=>o.value = !o.value)
                }, {
                    default: dn((()=>[Eo("div", OW, [vW, Eo("span", yW, K(e.title), 1)])])),
                    _: 1
                }, 512)]), e.$slots.options && r ? (mo(),
                vo("div", wW, [Fn(e.$slots, "options")])) : Do("", !0), xo(Ct(Qs), null, {
                    default: dn((()=>[Eo("div", _W, [Fn(e.$slots, "default")])])),
                    _: 3
                })], 2)])),
                _: 3
            }, 8, ["defaultOpen"]))
        }
    })
      , SW = $l(Symbol())
      , EW = {
        class: "table-row"
    }
      , xW = {
        class: "table-row-meta"
    }
      , TW = {
        class: "table-row-item"
    }
      , AW = {
        class: "table-row-item"
    }
      , CW = {
        key: 0,
        class: "table-row-item"
    }
      , PW = Ln({
        __name: "GridRow",
        props: {
            showDescription: {
                type: Boolean
            }
        },
        setup: e=>(e,t)=>(mo(),
        vo("div", EW, [Eo("div", xW, [Fn(e.$slots, "meta", {}, void 0, !0)]), Eo("div", TW, [Fn(e.$slots, "key", {}, void 0, !0)]), Eo("div", AW, [Fn(e.$slots, "value", {}, void 0, !0)]), e.showDescription ? (mo(),
        vo("div", CW, [Fn(e.$slots, "description", {}, void 0, !0)])) : Do("", !0)]))
    })
      , DW = iq(PW, [["__scopeId", "data-v-af7279f3"]])
      , RW = e=>(cn("data-v-28499a13"),
    e = e(),
    un(),
    e)
      , NW = RW((()=>Eo("label", {
        class: "table-column-header"
    }, "Key", -1)))
      , $W = RW((()=>Eo("label", {
        class: "table-column-header"
    }, "Value", -1)))
      , IW = RW((()=>Eo("label", {
        class: "table-column-header"
    }, "Description", -1)))
      , MW = RW((()=>Eo("svg", {
        fill: "currentColor",
        height: "12",
        width: "18",
        xmlns: "http://www.w3.org/2000/svg"
    }, [Eo("path", {
        d: "M0 11h9v-1H0v1ZM0 0v1h18V0H0Zm0 6h18V5H0v1Z"
    })], -1)))
      , LW = Ln({
        __name: "GridHeader",
        props: {
            showDescription: {
                type: Boolean
            }
        },
        emits: ["update:showDescription"],
        setup: e=>(e,t)=>(mo(),
        yo(DW, {
            showDescription: e.showDescription
        }, {
            key: dn((()=>[NW])),
            value: dn((()=>[$W])),
            description: dn((()=>[IW])),
            meta: dn((()=>[xo(Ct(Jc), {
                class: "table-description-toggle",
                variant: "text",
                onClick: t[0] || (t[0] = t=>e.$emit("update:showDescription", !e.showDescription))
            }, {
                default: dn((()=>[MW])),
                _: 1
            })])),
            _: 1
        }, 8, ["showDescription"]))
    })
      , QW = iq(LW, [["__scopeId", "data-v-28499a13"]])
      , BW = e=>(cn("data-v-88a71b55"),
    e = e(),
    un(),
    e)
      , UW = {
        class: "meta-check"
    }
      , FW = BW((()=>Eo("span", {
        class: "meta-checkmark"
    }, null, -1)))
      , jW = [BW((()=>Eo("svg", {
        fill: "none",
        height: "10",
        viewBox: "-0.5 -0.5 10 10",
        width: "10",
        xmlns: "http://www.w3.org/2000/svg"
    }, [Eo("path", {
        d: "m8.55 0.45 -8.1 8.1",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "1.5"
    }), Eo("path", {
        d: "m0.45 0.45 8.1 8.1",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "1.5"
    })], -1)))]
      , zW = Ln({
        __name: "GridRowEditable",
        props: {
            name: {},
            description: {},
            value: {},
            required: {
                type: Boolean
            },
            enabled: {
                type: Boolean
            }
        },
        emits: ["update:name", "update:value", "update:description", "update:enabled", "delete"],
        setup(e, {emit: t}) {
            const n = e
              , r = t
              , o = ei({
                get: ()=>n.name,
                set: e=>{
                    r("update:enabled", !0),
                    r("update:name", e)
                }
            })
              , i = ei({
                get: ()=>`${n.value}`,
                set: e=>{
                    r("update:enabled", !0),
                    r("update:value", e)
                }
            })
              , a = ei({
                get: ()=>n.description ?? "",
                set: e=>r("update:description", e)
            })
              , s = ei({
                get: ()=>n.enabled,
                set: e=>r("update:enabled", e)
            });
            return (e,t)=>(mo(),
            yo(DW, {
                class: Z(["table-row-editable", {
                    "required-parameter": e.required
                }])
            }, {
                key: dn((()=>[Nn(Eo("input", {
                    "onUpdate:modelValue": t[0] || (t[0] = e=>o.value = e),
                    placeholder: "Key"
                }, null, 512), [[$i, o.value]])])),
                value: dn((()=>[Nn(Eo("input", {
                    "onUpdate:modelValue": t[1] || (t[1] = e=>i.value = e),
                    placeholder: "Value"
                }, null, 512), [[$i, i.value]])])),
                description: dn((()=>[Nn(Eo("input", {
                    "onUpdate:modelValue": t[2] || (t[2] = e=>a.value = e),
                    placeholder: "Description"
                }, null, 512), [[$i, a.value]])])),
                meta: dn((()=>[Eo("label", UW, [Nn(Eo("input", {
                    "onUpdate:modelValue": t[3] || (t[3] = e=>s.value = e),
                    type: "checkbox"
                }, null, 512), [[Ii, s.value]]), FW]), e.required ? Do("", !0) : (mo(),
                vo("button", {
                    key: 0,
                    class: "meta-delete",
                    tabindex: "-1",
                    type: "button",
                    onClick: t[4] || (t[4] = t=>e.$emit("delete"))
                }, jW))])),
                _: 1
            }, 8, ["class"]))
        }
    })
      , qW = iq(zW, [["__scopeId", "data-v-88a71b55"]])
      , HW = e=>(cn("data-v-1a868951"),
    e = e(),
    un(),
    e)
      , ZW = ["value"]
      , WW = ["value"]
      , XW = HW((()=>Eo("input", {
        disabled: "",
        value: "Read-only"
    }, null, -1)))
      , VW = iq(Ln({
        __name: "GridRowGenerated",
        props: {
            item: {}
        },
        setup: e=>(e,t)=>(mo(),
        yo(DW, {
            class: "table-row-generated"
        }, {
            key: dn((()=>[Eo("input", {
                disabled: "",
                placeholder: "key",
                value: e.item.name
            }, null, 8, ZW)])),
            value: dn((()=>[Eo("input", {
                disabled: "",
                placeholder: "value",
                type: "password",
                value: e.item.value
            }, null, 8, WW)])),
            description: dn((()=>[XW])),
            _: 1
        }))
    }), [["__scopeId", "data-v-1a868951"]])
      , GW = {
        class: "table"
    }
      , YW = {
        class: "meta-actions"
    }
      , KW = {
        class: "meta-actions-item-icon"
    }
      , JW = {
        class: "meta-actions-item-icon"
    }
      , eX = Ln({
        __name: "Grid",
        props: {
            items: {},
            generatedItems: {},
            addLabel: {},
            showMoreFilter: {
                type: Boolean
            }
        },
        emits: ["deleteIndex", "addAnother"],
        setup(e, {emit: t}) {
            const n = t
              , r = Et(!1)
              , o = Et(!1);
            function i() {
                n("addAnother"),
                o.value = !0
            }
            return (e,t)=>(mo(),
            vo("div", GW, [xo(QW, {
                showDescription: r.value,
                "onUpdate:showDescription": t[0] || (t[0] = e=>r.value = e)
            }, null, 8, ["showDescription"]), (mo(!0),
            vo(lo, null, In(e.generatedItems, (e=>(mo(),
            yo(VW, {
                key: e.name,
                item: e,
                showDescription: r.value,
                onClick: t[1] || (t[1] = e=>Ct(SW).emit())
            }, null, 8, ["item", "showDescription"])))), 128)), (mo(!0),
            vo(lo, null, In(e.items, ((t,n)=>Nn((mo(),
            yo(qW, {
                key: n,
                description: t.description,
                "onUpdate:description": e=>t.description = e,
                enabled: t.enabled,
                "onUpdate:enabled": e=>t.enabled = e,
                name: t.name,
                "onUpdate:name": e=>t.name = e,
                value: t.value,
                "onUpdate:value": e=>t.value = e,
                required: t.required,
                showDescription: r.value,
                onDelete: t=>e.$emit("deleteIndex", n)
            }, null, 8, ["description", "onUpdate:description", "enabled", "onUpdate:enabled", "name", "onUpdate:name", "value", "onUpdate:value", "required", "showDescription", "onDelete"])), [[ci, !e.showMoreFilter || e.showMoreFilter && n < 5 || o.value]]))), 128)), Eo("div", YW, [e.addLabel ? (mo(),
            vo("button", {
                key: 0,
                class: "meta-actions-item",
                type: "button",
                onClick: i
            }, [Eo("i", KW, [xo(Ct(rC), {
                icon: "Add"
            })]), Co(" " + K(e.addLabel), 1)])) : Do("", !0), e.showMoreFilter && e.items && e.items.length > 5 && !o.value ? (mo(),
            vo("button", {
                key: 1,
                class: "meta-actions-item",
                type: "button",
                onClick: t[2] || (t[2] = e=>o.value = !0)
            }, [Co(" Show More "), Eo("i", JW, [xo(Ct(rC), {
                icon: "ChevronDown"
            })])])) : Do("", !0)])]))
        }
    })
      , tX = iq(eX, [["__scopeId", "data-v-c44da5e8"]])
      , nX = {
        key: 0
    }
      , rX = Ln({
        __name: "RequestBody",
        props: {
            body: {},
            formData: {}
        },
        setup(e) {
            const {activeRequest: t, setActiveRequest: n} = eq()
              , r = e=>{
                t.body !== e && n({
                    ...t,
                    body: e
                })
            }
            ;
            return (e,n)=>(mo(),
            yo(Ct(kW), {
                title: "Body"
            }, {
                default: dn((()=>[e.body && 0 === e.body.length && e.formData && 0 === e.formData.length ? (mo(),
                vo("span", nX, "No Body")) : e.formData && e.formData.length > 0 ? (mo(),
                yo(Ct(tX), {
                    key: 1,
                    items: e.formData
                }, null, 8, ["items"])) : (mo(),
                yo(Ct(Nz), {
                    key: 2,
                    content: Ct(t).body,
                    language: "json",
                    lineNumbers: "",
                    onChange: r
                }, null, 8, ["content"]))])),
                _: 1
            }))
        }
    })
      , oX = {
        key: 0,
        class: "scalar-api-client__empty-state"
    }
      , iX = Eo("svg", {
        class: "flow-icon",
        "data-v-aa4fbd2d": "",
        height: "100%",
        viewBox: "0 0 48 48",
        xmlns: "http://www.w3.org/2000/svg"
    }, [Eo("path", {
        d: "M24 1.714v44.572M1.714 24h44.572",
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "5",
        xmlns: "http://www.w3.org/2000/svg"
    })], -1)
      , aX = Ln({
        __name: "RequestCookies",
        props: {
            cookies: {},
            generatedCookies: {}
        },
        setup(e) {
            const t = e
              , {activeRequest: n} = eq();
            function r(e) {
                var t;
                null == (t = n.cookies) || t.splice(e, 1)
            }
            function o() {
                var e;
                void 0 === n.cookies && (n.cookies = []),
                null == (e = n.cookies) || e.push({
                    name: "",
                    value: "",
                    enabled: !0
                })
            }
            const i = ei((()=>{
                var e, n;
                return !!(null != (e = t.cookies) && e.length || null != (n = t.generatedCookies) && n.length)
            }
            ));
            return (e,t)=>(mo(),
            yo(Ct(kW), {
                defaultOpen: i.value,
                title: "Cookies"
            }, {
                default: dn((()=>[i.value ? (mo(),
                yo(Ct(tX), {
                    key: 1,
                    addLabel: "Cookie",
                    generatedItems: e.generatedCookies,
                    items: e.cookies,
                    onAddAnother: o,
                    onDeleteIndex: r
                }, null, 8, ["generatedItems", "items"])) : (mo(),
                vo("div", oX, [Eo("button", {
                    class: "scalar-api-client-add",
                    type: "button",
                    onClick: o
                }, [iX, Co(" Cookies ")])]))])),
                _: 1
            }, 8, ["defaultOpen"]))
        }
    })
      , sX = {
        key: 0,
        class: "scalar-api-client__empty-state"
    }
      , lX = Eo("svg", {
        class: "flow-icon",
        "data-v-aa4fbd2d": "",
        height: "100%",
        viewBox: "0 0 48 48",
        xmlns: "http://www.w3.org/2000/svg"
    }, [Eo("path", {
        d: "M24 1.714v44.572M1.714 24h44.572",
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "5",
        xmlns: "http://www.w3.org/2000/svg"
    })], -1)
      , cX = Ln({
        __name: "RequestHeaders",
        props: {
            headers: {},
            generatedHeaders: {}
        },
        setup(e) {
            const t = e
              , {activeRequest: n} = eq();
            function r(e) {
                var t;
                null == (t = n.headers) || t.splice(e, 1)
            }
            function o() {
                var e;
                void 0 === n.headers && (n.headers = []),
                null == (e = n.headers) || e.push({
                    name: "",
                    value: "",
                    enabled: !0
                })
            }
            const i = ei((()=>{
                var e, n;
                return !!(null != (e = t.headers) && e.length || null != (n = t.generatedHeaders) && n.length)
            }
            ));
            return (e,t)=>(mo(),
            yo(Ct(kW), {
                defaultOpen: i.value,
                title: "Headers"
            }, {
                default: dn((()=>[i.value ? (mo(),
                yo(Ct(tX), {
                    key: 1,
                    addLabel: "Header",
                    generatedItems: e.generatedHeaders,
                    items: e.headers,
                    onAddAnother: o,
                    onDeleteIndex: r
                }, null, 8, ["generatedItems", "items"])) : (mo(),
                vo("div", sX, [Eo("button", {
                    class: "scalar-api-client-add",
                    type: "button",
                    onClick: o
                }, [lX, Co(" Headers ")])]))])),
                _: 1
            }, 8, ["defaultOpen"]))
        }
    })
      , uX = {
        key: 0,
        class: "scalar-api-client__empty-state"
    }
      , dX = Eo("svg", {
        class: "flow-icon",
        "data-v-aa4fbd2d": "",
        height: "100%",
        viewBox: "0 0 48 48",
        xmlns: "http://www.w3.org/2000/svg"
    }, [Eo("path", {
        d: "M24 1.714v44.572M1.714 24h44.572",
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "5",
        xmlns: "http://www.w3.org/2000/svg"
    })], -1)
      , pX = Ln({
        __name: "RequestQuery",
        props: {
            queries: {},
            generatedQueries: {}
        },
        setup(e) {
            const t = e
              , {activeRequest: n} = eq();
            function r(e) {
                var t;
                null == (t = n.query) || t.splice(e, 1)
            }
            function o() {
                var e;
                void 0 === n.query && (n.query = []),
                null == (e = n.query) || e.push({
                    name: "",
                    value: "",
                    enabled: !0
                })
            }
            const i = ei((()=>{
                var e, n;
                return !!(null != (e = t.queries) && e.length || null != (n = t.generatedQueries) && n.length)
            }
            ));
            return (e,t)=>(mo(),
            yo(Ct(kW), {
                defaultOpen: i.value,
                title: "Query Parameters"
            }, {
                default: dn((()=>[i.value ? (mo(),
                yo(Ct(tX), {
                    key: 1,
                    addLabel: "Query Parameter",
                    generatedItems: e.generatedQueries,
                    items: e.queries,
                    showMoreFilter: !0,
                    onAddAnother: o,
                    onDeleteIndex: r
                }, null, 8, ["generatedItems", "items"])) : (mo(),
                vo("div", uX, [Eo("button", {
                    class: "scalar-api-client-add",
                    type: "button",
                    onClick: o
                }, [dX, Co(" Query Parameter ")])]))])),
                _: 1
            }, 8, ["defaultOpen"]))
        }
    })
      , hX = {
        key: 0,
        class: "scalar-api-client__empty-state"
    }
      , fX = Eo("svg", {
        class: "flow-icon",
        "data-v-aa4fbd2d": "",
        height: "100%",
        viewBox: "0 0 48 48",
        xmlns: "http://www.w3.org/2000/svg"
    }, [Eo("path", {
        d: "M24 1.714v44.572M1.714 24h44.572",
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "5",
        xmlns: "http://www.w3.org/2000/svg"
    })], -1)
      , mX = Ln({
        __name: "RequestVariables",
        props: {
            variables: {}
        },
        setup(e) {
            const {activeRequest: t} = eq();
            function n(e) {
                var n;
                null == (n = t.variables) || n.splice(e, 1)
            }
            function r() {
                var e;
                void 0 === t.variables && (t.variables = []),
                null == (e = t.variables) || e.push({
                    name: "",
                    value: "",
                    enabled: !0
                })
            }
            return (e,o)=>(mo(),
            yo(Ct(kW), {
                defaultOpen: Ct(t).variables && Ct(t).variables.length > 0,
                title: "Variables"
            }, {
                default: dn((()=>[e.variables && 0 !== e.variables.length ? (mo(),
                yo(Ct(tX), {
                    key: 1,
                    addLabel: "Variable",
                    items: e.variables,
                    showMoreFilter: !0,
                    onAddAnother: r,
                    onDeleteIndex: n
                }, null, 8, ["items"])) : (mo(),
                vo("div", hX, [Eo("button", {
                    class: "scalar-api-client-add",
                    type: "button",
                    onClick: r
                }, [fX, Co(" Variable ")])]))])),
                _: 1
            }, 8, ["defaultOpen"]))
        }
    });
    var gX = Object.defineProperty
      , bX = (e,t,n)=>(((e,t,n)=>{
        t in e ? gX(e, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: n
        }) : e[t] = n
    }
    )(e, "symbol" != typeof t ? t + "" : t, n),
    n);
    !function(e) {
        if (typeof document > "u")
            return;
        let t = document.head || document.getElementsByTagName("head")[0]
          , n = document.createElement("style");
        n.type = "text/css",
        t.appendChild(n),
        n.styleSheet ? n.styleSheet.cssText = e : n.appendChild(document.createTextNode(e))
    }("[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999}[data-sonner-toaster][data-x-position=right]{right:max(var(--offset),env(safe-area-inset-right))}[data-sonner-toaster][data-x-position=left]{left:max(var(--offset),env(safe-area-inset-left))}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:max(var(--offset),env(safe-area-inset-top))}[data-sonner-toaster][data-y-position=bottom]{bottom:max(var(--offset),env(safe-area-inset-bottom))}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;will-change:transform,opacity,height;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast] [data-description]{font-weight:400;line-height:1.4;color:inherit}[data-sonner-toast] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast] [data-icon]>*{flex-shrink:0}[data-sonner-toast] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast] [data-content]{display:flex;flex-direction:column;gap:2px;transform:translateZ(0)}[data-sonner-toast] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toast][data-theme=dark] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;background:var(--gray1);color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]:before{content:'';position:absolute;left:0;right:0;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]:before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]:before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]:before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast]:after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]:before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount,0));transition:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation:swipe-out .2s ease-out forwards}@keyframes swipe-out{from{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount)));opacity:1}to{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount) + var(--lift) * -100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;--mobile-offset:16px;right:var(--mobile-offset);left:var(--mobile-offset);width:100%}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - 32px)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset)}[data-sonner-toaster][data-y-position=bottom]{bottom:20px}[data-sonner-toaster][data-y-position=top]{top:20px}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset);right:var(--mobile-offset);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 91%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 91%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 91%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 100%, 12%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 12%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-rich-colors=true] [data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true] [data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true] [data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true] [data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true] [data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true] [data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true] [data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true] [data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}");
    let OX = 0;
    const vX = new class {
        constructor() {
            bX(this, "subscribers"),
            bX(this, "toasts"),
            bX(this, "subscribe", (e=>(this.subscribers.push(e),
            ()=>{
                const t = this.subscribers.indexOf(e);
                this.subscribers.splice(t, 1)
            }
            ))),
            bX(this, "publish", (e=>{
                this.subscribers.forEach((t=>t(e)))
            }
            )),
            bX(this, "addToast", (e=>{
                this.publish(e),
                this.toasts = [...this.toasts, e]
            }
            )),
            bX(this, "create", (e=>{
                var t;
                const {message: n, ...r} = e
                  , o = "number" == typeof e.id || e.id && (null == (t = e.id) ? void 0 : t.length) > 0 ? e.id : OX++
                  , i = this.toasts.find((e=>e.id === o))
                  , a = void 0 === e.dismissible || e.dismissible;
                return i ? this.toasts = this.toasts.map((t=>t.id === o ? (this.publish({
                    ...t,
                    ...e,
                    id: o,
                    title: n
                }),
                {
                    ...t,
                    ...e,
                    id: o,
                    dismissible: a,
                    title: n
                }) : t)) : this.addToast({
                    title: n,
                    ...r,
                    dismissible: a,
                    id: o
                }),
                o
            }
            )),
            bX(this, "dismiss", (e=>(e || this.toasts.forEach((e=>{
                this.subscribers.forEach((t=>t({
                    id: e.id,
                    dismiss: !0
                })))
            }
            )),
            this.subscribers.forEach((t=>t({
                id: e,
                dismiss: !0
            }))),
            e))),
            bX(this, "message", ((e,t)=>this.create({
                ...t,
                message: e,
                type: "default"
            }))),
            bX(this, "error", ((e,t)=>this.create({
                ...t,
                type: "error",
                message: e
            }))),
            bX(this, "success", ((e,t)=>this.create({
                ...t,
                type: "success",
                message: e
            }))),
            bX(this, "info", ((e,t)=>this.create({
                ...t,
                type: "info",
                message: e
            }))),
            bX(this, "warning", ((e,t)=>this.create({
                ...t,
                type: "warning",
                message: e
            }))),
            bX(this, "loading", ((e,t)=>this.create({
                ...t,
                type: "loading",
                message: e
            }))),
            bX(this, "promise", ((e,t)=>{
                if (!t)
                    return;
                let n;
                void 0 !== t.loading && (n = this.create({
                    ...t,
                    promise: e,
                    type: "loading",
                    message: t.loading,
                    description: "function" != typeof t.description ? t.description : void 0
                }));
                const r = e instanceof Promise ? e : e();
                let o = void 0 !== n;
                return r.then((e=>{
                    if (e && "boolean" == typeof e.ok && !e.ok) {
                        o = !1;
                        const e = "function" == typeof t.error ? t.error(`HTTP error! status: ${response.status}`) : t.error
                          , r = "function" == typeof t.description ? t.description(`HTTP error! status: ${response.status}`) : t.description;
                        this.create({
                            id: n,
                            type: "error",
                            message: e,
                            description: r
                        })
                    } else if (void 0 !== t.success) {
                        o = !1;
                        const r = "function" == typeof t.success ? t.success(e) : t.success
                          , i = "function" == typeof t.description ? t.description(e) : t.description;
                        this.create({
                            id: n,
                            type: "success",
                            message: r,
                            description: i
                        })
                    }
                }
                )).catch((e=>{
                    if (void 0 !== t.error) {
                        o = !1;
                        const r = "function" == typeof t.error ? t.error(e) : t.error
                          , i = "function" == typeof t.description ? t.description(e) : t.description;
                        this.create({
                            id: n,
                            type: "error",
                            message: r,
                            description: i
                        })
                    }
                }
                )).finally((()=>{
                    var e;
                    o && (this.dismiss(n),
                    n = void 0),
                    null == (e = t.finally) || e.call(t)
                }
                )),
                n
            }
            )),
            bX(this, "custom", ((e,t)=>{
                const n = (null == t ? void 0 : t.id) || OX++;
                return this.publish({
                    component: e,
                    id: n,
                    ...t
                }),
                n
            }
            )),
            this.subscribers = [],
            this.toasts = []
        }
    }
      , yX = (e,t)=>{
        const n = (null == t ? void 0 : t.id) || OX++;
        return vX.create({
            message: e,
            id: n,
            type: "default",
            ...t
        }),
        n
    }
      , wX = Object.assign(yX, {
        success: vX.success,
        info: vX.info,
        warning: vX.warning,
        error: vX.error,
        custom: vX.custom,
        message: vX.message,
        promise: vX.promise,
        dismiss: vX.dismiss,
        loading: vX.loading
    })
      , _X = (e,t)=>{
        const n = e.__vccOpts || e;
        for (const [r,o] of t)
            n[r] = o;
        return n
    }
      , kX = {}
      , SX = {
        xmlns: "http://www.w3.org/2000/svg",
        width: "12",
        height: "12",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        "stoke-width": "1.5",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    }
      , EX = [Eo("line", {
        x1: "18",
        y1: "6",
        x2: "6",
        y2: "18"
    }, null, -1), Eo("line", {
        x1: "6",
        y1: "6",
        x2: "18",
        y2: "18"
    }, null, -1)];
    const xX = _X(kX, [["render", function(e, t) {
        return mo(),
        vo("svg", SX, EX)
    }
    ]])
      , TX = ["aria-live", "data-styled", "data-mounted", "data-promise", "data-removed", "data-visible", "data-y-position", "data-x-position", "data-index", "data-front", "data-swiping", "data-dismissible", "data-type", "data-invert", "data-swipe-out", "data-expanded"]
      , AX = ["aria-label", "data-disabled"]
      , CX = {
        key: 0,
        "data-icon": ""
    }
      , PX = {
        "data-content": ""
    }
      , DX = Ln({
        __name: "Toast",
        props: {
            toast: {},
            toasts: {},
            index: {},
            expanded: {
                type: Boolean
            },
            invert: {
                type: Boolean
            },
            heights: {},
            gap: {},
            position: {},
            visibleToasts: {},
            expandByDefault: {
                type: Boolean
            },
            closeButton: {
                type: Boolean
            },
            interacting: {
                type: Boolean
            },
            duration: {},
            descriptionClass: {},
            style: {},
            cancelButtonStyle: {},
            actionButtonStyle: {},
            unstyled: {
                type: Boolean
            },
            loadingIcon: {},
            class: {},
            classes: {},
            icons: {},
            closeButtonAriaLabel: {},
            pauseWhenPageIsHidden: {
                type: Boolean
            },
            cn: {
                type: Function
            }
        },
        emits: ["update:heights", "removeToast"],
        setup(e, {emit: t}) {
            const n = t
              , r = e
              , o = Et(!1)
              , i = Et(!1)
              , a = Et(!1)
              , s = Et(!1)
              , l = Et(0)
              , c = Et(0)
              , u = Et(null)
              , d = Et(null)
              , p = ei((()=>0 === r.index))
              , h = ei((()=>r.index + 1 <= r.visibleToasts))
              , f = ei((()=>r.toast.type))
              , m = ei((()=>!1 !== r.toast.dismissible))
              , g = ei((()=>{
                var e, t, n, o, i, a, s;
                return r.cn(null == (e = r.classes) ? void 0 : e.toast, null == (n = null == (t = r.toast) ? void 0 : t.classes) ? void 0 : n.toast, null == (o = r.classes) ? void 0 : o.default, null == (i = r.classes) ? void 0 : i[r.toast.type || "default"], null == (s = null == (a = r.toast) ? void 0 : a.classes) ? void 0 : s[r.toast.type || "default"])
            }
            ))
              , b = r.toast.style || {}
              , O = ei((()=>r.heights.findIndex((e=>e.toastId === r.toast.id)) || 0))
              , v = ei((()=>r.toast.closeButton ?? r.closeButton))
              , y = ei((()=>r.toast.duration || r.duration || 4e3))
              , w = Et(0)
              , _ = Et(0)
              , k = Et(y.value)
              , S = Et(0)
              , E = Et(null)
              , x = ei((()=>r.position.split("-")))
              , T = ei((()=>x.value[0]))
              , A = ei((()=>x.value[1]))
              , C = "string" != typeof r.toast.title
              , P = "string" != typeof r.toast.description
              , D = ei((()=>r.heights.reduce(((e,t,n)=>n >= O.value ? e : e + t.height), 0)))
              , R = (()=>{
                const e = Et(!1);
                return Fr((()=>{
                    const t = ()=>{
                        e.value = document.hidden
                    }
                    ;
                    return document.addEventListener("visibilitychange", t),
                    ()=>window.removeEventListener("visibilitychange", t)
                }
                )),
                {
                    isDocumentHidden: e
                }
            }
            )()
              , N = ei((()=>r.toast.invert || r.invert))
              , $ = ei((()=>"loading" === f.value));
            Sn((()=>{
                if (!o.value)
                    return;
                const e = d.value
                  , t = null == e ? void 0 : e.style.height;
                e.style.height = "auto";
                const i = e.getBoundingClientRect().height;
                let a;
                e.style.height = t,
                c.value = i,
                a = r.heights.find((e=>e.toastId === r.toast.id)) ? r.heights.map((e=>e.toastId === r.toast.id ? {
                    ...e,
                    height: i
                } : e)) : [{
                    toastId: r.toast.id,
                    height: i,
                    position: r.toast.position
                }, ...r.heights],
                n("update:heights", a)
            }
            ));
            const I = ()=>{
                i.value = !0,
                l.value = _.value;
                const e = r.heights.filter((e=>e.toastId !== r.toast.id));
                n("update:heights", e),
                setTimeout((()=>{
                    n("removeToast", r.toast)
                }
                ), 200)
            }
              , M = ()=>{
                var e, t;
                $.value || !m.value || (I(),
                null == (t = (e = r.toast).onDismiss) || t.call(e, r.toast))
            }
              , L = e=>{
                $.value || !m.value || (u.value = new Date,
                l.value = _.value,
                e.target.setPointerCapture(e.pointerId),
                "BUTTON" !== e.target.tagName && (a.value = !0,
                E.value = {
                    x: e.clientX,
                    y: e.clientY
                }))
            }
              , Q = e=>{
                var t, n, o, i;
                if (s.value)
                    return;
                E.value = null;
                const c = Number((null == (t = d.value) ? void 0 : t.style.getPropertyValue("--swipe-amount").replace("px", "")) || 0)
                  , p = (new Date).getTime() - u.value.getTime()
                  , h = Math.abs(c) / p;
                if (Math.abs(c) >= 20 || h > .11)
                    return l.value = _.value,
                    null == (o = (n = r.toast).onDismiss) || o.call(n, r.toast),
                    I(),
                    void (s.value = !0);
                null == (i = d.value) || i.style.setProperty("--swipe-amount", "0px"),
                a.value = !1
            }
              , B = e=>{
                var t;
                if (!E.value)
                    return;
                const n = e.clientY - E.value.y
                  , r = e.clientX - E.value.x
                  , o = ("top" === x.value[0] ? Math.min : Math.max)(0, n)
                  , i = "touch" === e.pointerType ? 10 : 2;
                Math.abs(o) > i ? null == (t = d.value) || t.style.setProperty("--swipe-amount", `${n}px`) : Math.abs(r) > i && (E.value = null)
            }
            ;
            return Fr((()=>{
                _.value = 14 * O.value + D.value
            }
            )),
            Fr((e=>{
                if (r.toast.promise && "loading" === f.value || r.toast.duration === 1 / 0 || "loading" === r.toast.type)
                    return;
                let t;
                r.expanded || r.interacting || r.pauseWhenPageIsHidden && R ? (()=>{
                    if (S.value < w.value) {
                        const e = (new Date).getTime() - w.value;
                        k.value = k.value - e
                    }
                    S.value = (new Date).getTime()
                }
                )() : (w.value = (new Date).getTime(),
                t = setTimeout((()=>{
                    var e, t;
                    null == (t = (e = r.toast).onAutoClose) || t.call(e, r.toast),
                    I()
                }
                ), k.value)),
                e((()=>{
                    clearTimeout(t)
                }
                ))
            }
            )),
            Fr((()=>{
                r.toast.delete && I()
            }
            )),
            Sn((()=>{
                if (d.value) {
                    const e = d.value.getBoundingClientRect().height;
                    c.value = e;
                    const t = [{
                        toastId: r.toast.id,
                        height: e,
                        position: r.toast.position
                    }, ...r.heights];
                    n("update:heights", t)
                }
                o.value = !0
            }
            )),
            An((()=>{
                if (d.value) {
                    const e = r.heights.filter((e=>e.toastId !== r.toast.id));
                    n("update:heights", e)
                }
            }
            )),
            (e,t)=>{
                var n, r, u, O, y, w, k, S, E, x, D, R;
                return mo(),
                vo("li", {
                    "aria-live": e.toast.important ? "assertive" : "polite",
                    "aria-atomic": "true",
                    role: "status",
                    tabindex: "0",
                    ref_key: "toastRef",
                    ref: d,
                    "data-sonner-toast": "",
                    class: Z(g.value),
                    "data-styled": !(e.toast.component || null != (n = e.toast) && n.unstyled || e.unstyled),
                    "data-mounted": o.value,
                    "data-promise": !!e.toast.promise,
                    "data-removed": i.value,
                    "data-visible": h.value,
                    "data-y-position": T.value,
                    "data-x-position": A.value,
                    "data-index": e.index,
                    "data-front": p.value,
                    "data-swiping": a.value,
                    "data-dismissible": m.value,
                    "data-type": f.value,
                    "data-invert": N.value,
                    "data-swipe-out": s.value,
                    "data-expanded": !!(e.expanded || e.expandByDefault && o.value),
                    style: F({
                        "--index": e.index,
                        "--toasts-before": e.index,
                        "--z-index": e.toasts.length - e.index,
                        "--offset": `${i.value ? l.value : _.value}px`,
                        "--initial-height": e.expandByDefault ? "auto" : `${c.value}px`,
                        ...e.style,
                        ...Ct(b)
                    }),
                    onPointerdown: L,
                    onPointerup: Q,
                    onPointermove: B
                }, [v.value && !e.toast.component ? (mo(),
                vo("button", {
                    key: 0,
                    "aria-label": e.closeButtonAriaLabel || "Close toast",
                    "data-disabled": $.value,
                    "data-close-button": "",
                    class: Z(e.cn(null == (r = e.classes) ? void 0 : r.closeButton, null == (O = null == (u = e.toast) ? void 0 : u.classes) ? void 0 : O.closeButton)),
                    onClick: M
                }, [xo(xX)], 10, AX)) : Do("", !0), e.toast.component ? (mo(),
                yo(On(e.toast.component), Io({
                    key: 1
                }, e.toast.componentProps, {
                    onCloseToast: I
                }), null, 16)) : (mo(),
                vo(lo, {
                    key: 2
                }, ["default" !== f.value || e.toast.icon || e.toast.promise ? (mo(),
                vo("div", CX, [!e.toast.promise && "loading" !== f.value || e.toast.icon ? Do("", !0) : Fn(e.$slots, "loading-icon", {
                    key: 0
                }), e.toast.icon ? (mo(),
                yo(On(e.toast.icon), {
                    key: 1
                })) : (mo(),
                vo(lo, {
                    key: 2
                }, ["success" === f.value ? Fn(e.$slots, "success-icon", {
                    key: 0
                }) : "error" === f.value ? Fn(e.$slots, "error-icon", {
                    key: 1
                }) : "warning" === f.value ? Fn(e.$slots, "warning-icon", {
                    key: 2
                }) : "info" === f.value ? Fn(e.$slots, "info-icon", {
                    key: 3
                }) : Do("", !0)], 64))])) : Do("", !0), Eo("div", PX, [Eo("div", {
                    "data-title": "",
                    class: Z(e.cn(null == (y = e.classes) ? void 0 : y.title, null == (w = e.toast.classes) ? void 0 : w.title))
                }, [C ? (mo(),
                yo(On(e.toast.title), W(Io({
                    key: 0
                }, e.toast.componentProps)), null, 16)) : (mo(),
                vo(lo, {
                    key: 1
                }, [Co(K(e.toast.title), 1)], 64))], 2), e.toast.description ? (mo(),
                vo("div", {
                    key: 0,
                    "data-description": "",
                    class: Z(e.cn(e.descriptionClass, e.toast.descriptionClass, null == (k = e.classes) ? void 0 : k.description, null == (S = e.toast.classes) ? void 0 : S.description))
                }, [P ? (mo(),
                yo(On(e.toast.description), W(Io({
                    key: 0
                }, e.toast.componentProps)), null, 16)) : (mo(),
                vo(lo, {
                    key: 1
                }, [Co(K(e.toast.description), 1)], 64))], 2)) : Do("", !0)]), e.toast.cancel ? (mo(),
                vo("button", {
                    key: 1,
                    class: Z(e.cn(null == (E = e.classes) ? void 0 : E.cancelButton, null == (x = e.toast.classes) ? void 0 : x.cancelButton)),
                    "data-button": "",
                    "data-cancel": "",
                    onClick: t[0] || (t[0] = ()=>{
                        var t;
                        I(),
                        null != (t = e.toast.cancel) && t.onClick && e.toast.cancel.onClick()
                    }
                    )
                }, K(e.toast.cancel.label), 3)) : Do("", !0), e.toast.action ? (mo(),
                vo("button", {
                    key: 2,
                    class: Z(e.cn(null == (D = e.classes) ? void 0 : D.actionButton, null == (R = e.toast.classes) ? void 0 : R.actionButton)),
                    "data-button": "",
                    onClick: t[1] || (t[1] = t=>{
                        var n;
                        null == (n = e.toast.action) || n.onClick(t),
                        !t.defaultPrevented && I()
                    }
                    )
                }, K(e.toast.action.label), 3)) : Do("", !0)], 64))], 46, TX)
            }
        }
    })
      , RX = ["data-visible"]
      , NX = {
        class: "sonner-spinner"
    }
      , $X = Ln({
        __name: "Loader",
        props: {
            visible: {
                type: Boolean
            }
        },
        setup(e) {
            const t = Array(12).fill(0);
            return (e,n)=>(mo(),
            vo("div", {
                class: "sonner-loading-wrapper",
                "data-visible": e.visible
            }, [Eo("div", NX, [(mo(!0),
            vo(lo, null, In(Ct(t), (e=>(mo(),
            vo("div", {
                key: `spinner-bar-${e}`,
                class: "sonner-loading-bar"
            })))), 128))])], 8, RX))
        }
    })
      , IX = {}
      , MX = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20",
        fill: "currentColor",
        height: "20",
        width: "20"
    }
      , LX = [Eo("path", {
        "fill-rule": "evenodd",
        d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
        "clip-rule": "evenodd"
    }, null, -1)];
    const QX = _X(IX, [["render", function(e, t) {
        return mo(),
        vo("svg", MX, LX)
    }
    ]])
      , BX = {}
      , UX = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20",
        fill: "currentColor",
        height: "20",
        width: "20"
    }
      , FX = [Eo("path", {
        "fill-rule": "evenodd",
        d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
        "clip-rule": "evenodd"
    }, null, -1)];
    const jX = _X(BX, [["render", function(e, t) {
        return mo(),
        vo("svg", UX, FX)
    }
    ]])
      , zX = {}
      , qX = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        height: "20",
        width: "20"
    }
      , HX = [Eo("path", {
        "fill-rule": "evenodd",
        d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
        "clip-rule": "evenodd"
    }, null, -1)];
    const ZX = _X(zX, [["render", function(e, t) {
        return mo(),
        vo("svg", qX, HX)
    }
    ]])
      , WX = {}
      , XX = {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20",
        fill: "currentColor",
        height: "20",
        width: "20"
    }
      , VX = [Eo("path", {
        "fill-rule": "evenodd",
        d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
        "clip-rule": "evenodd"
    }, null, -1)];
    const GX = _X(WX, [["render", function(e, t) {
        return mo(),
        vo("svg", XX, VX)
    }
    ]])
      , YX = ["aria-label"]
      , KX = ["dir", "data-theme", "data-rich-colors", "data-y-position", "data-x-position"]
      , JX = "32px"
      , eV = typeof window < "u" && typeof document < "u"
      , tV = Ln({
        name: "Toaster",
        inheritAttrs: !1,
        __name: "Toaster",
        props: {
            invert: {
                type: Boolean,
                default: !1
            },
            theme: {
                default: "light"
            },
            position: {
                default: "bottom-right"
            },
            hotkey: {
                default: ()=>["altKey", "KeyT"]
            },
            richColors: {
                type: Boolean,
                default: !1
            },
            expand: {
                type: Boolean,
                default: !1
            },
            duration: {
                default: 4e3
            },
            gap: {
                default: 14
            },
            visibleToasts: {
                default: 3
            },
            closeButton: {
                type: Boolean,
                default: !1
            },
            toastOptions: {
                default: ()=>({})
            },
            class: {
                default: ""
            },
            style: {
                default: ()=>({})
            },
            offset: {
                default: JX
            },
            dir: {
                default: "auto"
            },
            icons: {},
            containerAriaLabel: {
                default: "Notifications"
            },
            pauseWhenPageIsHidden: {
                type: Boolean,
                default: !1
            },
            cn: {}
        },
        setup(e) {
            function t(...e) {
                return e.filter(Boolean).join(" ")
            }
            function n() {
                if (typeof window > "u" || typeof document > "u")
                    return "ltr";
                const e = document.documentElement.getAttribute("dir");
                return "auto" !== e && e ? e : window.getComputedStyle(document.documentElement).direction
            }
            const r = e
              , o = Wn()
              , i = Et([])
              , a = ei((()=>{
                const e = i.value.filter((e=>e.position)).map((e=>e.position));
                return e.length > 0 ? Array.from(new Set([r.position].concat(e))) : [r.position]
            }
            ))
              , s = Et([])
              , l = Et(!1)
              , c = Et(!1)
              , u = Et("system" !== r.theme ? r.theme : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light")
              , d = ei((()=>r.cn || t))
              , p = Et(null)
              , h = Et(null)
              , f = Et(!1)
              , m = r.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
            function g(e) {
                i.value = i.value.filter((({id: t})=>t !== e.id))
            }
            const b = e=>{
                var t, n;
                f.value && (null == (n = null == (t = e.currentTarget) ? void 0 : t.contains) || !n.call(t, e.relatedTarget)) && (f.value = !1,
                h.value && (h.value.focus({
                    preventScroll: !0
                }),
                h.value = null))
            }
              , O = e=>{
                e.target instanceof HTMLElement && "false" === e.target.dataset.dismissible || f.value || (f.value = !0,
                h.value = e.relatedTarget)
            }
              , v = e=>{
                e.target && e.target instanceof HTMLElement && "false" === e.target.dataset.dismissible || (c.value = !1)
            }
            ;
            return Fr((e=>{
                const t = vX.subscribe((e=>{
                    e.dismiss ? i.value = i.value.map((t=>t.id === e.id ? {
                        ...t,
                        delete: !0
                    } : t)) : Xt((()=>{
                        const t = i.value.findIndex((t=>t.id === e.id));
                        -1 !== t ? i.value.splice(t, 1, e) : i.value = [e, ...i.value]
                    }
                    ))
                }
                ));
                e((()=>{
                    t()
                }
                ))
            }
            )),
            zr((()=>r.theme), (e=>{
                "system" === e ? ("system" === e && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? u.value = "dark" : u.value = "light"),
                !(typeof window > "u") && window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", (({matches: e})=>{
                    u.value = e ? "dark" : "light"
                }
                ))) : u.value = e
            }
            )),
            zr((()=>p.value), (()=>{
                if (p.value)
                    return ()=>{
                        h.value && (h.value.focus({
                            preventScroll: !0
                        }),
                        h.value = null,
                        f.value = !1)
                    }
            }
            )),
            Fr((()=>{
                i.value.length <= 1 && (l.value = !1)
            }
            )),
            Fr((e=>{
                function t(e) {
                    const t = r.hotkey.every((t=>e[t] || e.code === t))
                      , n = Array.isArray(p.value) ? p.value[0] : p.value;
                    t && (l.value = !0,
                    null == n || n.focus());
                    const o = document.activeElement === p.value || (null == n ? void 0 : n.contains(document.activeElement));
                    "Escape" === e.code && o && (l.value = !1)
                }
                eV && (document.addEventListener("keydown", t),
                e((()=>{
                    document.removeEventListener("keydown", t)
                }
                )))
            }
            )),
            (e,t)=>(mo(),
            vo("section", {
                "aria-label": `${e.containerAriaLabel} ${Ct(m)}`,
                tabIndex: -1
            }, [(mo(!0),
            vo(lo, null, In(a.value, ((r,a)=>{
                var u;
                return mo(),
                vo("ol", Io({
                    key: r,
                    ref_for: !0,
                    ref_key: "listRef",
                    ref: p,
                    "data-sonner-toaster": "",
                    class: e.class,
                    dir: "auto" === e.dir ? n() : e.dir,
                    tabIndex: -1,
                    "data-theme": e.theme,
                    "data-rich-colors": e.richColors,
                    "data-y-position": r.split("-")[0],
                    "data-x-position": r.split("-")[1],
                    style: {
                        "--front-toast-height": `${null == (u = s.value[0]) ? void 0 : u.height}px`,
                        "--offset": "number" == typeof e.offset ? `${e.offset}px` : e.offset || JX,
                        "--width": "356px",
                        "--gap": "14px",
                        ...e.style,
                        ...Ct(o).style
                    },
                    onBlur: b,
                    onFocus: O,
                    onMouseenter: t[1] || (t[1] = e=>l.value = !0),
                    onMousemove: t[2] || (t[2] = e=>l.value = !0),
                    onMouseleave: t[3] || (t[3] = ()=>{
                        c.value || (l.value = !1)
                    }
                    ),
                    onPointerdown: v,
                    onPointerup: t[4] || (t[4] = e=>c.value = !1)
                }, e.$attrs), [(mo(!0),
                vo(lo, null, In(i.value.filter((t=>!t.position && 0 === a || t.position === e.position)), ((n,r)=>{
                    var o, a, u, p, h, f, m, b, O;
                    return mo(),
                    yo(DX, {
                        key: n.id,
                        index: r,
                        toast: n,
                        duration: (null == (o = e.toastOptions) ? void 0 : o.duration) ?? e.duration,
                        class: Z(null == (a = e.toastOptions) ? void 0 : a.class),
                        descriptionClass: null == (u = e.toastOptions) ? void 0 : u.descriptionClass,
                        invert: e.invert,
                        visibleToasts: e.visibleToasts,
                        closeButton: (null == (p = e.toastOptions) ? void 0 : p.closeButton) ?? e.closeButton,
                        interacting: c.value,
                        position: e.position,
                        style: F(null == (h = e.toastOptions) ? void 0 : h.style),
                        unstyled: null == (f = e.toastOptions) ? void 0 : f.unstyled,
                        classes: null == (m = e.toastOptions) ? void 0 : m.classes,
                        cancelButtonStyle: null == (b = e.toastOptions) ? void 0 : b.cancelButtonStyle,
                        actionButtonStyle: null == (O = e.toastOptions) ? void 0 : O.actionButtonStyle,
                        toasts: i.value,
                        expandByDefault: e.expand,
                        gap: e.gap,
                        expanded: l.value,
                        pauseWhenPageIsHidden: e.pauseWhenPageIsHidden,
                        cn: d.value,
                        heights: s.value,
                        "onUpdate:heights": t[0] || (t[0] = e=>s.value = e),
                        onRemoveToast: g
                    }, {
                        "loading-icon": dn((()=>[Fn(e.$slots, "loading-icon", {}, (()=>[xo($X, {
                            visible: "loading" === n.type
                        }, null, 8, ["visible"])]))])),
                        "success-icon": dn((()=>[Fn(e.$slots, "success-icon", {}, (()=>[xo(QX)]))])),
                        "error-icon": dn((()=>[Fn(e.$slots, "error-icon", {}, (()=>[xo(GX)]))])),
                        "warning-icon": dn((()=>[Fn(e.$slots, "warning-icon", {}, (()=>[xo(ZX)]))])),
                        "info-icon": dn((()=>[Fn(e.$slots, "info-icon", {}, (()=>[xo(jX)]))])),
                        _: 2
                    }, 1032, ["index", "toast", "duration", "class", "descriptionClass", "invert", "visibleToasts", "closeButton", "interacting", "position", "style", "unstyled", "classes", "cancelButtonStyle", "actionButtonStyle", "toasts", "expandByDefault", "gap", "expanded", "pauseWhenPageIsHidden", "cn", "heights"])
                }
                )), 128))], 16, KX)
            }
            )), 128))], 8, YX))
        }
    })
      , nV = {
        toast: ()=>null
    };
    function rV(e) {
        nV.toast = e
    }
    function oV() {
        return {
            initializeToasts: rV,
            toast: (e,t="info",n={
                timeout: 3e3
            })=>{
                nV.toast(e, t, n)
            }
        }
    }
    const iV = Ln({
        __name: "ScalarToasts",
        setup(e) {
            const t = Et(!1);
            Sn((()=>t.value = !0));
            const n = {
                success: wX.success,
                error: wX.error,
                warn: wX.warning,
                info: wX
            }
              , {initializeToasts: r} = oV();
            return r(((e,t="info",r={})=>{
                (n[t] || n.info)(e, {
                    duration: r.timeout || 3e3,
                    description: r.description
                })
            }
            )),
            (e,n)=>t.value ? (mo(),
            yo(Ct(tV), {
                key: 0,
                toastOptions: {
                    class: "toaster"
                }
            })) : Do("", !0)
        }
    });
    !function() {
        try {
            if (typeof document < "u") {
                var e = document.createElement("style");
                e.appendChild(document.createTextNode(".toaster[data-sonner-toast][data-styled=true]{background:var(--scalar-background-1);color:var(--scalar-color-1);padding:18px;border:none;border-radius:var(--scalar-radius-lg);font-size:var(--scalar-font-size-3);font-weight:var(--scalar-font-medium);box-shadow:var(--scalar-shadow-2)}.toaster[data-sonner-toast] [data-icon]{align-self:start}.toaster[data-sonner-toast][data-styled=true][data-expanded=true]{height:auto}.toaster[data-sonner-toast][data-type=error]{background:var(--scalar-background-1)}.toaster[data-sonner-toast][data-type=error] [data-icon]{color:color-mix(in srgb,var(--scalar-color-red) 75%,var(--scalar-color-1))}.toaster[data-sonner-toast][data-type=warning]{background:var(--scalar-background-1)}.toaster[data-sonner-toast][data-type=warning] [data-icon]{color:color-mix(in srgb,var(--scalar-color-orange) 90%,var(--scalar-color-1))}")),
                document.head.appendChild(e)
            }
        } catch (ja) {
            console.error("vite-plugin-css-injected-by-js", ja)
        }
    }();
    const aV = {
        class: "card-form"
    };
    const sV = iq({}, [["render", function(e, t) {
        return mo(),
        vo("form", aV, [Fn(e.$slots, "default", {}, void 0, !0)])
    }
    ], ["__scopeId", "data-v-bc8cea71"]])
      , lV = Ln({
        __name: "CardFormButton",
        setup(e, {expose: t}) {
            const n = Et();
            return t({
                el: n
            }),
            (e,t)=>(mo(),
            vo("button", {
                ref_key: "el",
                ref: n,
                class: "card-form-button",
                type: "button"
            }, [Fn(e.$slots, "default", {}, void 0, !0)], 512))
        }
    })
      , cV = iq(lV, [["__scopeId", "data-v-6ae053e9"]])
      , uV = {
        class: "card-form-group"
    };
    const dV = iq({}, [["render", function(e, t) {
        return mo(),
        vo("div", uV, [Fn(e.$slots, "default", {}, void 0, !0)])
    }
    ], ["__scopeId", "data-v-d894ccf7"]])
      , pV = {
        class: "card-form-rows"
    };
    const hV = iq({}, [["render", function(e, t) {
        return mo(),
        vo("div", pV, [Fn(e.$slots, "default", {}, void 0, !0)])
    }
    ], ["__scopeId", "data-v-25140d72"]])
      , fV = {
        class: "card-form-input"
    }
      , mV = ["for"]
      , gV = ["id", "type"]
      , bV = Ln({
        inheritAttrs: !1,
        __name: "CardFormTextInput",
        props: {
            id: {},
            type: {}
        },
        setup(e) {
            const t = e
              , n = Et(!0)
              , r = ei((()=>"password" === t.type ? n.value ? "password" : "text" : t.type ?? "text"));
            return (e,t)=>(mo(),
            vo("div", fV, [Eo("label", {
                for: e.id
            }, [Fn(e.$slots, "default", {}, void 0, !0)], 8, mV), Eo("input", Io(e.$attrs, {
                id: e.id,
                autocomplete: "off",
                "data-1p-ignore": "",
                spellcheck: "false",
                type: r.value
            }), null, 16, gV), "password" === e.type ? (mo(),
            yo(Ct(aC), {
                key: 0,
                class: "password-mask",
                icon: n.value ? "Show" : "Hide",
                label: n.value ? "Show Password" : "Hide Password",
                onClick: t[0] || (t[0] = e=>n.value = !n.value)
            }, null, 8, ["icon", "label"])) : Do("", !0)]))
        }
    })
      , OV = iq(bV, [["__scopeId", "data-v-140f9914"]])
      , vV = e=>(cn("data-v-6c24ccba"),
    e = e(),
    un(),
    e)
      , yV = {
        class: "scopes-label"
    }
      , wV = vV((()=>Eo("em", null, "/", -1)))
      , _V = ["checked"]
      , kV = {
        class: "dropdown-item-title"
    }
      , SV = {
        class: "dropdown-item-description"
    }
      , EV = Ln({
        __name: "SecuritySchemeScopes",
        props: {
            scopes: {},
            selected: {}
        },
        emits: ["update:selected"],
        setup(e, {emit: t}) {
            const n = e
              , r = t
              , o = Et()
              , i = Et()
              , {floatingStyles: a} = function(e, t, n) {
                void 0 === n && (n = {});
                const r = n.whileElementsMounted
                  , o = ei((()=>{
                    var e;
                    return null == (e = Ct(n.open)) || e
                }
                ))
                  , i = ei((()=>Ct(n.middleware)))
                  , a = ei((()=>{
                    var e;
                    return null != (e = Ct(n.placement)) ? e : "bottom"
                }
                ))
                  , s = ei((()=>{
                    var e;
                    return null != (e = Ct(n.strategy)) ? e : "absolute"
                }
                ))
                  , l = ei((()=>{
                    var e;
                    return null == (e = Ct(n.transform)) || e
                }
                ))
                  , c = ei((()=>JA(e.value)))
                  , u = ei((()=>JA(t.value)))
                  , d = Et(0)
                  , p = Et(0)
                  , h = Et(s.value)
                  , f = Et(a.value)
                  , m = xt({})
                  , g = Et(!1)
                  , b = ei((()=>{
                    const e = {
                        position: h.value,
                        left: "0",
                        top: "0"
                    };
                    if (!u.value)
                        return e;
                    const t = tC(u.value, d.value)
                      , n = tC(u.value, p.value);
                    return l.value ? {
                        ...e,
                        transform: "translate(" + t + "px, " + n + "px)",
                        ...eC(u.value) >= 1.5 && {
                            willChange: "transform"
                        }
                    } : {
                        position: h.value,
                        left: t + "px",
                        top: n + "px"
                    }
                }
                ));
                let O;
                function v() {
                    null != c.value && null != u.value && KA(c.value, u.value, {
                        middleware: i.value,
                        placement: a.value,
                        strategy: s.value
                    }).then((e=>{
                        d.value = e.x,
                        p.value = e.y,
                        h.value = e.strategy,
                        f.value = e.placement,
                        m.value = e.middlewareData,
                        g.value = !0
                    }
                    ))
                }
                function y() {
                    "function" == typeof O && (O(),
                    O = void 0)
                }
                return zr([i, a, s], v, {
                    flush: "sync"
                }),
                zr([c, u], (function() {
                    y(),
                    void 0 !== r ? null == c.value || null == u.value || (O = r(c.value, u.value, v)) : v()
                }
                ), {
                    flush: "sync"
                }),
                zr(o, (function() {
                    o.value || (g.value = !1)
                }
                ), {
                    flush: "sync"
                }),
                oe() && ie(y),
                {
                    x: pt(d),
                    y: pt(p),
                    strategy: pt(h),
                    placement: pt(f),
                    middlewareData: pt(m),
                    isPositioned: pt(g),
                    floatingStyles: b,
                    update: v
                }
            }(o, i, {
                placement: "bottom-end",
                whileElementsMounted: XA,
                middleware: [VA(5), YA(), GA()]
            })
              , s = ei({
                get: ()=>n.selected,
                set: e=>r("update:selected", e)
            });
            return (e,t)=>{
                const n = vn(gn, r = "ResetStyles", !0, l) || r;
                var r, l;
                return Object.keys(e.scopes ?? {}).length ? (mo(),
                yo(Ct(Xs), {
                    key: 0,
                    modelValue: s.value,
                    "onUpdate:modelValue": t[0] || (t[0] = e=>s.value = e),
                    multiple: ""
                }, {
                    default: dn((({open: t})=>[Eo("div", {
                        ref_key: "trigger",
                        ref: o,
                        class: Z(["wrapper", {
                            "wrapper-open": t
                        }])
                    }, [xo(Ct(Vs), {
                        as: cV
                    }, {
                        default: dn((()=>[Eo("div", yV, [Co(" Scopes " + K(s.value.length), 1), wV, Co(K(Object.entries(e.scopes ?? {}).length) + " ", 1), xo(Ct(rC), {
                            icon: t ? "ChevronUp" : "ChevronDown",
                            size: "sm"
                        }, null, 8, ["icon"])])])),
                        _: 2
                    }, 1024)], 2), (mo(),
                    yo(ao, {
                        to: "body"
                    }, [xo(n, null, {
                        default: dn((({styles: t})=>[Eo("div", {
                            ref_key: "dropdown",
                            ref: i,
                            class: Z(["floating", t]),
                            style: F(Ct(a))
                        }, [xo(Ct(Gs), {
                            as: "dl",
                            class: "dropdown"
                        }, {
                            default: dn((()=>[(mo(!0),
                            vo(lo, null, In(Object.entries(e.scopes ?? {}), (([e,t])=>(mo(),
                            yo(Ct(Ys), {
                                key: e,
                                as: "div",
                                class: "dropdown-item",
                                value: e
                            }, {
                                default: dn((({selected: n})=>[Eo("input", {
                                    checked: n,
                                    class: "dropdown-item-check",
                                    tabindex: "-1",
                                    type: "checkbox"
                                }, null, 8, _V), Eo("dt", kV, K(e), 1), Eo("dd", SV, K(t), 1)])),
                                _: 2
                            }, 1032, ["value"])))), 128))])),
                            _: 1
                        })], 6)])),
                        _: 1
                    })]))])),
                    _: 1
                }, 8, ["modelValue"])) : Do("", !0)
            }
        }
    })
      , xV = iq(EV, [["__scopeId", "data-v-6c24ccba"]]);
    function TV(e) {
        var t;
        const n = null == (t = null == e ? void 0 : e.servers) ? void 0 : t[e.selectedServer ?? 0]
          , r = e.variables.reduce(((e,t)=>(e[t.name] = t.value,
        e)), {});
        return "string" == typeof (null == n ? void 0 : n.url) ? eW(null == n ? void 0 : n.url, r) : null == n ? void 0 : n.url
    }
    const AV = ()=>({
        selectedServer: null,
        servers: [],
        variables: []
    })
      , CV = ut({
        selectedServer: null,
        servers: [],
        variables: []
    })
      , PV = e=>{
        Object.assign(CV, {
            ...CV,
            ...e
        })
    }
      , DV = ()=>({
        server: CV,
        setServer: PV
    })
      , RV = Ln({
        __name: "SecurityScheme",
        props: {
            value: {},
            proxy: {}
        },
        setup(e) {
            const {toast: t} = oV()
              , {server: n} = DV()
              , {authentication: r, setAuthentication: o} = xq()
              , i = e=>{
                o({
                    apiKey: {
                        ...r.apiKey,
                        token: e.target.value
                    }
                })
            }
              , a = e=>{
                o({
                    http: {
                        ...r.http,
                        basic: {
                            ...r.http.basic,
                            username: e.target.value
                        }
                    }
                })
            }
              , s = e=>{
                o({
                    http: {
                        ...r.http,
                        basic: {
                            ...r.http.basic,
                            password: e.target.value
                        }
                    }
                })
            }
              , l = e=>{
                o({
                    http: {
                        ...r.http,
                        bearer: {
                            ...r.http.bearer,
                            token: e.target.value
                        }
                    }
                })
            }
              , c = e=>{
                o({
                    oAuth2: {
                        ...r.oAuth2,
                        clientId: e.target.value
                    }
                })
            }
              , u = e=>{
                o({
                    oAuth2: {
                        ...r.oAuth2,
                        username: e.target.value
                    }
                })
            }
              , d = e=>{
                o({
                    oAuth2: {
                        ...r.oAuth2,
                        password: e.target.value
                    }
                })
            }
            ;
            const p = ei({
                get: ()=>r.oAuth2.scopes,
                set: e=>o({
                    oAuth2: {
                        ...r.oAuth2,
                        scopes: e
                    }
                })
            });
            return (e,h)=>{
                var f;
                return e.value && null != (f = e.value) && f.type ? (mo(),
                yo(sV, {
                    key: 0
                }, {
                    default: dn((()=>["apiKey" === e.value.type ? (mo(),
                    yo(OV, {
                        key: 0,
                        id: `security-scheme-${e.value.name}`,
                        placeholder: "Token",
                        type: "password",
                        value: Ct(r).apiKey.token,
                        onInput: i
                    }, {
                        default: dn((()=>{
                            var t, n, r;
                            return [e.value.in ? (mo(),
                            vo(lo, {
                                key: 0
                            }, [Co(K((null == (n = null == (t = e.value.in) ? void 0 : t.charAt(0)) ? void 0 : n.toUpperCase()) + (null == (r = e.value.in) ? void 0 : r.slice(1))), 1)], 64)) : Do("", !0), Co(" API ")]
                        }
                        )),
                        _: 1
                    }, 8, ["id", "value"])) : "http" === e.value.type || "basic" === e.value.type ? (mo(),
                    vo(lo, {
                        key: 1
                    }, ["basic" === e.value.type || "basic" === e.value.scheme ? (mo(),
                    yo(dV, {
                        key: 0
                    }, {
                        default: dn((()=>[xo(OV, {
                            id: "http.basic.username",
                            placeholder: "Username",
                            value: Ct(r).http.basic.username,
                            onInput: a
                        }, {
                            default: dn((()=>[Co(" Username ")])),
                            _: 1
                        }, 8, ["value"]), xo(OV, {
                            id: "http.basic.password",
                            placeholder: "Password",
                            type: "password",
                            value: Ct(r).http.basic.password,
                            onInput: s
                        }, {
                            default: dn((()=>[Co(" Password ")])),
                            _: 1
                        }, 8, ["value"])])),
                        _: 1
                    })) : "http" === e.value.type && "bearer" === e.value.scheme ? (mo(),
                    yo(OV, {
                        key: 1,
                        id: "http.bearer.token",
                        placeholder: "Token",
                        type: "password",
                        value: Ct(r).http.bearer.token,
                        onInput: l
                    }, {
                        default: dn((()=>[Co(" Bearer Token ")])),
                        _: 1
                    }, 8, ["value"])) : Do("", !0)], 64)) : "oauth2" === e.value.type.toLowerCase() && e.value.flows ? (mo(),
                    yo(dV, {
                        key: 2
                    }, {
                        default: dn((()=>{
                            var i, a;
                            return [e.value.flows.implicit ? (mo(),
                            vo(lo, {
                                key: 0
                            }, [Ct(r).oAuth2.accessToken ? (mo(),
                            vo(lo, {
                                key: 0
                            }, [xo(OV, {
                                id: "oAuth2.accessToken",
                                placeholder: "xxxxx",
                                type: "password",
                                value: Ct(r).oAuth2.accessToken
                            }, {
                                default: dn((()=>[Co(" Access Token ")])),
                                _: 1
                            }, 8, ["value"]), xo(cV, {
                                onClick: h[0] || (h[0] = ()=>Ct(o)({
                                    oAuth2: {
                                        ...Ct(r).oAuth2,
                                        accessToken: "",
                                        state: ""
                                    }
                                }))
                            }, {
                                default: dn((()=>[Co(" Reset ")])),
                                _: 1
                            })], 64)) : Do("", !0)], 64)) : Do("", !0), null != (a = null == (i = e.value) ? void 0 : i.flows) && a.password ? (mo(),
                            yo(hV, {
                                key: 1
                            }, {
                                default: dn((()=>[xo(dV, null, {
                                    default: dn((()=>[xo(OV, {
                                        id: "oAuth2.username",
                                        placeholder: "Username",
                                        value: Ct(r).oAuth2.username,
                                        onInput: u
                                    }, {
                                        default: dn((()=>[Co(" Username ")])),
                                        _: 1
                                    }, 8, ["value"]), xo(OV, {
                                        id: "oAuth2.password",
                                        placeholder: "Password",
                                        type: "password",
                                        value: Ct(r).oAuth2.password,
                                        onInput: d
                                    }, {
                                        default: dn((()=>[Co(" Password ")])),
                                        _: 1
                                    }, 8, ["value"])])),
                                    _: 1
                                }), xo(dV, null, {
                                    default: dn((()=>{
                                        var i, a, s, l, u, d, f, m, g, b, O;
                                        return [xo(OV, {
                                            id: "oAuth2.clientId",
                                            placeholder: "12345",
                                            type: "text",
                                            value: Ct(r).oAuth2.clientId,
                                            onInput: c
                                        }, {
                                            default: dn((()=>[Co(" Client ID ")])),
                                            _: 1
                                        }, 8, ["value"]), void 0 !== e.value && Object.entries((null == (s = null == (a = null == (i = e.value) ? void 0 : i.flows) ? void 0 : a.implicit) ? void 0 : s.scopes) ?? (null == (d = null == (u = null == (l = e.value) ? void 0 : l.flows) ? void 0 : u.password) ? void 0 : d.scopes) ?? {}).length > 0 ? (mo(),
                                        yo(xV, {
                                            key: 0,
                                            selected: p.value,
                                            "onUpdate:selected": h[1] || (h[1] = e=>p.value = e),
                                            scopes: (null == (g = null == (m = null == (f = e.value) ? void 0 : f.flows) ? void 0 : m.implicit) ? void 0 : g.scopes) ?? (null == (O = null == (b = e.value) ? void 0 : b.flows) ? void 0 : O.password.scopes)
                                        }, null, 8, ["selected", "scopes"])) : Do("", !0), Eo("button", {
                                            class: "cardform-auth-button",
                                            type: "button",
                                            onClick: h[2] || (h[2] = ()=>{
                                                var i, a;
                                                return function(e, n) {
                                                    if ("string" != typeof e)
                                                        return void console.log("tokenUrl is not a string");
                                                    const i = null != n && n.baseUrl && !e.startsWith("http") ? JZ(null == n ? void 0 : n.baseUrl, e) : e
                                                      , a = new URL(i);
                                                    a.searchParams.set("grant_type", "password"),
                                                    a.searchParams.set("username", r.oAuth2.username),
                                                    a.searchParams.set("password", r.oAuth2.password),
                                                        a.searchParams.set("client_id", r.oAuth2.clientId),
                                                        a.searchParams.set("resouce_id", "api://f58729ba-d0c3-4c77-b2b4-a811bb5ff182"),
                                                    a.searchParams.set("scope", r.oAuth2.scopes.join(" ")),
                                                    fetch(null != n && n.proxy ? WZ(null == n ? void 0 : n.proxy, a.toString()) : a.toString(), {
                                                        method: "POST",
                                                        headers: {
                                                            "Content-Type": "application/x-www-form-urlencoded"
                                                        }
                                                    }).then((e=>{
                                                        if (!e.ok)
                                                            throw new Error("Failed to get an access token. Please check your credentials.");
                                                        return e.json()
                                                    }
                                                    )).then((e=>{
                                                        o({
                                                            oAuth2: {
                                                                ...r.oAuth2,
                                                                accessToken: e.access_token
                                                            }
                                                        })
                                                    }
                                                    )).catch((e=>{
                                                        t("Couldn’t retrieve the password grant token", "warn", {
                                                            description: "Open your browser console to get more information."
                                                        }),
                                                        console.error("[authorizeWithPassword]", e)
                                                    }
                                                    ))
                                                }(null == (a = null == (i = e.value.flows) ? void 0 : i.password) ? void 0 : a.tokenUrl, {
                                                    baseUrl: Ct(TV)(Ct(n)),
                                                    proxy: e.proxy
                                                })
                                            }
                                            )
                                        }, " Authorize ")]
                                    }
                                    )),
                                    _: 1
                                })])),
                                _: 1
                            })) : (mo(),
                            yo(hV, {
                                key: 2
                            }, {
                                default: dn((()=>[xo(dV, null, {
                                    default: dn((()=>{
                                        var t, n;
                                        return [xo(OV, {
                                            id: "oAuth2.clientId",
                                            placeholder: "12345",
                                            type: "text",
                                            value: Ct(r).oAuth2.clientId,
                                            onInput: c
                                        }, {
                                            default: dn((()=>[Co(" Client ID ")])),
                                            _: 1
                                        }, 8, ["value"]), void 0 !== e.value && Object.entries((null == (t = e.value.flows.implicit) ? void 0 : t.scopes) ?? e.value.flows.password.scopes).length > 0 ? (mo(),
                                        yo(xV, {
                                            key: 0,
                                            selected: p.value,
                                            "onUpdate:selected": h[3] || (h[3] = e=>p.value = e),
                                            scopes: (null == (n = e.value.flows.implicit) ? void 0 : n.scopes) ?? e.value.flows.password.scopes
                                        }, null, 8, ["selected", "scopes"])) : Do("", !0), Eo("button", {
                                            class: "cardform-auth-button",
                                            type: "button",
                                            onClick: h[4] || (h[4] = ()=>{
                                                var t, n, i, a;
                                                return (e=>{
                                                    const t = window.open(e, "openAuth2Window", "left=100,top=100,width=800,height=600");
                                                    if (t) {
                                                        const e = setInterval((function() {
                                                            var n;
                                                            try {
                                                                const i = new URLSearchParams(t.location.href).get("access_token");
                                                                if (t.closed || i) {
                                                                    clearInterval(e);
                                                                    const a = null == (n = t.location.href.match(/state=([^&]*)/)) ? void 0 : n[1];
                                                                    i && r.oAuth2.state === a && o({
                                                                        oAuth2: {
                                                                            ...r.oAuth2,
                                                                            accessToken: i
                                                                        }
                                                                    }),
                                                                    t.close()
                                                                }
                                                            } catch {}
                                                        }
                                                        ), 200)
                                                    }
                                                }
                                                )(function(e) {
                                                    const t = r.oAuth2.scopes.join(" ")
                                                      , n = (Math.random() + 1).toString(36).substring(7)
                                                      , i = new URL(e.authorizationUrl);
                                                    return o({
                                                        oAuth2: {
                                                            ...r.oAuth2,
                                                            state: n
                                                        }
                                                    }),
                                                    i.searchParams.set("response_type", "token"),
                                                    i.searchParams.set("client_id", r.oAuth2.clientId),
                                                    i.searchParams.set("redirect_uri", window.location.href),
                                                    i.searchParams.set("scope", t),
                                                    i.searchParams.set("state", n),
                                                    i.toString()
                                                }((null == (n = null == (t = e.value) ? void 0 : t.flows) ? void 0 : n.implicit) ?? (null == (a = null == (i = e.value) ? void 0 : i.flows) ? void 0 : a.password)))
                                            }
                                            )
                                        }, " Authorize ")]
                                    }
                                    )),
                                    _: 1
                                })])),
                                _: 1
                            }))]
                        }
                        )),
                        _: 1
                    })) : Do("", !0)])),
                    _: 1
                })) : Do("", !0)
            }
        }
    })
      , NV = iq(RV, [["__scopeId", "data-v-d25c85a2"]])
      , $V = e=>(cn("data-v-4f880c55"),
    e = e(),
    un(),
    e)
      , IV = {
        key: 0,
        class: "security-scheme-label"
    }
      , MV = {
        key: 1,
        class: "security-scheme-selector"
    }
      , LV = {
        class: "security-scheme-label"
    }
      , QV = ["value"]
      , BV = $V((()=>Eo("option", {
        value: ""
    }, "None", -1)))
      , UV = ["value"]
      , FV = Ln({
        __name: "SecuritySchemeSelector",
        props: {
            value: {}
        },
        emits: ["input"],
        setup(e, {emit: t}) {
            const n = e
              , r = t
              , {authentication: o, setAuthentication: i} = xq()
              , a = e=>{
                s(e.target.value)
            }
            ;
            Sn((()=>{
                o.preferredSecurityScheme || s(Object.keys(n.value ?? {})[0] ?? null)
            }
            ));
            const s = e=>{
                i({
                    preferredSecurityScheme: e
                }),
                r("input", e)
            }
            ;
            Cn((()=>s(Object.keys(n.value ?? {})[0] ?? null)));
            const l = (e,t)=>`${c(e)} (${t})`
              , c = e=>{
                var t, n;
                return (e=>!(null != e && e.type))(e) ? "No Authentication" : (e=>"apikey" === e.type.toLowerCase())(e) ? "API Key" : (e=>"http" === e.type && "basic" === e.scheme.toLowerCase() || "basic" === e.type.toLowerCase())(e) ? "Basic Authentication" : (e=>"http" === e.type && "bearer" === e.scheme.toLowerCase())(e) ? "Bearer Authentication" : (e=>"oauth2" === e.type.toLowerCase())(e) ? null != (t = e.flows) && t.implicit ? "OAuth 2.0 Implicit" : null != (n = e.flows) && n.password ? "OAuth 2.0 Password" : "OAuth 2.0" : `${e.type} (not yet supported)`
            }
              , u = ei((()=>Object.keys(n.value ?? {})));
            return (e,t)=>{
                var n, r;
                return 1 === u.value.length ? (mo(),
                vo("div", IV, K(l(null == (n = e.value) ? void 0 : n[u.value[0]], u.value[0])), 1)) : u.value.length > 1 ? (mo(),
                vo("div", MV, [Eo("span", LV, K(Ct(o).preferredSecurityScheme ? l(null == (r = e.value) ? void 0 : r[Ct(o).preferredSecurityScheme], Ct(o).preferredSecurityScheme) : "None"), 1), xo(Ct(rC), {
                    icon: "ChevronDown"
                }), Eo("select", {
                    value: Ct(o).preferredSecurityScheme,
                    onClick: t[0] || (t[0] = zi((()=>{}
                    ), ["prevent"])),
                    onInput: a
                }, [BV, (mo(!0),
                vo(lo, null, In(u.value, (t=>{
                    var n;
                    return mo(),
                    vo("option", {
                        key: t,
                        value: t ?? null
                    }, K(l(null == (n = e.value) ? void 0 : n[t], t)), 9, UV)
                }
                )), 128))], 40, QV)])) : Do("", !0)
            }
        }
    })
      , jV = iq(FV, [["__scopeId", "data-v-4f880c55"]])
      , zV = {
        key: 0,
        class: "preferred-security-scheme"
    }
      , qV = {
        key: 1,
        class: "security-scheme-empty-state"
    }
      , HV = Ln({
        __name: "RequestAuthentication",
        props: {
            proxy: {}
        },
        setup(e) {
            const t = Et(null);
            SW.on((()=>{
                t.value && t.value.scrollIntoView({
                    behavior: "smooth",
                    block: "center"
                })
            }
            ));
            const {authentication: n, setAuthentication: r} = xq()
              , o = e=>{
                r({
                    customSecurity: !0,
                    preferredSecurityScheme: e,
                    securitySchemes: {
                        apiKey: {
                            type: "apiKey",
                            name: "apiKey",
                            in: "header"
                        },
                        httpBasic: {
                            type: "http",
                            scheme: "basic"
                        },
                        httpBearer: {
                            type: "http",
                            scheme: "bearer"
                        }
                    }
                })
            }
            ;
            return (e,r)=>(mo(),
            vo("div", {
                ref_key: "requestAuthenticationRef",
                ref: t
            }, [xo(Ct(kW), {
                title: "Authentication"
            }, {
                options: dn((()=>[xo(jV, {
                    value: Ct(n).securitySchemes
                }, null, 8, ["value"])])),
                default: dn((()=>{
                    var t;
                    return [Ct(n).preferredSecurityScheme ? (mo(),
                    vo("div", zV, [xo(NV, {
                        proxy: e.proxy,
                        value: null == (t = Ct(n).securitySchemes) ? void 0 : t[Ct(n).preferredSecurityScheme]
                    }, null, 8, ["proxy", "value"])])) : Do("", !0), Ct(n).securitySchemes ? Do("", !0) : (mo(),
                    vo("div", qV, [Eo("div", {
                        class: "scalar-api-client-add",
                        variant: "outlined",
                        onClick: r[0] || (r[0] = e=>o("apiKey"))
                    }, " ApiKey "), Eo("div", {
                        class: "scalar-api-client-add",
                        variant: "outlined",
                        onClick: r[1] || (r[1] = e=>o("httpBasic"))
                    }, " Basic "), Eo("div", {
                        class: "scalar-api-client-add",
                        variant: "outlined",
                        onClick: r[2] || (r[2] = e=>o("httpBearer"))
                    }, " Bearer ")]))]
                }
                )),
                _: 1
            })], 512))
        }
    })
      , ZV = iq(HV, [["__scopeId", "data-v-9f62f731"]])
      , WV = {
        class: "scalar-api-client__main__left custom-scroll"
    }
      , XV = {
        class: "scalar-api-client__main__content"
    }
      , VV = {
        class: "scalar-api-client__main__content__header"
    }
      , GV = Eo("label", null, "Request", -1)
      , YV = {
        class: "meta"
    }
      , KV = {
        class: "meta-item meta-item__input"
    }
      , JV = {
        class: "scalar-api-client__main__content__body"
    }
      , eG = Eo("div", {
        class: "scalar-api-client__main__scroll-container"
    }, null, -1)
      , tG = Ln({
        __name: "Request",
        setup(e) {
            const {activeRequest: t} = eq()
              , {authentication: n} = xq()
              , {openApi: {operation: r, globalSecurity: o}} = Dq()
              , i = ei((()=>{
                var e;
                return yq(n, (null == (e = null == r ? void 0 : r.information) ? void 0 : e.security) ?? o)
            }
            ))
              , a = ei((()=>{
                const e = t.type.toLowerCase();
                return "put" === e || "post" === e || "patch" === e || "delete" === e
            }
            ));
            return (e,n)=>(mo(),
            vo("div", WV, [Eo("div", XV, [Eo("div", VV, [GV, Eo("div", YV, [Eo("div", KV, [Nn(Eo("input", {
                "onUpdate:modelValue": n[0] || (n[0] = e=>Ct(t).name = e),
                class: "scalar-api-client__request-name",
                disabled: true,
                placeholder: "Request Name",
                type: "text"
            }, null, 512), [[$i, Ct(t).name]])])])]), Eo("div", JV, [xo(Ct(ZV)), xo(mX, {
                variables: Ct(t).variables
            }, null, 8, ["variables"]), xo(aX, {
                cookies: Ct(t).cookies,
                generatedCookies: i.value.cookies
            }, null, 8, ["cookies", "generatedCookies"]), xo(cX, {
                generatedHeaders: i.value.headers,
                headers: Ct(t).headers
            }, null, 8, ["generatedHeaders", "headers"]), xo(pX, {
                generatedQueries: i.value.queryString,
                queries: Ct(t).query
            }, null, 8, ["generatedQueries", "queries"]), a.value ? (mo(),
            yo(rX, {
                key: 0,
                body: Ct(t).body,
                formData: Ct(t).formData,
                requestBody: Ct(t).body
            }, null, 8, ["body", "formData", "requestBody"])) : Do("", !0), eG])])]))
        }
    })
      , nG = {
        class: "ascii-art"
    }
      , rG = {
        class: "ascii-art-line"
    }
      , oG = Ln({
        __name: "ScalarAsciiArt",
        props: {
            art: {}
        },
        setup(e) {
            const t = e
              , n = ei((()=>t.art.split("\n")));
            return (e,t)=>(mo(),
            vo("div", nG, [(mo(!0),
            vo(lo, null, In(n.value, ((e,t)=>(mo(),
            vo("span", {
                key: t,
                class: "ascii-art-line-wrapper",
                style: F({
                    width: `calc(${e.length + 1}ch)`
                })
            }, [Eo("span", rG, K(e), 1)], 4)))), 128))]))
        }
    })
      , iG = iq(oG, [["__scopeId", "data-v-9045c053"]])
      , aG = e=>Object.fromEntries(Object.entries(e ?? {}).map((([e,t])=>[e.toLowerCase(), t])))
      , sG = {
        key: 1,
        class: "scalar-api-client__empty-state"
    }
      , lG = {
        key: 1,
        class: "scalar-api-client__empty-state"
    }
      , cG = Ln({
        __name: "ResponseBody",
        props: {
            response: {}
        },
        setup(e) {
            const t = e
              , n = ei((()=>{
                var e;
                const n = `${aG(null == (e = t.response) ? void 0 : e.headers)["content-type"]}`;
                return n ? UT(n) : null
            }
            ))
              , r = ei((()=>"application/json" === n.value ? "json" : ("text/html" === n.value || n.value,
            "html")))
              , o = ei((()=>{
                var e;
                const n = null == (e = t.response) ? void 0 : e.data;
                return n && LT(n) ? JSON.stringify(JSON.parse(n), null, 2) : n && "object" == typeof Ot(n) ? JSON.stringify(n, null, 2) : n
            }
            ));
            return (e,t)=>(mo(),
            yo(Ct(kW), {
                title: "Body"
            }, {
                default: dn((()=>{
                    var t, i;
                    return [e.response ? (mo(),
                    vo(lo, {
                        key: 0
                    }, [r.value || "string" == typeof e.response.data ? (mo(),
                    yo(Ct(ZT), {
                        key: 0,
                        class: "custom-scroll",
                        content: o.value || (null == (i = null == (t = e.response) ? void 0 : t.error) ? void 0 : i.message),
                        lang: r.value
                    }, null, 8, ["content", "lang"])) : (mo(),
                    vo("div", sG, [n.value ? (mo(),
                    vo(lo, {
                        key: 0
                    }, [Co(" No preview available for " + K(n.value), 1)], 64)) : (mo(),
                    vo(lo, {
                        key: 1
                    }, [Co(" Can’t render a preview. The Content-Type header is missing or unknown. ")], 64))]))], 64)) : (mo(),
                    vo("div", lG, " No Response "))]
                }
                )),
                _: 1
            }))
        }
    })
      , uG = {
        class: "simple-table-container"
    }
      , dG = {
        class: "simple-table"
    };
    const pG = iq({}, [["render", function(e, t) {
        return mo(),
        vo("div", uG, [Eo("table", dG, [Fn(e.$slots, "default", {}, void 0, !0)])])
    }
    ], ["__scopeId", "data-v-afe94232"]])
      , hG = {
        class: "simple-row"
    };
    const fG = iq({}, [["render", function(e, t) {
        return mo(),
        vo("tr", hG, [Fn(e.$slots, "default", {}, void 0, !0)])
    }
    ], ["__scopeId", "data-v-3e78d3f1"]])
      , mG = ["href"]
      , gG = Ln({
        __name: "HelpfulLink",
        props: {
            href: {}
        },
        setup: e=>(e,t)=>(mo(),
        vo("a", {
            href: e.href,
            rel: "noopener noreferrer",
            target: "_blank"
        }, [Fn(e.$slots, "default", {}, void 0, !0)], 8, mG))
    })
      , bG = iq(gG, [["__scopeId", "data-v-88788c44"]])
      , OG = Ln({
        __name: "SimpleCell",
        props: {
            wrap: {
                type: Boolean,
                default: !0
            },
            strong: {
                type: Boolean,
                default: !1
            },
            href: {
                default: null
            }
        },
        setup: e=>(e,t)=>(mo(),
        vo("td", {
            class: Z(["simple-cell", {
                wrap: e.wrap,
                strong: e.strong
            }])
        }, [e.href ? (mo(),
        yo(bG, {
            key: 0,
            href: e.href
        }, {
            default: dn((()=>[Fn(e.$slots, "default", {}, void 0, !0)])),
            _: 3
        }, 8, ["href"])) : Fn(e.$slots, "default", {
            key: 1
        }, void 0, !0)], 2))
    })
      , vG = iq(OG, [["__scopeId", "data-v-52c6cbd0"]])
      , yG = Ln({
        __name: "SimpleHeader",
        setup: e=>(e,t)=>(mo(),
        yo(vG, {
            as: "th",
            class: "simple-header"
        }, {
            default: dn((()=>[Fn(e.$slots, "default", {}, void 0, !0)])),
            _: 3
        }))
    })
      , wG = iq(yG, [["__scopeId", "data-v-e3a12d86"]])
      , _G = [{
        name: "Accept",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept"
    }, {
        name: "Accept-CH",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH"
    }, {
        name: "Accept-CH-Lifetime",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH-Lifetime"
    }, {
        name: "Accept-Charset",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Charset"
    }, {
        name: "Accept-Encoding",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding"
    }, {
        name: "Accept-Language",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language"
    }, {
        name: "Accept-Patch",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Patch"
    }, {
        name: "Accept-Post",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Post"
    }, {
        name: "Accept-Ranges",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Ranges"
    }, {
        name: "Access-Control-Allow-Credentials",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials"
    }, {
        name: "Access-Control-Allow-Headers",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers"
    }, {
        name: "Access-Control-Allow-Methods",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods"
    }, {
        name: "Access-Control-Allow-Origin",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"
    }, {
        name: "Access-Control-Expose-Headers",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers"
    }, {
        name: "Access-Control-Max-Age",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Max-Age"
    }, {
        name: "Access-Control-Request-Headers",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Request-Headers"
    }, {
        name: "Access-Control-Request-Method",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Request-Method"
    }, {
        name: "Age",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Age"
    }, {
        name: "Allow",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Allow"
    }, {
        name: "Alt-Svc",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Alt-Svc"
    }, {
        name: "Alt-Used",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Alt-Used"
    }, {
        name: "Authorization",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization"
    }, {
        name: "Cache-Control",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control"
    }, {
        name: "Clear-Site-Data",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Clear-Site-Data"
    }, {
        name: "Connection",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Connection"
    }, {
        name: "Content-Disposition",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition"
    }, {
        name: "Content-DPR",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-DPR"
    }, {
        name: "Content-Encoding",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding"
    }, {
        name: "Content-Language",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Language"
    }, {
        name: "Content-Length",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length"
    }, {
        name: "Content-Location",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Location"
    }, {
        name: "Content-Range",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range"
    }, {
        name: "Content-Security-Policy",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy"
    }, {
        name: "Content-Security-Policy-Report-Only",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy-Report-Only"
    }, {
        name: "Content-Type",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type"
    }, {
        name: "Cookie",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cookie"
    }, {
        name: "Critical-CH",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Critical-CH"
    }, {
        name: "Cross-Origin-Embedder-Policy",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy"
    }, {
        name: "Cross-Origin-Opener-Policy",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy"
    }, {
        name: "Cross-Origin-Resource-Policy",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Resource-Policy"
    }, {
        name: "Date",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Date"
    }, {
        name: "Device-Memory",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Device-Memory"
    }, {
        name: "Digest",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Digest"
    }, {
        name: "DNT",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DNT"
    }, {
        name: "Downlink",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Downlink"
    }, {
        name: "DPR",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DPR"
    }, {
        name: "Early-Data",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Early-Data"
    }, {
        name: "ECT",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ECT"
    }, {
        name: "ETag",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"
    }, {
        name: "Expect",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expect"
    }, {
        name: "Expect-CT",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expect-CT"
    }, {
        name: "Expires",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires"
    }, {
        name: "Forwarded",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded"
    }, {
        name: "From",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/From"
    }, {
        name: "Host",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host"
    }, {
        name: "If-Match",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match"
    }, {
        name: "If-Modified-Since",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since"
    }, {
        name: "If-None-Match",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match"
    }, {
        name: "If-Range",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Range"
    }, {
        name: "If-Unmodified-Since",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Unmodified-Since"
    }, {
        name: "Keep-Alive",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Keep-Alive"
    }, {
        name: "Large-Allocation",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Large-Allocation"
    }, {
        name: "Last-Modified",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified"
    }, {
        name: "Link",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Link"
    }, {
        name: "Location",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Location"
    }, {
        name: "Max-Forwards",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards"
    }, {
        name: "NEL",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/NEL"
    }, {
        name: "Origin",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin"
    }, {
        name: "Permissions-Policy",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Permissions-Policy"
    }, {
        name: "Pragma",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Pragma"
    }, {
        name: "Proxy-Authenticate",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Proxy-Authenticate"
    }, {
        name: "Proxy-Authorization",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Proxy-Authorization"
    }, {
        name: "Range",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range"
    }, {
        name: "Referer",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer"
    }, {
        name: "Referrer-Policy",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy"
    }, {
        name: "Retry-After",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"
    }, {
        name: "RTT",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/RTT"
    }, {
        name: "Save-Data",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Save-Data"
    }, {
        name: "Sec-CH-Prefers-Reduced-Motion",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-Prefers-Reduced-Motion"
    }, {
        name: "Sec-CH-Prefers-Reduced-Transparency",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-Prefers-Reduced-Transparency"
    }, {
        name: "Sec-CH-UA",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA"
    }, {
        name: "Sec-CH-UA-Arch",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Arch"
    }, {
        name: "Sec-CH-UA-Bitness",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Bitness"
    }, {
        name: "Sec-CH-UA-Full-Version",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Full-Version"
    }, {
        name: "Sec-CH-UA-Full-Version-List",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Full-Version-List"
    }, {
        name: "Sec-CH-UA-Mobile",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Mobile"
    }, {
        name: "Sec-CH-UA-Model",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Model"
    }, {
        name: "Sec-CH-UA-Platform",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Platform"
    }, {
        name: "Sec-CH-UA-Platform-Version",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Platform-Version"
    }, {
        name: "Sec-Fetch-Dest",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Dest"
    }, {
        name: "Sec-Fetch-Mode",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Mode"
    }, {
        name: "Sec-Fetch-Site",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Site"
    }, {
        name: "Sec-Fetch-User",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-User"
    }, {
        name: "Sec-GPC",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-GPC"
    }, {
        name: "Sec-Purpose",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Purpose"
    }, {
        name: "Sec-WebSocket-Accept",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-WebSocket-Accept"
    }, {
        name: "Server",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Server"
    }, {
        name: "Server-Timing",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Server-Timing"
    }, {
        name: "Service-Worker-Navigation-Preload",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Service-Worker-Navigation-Preload"
    }, {
        name: "Set-Cookie",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie"
    }, {
        name: "SourceMap",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/SourceMap"
    }, {
        name: "Strict-Transport-Security",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security"
    }, {
        name: "TE",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/TE"
    }, {
        name: "Timing-Allow-Origin",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Timing-Allow-Origin"
    }, {
        name: "Tk",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Tk"
    }, {
        name: "Trailer",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Trailer"
    }, {
        name: "Transfer-Encoding",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding"
    }, {
        name: "Upgrade",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade"
    }, {
        name: "Upgrade-Insecure-Requests",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade-Insecure-Requests"
    }, {
        name: "User-Agent",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent"
    }, {
        name: "Vary",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Vary"
    }, {
        name: "Via",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Via"
    }, {
        name: "Viewport-Width",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Viewport-Width"
    }, {
        name: "Want-Digest",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Want-Digest"
    }, {
        name: "Warning",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Warning"
    }, {
        name: "Width",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Width"
    }, {
        name: "WWW-Authenticate",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/WWW-Authenticate"
    }, {
        name: "X-Content-Type-Options",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options"
    }, {
        name: "X-DNS-Prefetch-Control",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-DNS-Prefetch-Control"
    }, {
        name: "Non-standard",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Non-standard"
    }, {
        name: "X-Forwarded-For",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For"
    }, {
        name: "Non-standard",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Non-standard"
    }, {
        name: "X-Forwarded-Host",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host"
    }, {
        name: "Non-standard",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Non-standard"
    }, {
        name: "X-Forwarded-Proto",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto"
    }, {
        name: "Non-standard",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Non-standard"
    }, {
        name: "X-Frame-Options",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options"
    }, {
        name: "X-XSS-Protection",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection"
    }, {
        name: "Cf-Cache-Status",
        url: "https://developers.cloudflare.com/cache/concepts/default-cache-behavior/#cloudflare-cache-responses"
    }, {
        name: "Cf-Ray",
        url: "https://developers.cloudflare.com/fundamentals/get-started/reference/http-request-headers/#cf-ray"
    }, {
        name: "Report-To",
        url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/report-to"
    }]
      , kG = {
        key: 1,
        class: "scalar-api-client__empty-state"
    }
      , SG = Ln({
        __name: "ResponseHeaders",
        props: {
            headers: {}
        },
        setup(e) {
            const t = e=>{
                var t;
                return null == (t = _G.find((t=>t.name.toLowerCase() === e.toLowerCase()))) ? void 0 : t.url
            }
              , n = e=>e.split("-").map((e=>e.charAt(0).toUpperCase() + e.slice(1))).join("-");
            return (e,r)=>(mo(),
            yo(Ct(kW), {
                title: "Headers"
            }, {
                default: dn((()=>[e.headers.length > 0 ? (mo(),
                yo(Ct(pG), {
                    key: 0
                }, {
                    default: dn((()=>[xo(Ct(fG), null, {
                        default: dn((()=>[xo(Ct(wG), null, {
                            default: dn((()=>[Co("Key")])),
                            _: 1
                        }), xo(Ct(wG), null, {
                            default: dn((()=>[Co("Value")])),
                            _: 1
                        })])),
                        _: 1
                    }), (mo(!0),
                    vo(lo, null, In(e.headers, (e=>(mo(),
                    yo(Ct(fG), {
                        key: e.name
                    }, {
                        default: dn((()=>[xo(Ct(vG), {
                            href: t(e.name),
                            strong: !0,
                            wrap: !1
                        }, {
                            default: dn((()=>[Co(K(n(e.name)), 1)])),
                            _: 2
                        }, 1032, ["href"]), xo(Ct(vG), null, {
                            default: dn((()=>[Co(K(e.value), 1)])),
                            _: 2
                        }, 1024)])),
                        _: 2
                    }, 1024)))), 128))])),
                    _: 1
                })) : (mo(),
                vo("div", kG, "No Headers"))])),
                _: 1
            }))
        }
    })
      , EG = {
        class: "meta-item"
    }
      , xG = {
        key: 0,
        class: "meta-item"
    }
      , TG = {
        class: "meta-item"
    }
      , AG = Ln({
        __name: "ResponseMetaInformation",
        props: {
            response: {}
        },
        setup(e) {
            const t = e
              , n = e=>{
                var t;
                const n = parseInt(null == (t = e.headers) ? void 0 : t["content-length"], 10);
                return n ? Uz(n) : void 0
            }
              , r = ei((()=>{
                const e = t.response.statusCode;
                if (e)
                    return BT[e] ?? void 0
            }
            ));
            return (e,t)=>{
                var o, i;
                return mo(),
                vo(lo, null, [Eo("div", EG, [Eo("span", null, K(Ct(Fz)(e.response.duration)), 1)]), n(e.response) ? (mo(),
                vo("div", xG, [Eo("span", null, K(n(e.response)), 1)])) : Do("", !0), Eo("div", TG, [Eo("span", null, [e.response.statusCode ? (mo(),
                vo(lo, {
                    key: 0
                }, [null != (o = r.value) && o.url ? (mo(),
                yo(bG, {
                    key: 0,
                    href: r.value.url
                }, {
                    default: dn((()=>[Co(K(e.response.statusCode) + " " + K(r.value.name), 1)])),
                    _: 1
                }, 8, ["href"])) : (mo(),
                vo(lo, {
                    key: 1
                }, [Co(K(e.response.statusCode) + " " + K(null == (i = r.value) ? void 0 : i.name), 1)], 64))], 64)) : Do("", !0)])])], 64)
            }
        }
    })
      , CG = {
        class: "navtable simpletable"
    }
      , PG = {
        class: "navtable-table"
    }
      , DG = Po('<div class="navtable-item navtable-item__top" data-v-5ba40e52><div class="navtable-item-33" data-v-5ba40e52><label for="" data-v-5ba40e52>Name</label></div><div class="navtable-item-66" data-v-5ba40e52><label for="" data-v-5ba40e52>Value</label></div></div>', 1)
      , RG = {
        class: "navtable-item-33"
    }
      , NG = {
        class: "navtable-item-66"
    }
      , $G = Ln({
        __name: "SimpleGrid",
        props: {
            items: {}
        },
        setup: e=>(e,t)=>(mo(),
        vo("div", CG, [Eo("div", PG, [DG, (mo(!0),
        vo(lo, null, In(e.items, (e=>(mo(),
        vo("div", {
            key: e.id,
            class: "navtable-item"
        }, [Eo("div", RG, [Eo("p", null, K(e.name), 1)]), Eo("div", NG, [Eo("p", null, K(e.value), 1)])])))), 128))])]))
    })
      , IG = iq($G, [["__scopeId", "data-v-5ba40e52"]])
      , MG = {
        class: "scalar-api-client__main__right custom-scroll"
    }
      , LG = {
        class: "scalar-api-client__main__content"
    }
      , QG = {
        class: "scalar-api-client__main__content__header"
    }
      , BG = Eo("label", null, "Response", -1)
      , UG = {
        key: 0,
        class: "meta"
    }
      , FG = {
        key: 0,
        class: "scalar-api-client__main__content__body"
    }
      , jG = {
        key: 0,
        class: "scalar-api-client__empty-state"
    }
      , zG = Eo("div", {
        class: "scalar-api-client__main__scroll-container"
    }, null, -1)
      , qG = {
        key: 1,
        class: "scalar-api-client__main__content empty-state"
    }
      , HG = Ln({
        __name: "Response",
        setup(e) {
            const {activeResponse: t, activeRequestId: n} = eq()
              , r = ei((()=>{
                var e;
                const n = null == (e = t.value) ? void 0 : e.headers;
                return n ? Object.keys(n).map((e=>({
                    name: e,
                    value: n[e]
                }))) : []
            }
            ))
              , o = ei((()=>{
                var e;
                const n = null == (e = t.value) ? void 0 : e.cookies;
                return n ? Object.keys(n).map((e=>({
                    name: e,
                    value: n[e]
                }))) : []
            }
            ));
            return (e,i)=>(mo(),
            vo("div", MG, [Eo("div", LG, [Eo("div", QG, [BG, Ct(n) && Ct(t) ? (mo(),
            vo("div", UG, [xo(AG, {
                response: Ct(t)
            }, null, 8, ["response"])])) : Do("", !0)]), Ct(n) && Ct(t) ? (mo(),
            vo("div", FG, [xo(cG, {
                response: Ct(t)
            }, null, 8, ["response"]), xo(SG, {
                headers: r.value
            }, null, 8, ["headers"]), xo(Ct(kW), {
                title: "Cookies"
            }, {
                default: dn((()=>[Nn(xo(Ct(IG), {
                    items: o.value
                }, null, 8, ["items"]), [[ci, o.value.length > 0]]), 0 === o.value.length ? (mo(),
                vo("div", jG, "No Cookies")) : Do("", !0)])),
                _: 1
            }), zG])) : (mo(),
            vo("div", qG, [xo(iG, {
                art: Ct("                         .,,uod8B8bou,,.\n                ..,uod8BBBBBBBBBBBBBBBBRPFT?l!i:.\n           ||||||||||||||!?TFPRBBBBBBBBBBBBBBB8m=,\n           ||||   '\"\"^^!!||||||||||TFPRBBBVT!:...!\n           ||||            '\"\"^^!!|||||?!:.......!\n           ||||                     ||||.........!\n           ||||                     ||||.........!\n           ||||                     ||||.........!\n           ||||                     ||||.........!\n           ||||                     ||||.........!\n           ||||                     ||||.........!\n           ||||,                    ||||.........`\n           |||||!!-._               ||||.......;.\n           ':!|||||||||!!-._        ||||.....bBBBBWdou,.\n         bBBBBB86foi!|||||||!!-..:|||!..bBBBBBBBBBBBBBBY!\n         ::!?TFPRBBBBBB86foi!||||||||!!bBBBBBBBBBBBBBBY..!\n         :::::::::!?TFPRBBBBBB86ftiaabBBBBBBBBBBBBBBY....!\n         :::;`\"^!:;::::::!?TFPRBBBBBBBBBBBBBBBBBBBY......!\n         ;::::::...''^::::::::::!?TFPRBBBBBBBBBBY........!\n     .ob86foi;::::::::::::::::::::::::!?TFPRBY..........`\n    .b888888888886foi;:::::::::::::::::::::::..........`\n .b888888888888888888886foi;::::::::::::::::..........\n.b888888888888888888888888888886foi;:::::::::......`\n!Tf998888888888888888888888888888888886foi;:::....`\n  '\"^!|Tf9988888888888888888888888888888888!::..`\n       '\"^!|Tf998888888888888888888888889!! '`\n             '\"^!|Tf9988888888888888888!!`            iBBbo.\n                  '\"^!|Tf998888888889!`             WBBBBbo.\n                        '\"^!|Tf9989!`              YBBBP^'\n                              '\"^!`               `\n")
            }, null, 8, ["art"])]))])]))
        }
    })
      , ZG = {
        class: "scalar-api-client__main"
    }
      , WG = Ln({
        __name: "ApiClient",
        props: {
            proxyUrl: {},
            readOnly: {
                type: Boolean,
                default: !1
            },
            theme: {},
            withDefaultFonts: {
                type: Boolean,
                default: !0
            },
            showSideBar: {
                type: Boolean,
                default: !1
            }
        },
        emits: ["escapeKeyPress", "toggleSidebar"],
        setup(e, {emit: t}) {
            const n = e
              , r = t
              , o = Ml();
            xl(o.escape, (()=>r("escapeKeyPress"))),
            xl(o.meta_b, (()=>r("toggleSidebar")));
            const {activeRequest: i, readOnly: a} = eq()
              , s = Rl("(max-width: 820px)")
              , l = Et(0)
              , c = 1;
            function u(e) {
                l.value = e
            }
            return zr((()=>n.readOnly), (()=>{
                a.value = n.readOnly
            }
            ), {
                immediate: !0
            }),
            (e,t)=>(mo(),
            vo(lo, null, [xo(gW, null, {
                default: dn((()=>[Co(K(Ct(bl)(e.theme, {
                    fonts: e.withDefaultFonts
                })), 1)])),
                _: 1
            }), xo(Fl, {
                class: "scalar-app scalar-api-client",
                method: Ct(i).type ?? "get",
                property: "--scalar-api-client-color",
                onKeydown: t[1] || (t[1] = Hi((e=>r("escapeKeyPress")), ["esc"]))
            }, {
                default: dn((()=>[Eo("div", null, [Fn(e.$slots, "address-bar-controls"), xo(mW, {
                    proxyUrl: e.proxyUrl,
                    onOnSend: t[0] || (t[0] = e=>u(c))
                }, null, 8, ["proxyUrl"])]), Eo("div", ZG, [e.showSideBar ? Fn(e.$slots, "sidebar", {
                    key: 0
                }) : Do("", !0), Ct(s) ? (mo(),
                yo(Ct(al), {
                    key: 2,
                    selectedIndex: l.value,
                    onChange: u
                }, {
                    default: dn((()=>[xo(Ct(sl), {
                        class: "scalar-api-client__mobile-navigation"
                    }, {
                        default: dn((()=>[xo(Ct(ll), {
                            class: "scalar-api-client__mobile-navigation__toggle"
                        }, {
                            default: dn((({selected: e})=>[Eo("span", {
                                class: Z({
                                    "scalar-api-client__mobile-navigation--active": e
                                })
                            }, " Request ", 2)])),
                            _: 1
                        }), xo(Ct(ll), {
                            class: "scalar-api-client__mobile-navigation__toggle"
                        }, {
                            default: dn((({selected: e})=>[Eo("span", {
                                class: Z({
                                    "scalar-api-client__mobile-navigation--active": e
                                })
                            }, " Response ", 2)])),
                            _: 1
                        })])),
                        _: 1
                    }), xo(Ct(cl), {
                        as: "template"
                    }, {
                        default: dn((()=>[xo(Ct(ul), {
                            as: "template"
                        }, {
                            default: dn((()=>[xo(Ct(tG))])),
                            _: 1
                        }), xo(Ct(ul), {
                            as: "template"
                        }, {
                            default: dn((()=>[xo(Ct(HG))])),
                            _: 1
                        })])),
                        _: 1
                    })])),
                    _: 1
                }, 8, ["selectedIndex"])) : (mo(),
                vo(lo, {
                    key: 1
                }, [xo(Ct(tG)), xo(Ct(HG))], 64))])])),
                _: 3
            }, 8, ["method"])], 64))
        }
    })
      , XG = e=>[...e.matchAll(/(?:\{+)\s*(\w+)\s*(?:\}+)/g)].map((e=>e[1].trim())) || [];
    const VG = ut({
        showApiClient: !1,
        activeApiClientEndpointId: "",
        activeItem: {},
        snippetType: "javascript"
    });
    function GG(e, t=!1) {
        VG.showApiClient = !!t || !VG.showApiClient,
        e && (VG.activeItem = e)
    }
    function YG() {
        VG.showApiClient = !1
    }
    function KG(e) {
        VG.activeApiClientEndpointId = e
    }
    function JG(e) {
        VG.snippetType = e
    }
    const eY = ()=>({
        state: dt(VG),
        toggleApiClient: GG,
        setActiveApiClientEndpointId: KG,
        setSnippetType: JG,
        hideApiClient: YG
    });
    !function() {
        try {
            if ("undefined" == typeof document || document.getElementById("scalar-style-api-client"))
                return;
            setTimeout((()=>{
                if ("true" === getComputedStyle(document.body).getPropertyValue("--scalar-loaded-api-client"))
                    return;
                const e = document.createElement("style");
                e.setAttribute("id", "scalar-style-api-client"),
                e.appendChild(document.createTextNode('.navtable-item-time[data-v-353c6d86]{text-transform:capitalize}.navtable-item__active[data-v-353c6d86]{background:var(--scalar-background-2);cursor:default}.navtable{width:100%}.navtable-follow{background-color:#000;color:#fff;font-size:9px;padding:6px;display:-webkit-box;max-width:250px;-webkit-line-clamp:12;border-radius:3px;-webkit-box-orient:vertical;overflow:hidden;line-height:1.24;transform:translate3d(10px,0,0)}.navtable-follow:after{content:"";position:absolute;bottom:0;width:100%;height:6px;background-color:#000}.navtable-follow *{font-family:var(--scalar-font-code)!important}.navtable-table{position:relative;display:flex;flex-direction:column;min-height:389px;border-radius:var(--scalar-radius);border:1px solid var(--scalar-border-color)}.navtable-radios{z-index:1;border-top:1px solid var(--scalar-border-color)}.navtable-item{display:flex;position:relative;color:var(--scalar-color-1);font-size:var(--scalar-micro);border-top:1px solid var(--scalar-border-color);font-weight:var(--scalar-semibold)}.navtable-item:first-of-type{border-top:none}.navtable-item>div{word-wrap:break-word}.navtable-item>div:not(:first-child){border-left:1px solid var(--scalar-border-color)}.navtable-item-action{color:var(--scalar-color-2);font-size:var(--scalar-micro);font-weight:var(--scalar-bold);background:var(--scalar-api-client-bg3);border:none;border-radius:30px;-webkit-appearance:none;-moz-appearance:none;appearance:none;max-height:25px;margin-left:12px;margin-right:6px;padding:4px 8px;outline:none;cursor:pointer;opacity:0;transition:opacity .15s ease-in-out;white-space:nowrap;position:relative}.navtable-item-action:hover{color:var(--scalar-color-1);background:var(--scalar-api-client-gradient);box-shadow:0 0 0 1px var(--scalar-border-color)}.navtable-item-action:focus{background:var(--scalar-background-2)}.navtable-item:hover,.navtable-item:focus-within .navtable-item-action{opacity:1}.navtable-item-add{display:flex;align-items:center;padding:9px;font-weight:var(--scalar-bold);outline:none;border:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;background:transparent;color:var(--scalar-color-1)}.navtable-item-add:hover{background:var(--scalar-background-2);cursor:pointer}.navtable-item-25{width:25%;font-size:var(--scalar-micro);display:flex;align-items:center}.navtable-item-33{width:33.33333%;display:flex;font-size:var(--scalar-micro);align-items:center}.navtable-item-66{width:66.6666%;display:flex;font-size:var(--scalar-micro);align-items:center}.navtable-item-75{width:75%;display:flex;align-items:center}.navtable-item-75:focus-within{background:var(--scalar-background-2)}.navtable-item-40{width:40%;display:flex;align-items:center;padding:9px}.navtable-item-20{width:20%;display:flex;align-items:center;padding:9px}.navtable-item-50{width:50%;display:flex;align-items:center}.navtable-item-50:focus-within{background:var(--scalar-background-2)}.navtable-item p{padding:9px}.navtable-item input{padding:12px 6px;border:none;outline:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;font-size:var(--scalar-micro);color:var(--scalar-color-1);background:transparent;width:100%}.navtable-item input:focus{background:var(--scalar-background-2)}.navtable-item-select{position:relative}.navtable-item-select select{background:transparent;outline:none;border:none;font-size:var(--scalar-micro);-moz-appearance:none;-webkit-appearance:none;appearance:none;width:100%;padding:12px 6px;top:0;position:relative;cursor:pointer;color:var(--scalar-color-2)}.navtable-item-select svg{position:absolute;right:6px;color:var(--scalar-color-ghost);width:6px;top:12px;pointer-events:none}.navtable-item .option{padding:12px 6px;font-size:var(--scalar-micro);color:var(--scalar-color-1);width:100%}.navtable-item label{color:var(--scalar-color-3);font-size:var(--scalar-micro);font-weight:var(--scalar-semibold);text-transform:uppercase;display:block;width:100%}.navtable-item-response{padding:0 9px}.navtable-item-response span{font-size:var(--scalar-micro);display:flex;align-items:center;margin-right:9px;min-width:40px}.navtable-item-response span:empty{display:none}.navtable-mock{background-repeat:repeat;width:100%;background-size:31px 31px;background-position:center 1px;flex:1;position:relative;z-index:0;border-top:1px solid var(--scalar-border-color);background:repeating-linear-gradient(var(--scalar-background-1),var(--scalar-background-1) 34.8px,var(--scalar-border-color) 34.8px,var(--scalar-border-color) 35.8px)}.navtable-mock .navtable-item{position:absolute;width:100%;height:100%;left:0;top:0;background:transparent;box-shadow:none}.radio{height:10px;max-width:10px;width:10px;max-height:10px;background:transparent;border:var(--border);flex-shrink:0;margin-right:6px;margin-left:0;border-radius:50%;display:flex;align-items:center;justify-content:center;outline:none;padding:0}.radio:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;cursor:pointer}.navtable-item__active:before{content:"";display:block;box-shadow:0 0 0 1px var(--scalar-color-1)!important;width:100%;position:absolute;top:0;left:0;height:100%}.radio.post{background:var(--scalar-color-green)}.radio.delete{background:var(--scalar-color-red)}.radio.patch{background:var(--scalar-color-yellow)}.radio.get{background:var(--scalar-color-blue)}.radio.put{background:var(--scalar-color-orange)}.navtable-item-request span{border:none;outline:none;font-size:var(--scalar-micro);color:var(--scalar-color-1);width:100%;display:block;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.navtable-item-request span em{text-transform:uppercase;font-style:normal;font-family:var(--scalar-font-code);font-size:var(--scalar-micro);margin-right:6px;font-weight:var(--scalar-semibold);color:var(--scalar-color-3)}.request-method-select[data-v-0f1e5bdc]{position:relative;display:flex}.request-method-select select[data-v-0f1e5bdc]{border:none;outline:none;cursor:pointer;box-shadow:-2px 0 0 0 var(--scalar-background-3);position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;-moz-appearance:none;-webkit-appearance:none;appearance:none}.request-method-select select[disabled][data-v-0f1e5bdc]{pointer-events:none}.request-method[data-v-0f1e5bdc]{align-items:center;-moz-appearance:none;appearance:none;background:var(--scalar-api-client-color, var(--scalar-background-3));background:color-mix(in srgb,var(--scalar-api-client-color, var(--scalar-background-3)),transparent 90%);border-radius:var(--scalar-radius);color:var(--scalar-api-client-color);display:flex;-webkit-appearance:none;padding:0 12px;position:relative}.request-method span[data-v-0f1e5bdc]{font-family:var(--scalar-font-code);font-size:500;font-size:var(--scalar-micro);text-transform:uppercase;display:flex;align-items:center}.api-client-url-variable{color:var(--scalar-api-client-color)}.loader[data-v-c2ef499b]{position:absolute;z-index:3;height:2px;background:var(--scalar-api-client-color);animation:loading-c2ef499b 5s cubic-bezier(0,.5,.25,1)}@keyframes loading-c2ef499b{0%{width:0}to{width:100%}}.address-bar[data-v-c2ef499b]{width:100%;padding:10px;display:flex;align-items:center;position:relative}.url-form[data-v-c2ef499b]{display:flex;width:720px;align-items:stretch;border-radius:var(--scalar-radius-lg);max-width:720px;margin:auto;z-index:2;max-width:calc(100% - 68px)}.url-form[data-v-c2ef499b] .cm-content{display:flex;align-items:center}.url-form-field[data-v-c2ef499b]{align-items:stretch;border:1px solid var(--scalar-border-color);border-radius:var(--scalar-radius);display:flex;min-height:31px;overflow:hidden;padding:2px;width:100%}.url-form-input-wrapper[data-v-c2ef499b]{display:flex;position:relative;overflow-x:auto;overflow-y:hidden;width:100%;scroll-timeline:--scroll-timeline x;scroll-timeline:--scroll-timeline horizontal}.url-form-input-wrapper .url-form-input[data-v-c2ef499b]{background:var(--scalar-background-1);color:var(--scalar-color-1);font-weight:var(--scalar-semibold);min-height:auto;min-width:fit-content;padding-top:0;position:relative;max-width:calc(100% - 153px);margin-right:auto}.url-form-input-fade__left[data-v-c2ef499b],.url-form-input-fade__right[data-v-c2ef499b]{content:"";position:sticky;height:100%;animation-name:fadein-c2ef499b;animation-duration:1ms;animation-direction:reverse;animation-timeline:--scroll-timeline;z-index:1}.url-form-input-fade__left[data-v-c2ef499b]{background:linear-gradient(-90deg,color-mix(in srgb,var(--scalar-background-1),transparent 100%) 0%,color-mix(in srgb,var(--scalar-background-1),transparent 20%) 30%,var(--scalar-background-1) 100%);left:0;min-width:6px}.url-form-input-fade__right[data-v-c2ef499b]{background:linear-gradient(90deg,color-mix(in srgb,var(--scalar-background-1),transparent 100%) 0%,color-mix(in srgb,var(--scalar-background-1),transparent 20%) 30%,var(--scalar-background-1) 100%);right:0;min-width:24px;animation-direction:reverse}@keyframes fadein-c2ef499b{0%{opacity:0}2%{opacity:1}}@media screen and (max-width: 720px){.url-form-input[data-v-c2ef499b]{max-width:calc(100% - 113px)}}.url-form-input[data-v-c2ef499b] .cm-scroller{overflow-y:hidden}.url-form-input[data-v-c2ef499b] .cm-line{font-size:var(--scalar-micro);padding:0}.history[data-v-c2ef499b]{-moz-appearance:none;appearance:none;-webkit-appearance:none;background:transparent;color:var(--scalar-color-2);display:flex;align-items:center;border-radius:var(--scalar-radius)}.send-button[type=submit][data-v-c2ef499b]{font-size:var(--scalar-micro);letter-spacing:.25px;color:var(--scalar-button-1-color);border:none;white-space:nowrap;padding:0 9px;cursor:pointer;outline:none;font-family:var(--scalar-font);font-weight:var(--scalar-semibold);border-radius:var(--scalar-radius);background:var(--scalar-button-1);position:relative;display:flex;align-items:center;overflow:hidden;flex-shrink:0}.send-button[data-v-c2ef499b]:hover{background:var(--scalar-button-1-hover)}.send-button svg[data-v-c2ef499b]{width:12px;height:12px;flex-shrink:0;margin-right:6px;position:relative}.send-button span[data-v-c2ef499b]{position:relative}@media screen and (max-width: 720px){.history-toggle span[data-v-c2ef499b],.send-button span[data-v-c2ef499b]{display:none}.history-toggle svg[data-v-c2ef499b],.send-button svg[data-v-c2ef499b]{margin-right:0}}.send-button[disabled][data-v-c2ef499b]{pointer-events:none;color:var(--scalar-color-2);background:var(--scalar-background-3);border:1px solid var(--scalar-border-color)}.history-toggle[data-v-c2ef499b]{padding:7px;line-height:30px;color:var(--scalar-color-3);font-size:var(--scalar-micro);height:100%;display:flex;align-items:center;cursor:pointer;white-space:nowrap;-webkit-user-select:none;user-select:none;border-radius:var(--scalar-radius);margin-right:4px;transition:background-color .15s ease-in-out,color .15s ease-in-out}.history-toggle[data-v-c2ef499b]:hover{background-color:var(--scalar-background-2);color:var(--scalar-color-1)}.history-toggle svg[data-v-c2ef499b]{height:13px;width:13px;color:currentColor}.address-bar-content[data-v-c2ef499b]{width:640px;height:100%;background:var(--scalar-background-1);position:fixed;top:0;right:0;z-index:1000;transform:translate3d(640px,0,0);opacity:0;transition:transform .5s cubic-bezier(.77,0,.175,1),opacity .01s ease-in-out .5s;pointer-events:none}.address-bar--with-history[data-v-c2ef499b]{z-index:100000}.address-bar--with-history .address-bar-content[data-v-c2ef499b]{transform:translateZ(0);opacity:1;pointer-events:all;transition:transform .5s cubic-bezier(.77,0,.175,1)}.address-bar--with-history .address-bar-close[data-v-c2ef499b]{opacity:1;pointer-events:all;cursor:pointer}.address-bar-close[data-v-c2ef499b]{width:100%;height:100%;position:fixed;top:0;left:0;pointer-events:none;opacity:0;transition:all .1s ease-in-out;z-index:1000}.scalar-api-client__item{position:relative;margin-bottom:6px}.scalar-api-client__item button{background-color:transparent;text-align:left}.scalar-api-client__item:hover{cursor:pointer}.scalar-api-client__toggle:after{content:"";position:absolute;bottom:-6.5px;width:100%;height:6px;left:0}.scalar-api-client__toggle-container{display:flex;align-items:center;width:100%}.scalar-api-client__item--open .scalar-api-client__toggle:after{display:none}.scalar-api-client__item--open .scalar-api-client__item__content{display:flex}.scalar-api-client__item--open:hover{cursor:default}.scalar-api-client__toggle{padding:0 9px;display:flex;align-items:center;position:relative;width:100%;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:0;border:none;font-family:var(--scalar-font);cursor:pointer}.scalar-api-client__item .scalar-api-client__item__title{color:var(--scalar-color-2);font-size:var(--scalar-mini);font-weight:var(--scalar-semibold);font-family:var(--scalar-font);-webkit-user-select:none;user-select:none;position:relative;z-index:1;flex:1;padding:6px 0}.scalar-api-client__item:hover .scalar-api-client__item__title,.scalar-api-client__item--open .scalar-api-client__item__title{color:var(--scalar-color-1)}.scalar-api-client__item .scalar-api-client__toggle__icon{width:20px;padding:3px;color:var(--scalar-color-3);z-index:1;position:relative;transform:rotate(-90deg);margin:5px 0 5px -4.5px}.scalar-api-client__item--open .scalar-api-client__toggle__icon{transform:rotate(0)}.scalar-api-client__toggle:hover .scalar-api-client__toggle__icon{color:var(--scalar-color-1)}.scalar-api-client__item__options{position:relative;z-index:1;margin:0 0 0 24px;font-weight:var(--scalar-semibold);color:var(--scalar-color-2);padding:6px 9px;border:.5px solid var(--scalar-border-color);border-radius:var(--scalar-radius) var(--scalar-radius) 0 0}.scalar-api-client__item__options .security-scheme-selector .security-scheme-label{color:var(--scalar-color-2)}.scalar-api-client__item__options+div .scalar-api-client__item__content{border-radius:0 0 var(--scalar-radius) var(--scalar-radius);border-top:none}.scalar-api-client__item__options:has(+div .scalar-api-client__item__content:empty){border-radius:var(--scalar-radius)}.scalar-api-client__item__options span{background:transparent;padding:2px 0;border-radius:3px;font-size:var(--scalar-small);pointer-events:none;color:var(--scalar-color-3);display:flex;align-items:center;justify-content:center;white-space:nowrap}.scalar-api-client__item__options:hover span{color:var(--scalar-color-1);border-color:currentColor}.scalar-api-client__item__options span svg{width:15px;height:15px;margin-left:3px}.scalar-api-client__item__options select{position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer;-moz-appearance:none;-webkit-appearance:none;appearance:none}.scalar-api-client__item__content .scalar-api-client__codemirror__wrapper{padding-top:0}.scalar-api-client-item-topbar{display:flex;justify-content:space-between;align-items:center}.table-row[data-v-af7279f3]{border-bottom:.5px solid var(--scalar-border-color);display:flex;position:relative}.table-row[data-v-af7279f3]:active,.table-row[data-v-af7279f3]:focus-within{background-color:color-mix(in srgb,transparent 60%,var(--scalar-background-2))}.table-row[data-v-af7279f3]:last-of-type{border-bottom:none}.table-row__active[data-v-af7279f3]{border-radius:0 0 var(--scalar-radius-lg) var(--scalar-radius-lg)}.table-row-item[data-v-af7279f3]{width:100%;border-left:.5px solid var(--scalar-border-color);position:relative}.table-row:hover .table-row-item[data-v-af7279f3]:last-of-type{-webkit-mask-image:linear-gradient(to left,transparent 20px,var(--scalar-background-2) 40px);mask-image:linear-gradient(to left,transparent 20px,var(--scalar-background-2) 40px)}.table-row-item[data-v-af7279f3]:last-of-type:focus-within input{width:calc(100% - 18px)}.table-row-item[data-v-af7279f3] input{border:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;padding:9px;width:100%;min-height:100%;color:var(--scalar-color-1);font-size:var(--scalar-mini);background:transparent;font-family:var(--scalar-font)}.table-row-item[data-v-af7279f3] input::placeholder{font-family:var(--scalar-font)}.table-row-item[data-v-af7279f3] input[disabled]{background:transparent}.table-row-meta[data-v-af7279f3]{overflow:hidden;flex-shrink:0;transition:all .15s ease-in-out;display:flex;align-items:center;justify-content:center;width:26px;-webkit-user-select:none;user-select:none}.table-column-header[data-v-28499a13]{background:transparent;text-transform:capitalize;display:block;padding:9px;font-weight:var(--scalar-semibold);color:var(--scalar-color-3);font-size:var(--scalar-mini)}.table-description-toggle[data-v-28499a13]{padding:0;width:100%;height:100%}.table-description-toggle svg[data-v-28499a13]{width:13px;height:13px;margin:0 1px;color:var(--scalar-color-3);cursor:pointer}.table-description-toggle svg[data-v-28499a13]:hover{color:var(--scalar-color-2)}.table-row-editable.required-parameter[data-v-88a71b55] .table-row-item:nth-of-type(2):after{content:"Required";position:absolute;top:4px;right:0;padding:5px 9px 5px 6px;font-weight:var(--scalar-semibold);font-size:var(--scalar-micro);background:var(--scalar-background-1);box-shadow:-2px 0 4px var(--scalar-background-1)}.table-row-editable.required-parameter[data-v-88a71b55] .table-row-item:nth-of-type(2):focus-within:after{display:none}.table-row-meta-check[data-v-88a71b55]{width:18px;height:18px;border-radius:var(--scalar-radius-lg);background:#2fb1e41a}.meta-check[data-v-88a71b55]{display:flex;position:relative;cursor:pointer;align-items:center;font-size:var(--scalar-micro);border-radius:var(--scalar-radius-lg);-webkit-user-select:none;user-select:none;margin:0 1px;transition:all .15s ease-in-out}.meta-check input[data-v-88a71b55]{position:absolute;opacity:0;cursor:pointer;height:0;width:0}.meta-checkmark[data-v-88a71b55]{height:33.5px;width:26px;display:flex;align-items:center;justify-content:center;position:relative}.meta-check .meta-checkmark[data-v-88a71b55]:after{content:"";width:6px;height:10px;left:-.5px;top:-.5px;position:relative;border:solid var(--scalar-border-color);border-width:0 1px 1px 0;transform:rotate(45deg) translate3d(0,-1px,0)}.meta-check input:checked~.meta-checkmark[data-v-88a71b55]:after{border-color:var(--scalar-color-1)}.meta-checkmark[data-v-88a71b55]:before{content:"";position:absolute;left:0;top:0;bottom:0;right:0;margin:auto;width:20px;height:20px;border-radius:var(--scalar-radius);border:.5px solid var(--scalar-border-color);opacity:0}.meta-check input:checked~.meta-checkmark[data-v-88a71b55]:before{border-color:var(--scalar-color-3)}.meta-check:focus-within .meta-checkmark[data-v-88a71b55]:before,.meta-checkmark[data-v-88a71b55]:hover:before{opacity:1}.meta-delete[data-v-88a71b55]{position:absolute;right:6px;height:20px;width:20px;border:none;outline:none;border-radius:50%;opacity:0;padding:5px;display:flex;align-items:center;justify-content:center;cursor:pointer;z-index:10}.meta-delete svg[data-v-88a71b55]{width:11px;height:11px;color:var(--scalar-color-3)}.meta-delete:hover svg[data-v-88a71b55]{color:var(--scalar-color-red)}.meta-delete:focus svg[data-v-88a71b55]{color:var(--scalar-color-3)}.meta-delete[data-v-88a71b55]:focus{border-color:var(--scalar-color-3);color:var(--scalar-color-3)}.table-row-editable:hover .meta-delete[data-v-88a71b55]{opacity:1}@media (pointer: coarse){.table-row-editable:hover .meta-delete[data-v-88a71b55]{opacity:1}}.table-row-generated.table-row-generated[data-v-1a868951] *{color:var(--scalar-color-3)}.table-row-generated.table-row-generated[data-v-1a868951] input{pointer-events:none}.table[data-v-c44da5e8]{background:transparent;width:100%}.table .table-row[data-v-c44da5e8]{padding:0 3px}.table[data-v-c44da5e8]:focus-within,.table[data-v-c44da5e8]:active{margin:0}.meta-actions-item[data-v-c44da5e8]{border:none;padding:9px;width:100%;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;font-size:var(--scalar-mini);font-family:var(--scalar-font);color:var(--scalar-color-3);cursor:pointer;display:flex;align-items:center;gap:16px}.meta-actions[data-v-c44da5e8]{display:flex;justify-content:space-between}.meta-actions-item[data-v-c44da5e8]:nth-of-type(2){display:flex;justify-content:flex-end}.meta-actions-item:nth-of-type(2) i[data-v-c44da5e8]{filter:drop-shadow(0 .125px 0 currentColor) drop-shadow(0 -.125px 0 currentColor)}.meta-actions-item-icon[data-v-c44da5e8]{width:12px;height:12px}.meta-actions-item[data-v-c44da5e8]:hover,.meta-actions-item[data-v-c44da5e8]:focus{color:var(--scalar-color-1)}.scalar-api-client-add{color:var(--scalar-color-3);padding:3px 6px;width:fit-content;cursor:pointer;font-size:var(--scalar-mini);font-weight:var(--scalar-semibold);text-decoration:none;margin:0 6px;border:none;font-family:var(--scalar-font);-webkit-appearance:none;-moz-appearance:none;appearance:none;display:flex;align-items:center;border:.5px solid var(--scalar-border-color);border-radius:var(--scalar-radius)}.scalar-api-client-add svg{width:12px;height:12px;margin-right:3px}.scalar-api-client-add:hover{color:var(--scalar-color-1)}.scalar-api-client-add:focus-within{background:var(--scalar-background-3)}.card-form[data-v-bc8cea71]{color:var(--scalar-color-1);width:100%;border:1px solid var(--scalar-border-color);border-radius:var(--scalar-radius)}.card-form-button[data-v-6ae053e9]{display:flex;align-items:center;position:relative;background:transparent;cursor:pointer;padding:9px;outline:none;white-space:nowrap;font-family:var(--scalar-font);font-size:var(--scalar-micro);font-weight:var(--scalar-semibold);color:var(--scalar-color-2)}.card-form-button[data-v-6ae053e9]:hover{color:var(--scalar-color-1)}.card-form-group[data-v-d894ccf7]{display:flex}:where(.card-form-rows[data-v-25140d72]){display:flex;flex-direction:column;width:100%}:where(.card-form-rows[data-v-25140d72])>*+*{border-top:1px solid var(--scalar-border-color)}.card-form-input[data-v-140f9914]{background:transparent;position:relative;width:100%;text-align:left;display:flex;align-items:baseline;border-color:inherit}.card-form-input label[data-v-140f9914],.card-form-input input[data-v-140f9914]{padding:9px;border:0;outline:none;font-size:var(--scalar-mini);color:var(--scalar-color-2);width:100%;background:transparent;-moz-appearance:none;appearance:none;-webkit-appearance:none;left:0}.card-form-input label[data-v-140f9914]{width:fit-content;white-space:nowrap;cursor:text;padding:9px 0 9px 9px;border-radius:var(--scalar-radius);font-weight:var(--scalar-semibold)}.card-form-input input[data-v-140f9914]{position:relative;z-index:99;color:var(--scalar-color-1)}.card-form-input+.card-form-input[data-v-140f9914]{border-left:1px solid var(--scalar-border-color)}.card-form-input input:not(:placeholder-shown)+label[data-v-140f9914]{color:var(--scalar-color-2)}.password-mask[data-v-140f9914]{padding:4px;margin-right:6px;height:24px;width:auto;align-self:center;stroke-width:.75}.wrapper[data-v-6c24ccba]{display:grid;border-color:inherit}.scopes-label[data-v-6c24ccba]{display:inline-flex;align-items:center;height:1em;line-height:1;gap:4px}.scopes-label-badge[data-v-6c24ccba]{display:inline-flex;align-items:center;gap:2px}.scopes-label-badge em[data-v-6c24ccba]{transform:rotate(10deg) translateY(-.9px)}.floating[data-v-6c24ccba]{position:relative;z-index:1010}.dropdown[data-v-6c24ccba]{background:var(--scalar-background-1);filter:brightness(var(--scalar-lifted-brightness));border-radius:var(--scalar-radius);box-shadow:var(--scalar-shadow-2);padding:4px;font-style:normal;display:flex;flex-direction:column;gap:10px}.dropdown-item[data-v-6c24ccba]{display:grid;grid-template-areas:"check title" "check description";grid-template-columns:auto 1fr;padding:6px 10px 8px 6px;row-gap:2px;column-gap:8px;border-radius:var(--scalar-radius);font-size:var(--scalar-mini);cursor:pointer}.dropdown-item[data-headlessui-state=active][data-v-6c24ccba],.dropdown-item[data-headlessui-state="active selected"][data-v-6c24ccba]{background:var(--scalar-background-2)}.dropdown-item-title[data-v-6c24ccba]{grid-area:title;color:var(--scalar-color-1);font-weight:var(--scalar-semibold)}.dropdown-item-description[data-v-6c24ccba]{grid-area:description;color:var(--scalar-color-2);line-height:initial}.dropdown-item-check[data-v-6c24ccba]{all:unset;position:relative;grid-area:check;width:20px;height:20px;color:var(--scalar-color-2);background:var(--scalar-background-1);border:1px solid var(--scalar-border-color);border-radius:var(--scalar-radius)}.dropdown-item-check[data-v-6c24ccba]:checked:after{content:"";position:absolute;border-bottom:1.5px solid currentColor;border-right:1.5px solid currentColor;width:6px;height:12px;top:calc(50% - 1.5px);left:50%;transform:translate(-50%,-50%) rotate(45deg)}.dropdown-item-check[data-v-6c24ccba]:checked{background:var(--scalar-color-accent);color:var(--scalar-background-1);border:1px solid currentColor}.description[data-v-d25c85a2]{padding:12px 4px 4px;font-size:var(--scalar-mini)}.cardform-auth-button[data-v-d25c85a2]{background:var(--scalar-button-1);color:var(--scalar-button-1-color);font-size:var(--scalar-mini);font-weight:var(--scalar-semibold);border-radius:var(--scalar-radius);margin:3px;padding:0 9px;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none}.cardform-auth-button[data-v-d25c85a2]:hover{background:var(--scalar-button-1-hover)}.security-scheme-selector[data-v-4f880c55]{position:relative;border-radius:var(--scalar-radius);color:var(--scalar-color-3);display:flex;align-items:center;gap:4px;cursor:pointer}.security-scheme-selector[data-v-4f880c55]:hover{color:var(--scalar-color-1)}.security-scheme-label[data-v-4f880c55]{color:var(--scalar-color-3);font-size:var(--scalar-mini)}.security-scheme-selector:hover .security-scheme-label[data-v-4f880c55]{color:var(--scalar-color-1)}.security-scheme-selector select[data-v-4f880c55]{position:absolute;cursor:pointer;opacity:0;right:0;-moz-appearance:none;-webkit-appearance:none;appearance:none;width:100%;margin-top:-5px;padding:10px 0}.security-scheme-selector svg[data-v-4f880c55]{width:12px;stroke:currentColor}.preferred-security-scheme[data-v-9f62f731]{display:flex;width:100%}.preferred-security-scheme[data-v-9f62f731]:focus-within,.preferred-security-scheme[data-v-9f62f731]:active{margin:0}.preferred-security-scheme .card-form[data-v-9f62f731]{border-radius:0;border:none}.preferred-security-scheme:focus-within .card-form[data-v-9f62f731]{background-color:color-mix(in srgb,transparent 60%,var(--scalar-background-2))}.security-scheme-empty-state[data-v-9f62f731]{border:1px dashed var(--scalar-border-color);width:100%;text-align:center;border-radius:var(--scalar-radius);font-size:var(--scalar-small);min-height:58px;display:flex;align-items:center;justify-content:center}.scalar-api-client-add[data-v-9f62f731]{color:var(--scalar-color-3);padding:3px 9px;width:fit-content;cursor:pointer;font-size:var(--scalar-micro);font-weight:var(--scalar-semibold);text-decoration:none;margin:0 6px;border:none;font-family:var(--scalar-font);-webkit-appearance:none;-moz-appearance:none;appearance:none;display:flex;align-items:center;border:1px solid var(--scalar-border-color);border-radius:30px}.scalar-api-client-add svg[data-v-9f62f731]{width:12px;height:12px;margin-right:3px}.scalar-api-client-add[data-v-9f62f731]:hover{color:var(--scalar-color-1)}.scalar-api-client-add[data-v-9f62f731]:focus-within{background:var(--scalar-background-3)}.scalar-api-client__main__left{width:50%;border-right:1px solid var(--scalar-border-color)}@media screen and (max-width: 820px){.scalar-api-client__main__left{width:100%;border-right:none}}.scalar-api-client__main__left .scalar-api-client__item__content,.scalar-api-client__main__right .scalar-api-client__item__content{flex-flow:wrap;color:var(--scalar-color-3);font-size:var(--scalar-mini);justify-content:space-between;z-index:2;position:relative;border:.5px solid var(--scalar-border-color);border-radius:var(--scalar-radius);margin-left:24px;margin-bottom:12px}.scalar-api-client__main__left .scalar-api-client__item__content:empty,.scalar-api-client__main__right .scalar-api-client__item__content:empty{display:none}.scalar-api-client__main__left .scalar-api-client__item__content .scalar-api-client__codemirror__wrapper,.scalar-api-client__main__right .scalar-api-client__item__content .scalar-api-client__codemirror__wrapper{width:100%;min-height:63px}.scalar-api-client__main__left .scalar-api-client__item__content .scalar-codeblock-pre,.scalar-api-client__main__left .scalar-api-client__item__content .cm-s-default,.scalar-api-client__main__right .scalar-api-client__item__content .scalar-codeblock-pre,.scalar-api-client__main__right .scalar-api-client__item__content .cm-s-default{background:transparent}.scalar-api-client__main__left .scalar-api-client__item__content .scalar-codeblock-pre *,.scalar-api-client__main__right .scalar-api-client__item__content .scalar-codeblock-pre *{font-size:var(--scalar-micro)}.scalar-api-client__main__left .scalar-api-client__item__content .scalar-codeblock-pre,.scalar-api-client__main__left .scalar-api-client__item__content .codemirror-container,.scalar-api-client__main__right .scalar-api-client__item__content .scalar-codeblock-pre,.scalar-api-client__main__right .scalar-api-client__item__content .codemirror-container{width:100%;max-height:calc(100vh - 300px);overflow:auto}.scalar-api-client__main__left .scalar-api-client__item__content .cm-scroller,.scalar-api-client__main__right .scalar-api-client__item__content .cm-scroller{border-radius:var(--scalar-radius);background-color:transparent}.scalar-api-client__main__left .scalar-api-client__item__content .cm-scroller,.scalar-api-client__main__right .scalar-api-client__item__content .cm-scroller{padding:0;margin:0;border-radius:0;border-left:none;border-right:none;border-top:none}.scalar-api-client__main__left .scalar-api-client__item__content .cm-scroller:focus-within,.scalar-api-client__main__right .scalar-api-client__item__content .cm-scroller:focus-within{background:color-mix(in srgb,transparent 60%,var(--scalar-background-2))}.scalar-api-client__main__left .scalar-api-client__item__content .cm-editor,.scalar-api-client__main__right .scalar-api-client__item__content .cm-editor{outline:none!important}.scalar-api-client__main__left .scalar-api-client__item__content .cm-editor .cm-gutters,.scalar-api-client__main__left .scalar-api-client__item__content .cm-scroll,.scalar-api-client__main__right .scalar-api-client__item__content .cm-editor .cm-gutters,.scalar-api-client__main__right .scalar-api-client__item__content .cm-scroll{background:transparent}.scalar-api-client__main__left .scalar-api-client__item__content .cm-editor *,.scalar-api-client__main__right .scalar-api-client__item__content .cm-editor *{font-size:var(--scalar-micro)}.scalar-api-client__main__left .scalar-api-client__item__content .cm-editor .cm-line,.scalar-api-client__main__right .scalar-api-client__item__content .cm-editor .cm-line{color:var(--scalar-color-1)}.scalar-api-client__main__left .scalar-api-client__item__content .card-form,.scalar-api-client__main__right .scalar-api-client__item__content .card-form{border-radius:var(--scalar-radius)}.scalar-api-client__main__left .scalar-api-client__item__content-button,.scalar-api-client__main__right .scalar-api-client__item__content-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;outline:none;font-size:var(--scalar-micro);background:var(--scalar-api-client-color)!important;text-align:center;font-weight:var(--scalar-semibold);font-family:var(--scalar-font);padding:6px;width:fit-content;margin:3px 3px 3px auto;text-transform:uppercase;border-radius:var(--scalar-radius);color:#fff;cursor:pointer;text-align:center!important;position:relative}.scalar-api-client__main__left .scalar-api-client__item__content-button span,.scalar-api-client__main__right .scalar-api-client__item__content-button span{position:relative}.scalar-api-client__main__left .scalar-api-client__item__content-button:before,.scalar-api-client__main__right .scalar-api-client__item__content-button:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;cursor:pointer;border-radius:var(--scalar-radius);background:linear-gradient(#0000001a,#0003)}.scalar-api-client__main__left .scalar-api-client__item__content-button:hover:before,.scalar-api-client__main__right .scalar-api-client__item__content-button:hover:before{background:linear-gradient(#0003,#0000001a)}.scalar-api-client__main__left .scalar-api-client__item__content__split,.scalar-api-client__main__right .scalar-api-client__item__content__split{justify-content:space-between}.scalar-api-client__main__left .scalar-collapsible-section-flex,.scalar-api-client__main__right .scalar-collapsible-section-flex{width:100%}.scalar-api-client__main__left .input,.scalar-api-client__main__right .input{background:transparent;position:relative;width:100%;text-align:left;display:flex;box-shadow:0 1px 0 var(--scalar-border-color)}.scalar-api-client__main__left .input:focus-within,.scalar-api-client__main__right .input:focus-within{box-shadow:0 0 0 1px var(--scalar-color-1)!important;z-index:10}.scalar-api-client__main__left .input:first-of-type,.scalar-api-client__main__right .input:first-of-type{border-radius:var(--scalar-radius) var(--scalar-radius) 0 0}.scalar-api-client__main__left .input:first-child:last-child,.scalar-api-client__main__right .input:first-child:last-child{border-radius:var(--scalar-radius)}.scalar-api-client__main__left .input:last-child,.scalar-api-client__main__right .input:last-child{box-shadow:none;border-radius:var(--scalar-radius)}.scalar-api-client__main__left .input__half:first-of-type,.scalar-api-client__main__right .input__half:first-of-type{border-radius:var(--scalar-radius) 0 0 0}.scalar-api-client__main__left .input__half:nth-of-type(2),.scalar-api-client__main__right .input__half:nth-of-type(2){border-radius:0 var(--scalar-radius) 0 0}.scalar-api-client__main__left .authentication-form,.scalar-api-client__main__right .authentication-form{box-shadow:0 0 0 1px var(--scalar-border-color);border-radius:var(--scalar-radius);width:100%;display:flex;flex-flow:wrap}.scalar-api-client__main__left .input__half,.scalar-api-client__main__right .input__half{width:50%}.scalar-api-client__main__left .input__half+.input__half,.scalar-api-client__main__right .input__half+.input__half{border-left:1px solid var(--scalar-border-color)}.scalar-api-client__main__left .input__half:focus-within,.scalar-api-client__main__right .input__half:focus-within{border-color:transparent}.scalar-api-client__main__left .input label,.scalar-api-client__main__left .input input,.scalar-api-client__main__right .input label,.scalar-api-client__main__right .input input{padding:9px;border:0;outline:none;font-size:var(--scalar-micro);color:var(--scalar-color-2);width:100%;background:transparent;-moz-appearance:none;appearance:none;-webkit-appearance:none;left:0}.scalar-api-client__main__left .input label,.scalar-api-client__main__right .input label{color:var(--scalar-color-1);width:fit-content;padding-right:0;white-space:nowrap;cursor:text}.scalar-api-client__main__left .input input,.scalar-api-client__main__right .input input{position:relative;z-index:99}.scalar-api-client__main__left .input input:not(:placeholder-shown)+label,.scalar-api-client__main__right .input input:not(:placeholder-shown)+label{color:var(--scalar-color-2)}.scalar-api-client__main__left .select,.scalar-api-client__main__right .select{background:var(--scalar-background-1);border-radius:var(--scalar-radius-lg);font-size:var(--scalar-micro);border:1px solid var(--scalar-border-color);width:100%;position:relative;margin-bottom:6px}.scalar-api-client__main__left .select:focus-within,.scalar-api-client__main__right .select:focus-within{background:var(--scalar-background-3)}.scalar-api-client__main__left .select:hover,.scalar-api-client__main__right .select:hover{background:var(--scalar-background-3)}.scalar-api-client__main__left .select svg,.scalar-api-client__main__right .select svg{position:absolute;right:9px;pointer-events:none;color:var(--scalar-color-2);width:6px;top:10px}.scalar-api-client__main__left .select label,.scalar-api-client__main__right .select label{display:block;font-size:10px;color:var(--scalar-color-2);position:absolute;left:9px;top:6px}.scalar-api-client__main__left .select select,.scalar-api-client__main__right .select select{background:transparent;outline:none;border:none;-moz-appearance:none;-webkit-appearance:none;appearance:none;font-size:var(--scalar-micro);color:var(--scalar-color-1);width:100%;padding:14px 9px 4px;top:0;position:relative;cursor:pointer}.scalar-api-client__main__left .check,.scalar-api-client__main__right .check{display:flex;position:relative;cursor:pointer;align-items:center;font-size:var(--scalar-micro);padding:6px 9px;border-radius:var(--scalar-radius);-webkit-user-select:none;user-select:none;width:100%;outline:none}.scalar-api-client__main__left .check:focus-within,.scalar-api-client__main__right .check:focus-within{box-shadow:0 0 0 1px var(--scalar-color-1)}.scalar-api-client__main__left .checkmark:hover,.scalar-api-client__main__right .checkmark:hover{background:var(--scalar-background-3)}.scalar-api-client__main__left .check:focus-within,.scalar-api-client__main__right .check:focus-within{border-color:var(--scalar-color-1)}.scalar-api-client__main__left .check p,.scalar-api-client__main__right .check p{color:var(--scalar-color-3)}.scalar-api-client__main__left .check input,.scalar-api-client__main__right .check input{position:absolute;opacity:0;cursor:pointer;height:0;width:0}.scalar-api-client__main__left .checkmark,.scalar-api-client__main__right .checkmark{height:17px;width:17px;background:var(--scalar-background-3);margin-right:10px;border-radius:3px;display:flex;align-items:center;justify-content:center;position:relative}.scalar-api-client__main__left .check input:checked~p,.scalar-api-client__main__right .check input:checked~p{color:var(--scalar-color-1)}.scalar-api-client__main__left .check .checkmark:after,.scalar-api-client__main__right .check .checkmark:after{content:"";display:none;width:5px;height:8px;border:solid var(--scalar-color-1);border-width:0 1.5px 1.5px 0;transform:rotate(45deg) translate3d(0,-1px,0)}.scalar-api-client__main__left .check input:checked~.checkmark:after,.scalar-api-client__main__right .check input:checked~.checkmark:after{display:block}.scalar-api-client__main__left .scalar-api-client__main__scroll-container,.scalar-api-client__main__right .scalar-api-client__main__scroll-container{height:calc(100vh - 320px)}.scalar-api-client__main__left .scalar-api-client__request-name,.scalar-api-client__main__right .scalar-api-client__request-name{outline:none;border:none;-moz-appearance:none;appearance:none;-webkit-appearance:none;font-size:var(--scalar-mini);font-weight:var(--scalar-semibold);color:var(--scalar-color-3);width:100%;padding:0;background:transparent;font-family:var(--scalar-font)}.scalar-api-client__main__left .scalar-api-client__request-name::-webkit-input-placeholder,.scalar-api-client__main__right .scalar-api-client__request-name::-webkit-input-placeholder{font-weight:var(--scalar-semibold)}.scalar-api-client__main__left .scalar-api-client__request-name:-ms-input-placeholder,.scalar-api-client__main__right .scalar-api-client__request-name:-ms-input-placeholder{font-weight:var(--scalar-semibold)}.scalar-api-client__main__left .scalar-api-client__request-name::placeholder,.scalar-api-client__main__right .scalar-api-client__request-name::placeholder{font-weight:var(--scalar-semibold)}.ascii-art[data-v-9045c053]{font-family:var(--scalar-font-code);font-weight:var(--scalar-bold);font-size:6px;color:var(--scalar-color-3);line-height:7px;display:flex;flex-direction:column;align-items:flex-start}.ascii-art-line-wrapper[data-v-9045c053]{display:inline-block}.ascii-art-line[data-v-9045c053]{display:inline-block;white-space:pre;overflow:hidden}.simple-table[data-v-afe94232]{all:unset;display:table;width:100%}.simple-table-container[data-v-afe94232]{border-right:none;border-left:none;width:100%;overflow:auto}.simple-row[data-v-3e78d3f1]{all:unset;display:table-row;box-shadow:0 -.5px var(--scalar-border-color)}.simple-row[data-v-3e78d3f1]:first-of-type{box-shadow:none}a[data-v-88788c44]{color:var(--scalar-color-3);text-decoration:underline;text-decoration-color:var(--scalar-border-color);text-underline-offset:2px;cursor:help}.simple-cell[data-v-52c6cbd0]{all:unset;display:table-cell;border-right:.5px solid var(--scalar-border-color);position:relative;padding:9px!important;color:var(--scalar-color-1);white-space:nowrap}.simple-cell[data-v-52c6cbd0]:first-of-type{position:sticky;left:0;background-color:var(--scalar-background-1);z-index:1;box-shadow:0 -.5px var(--scalar-border-color);color:var(--scalar-color-3)}.simple-row:first-of-type .simple-cell[data-v-52c6cbd0]:first-of-type{border-top-left-radius:var(--scalar-radius)}.simple-cell a[data-v-52c6cbd0]{color:var(--scalar-color-1)!important}.simple-cell[data-v-52c6cbd0]:last-of-type{border-right:none}.simple-cell.wrap[data-v-52c6cbd0]{white-space:normal}.simple-cell.strong[data-v-52c6cbd0]{font-weight:var(--scalar-semibold)}.simple-header[data-v-e3a12d86]{color:var(--scalar-color-3);font-weight:var(--scalar-semibold);text-transform:capitalize}.simpletable.navtable[data-v-5ba40e52]{padding:0}.simpletable.navtable .navtable-item-66[data-v-5ba40e52],.simpletable.navtable .navtable-item-33[data-v-5ba40e52]{display:block}.simpletable.navtable .navtable-table[data-v-5ba40e52]{height:fit-content}.scalar-api-client__main__right{width:50%}@media screen and (max-width: 820px){.scalar-api-client__main__right{border-right:none;height:100%;width:100%}}.scalar-api-client__main__right :deep(.scalar-copilot__header-button){position:absolute;top:6px;right:12px}.scalar-api-client__main__content .empty-state{align-items:center;display:flex;flex-direction:column;gap:20px;height:calc(100% - 90px);justify-content:center}.scalar-api-client__main__content .empty-state p{color:var(--scalar-color-2);font-size:var(--scalar-small);text-transform:capitalize}:root{--scalar-loaded-api-client: true}.scalar-api-client{background:var(--scalar-background-1);position:relative;height:100%;overflow:hidden!important;display:flex;flex-direction:column;font-family:var(--scalar-font)}.scalar-api-client{flex:1;max-height:100vh}@media screen and (max-width: 1000px){.scalar-api-client{width:100%}}.scalar-api-client pre{font-family:var(--scalar-font-code)}.scalar-api-client__mobile-navigation{padding:12px 12px 0;display:flex;font-size:var(--scalar-small);color:var(--scalar-color-2);font-weight:var(--scalar-bold)}.scalar-api-client__mobile-navigation__toggle{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;outline:none;background:transparent;font-size:var(--scalar-font-size-2);color:var(--scalar-color-2);font-weight:var(--scalar-semibold);font-family:var(--scalar-font);padding:0;margin-right:9px;cursor:pointer}.scalar-api-client__mobile-navigation--active{color:var(--scalar-color-1)}.scalar-api-client__mobile-navigation--active:hover{cursor:pointer}.scalar-api-client__main{display:flex;height:100%;min-height:0;background:var(--scalar-background-1);border-top:1px solid var(--scalar-border-color)}@media screen and (max-width: 820px){.scalar-api-client__main{flex-direction:column}}.scalar-api-client__main__content__header{align-items:center;background:var(--scalar-background-1);border-bottom:1px solid var(--scalar-border-color);display:flex;gap:6px;height:50px;padding:16px 18px;position:sticky;top:0;z-index:100}.scalar-api-client__main__content__header label{font-size:var(--scalar-mini);color:var(--scalar-color-1);font-weight:var(--scalar-semibold);display:flex;align-items:center}.scalar-api-client__main__content:has(.scalar-api-client__main__content.empty-state){height:100%}.scalar-api-client__main__content__body{padding:10px 18px 10px 9px}@media screen and (max-width: 820px){.scalar-api-client__main__content__header{padding:14px}.scalar-api-client__main__content label{display:none}}.meta{color:var(--scalar-api-client-color);display:flex;flex:1;font-size:var(--scalar-font-size-2);font-weight:var(--scalar-font-size-2);gap:6px}.meta-item svg{fill:var(--scalar-color-ghost);height:14px;width:14px;margin-right:6px}.meta-item{display:flex;align-items:center;white-space:nowrap;font-weight:var(--scalar-semibold);font-size:var(--scalar-mini);color:var(--scalar-color-3);min-height:17px}.meta-item__input{background:transparent;flex:1;margin-right:0;width:100%}.types{margin:auto;width:580px;display:flex;align-items:center;justify-content:center;flex-flow:wrap}.types-heading{width:100%;text-align:center}.types-heading b{font-size:42px}.types-heading p{margin-bottom:20px;margin-top:12px;font-size:24px}.scalar-api-client__empty-state{width:100%;text-align:center;font-size:var(--scalar-small);min-height:60px;display:flex;align-items:center;justify-content:center}.scalar-api-client__main__right .scalar-api-client__empty-state{margin:0 18px;border-radius:var(--scalar-radius)}\n')),
                document.head.appendChild(e),
                console.warn("Auto-loading the client css through js has been deprecated. Please import the css directly. Visit https://github.com/scalar/scalar for more info.")
            }
            ), 0)
        } catch (e) {
            console.error(e, "unable to concat style inside the bundled file")
        }
    }();
    const tY = Object.freeze(Object.defineProperty({
        __proto__: null,
        ApiClient: WG,
        HttpMethod: Fl,
        RequestAuthentication: ZV,
        SecurityScheme: NV,
        SecuritySchemeSelector: jV,
        concatenateUrlAndPath: JZ,
        createEmptyAuthenticationState: kq,
        createEmptyOpenApiState: Tq,
        createEmptyServerState: AV,
        createPlaceholderRequest: zz,
        encodeStringAsBase64: vq,
        findVariables: XG,
        getBase64Token: wq,
        getRequestFromAuthentication: yq,
        getSecretCredentialsFromAuthentication: _q,
        getUrlFromServerState: TV,
        httpHeaders: _G,
        humanDiff: jz,
        isRequestMethod: Ql,
        mapFromArray: GZ,
        normalizeHeaders: aG,
        normalizePath: KZ,
        normalizeRequestMethod: VZ,
        normalizeUrl: YZ,
        prepareClientRequestConfig: Nq,
        redirectToProxy: WZ,
        replaceVariables: eW,
        requestMethodAbbreviations: Ul,
        requestMethodColors: Bl,
        sendRequest: tW,
        useApiClientStore: eY,
        useAuthenticationStore: xq,
        useOpenApiStore: Dq,
        useRequestStore: eq,
        useServerStore: DV,
        validRequestMethods: Ll
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    function nY(e, t) {
        const n = []
          , r = t.resolveKeyData || (e=>e.key)
          , o = t.resolveValueData || (e=>e.value);
        for (const [i,a] of Object.entries(e))
            n.push(...(Array.isArray(a) ? a : [a]).map((e=>{
                const n = {
                    key: i,
                    value: e
                }
                  , a = o(n);
                return "object" == typeof a ? nY(a, t) : Array.isArray(a) ? a : {
                    ["function" == typeof t.key ? t.key(n) : t.key]: r(n),
                    ["function" == typeof t.value ? t.value(n) : t.value]: a
                }
            }
            )).flat());
        return n
    }
    function rY(e, t) {
        return Object.entries(e).map((([e,n])=>{
            if ("object" == typeof n && (n = rY(n, t)),
            t.resolve) {
                const r = t.resolve({
                    key: e,
                    value: n
                });
                if (void 0 !== r)
                    return r
            }
            return "number" == typeof n && (n = n.toString()),
            "string" == typeof n && t.wrapValue && (n = n.replace(new RegExp(t.wrapValue,"g"), `\\${t.wrapValue}`),
            n = `${t.wrapValue}${n}${t.wrapValue}`),
            `${e}${t.keyValueSeparator || ""}${n}`
        }
        )).join(t.entrySeparator || "")
    }
    const oY = e=>({
        keyValue: e,
        metaKey: "property"
    })
      , iY = e=>({
        keyValue: e
    })
      , aY = {
        appleItunesApp: {
            unpack: {
                entrySeparator: ", ",
                resolve: ({key: e, value: t})=>`${cY(e)}=${t}`
            }
        },
        articleExpirationTime: oY("article:expiration_time"),
        articleModifiedTime: oY("article:modified_time"),
        articlePublishedTime: oY("article:published_time"),
        bookReleaseDate: oY("book:release_date"),
        charset: {
            metaKey: "charset"
        },
        contentSecurityPolicy: {
            unpack: {
                entrySeparator: "; ",
                resolve: ({key: e, value: t})=>`${cY(e)} ${t}`
            },
            metaKey: "http-equiv"
        },
        contentType: {
            metaKey: "http-equiv"
        },
        defaultStyle: {
            metaKey: "http-equiv"
        },
        fbAppId: oY("fb:app_id"),
        msapplicationConfig: iY("msapplication-Config"),
        msapplicationTileColor: iY("msapplication-TileColor"),
        msapplicationTileImage: iY("msapplication-TileImage"),
        ogAudioSecureUrl: oY("og:audio:secure_url"),
        ogAudioUrl: oY("og:audio"),
        ogImageSecureUrl: oY("og:image:secure_url"),
        ogImageUrl: oY("og:image"),
        ogSiteName: oY("og:site_name"),
        ogVideoSecureUrl: oY("og:video:secure_url"),
        ogVideoUrl: oY("og:video"),
        profileFirstName: oY("profile:first_name"),
        profileLastName: oY("profile:last_name"),
        profileUsername: oY("profile:username"),
        refresh: {
            metaKey: "http-equiv",
            unpack: {
                entrySeparator: ";",
                resolve({key: e, value: t}) {
                    if ("seconds" === e)
                        return `${t}`
                }
            }
        },
        robots: {
            unpack: {
                entrySeparator: ", ",
                resolve: ({key: e, value: t})=>"boolean" == typeof t ? `${cY(e)}` : `${cY(e)}:${t}`
            }
        },
        xUaCompatible: {
            metaKey: "http-equiv"
        }
    }
      , sY = ["og", "book", "article", "profile"];
    function lY(e) {
        var t;
        const n = cY(e).split(":")[0];
        return sY.includes(n) ? "property" : (null == (t = aY[e]) ? void 0 : t.metaKey) || "name"
    }
    function cY(e) {
        const t = e.replace(/([A-Z])/g, "-$1").toLowerCase()
          , n = t.split("-")[0];
        return sY.includes(n) || "twitter" === n ? e.replace(/([A-Z])/g, ":$1").toLowerCase() : t
    }
    function uY(e) {
        if (Array.isArray(e))
            return e.map((e=>uY(e)));
        if ("object" != typeof e || Array.isArray(e))
            return e;
        const t = {};
        for (const [n,r] of Object.entries(e))
            t[cY(n)] = uY(r);
        return t
    }
    function dY(e, t) {
        const n = aY[t];
        return "refresh" === t ? `${e.seconds};url=${e.url}` : rY(uY(e), {
            keyValueSeparator: "=",
            entrySeparator: ", ",
            resolve: ({value: e, key: t})=>null === e ? "" : "boolean" == typeof e ? `${t}` : void 0,
            ...null == n ? void 0 : n.unpack
        })
    }
    const pY = ["og:image", "og:video", "og:audio", "twitter:image"];
    function hY(e) {
        const t = {};
        return Object.entries(e).forEach((([e,n])=>{
            "false" !== String(n) && e && (t[e] = n)
        }
        )),
        t
    }
    function fY(e, t) {
        const n = hY(t)
          , r = cY(e)
          , o = lY(r);
        if (pY.includes(r)) {
            const t = {};
            return Object.entries(n).forEach((([n,r])=>{
                t[`${e}${"url" === n ? "" : `${n.charAt(0).toUpperCase()}${n.slice(1)}`}`] = r
            }
            )),
            mY(t).sort(((e,t)=>{
                var n, r;
                return ((null == (n = e[o]) ? void 0 : n.length) || 0) - ((null == (r = t[o]) ? void 0 : r.length) || 0)
            }
            ))
        }
        return [{
            [o]: r,
            ...n
        }]
    }
    function mY(e) {
        const t = []
          , n = {};
        Object.entries(e).forEach((([e,r])=>{
            if (Array.isArray(r))
                r.forEach((n=>{
                    t.push(..."string" == typeof n ? mY({
                        [e]: n
                    }) : fY(e, n))
                }
                ));
            else if ("object" == typeof r && r) {
                if (pY.includes(cY(e)))
                    return void t.push(...fY(e, r));
                n[e] = hY(r)
            } else
                n[e] = r
        }
        ));
        const r = nY(n, {
            key: ({key: e})=>lY(e),
            value: ({key: e})=>"charset" === e ? "charset" : "content",
            resolveKeyData: ({key: e})=>function(e) {
                var t;
                return (null == (t = aY[e]) ? void 0 : t.keyValue) || cY(e)
            }(e),
            resolveValueData: ({value: e, key: t})=>null === e ? "_null" : "object" == typeof e ? dY(e, t) : "number" == typeof e ? e.toString() : e
        });
        return [...t, ...r].map((e=>("_null" === e.content && (e.content = null),
        e)))
    }
    let gY;
    function bY(e, t={}) {
        const n = t.head || gY;
        return null == n ? void 0 : n.push(e, t)
    }
    const OY = ()=>{
        const {toast: e} = oV();
        return {
            copyToClipboard: t=>{
                navigator.clipboard.writeText(t).then((()=>{
                    e("Copied to the clipboard", "info")
                }
                ))
            }
        }
    }
      , vY = Et(!1);
    const yY = "https://api.scalar.com/request-proxy"
      , wY = "https://proxy.scalar.com";
    const _Y = /[\0-\x1F!-,\.\/:-@\[-\^`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482\u0530\u0557\u0558\u055A-\u055F\u0589-\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05EB-\u05EE\u05F3-\u060F\u061B-\u061F\u066A-\u066D\u06D4\u06DD\u06DE\u06E9\u06FD\u06FE\u0700-\u070F\u074B\u074C\u07B2-\u07BF\u07F6-\u07F9\u07FB\u07FC\u07FE\u07FF\u082E-\u083F\u085C-\u085F\u086B-\u089F\u08B5\u08C8-\u08D2\u08E2\u0964\u0965\u0970\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09F2-\u09FB\u09FD\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF0-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B54\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B70\u0B72-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BF0-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C7F\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D0D\u0D11\u0D45\u0D49\u0D4F-\u0D53\u0D58-\u0D5E\u0D64\u0D65\u0D70-\u0D79\u0D80\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF4-\u0E00\u0E3B-\u0E3F\u0E4F\u0E5A-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F01-\u0F17\u0F1A-\u0F1F\u0F2A-\u0F34\u0F36\u0F38\u0F3A-\u0F3D\u0F48\u0F6D-\u0F70\u0F85\u0F98\u0FBD-\u0FC5\u0FC7-\u0FFF\u104A-\u104F\u109E\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u1360-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16ED\u16F9-\u16FF\u170D\u1715-\u171F\u1735-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17D4-\u17D6\u17D8-\u17DB\u17DE\u17DF\u17EA-\u180A\u180E\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u1945\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DA-\u19FF\u1A1C-\u1A1F\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1AA6\u1AA8-\u1AAF\u1AC1-\u1AFF\u1B4C-\u1B4F\u1B5A-\u1B6A\u1B74-\u1B7F\u1BF4-\u1BFF\u1C38-\u1C3F\u1C4A-\u1C4C\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CCF\u1CD3\u1CFB-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u203E\u2041-\u2053\u2055-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u20CF\u20F1-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u215F\u2189-\u24B5\u24EA-\u2BFF\u2C2F\u2C5F\u2CE5-\u2CEA\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E00-\u2E2E\u2E30-\u3004\u3008-\u3020\u3030\u3036\u3037\u303D-\u3040\u3097\u3098\u309B\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\u9FFD-\u9FFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA62C-\uA63F\uA673\uA67E\uA6F2-\uA716\uA720\uA721\uA789\uA78A\uA7C0\uA7C1\uA7CB-\uA7F4\uA828-\uA82B\uA82D-\uA83F\uA874-\uA87F\uA8C6-\uA8CF\uA8DA-\uA8DF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA954-\uA95F\uA97D-\uA97F\uA9C1-\uA9CE\uA9DA-\uA9DF\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A-\uAA5F\uAA77-\uAA79\uAAC3-\uAADA\uAADE\uAADF\uAAF0\uAAF1\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABEB\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFDFF\uFE10-\uFE1F\uFE30-\uFE32\uFE35-\uFE4C\uFE50-\uFE6F\uFE75\uFEFD-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF3E\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDD3F\uDD75-\uDDFC\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEE1-\uDEFF\uDF20-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE40-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE7-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD28-\uDD2F\uDD3A-\uDE7F\uDEAA\uDEAD-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF51-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC47-\uDC65\uDC70-\uDC7E\uDCBB-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD40-\uDD43\uDD48-\uDD4F\uDD74\uDD75\uDD77-\uDD7F\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDFF\uDE12\uDE38-\uDE3D\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC4B-\uDC4F\uDC5A-\uDC5D\uDC62-\uDC7F\uDCC6\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDC1-\uDDD7\uDDDE-\uDDFF\uDE41-\uDE43\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF3A-\uDFFF]|\uD806[\uDC3B-\uDC9F\uDCEA-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD44-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE2\uDDE5-\uDDFF\uDE3F-\uDE46\uDE48-\uDE4F\uDE9A-\uDE9C\uDE9E-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC41-\uDC4F\uDC5A-\uDC71\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF7-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD824-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83D\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDECF\uDEEE\uDEEF\uDEF5-\uDEFF\uDF37-\uDF3F\uDF44-\uDF4F\uDF5A-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE2\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDC9C\uDC9F-\uDFFF]|\uD834[\uDC00-\uDD64\uDD6A-\uDD6C\uDD73-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDE41\uDE45-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC\uDFCD]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD4F-\uDEBF\uDEFA-\uDFFF]|\uD83A[\uDCC5-\uDCCF\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD83C[\uDC00-\uDD2F\uDD4A-\uDD4F\uDD6A-\uDD6F\uDD8A-\uDFFF]|\uD83E[\uDC00-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEDE-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]/g
      , kY = Object.hasOwnProperty;
    class SY {
        constructor() {
            this.occurrences,
            this.reset()
        }
        slug(e, t) {
            const n = this;
            let r = EY(e, !0 === t);
            const o = r;
            for (; kY.call(n.occurrences, r); )
                n.occurrences[o]++,
                r = o + "-" + n.occurrences[o];
            return n.occurrences[r] = 0,
            r
        }
        reset() {
            this.occurrences = Object.create(null)
        }
    }
    function EY(e, t) {
        return "string" != typeof e ? "" : (t || (e = e.toLowerCase()),
        e.replace(_Y, "").replace(/ /g, "-"))
    }
    const xY = Et(qT.hash ?? "")
      , TY = Et()
      , AY = Et(!1)
      , CY = e=>e.slug ? `description/${e.slug}` : ""
      , PY = e=>{
        var t;
        if (!TY.value)
            return "";
        const n = new RegExp("^" + (null == (t = TY.value) ? void 0 : t.basePath) + "/?");
        return decodeURIComponent(e.replace(n, ""))
    }
      , DY = (e,t)=>{
        if (!e)
            return "webhooks";
        const n = EY(e);
        return `webhook/${t}/${encodeURIComponent(n)}`
    }
      , RY = e=>{
        if (!e)
            return "models";
        const t = EY(e);
        return `model/${encodeURIComponent(t)}`
    }
      , NY = (e,t)=>`${$Y(t)}/${e.httpVerb}${e.path}`
      , $Y = ({name: e})=>{
        const t = EY(e);
        return `tag/${encodeURIComponent(t)}`
    }
      , IY = (e=xY.value)=>{
        var t;
        const n = null == (t = e.match(/(tag\/[^/]+)/)) ? void 0 : t[0]
          , r = e.startsWith("model") ? "models" : ""
          , o = e.startsWith("webhook") ? "webhooks" : "";
        return n || r || o
    }
      , MY = ()=>{
        xY.value = TY.value ? PY(window.location.pathname) : decodeURIComponent(window.location.hash.replace(/^#/, ""))
    }
      , LY = ()=>({
        hash: xY,
        getWebhookId: DY,
        getModelId: RY,
        getHeadingId: CY,
        getOperationId: NY,
        getPathRoutingId: PY,
        getSectionId: IY,
        getTagId: $Y,
        isIntersectionEnabled: AY,
        pathRouting: TY,
        updateHash: MY
    });
    function QY(e) {
        return {
            parameterMap: ei((()=>{
                var t;
                const n = (null == (t = e.operation.information) ? void 0 : t.parameters) ?? []
                  , r = {
                    path: [],
                    query: [],
                    header: [],
                    body: [],
                    formData: []
                };
                return e.operation.pathParameters && e.operation.pathParameters.forEach((e=>{
                    "path" === e.in ? r.path.push(e) : "query" === e.in ? r.query.push(e) : "header" === e.in ? r.header.push(e) : "body" === e.in ? r.body.push(e) : "formData" === e.in && r.formData.push(e)
                }
                )),
                n && n.forEach((e=>{
                    "path" === e.in ? r.path.push(e) : "query" === e.in ? r.query.push(e) : "header" === e.in ? r.header.push(e) : "body" === e.in ? r.body.push(e) : "formData" === e.in && r.formData.push(e)
                }
                )),
                r
            }
            ))
        }
    }
    function BY(e, t="") {
        return {
            "date-time": (new Date).toISOString(),
            date: (new Date).toISOString().split("T")[0],
            email: "hello@example.com",
            hostname: "example.com",
            "idn-email": "jane.doe@example.com",
            "idn-hostname": "example.com",
            ipv4: "127.0.0.1",
            ipv6: "51d4:7fab:bfbf:b7d7:b2cb:d4b4:3dad:d998",
            "iri-reference": "/entitiy/1",
            iri: "https://example.com/entity/123",
            "json-pointer": "/nested/objects",
            password: "super-secret",
            regex: "/[a-z]/",
            "relative-json-pointer": "1/nested/objects",
            time: (new Date).toISOString().split("T")[1].split(".")[0],
            "uri-reference": "../folder",
            "uri-template": "https://example.com/{id}",
            uri: "https://example.com",
            uuid: "123e4567-e89b-12d3-a456-426614174000"
        }[e.format] ?? t
    }
    const UY = (e,t,n=0,r,o)=>{
        var i, a, s, l, c, u;
        if (n > 5)
            return null;
        const d = !!(null == t ? void 0 : t.emptyString);
        if ("write" === (null == t ? void 0 : t.mode) && e.readOnly)
            return;
        if ("read" === (null == t ? void 0 : t.mode) && e.writeOnly)
            return;
        if (e["x-variable"]) {
            const n = null == (i = null == t ? void 0 : t.variables) ? void 0 : i[e["x-variable"]];
            if (void 0 !== n)
                return "number" === e.type || "integer" === e.type ? parseInt(n, 10) : n
        }
        if (Array.isArray(e.examples) && e.examples.length > 0)
            return e.examples[0];
        if (void 0 !== e.example)
            return e.example;
        if (void 0 !== e.default)
            return e.default;
        if (void 0 !== e.enum)
            return e.enum[0];
        if (!("object" === e.type || "array" === e.type) && !0 === (null == t ? void 0 : t.omitEmptyAndOptionalProperties)) {
            if (!(!0 === e.required || !0 === (null == r ? void 0 : r.required) || (null == (a = null == r ? void 0 : r.required) ? void 0 : a.includes(o ?? e.name))))
                return
        }
        if ("object" === e.type || void 0 !== e.properties) {
            const r = {};
            if (void 0 !== e.properties && Object.keys(e.properties).forEach((o=>{
                var i;
                const a = e.properties[o]
                  , s = (null == t ? void 0 : t.xml) ? null == (i = a.xml) ? void 0 : i.name : void 0;
                r[s ?? o] = UY(a, t, n + 1, e, o),
                void 0 === r[s ?? o] && delete r[s ?? o]
            }
            )),
            void 0 !== e.anyOf ? Object.assign(r, UY(e.anyOf[0]), t, n + 1) : void 0 !== e.oneOf ? Object.assign(r, UY(e.oneOf[0]), t, n + 1) : void 0 !== e.allOf && Object.assign(r, ...e.allOf.map((r=>UY(r, t, n + 1, e))).filter((e=>void 0 !== e))),
            void 0 !== e.additionalProperties && !1 !== e.additionalProperties) {
                const o = UY(e.additionalProperties, t, n + 1);
                if (o && "object" == typeof o && !Array.isArray(o))
                    return {
                        ...r,
                        ...UY(e.additionalProperties, t, n + 1)
                    };
                if (null === o)
                    return null;
                const i = UY(e.additionalProperties, {
                    ...t,
                    omitEmptyAndOptionalProperties: !1
                }, n + 1);
                return {
                    ...r,
                    ...void 0 === i ? {} : {
                        "{{key}}": i
                    }
                }
            }
            return r
        }
        if ("array" === e.type || void 0 !== e.items) {
            const r = null == (l = null == (s = null == e ? void 0 : e.items) ? void 0 : s.xml) ? void 0 : l.name
              , o = !!((null == t ? void 0 : t.xml) && (null == (c = e.xml) ? void 0 : c.wrapped) && r);
            if (void 0 !== e.example)
                return o ? {
                    [r]: e.example
                } : e.example;
            if (e.items) {
                const i = ["anyOf", "oneOf", "allOf"];
                for (const a of i) {
                    if (!e.items[a])
                        continue;
                    const i = (["anyOf", "oneOf"].includes(a) ? e.items[a].slice(0, 1) : e.items[a]).map((r=>UY(r, t, n + 1, e))).filter((e=>void 0 !== e));
                    return o ? [{
                        [r]: i
                    }] : i
                }
            }
            if (null == (u = e.items) ? void 0 : u.type) {
                const i = UY(e.items, t, n + 1);
                return o ? [{
                    [r]: i
                }] : [i]
            }
            return []
        }
        const p = {
            string: d ? BY(e, null == t ? void 0 : t.emptyString) : "",
            boolean: !0,
            integer: e.min ?? 1,
            number: e.min ?? 1,
            array: []
        };
        if (void 0 !== e.type && void 0 !== p[e.type])
            return p[e.type];
        if (Array.isArray(e.oneOf) && e.oneOf.length > 0) {
            const r = e.oneOf[0];
            return UY(r, t, n + 1)
        }
        if (Array.isArray(e.allOf)) {
            let r = null;
            return e.allOf.forEach((e=>{
                const o = UY(e, t, n + 1);
                r = "object" == typeof o && "object" == typeof r ? {
                    ...r ?? {},
                    ...o
                } : Array.isArray(o) && Array.isArray(r) ? [...r ?? {}, ...o] : o
            }
            )),
            r
        }
        if (Array.isArray(e.type)) {
            if (e.type.includes("null"))
                return null;
            const t = p[e.type[0]];
            if (void 0 !== t)
                return t
        }
        return console.warn(`[getExampleFromSchema] Unknown property type "${e.type}".`),
        null
    }
    ;
    function FY(e, t, n=!0) {
        var r;
        return [...e.pathParameters || [], ...(null == (r = e.information) ? void 0 : r.parameters) || []].filter((e=>e.in === t)).filter((e=>n && e.required || !n)).map((e=>({
            name: e.name,
            description: e.description ?? null,
            value: e.example ? e.example : e.schema ? UY(e.schema, {
                mode: "write"
            }) : "",
            required: e.required ?? !1,
            enabled: e.required ?? !1
        }))).sort(((e,t)=>e.required && !t.required ? -1 : !e.required && t.required ? 1 : 0))
    }
    function jY(e, t) {
        const n = function(e, t, r) {
            let o = "";
            if (e instanceof Array)
                for (let i = 0, a = e.length; i < a; i++)
                    o += r + n(e[i], t, r + "\t") + "\n";
            else if ("object" == typeof e) {
                let i = !1;
                o += r + "<" + t;
                for (const t in e)
                    "@" == t.charAt(0) ? o += " " + t.substr(1) + '="' + e[t].toString() + '"' : i = !0;
                if (o += i ? ">" : "/>",
                i) {
                    for (const t in e)
                        "#text" == t ? o += e[t] : "#cdata" == t ? o += "<![CDATA[" + e[t] + "]]>" : "@" != t.charAt(0) && (o += n(e[t], t, r + "\t"));
                    o += ("\n" == o.charAt(o.length - 1) ? r : "") + "</" + t + ">"
                }
            } else
                o += r + "<" + t + ">" + e.toString() + "</" + t + ">";
            return o
        };
        let r = "";
        for (const o in e)
            r += n(e[o], o, "");
        return t ? r.replace(/\t/g, t) : r.replace(/\t|\n/g, "")
    }
    const zY = (e,t,n)=>{
        let r = e.path;
        const o = FY(e, "path", !1);
        if (o.length) {
            const e = r.match(/{(.*?)}/g);
            e && e.forEach((e=>{
                const t = e.replace(/{|}/g, "");
                if (o) {
                    const n = o.find((e=>e.name === t));
                    (null == n ? void 0 : n.value) && (r = r.replace(e, n.value.toString()))
                }
            }
            ))
        }
        if (!0 === (null == t ? void 0 : t.replaceVariables)) {
            const e = r.match(/{(.*?)}/g);
            e && e.forEach((e=>{
                const t = e.replace(/{|}/g, "");
                r = r.replace(e, `__${t.toUpperCase()}__`)
            }
            ))
        }
        const i = function(e, t) {
            var n, r, o, i;
            const a = FT(null == (r = null == (n = e.information) ? void 0 : n.requestBody) ? void 0 : r.content)
              , s = ["application/json", "application/octet-stream", "application/x-www-form-urlencoded", "application/xml", "multipart/form-data", "text/plain"].find((e=>!!(null == a ? void 0 : a[e])))
              , l = null == (o = null == a ? void 0 : a["application/json"]) ? void 0 : o.examples
              , c = null == (i = l ?? {}) ? void 0 : i[t ?? Object.keys(l ?? {})[0]];
            if (c)
                return {
                    postData: {
                        mimeType: "application/json",
                        text: zT(null == c ? void 0 : c.value)
                    }
                };
            const u = FY(e, "body", !1);
            if (u.length > 0)
                return {
                    postData: {
                        mimeType: "application/json",
                        text: zT(u[0].value)
                    }
                };
            const d = FY(e, "formData", !1);
            if (d.length > 0)
                return {
                    postData: {
                        mimeType: "application/x-www-form-urlencoded",
                        params: d.map((e=>({
                            name: e.name,
                            value: e.value
                        })))
                    }
                };
            if (!s)
                return {
                    postData: void 0
                };
            const p = null == a ? void 0 : a[s]
              , h = [{
                name: "Content-Type",
                value: s
            }]
              , f = (null == p ? void 0 : p.example) ? null == p ? void 0 : p.example : void 0;
            if ("application/json" === s) {
                const e = (null == p ? void 0 : p.schema) ? UY(null == p ? void 0 : p.schema, {
                    mode: "write",
                    omitEmptyAndOptionalProperties: !0
                }) : null
                  , t = f ?? e;
                return {
                    headers: h,
                    postData: {
                        mimeType: s,
                        text: "string" == typeof t ? t : JSON.stringify(t, null, 2)
                    }
                }
            }
            if ("application/xml" === s) {
                const e = (null == p ? void 0 : p.schema) ? UY(null == p ? void 0 : p.schema, {
                    xml: !0,
                    mode: "write",
                    omitEmptyAndOptionalProperties: !0
                }) : null;
                return {
                    headers: h,
                    postData: {
                        mimeType: s,
                        text: f ?? jY(e, "  ")
                    }
                }
            }
            if ("application/octet-stream" === s)
                return {
                    headers: h,
                    postData: {
                        mimeType: s,
                        text: "BINARY"
                    }
                };
            if ("text/plain" === s) {
                const e = (null == p ? void 0 : p.schema) ? UY(null == p ? void 0 : p.schema, {
                    xml: !0,
                    mode: "write",
                    omitEmptyAndOptionalProperties: !0
                }) : null;
                return {
                    headers: h,
                    postData: {
                        mimeType: s,
                        text: f ?? e ?? ""
                    }
                }
            }
            return "application/x-www-form-urlencoded" === s || "multipart/form-data" === s ? {
                headers: h,
                postData: {
                    mimeType: s
                }
            } : void 0
        }(e, n);
        return {
            method: e.httpVerb.toUpperCase(),
            path: r,
            headers: [...FY(e, "header", null == t ? void 0 : t.requiredOnly), ...(null == i ? void 0 : i.headers) ?? []],
            postData: null == i ? void 0 : i.postData,
            queryString: FY(e, "query", null == t ? void 0 : t.requiredOnly),
            cookies: FY(e, "cookie", null == t ? void 0 : t.requiredOnly)
        }
    }
    ;
    function qY({serverState: e, authenticationState: t, operation: n, globalSecurity: r}) {
        var o, i;
        const a = AK({
            url: TV(e)
        }, zY(n, {
            requiredOnly: !1
        }), t ? yq(t, (null == (o = n.information) ? void 0 : o.security) ?? r ?? []) : {})
          , s = zY(n, {
            requiredOnly: !1
        })
          , l = FY(n, "path", !1);
        return {
            id: n.operationId,
            name: n.name,
            type: a.method,
            path: s.path ?? "",
            variables: l,
            cookies: HY(a.cookies),
            query: a.queryString.map((e=>{
                const t = e;
                return {
                    ...e,
                    enabled: t.required ?? !0
                }
            }
            )),
            headers: HY(a.headers),
            url: TV(e) ?? "",
            body: null == (i = a.postData) ? void 0 : i.text
        }
    }
    function HY(e) {
        return (e ?? []).map((e=>({
            ...e,
            enabled: !0
        })))
    }
    function ZY(e) {
        const t = new SY
          , n = new RegExp("^(#{1,6}) (?!#)(.*)","gm")
          , r = [...e.matchAll(n)].map((e=>({
            value: e[2],
            depth: e[1].length
        })));
        return ((e,t)=>e.map((e=>({
            ...e,
            slug: t.slug(e.value)
        }))))(r, t)
    }
    const WY = e=>{
        const t = Math.min(...e.map((e=>e.depth)));
        return t >= 1 && t <= 6 ? t : 1
    }
    ;
    function XY(e) {
        var t, n;
        return e ? Object.keys((null == (t = null == e ? void 0 : e.components) ? void 0 : t.schemas) ?? {}).length ? null == (n = null == e ? void 0 : e.components) ? void 0 : n.schemas : Object.keys((null == e ? void 0 : e.definitions) ?? {}).length ? null == e ? void 0 : e.definitions : {} : {}
    }
    const VY = e=>!!e && !!Object.keys(XY(e) ?? {}).length
      , GY = e=>{
        var t;
        return !!Object.keys((null == (t = null == e ? void 0 : e.components) ? void 0 : t.securitySchemes) ?? {}).length
    }
    ;
    const YY = (e,t)=>e.replace(/\/$/, "") + "/" + t.replace(/^\//, "")
      , {server: KY} = DV()
      , {setOperation: JY, setGlobalSecurity: eK} = Dq()
      , {toggleApiClient: tK} = eY()
      , {setActiveRequest: nK, resetActiveResponse: rK} = eq();
    function oK(e, t) {
        const n = qY({
            serverState: KY,
            operation: e,
            authenticationState: null,
            globalSecurity: null
        });
        rK(),
        nK(n),
        JY(e),
        eK(t),
        tK(n, !0)
    }
    function iK(e) {
        return e.find((e=>e.isEntrypoint))
    }
    function aK(e, t) {
        const n = {};
        for (const [r,o] of Object.entries(e))
            Array.isArray(o) ? n[r] = o.map((e=>"object" == typeof e && null !== e ? aK(e, t) : e)) : n[r] = "object" == typeof o && null !== o ? aK(o, t) : o;
        return t(n)
    }
    function sK(e) {
        const t = [];
        return e && "object" == typeof e ? (aK(e, (e=>(e.$ref && "string" == typeof e.$ref && !e.$ref.startsWith("#") && t.push(e.$ref.split("#")[0]),
        e))),
        [...new Set(t)]) : t
    }
    function lK(e) {
        return void 0 !== typeof e && Array.isArray(e) && e.length > 0 && e.some((e=>!0 === e.isEntrypoint))
    }
    function cK(e) {
        if (lK(e))
            return e;
        if ("string" == typeof e)
            try {
                return JSON.parse(e)
            } catch (t) {
                return function(e, t, n) {
                    let r;
                    "function" == typeof t ? r = t : void 0 === n && t && "object" == typeof t && (n = t);
                    const o = IT(e, n);
                    if (!o)
                        return null;
                    if (o.warnings.forEach((e=>NE(o.options.logLevel, e))),
                    o.errors.length > 0) {
                        if ("silent" !== o.options.logLevel)
                            throw o.errors[0];
                        o.errors = []
                    }
                    return o.toJS(Object.assign({
                        reviver: r
                    }, n))
                }(e, {
                    maxAliasCount: 1e4
                })
            }
        return e
    }
    function uK(e, t={}) {
        if (lK(e))
            return e;
        const n = cK(e);
        return [{
            isEntrypoint: !0,
            specification: n,
            filename: null,
            dir: "./",
            references: sK(n),
            ...t
        }]
    }
    const dK = {
        "2.0": {
            title: "A JSON Schema for Swagger 2.0 API.",
            id: "http://swagger.io/v2/schema.json#",
            $schema: "http://json-schema.org/draft-04/schema#",
            type: "object",
            required: ["swagger", "info", "paths"],
            additionalProperties: !1,
            patternProperties: {
                "^x-": {
                    $ref: "#/definitions/vendorExtension"
                }
            },
            properties: {
                swagger: {
                    type: "string",
                    enum: ["2.0"],
                    description: "The Swagger version of this document."
                },
                info: {
                    $ref: "#/definitions/info"
                },
                host: {
                    type: "string",
                    pattern: "^[^{}/ :\\\\]+(?::\\d+)?$",
                    description: "The host (name or ip) of the API. Example: 'swagger.io'"
                },
                basePath: {
                    type: "string",
                    pattern: "^/",
                    description: "The base path to the API. Example: '/api'."
                },
                schemes: {
                    $ref: "#/definitions/schemesList"
                },
                consumes: {
                    description: "A list of MIME types accepted by the API.",
                    allOf: [{
                        $ref: "#/definitions/mediaTypeList"
                    }]
                },
                produces: {
                    description: "A list of MIME types the API can produce.",
                    allOf: [{
                        $ref: "#/definitions/mediaTypeList"
                    }]
                },
                paths: {
                    $ref: "#/definitions/paths"
                },
                definitions: {
                    $ref: "#/definitions/definitions"
                },
                parameters: {
                    $ref: "#/definitions/parameterDefinitions"
                },
                responses: {
                    $ref: "#/definitions/responseDefinitions"
                },
                security: {
                    $ref: "#/definitions/security"
                },
                securityDefinitions: {
                    $ref: "#/definitions/securityDefinitions"
                },
                tags: {
                    type: "array",
                    items: {
                        $ref: "#/definitions/tag"
                    },
                    uniqueItems: !0
                },
                externalDocs: {
                    $ref: "#/definitions/externalDocs"
                }
            },
            definitions: {
                info: {
                    type: "object",
                    description: "General information about the API.",
                    required: ["version", "title"],
                    additionalProperties: !1,
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    },
                    properties: {
                        title: {
                            type: "string",
                            description: "A unique and precise title of the API."
                        },
                        version: {
                            type: "string",
                            description: "A semantic version number of the API."
                        },
                        description: {
                            type: "string",
                            description: "A longer description of the API. Should be different from the title.  GitHub Flavored Markdown is allowed."
                        },
                        termsOfService: {
                            type: "string",
                            description: "The terms of service for the API."
                        },
                        contact: {
                            $ref: "#/definitions/contact"
                        },
                        license: {
                            $ref: "#/definitions/license"
                        }
                    }
                },
                contact: {
                    type: "object",
                    description: "Contact information for the owners of the API.",
                    additionalProperties: !1,
                    properties: {
                        name: {
                            type: "string",
                            description: "The identifying name of the contact person/organization."
                        },
                        url: {
                            type: "string",
                            description: "The URL pointing to the contact information.",
                            format: "uri"
                        },
                        email: {
                            type: "string",
                            description: "The email address of the contact person/organization.",
                            format: "email"
                        }
                    },
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    }
                },
                license: {
                    type: "object",
                    required: ["name"],
                    additionalProperties: !1,
                    properties: {
                        name: {
                            type: "string",
                            description: "The name of the license type. It's encouraged to use an OSI compatible license."
                        },
                        url: {
                            type: "string",
                            description: "The URL pointing to the license.",
                            format: "uri"
                        }
                    },
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    }
                },
                paths: {
                    type: "object",
                    description: "Relative paths to the individual endpoints. They must be relative to the 'basePath'.",
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        },
                        "^/": {
                            $ref: "#/definitions/pathItem"
                        }
                    },
                    additionalProperties: !1
                },
                definitions: {
                    type: "object",
                    additionalProperties: {
                        $ref: "#/definitions/schema"
                    },
                    description: "One or more JSON objects describing the schemas being consumed and produced by the API."
                },
                parameterDefinitions: {
                    type: "object",
                    additionalProperties: {
                        $ref: "#/definitions/parameter"
                    },
                    description: "One or more JSON representations for parameters"
                },
                responseDefinitions: {
                    type: "object",
                    additionalProperties: {
                        $ref: "#/definitions/response"
                    },
                    description: "One or more JSON representations for responses"
                },
                externalDocs: {
                    type: "object",
                    additionalProperties: !1,
                    description: "information about external documentation",
                    required: ["url"],
                    properties: {
                        description: {
                            type: "string"
                        },
                        url: {
                            type: "string",
                            format: "uri"
                        }
                    },
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    }
                },
                examples: {
                    type: "object",
                    additionalProperties: !0
                },
                mimeType: {
                    type: "string",
                    description: "The MIME type of the HTTP message."
                },
                operation: {
                    type: "object",
                    required: ["responses"],
                    additionalProperties: !1,
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    },
                    properties: {
                        tags: {
                            type: "array",
                            items: {
                                type: "string"
                            },
                            uniqueItems: !0
                        },
                        summary: {
                            type: "string",
                            description: "A brief summary of the operation."
                        },
                        description: {
                            type: "string",
                            description: "A longer description of the operation, GitHub Flavored Markdown is allowed."
                        },
                        externalDocs: {
                            $ref: "#/definitions/externalDocs"
                        },
                        operationId: {
                            type: "string",
                            description: "A unique identifier of the operation."
                        },
                        produces: {
                            description: "A list of MIME types the API can produce.",
                            allOf: [{
                                $ref: "#/definitions/mediaTypeList"
                            }]
                        },
                        consumes: {
                            description: "A list of MIME types the API can consume.",
                            allOf: [{
                                $ref: "#/definitions/mediaTypeList"
                            }]
                        },
                        parameters: {
                            $ref: "#/definitions/parametersList"
                        },
                        responses: {
                            $ref: "#/definitions/responses"
                        },
                        schemes: {
                            $ref: "#/definitions/schemesList"
                        },
                        deprecated: {
                            type: "boolean",
                            default: !1
                        },
                        security: {
                            $ref: "#/definitions/security"
                        }
                    }
                },
                pathItem: {
                    type: "object",
                    additionalProperties: !1,
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    },
                    properties: {
                        $ref: {
                            type: "string"
                        },
                        get: {
                            $ref: "#/definitions/operation"
                        },
                        put: {
                            $ref: "#/definitions/operation"
                        },
                        post: {
                            $ref: "#/definitions/operation"
                        },
                        delete: {
                            $ref: "#/definitions/operation"
                        },
                        options: {
                            $ref: "#/definitions/operation"
                        },
                        head: {
                            $ref: "#/definitions/operation"
                        },
                        patch: {
                            $ref: "#/definitions/operation"
                        },
                        parameters: {
                            $ref: "#/definitions/parametersList"
                        }
                    }
                },
                responses: {
                    type: "object",
                    description: "Response objects names can either be any valid HTTP status code or 'default'.",
                    minProperties: 1,
                    additionalProperties: !1,
                    patternProperties: {
                        "^([0-9]{3})$|^(default)$": {
                            $ref: "#/definitions/responseValue"
                        },
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    },
                    not: {
                        type: "object",
                        additionalProperties: !1,
                        patternProperties: {
                            "^x-": {
                                $ref: "#/definitions/vendorExtension"
                            }
                        }
                    }
                },
                responseValue: {
                    oneOf: [{
                        $ref: "#/definitions/response"
                    }, {
                        $ref: "#/definitions/jsonReference"
                    }]
                },
                response: {
                    type: "object",
                    required: ["description"],
                    properties: {
                        description: {
                            type: "string"
                        },
                        schema: {
                            oneOf: [{
                                $ref: "#/definitions/schema"
                            }, {
                                $ref: "#/definitions/fileSchema"
                            }]
                        },
                        headers: {
                            $ref: "#/definitions/headers"
                        },
                        examples: {
                            $ref: "#/definitions/examples"
                        }
                    },
                    additionalProperties: !1,
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    }
                },
                headers: {
                    type: "object",
                    additionalProperties: {
                        $ref: "#/definitions/header"
                    }
                },
                header: {
                    type: "object",
                    additionalProperties: !1,
                    required: ["type"],
                    properties: {
                        type: {
                            type: "string",
                            enum: ["string", "number", "integer", "boolean", "array"]
                        },
                        format: {
                            type: "string"
                        },
                        items: {
                            $ref: "#/definitions/primitivesItems"
                        },
                        collectionFormat: {
                            $ref: "#/definitions/collectionFormat"
                        },
                        default: {
                            $ref: "#/definitions/default"
                        },
                        maximum: {
                            $ref: "#/definitions/maximum"
                        },
                        exclusiveMaximum: {
                            $ref: "#/definitions/exclusiveMaximum"
                        },
                        minimum: {
                            $ref: "#/definitions/minimum"
                        },
                        exclusiveMinimum: {
                            $ref: "#/definitions/exclusiveMinimum"
                        },
                        maxLength: {
                            $ref: "#/definitions/maxLength"
                        },
                        minLength: {
                            $ref: "#/definitions/minLength"
                        },
                        pattern: {
                            $ref: "#/definitions/pattern"
                        },
                        maxItems: {
                            $ref: "#/definitions/maxItems"
                        },
                        minItems: {
                            $ref: "#/definitions/minItems"
                        },
                        uniqueItems: {
                            $ref: "#/definitions/uniqueItems"
                        },
                        enum: {
                            $ref: "#/definitions/enum"
                        },
                        multipleOf: {
                            $ref: "#/definitions/multipleOf"
                        },
                        description: {
                            type: "string"
                        }
                    },
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    }
                },
                vendorExtension: {
                    description: "Any property starting with x- is valid.",
                    additionalProperties: !0,
                    additionalItems: !0
                },
                bodyParameter: {
                    type: "object",
                    required: ["name", "in", "schema"],
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    },
                    properties: {
                        description: {
                            type: "string",
                            description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
                        },
                        name: {
                            type: "string",
                            description: "The name of the parameter."
                        },
                        in: {
                            type: "string",
                            description: "Determines the location of the parameter.",
                            enum: ["body"]
                        },
                        required: {
                            type: "boolean",
                            description: "Determines whether or not this parameter is required or optional.",
                            default: !1
                        },
                        schema: {
                            $ref: "#/definitions/schema"
                        }
                    },
                    additionalProperties: !1
                },
                headerParameterSubSchema: {
                    additionalProperties: !1,
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    },
                    properties: {
                        required: {
                            type: "boolean",
                            description: "Determines whether or not this parameter is required or optional.",
                            default: !1
                        },
                        in: {
                            type: "string",
                            description: "Determines the location of the parameter.",
                            enum: ["header"]
                        },
                        description: {
                            type: "string",
                            description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
                        },
                        name: {
                            type: "string",
                            description: "The name of the parameter."
                        },
                        type: {
                            type: "string",
                            enum: ["string", "number", "boolean", "integer", "array"]
                        },
                        format: {
                            type: "string"
                        },
                        items: {
                            $ref: "#/definitions/primitivesItems"
                        },
                        collectionFormat: {
                            $ref: "#/definitions/collectionFormat"
                        },
                        default: {
                            $ref: "#/definitions/default"
                        },
                        maximum: {
                            $ref: "#/definitions/maximum"
                        },
                        exclusiveMaximum: {
                            $ref: "#/definitions/exclusiveMaximum"
                        },
                        minimum: {
                            $ref: "#/definitions/minimum"
                        },
                        exclusiveMinimum: {
                            $ref: "#/definitions/exclusiveMinimum"
                        },
                        maxLength: {
                            $ref: "#/definitions/maxLength"
                        },
                        minLength: {
                            $ref: "#/definitions/minLength"
                        },
                        pattern: {
                            $ref: "#/definitions/pattern"
                        },
                        maxItems: {
                            $ref: "#/definitions/maxItems"
                        },
                        minItems: {
                            $ref: "#/definitions/minItems"
                        },
                        uniqueItems: {
                            $ref: "#/definitions/uniqueItems"
                        },
                        enum: {
                            $ref: "#/definitions/enum"
                        },
                        multipleOf: {
                            $ref: "#/definitions/multipleOf"
                        }
                    }
                },
                queryParameterSubSchema: {
                    additionalProperties: !1,
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    },
                    properties: {
                        required: {
                            type: "boolean",
                            description: "Determines whether or not this parameter is required or optional.",
                            default: !1
                        },
                        in: {
                            type: "string",
                            description: "Determines the location of the parameter.",
                            enum: ["query"]
                        },
                        description: {
                            type: "string",
                            description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
                        },
                        name: {
                            type: "string",
                            description: "The name of the parameter."
                        },
                        allowEmptyValue: {
                            type: "boolean",
                            default: !1,
                            description: "allows sending a parameter by name only or with an empty value."
                        },
                        type: {
                            type: "string",
                            enum: ["string", "number", "boolean", "integer", "array"]
                        },
                        format: {
                            type: "string"
                        },
                        items: {
                            $ref: "#/definitions/primitivesItems"
                        },
                        collectionFormat: {
                            $ref: "#/definitions/collectionFormatWithMulti"
                        },
                        default: {
                            $ref: "#/definitions/default"
                        },
                        maximum: {
                            $ref: "#/definitions/maximum"
                        },
                        exclusiveMaximum: {
                            $ref: "#/definitions/exclusiveMaximum"
                        },
                        minimum: {
                            $ref: "#/definitions/minimum"
                        },
                        exclusiveMinimum: {
                            $ref: "#/definitions/exclusiveMinimum"
                        },
                        maxLength: {
                            $ref: "#/definitions/maxLength"
                        },
                        minLength: {
                            $ref: "#/definitions/minLength"
                        },
                        pattern: {
                            $ref: "#/definitions/pattern"
                        },
                        maxItems: {
                            $ref: "#/definitions/maxItems"
                        },
                        minItems: {
                            $ref: "#/definitions/minItems"
                        },
                        uniqueItems: {
                            $ref: "#/definitions/uniqueItems"
                        },
                        enum: {
                            $ref: "#/definitions/enum"
                        },
                        multipleOf: {
                            $ref: "#/definitions/multipleOf"
                        }
                    }
                },
                formDataParameterSubSchema: {
                    additionalProperties: !1,
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    },
                    properties: {
                        required: {
                            type: "boolean",
                            description: "Determines whether or not this parameter is required or optional.",
                            default: !1
                        },
                        in: {
                            type: "string",
                            description: "Determines the location of the parameter.",
                            enum: ["formData"]
                        },
                        description: {
                            type: "string",
                            description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
                        },
                        name: {
                            type: "string",
                            description: "The name of the parameter."
                        },
                        allowEmptyValue: {
                            type: "boolean",
                            default: !1,
                            description: "allows sending a parameter by name only or with an empty value."
                        },
                        type: {
                            type: "string",
                            enum: ["string", "number", "boolean", "integer", "array", "file"]
                        },
                        format: {
                            type: "string"
                        },
                        items: {
                            $ref: "#/definitions/primitivesItems"
                        },
                        collectionFormat: {
                            $ref: "#/definitions/collectionFormatWithMulti"
                        },
                        default: {
                            $ref: "#/definitions/default"
                        },
                        maximum: {
                            $ref: "#/definitions/maximum"
                        },
                        exclusiveMaximum: {
                            $ref: "#/definitions/exclusiveMaximum"
                        },
                        minimum: {
                            $ref: "#/definitions/minimum"
                        },
                        exclusiveMinimum: {
                            $ref: "#/definitions/exclusiveMinimum"
                        },
                        maxLength: {
                            $ref: "#/definitions/maxLength"
                        },
                        minLength: {
                            $ref: "#/definitions/minLength"
                        },
                        pattern: {
                            $ref: "#/definitions/pattern"
                        },
                        maxItems: {
                            $ref: "#/definitions/maxItems"
                        },
                        minItems: {
                            $ref: "#/definitions/minItems"
                        },
                        uniqueItems: {
                            $ref: "#/definitions/uniqueItems"
                        },
                        enum: {
                            $ref: "#/definitions/enum"
                        },
                        multipleOf: {
                            $ref: "#/definitions/multipleOf"
                        }
                    }
                },
                pathParameterSubSchema: {
                    additionalProperties: !1,
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    },
                    required: ["required"],
                    properties: {
                        required: {
                            type: "boolean",
                            enum: [!0],
                            description: "Determines whether or not this parameter is required or optional."
                        },
                        in: {
                            type: "string",
                            description: "Determines the location of the parameter.",
                            enum: ["path"]
                        },
                        description: {
                            type: "string",
                            description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
                        },
                        name: {
                            type: "string",
                            description: "The name of the parameter."
                        },
                        type: {
                            type: "string",
                            enum: ["string", "number", "boolean", "integer", "array"]
                        },
                        format: {
                            type: "string"
                        },
                        items: {
                            $ref: "#/definitions/primitivesItems"
                        },
                        collectionFormat: {
                            $ref: "#/definitions/collectionFormat"
                        },
                        default: {
                            $ref: "#/definitions/default"
                        },
                        maximum: {
                            $ref: "#/definitions/maximum"
                        },
                        exclusiveMaximum: {
                            $ref: "#/definitions/exclusiveMaximum"
                        },
                        minimum: {
                            $ref: "#/definitions/minimum"
                        },
                        exclusiveMinimum: {
                            $ref: "#/definitions/exclusiveMinimum"
                        },
                        maxLength: {
                            $ref: "#/definitions/maxLength"
                        },
                        minLength: {
                            $ref: "#/definitions/minLength"
                        },
                        pattern: {
                            $ref: "#/definitions/pattern"
                        },
                        maxItems: {
                            $ref: "#/definitions/maxItems"
                        },
                        minItems: {
                            $ref: "#/definitions/minItems"
                        },
                        uniqueItems: {
                            $ref: "#/definitions/uniqueItems"
                        },
                        enum: {
                            $ref: "#/definitions/enum"
                        },
                        multipleOf: {
                            $ref: "#/definitions/multipleOf"
                        }
                    }
                },
                nonBodyParameter: {
                    type: "object",
                    required: ["name", "in", "type"],
                    oneOf: [{
                        $ref: "#/definitions/headerParameterSubSchema"
                    }, {
                        $ref: "#/definitions/formDataParameterSubSchema"
                    }, {
                        $ref: "#/definitions/queryParameterSubSchema"
                    }, {
                        $ref: "#/definitions/pathParameterSubSchema"
                    }]
                },
                parameter: {
                    oneOf: [{
                        $ref: "#/definitions/bodyParameter"
                    }, {
                        $ref: "#/definitions/nonBodyParameter"
                    }]
                },
                schema: {
                    type: "object",
                    description: "A deterministic version of a JSON Schema object.",
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    },
                    properties: {
                        $ref: {
                            type: "string"
                        },
                        format: {
                            type: "string"
                        },
                        title: {
                            $ref: "http://json-schema.org/draft-04/schema#/properties/title"
                        },
                        description: {
                            $ref: "http://json-schema.org/draft-04/schema#/properties/description"
                        },
                        default: {
                            $ref: "http://json-schema.org/draft-04/schema#/properties/default"
                        },
                        multipleOf: {
                            $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
                        },
                        maximum: {
                            $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
                        },
                        exclusiveMaximum: {
                            $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
                        },
                        minimum: {
                            $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
                        },
                        exclusiveMinimum: {
                            $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
                        },
                        maxLength: {
                            $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
                        },
                        minLength: {
                            $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
                        },
                        pattern: {
                            $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
                        },
                        maxItems: {
                            $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
                        },
                        minItems: {
                            $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
                        },
                        uniqueItems: {
                            $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
                        },
                        maxProperties: {
                            $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
                        },
                        minProperties: {
                            $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
                        },
                        required: {
                            $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray"
                        },
                        enum: {
                            $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
                        },
                        additionalProperties: {
                            anyOf: [{
                                $ref: "#/definitions/schema"
                            }, {
                                type: "boolean"
                            }],
                            default: {}
                        },
                        type: {
                            $ref: "http://json-schema.org/draft-04/schema#/properties/type"
                        },
                        items: {
                            anyOf: [{
                                $ref: "#/definitions/schema"
                            }, {
                                type: "array",
                                minItems: 1,
                                items: {
                                    $ref: "#/definitions/schema"
                                }
                            }],
                            default: {}
                        },
                        allOf: {
                            type: "array",
                            minItems: 1,
                            items: {
                                $ref: "#/definitions/schema"
                            }
                        },
                        properties: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/definitions/schema"
                            },
                            default: {}
                        },
                        discriminator: {
                            type: "string"
                        },
                        readOnly: {
                            type: "boolean",
                            default: !1
                        },
                        xml: {
                            $ref: "#/definitions/xml"
                        },
                        externalDocs: {
                            $ref: "#/definitions/externalDocs"
                        },
                        example: {}
                    },
                    additionalProperties: !1
                },
                fileSchema: {
                    type: "object",
                    description: "A deterministic version of a JSON Schema object.",
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    },
                    required: ["type"],
                    properties: {
                        format: {
                            type: "string"
                        },
                        title: {
                            $ref: "http://json-schema.org/draft-04/schema#/properties/title"
                        },
                        description: {
                            $ref: "http://json-schema.org/draft-04/schema#/properties/description"
                        },
                        default: {
                            $ref: "http://json-schema.org/draft-04/schema#/properties/default"
                        },
                        required: {
                            $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray"
                        },
                        type: {
                            type: "string",
                            enum: ["file"]
                        },
                        readOnly: {
                            type: "boolean",
                            default: !1
                        },
                        externalDocs: {
                            $ref: "#/definitions/externalDocs"
                        },
                        example: {}
                    },
                    additionalProperties: !1
                },
                primitivesItems: {
                    type: "object",
                    additionalProperties: !1,
                    properties: {
                        type: {
                            type: "string",
                            enum: ["string", "number", "integer", "boolean", "array"]
                        },
                        format: {
                            type: "string"
                        },
                        items: {
                            $ref: "#/definitions/primitivesItems"
                        },
                        collectionFormat: {
                            $ref: "#/definitions/collectionFormat"
                        },
                        default: {
                            $ref: "#/definitions/default"
                        },
                        maximum: {
                            $ref: "#/definitions/maximum"
                        },
                        exclusiveMaximum: {
                            $ref: "#/definitions/exclusiveMaximum"
                        },
                        minimum: {
                            $ref: "#/definitions/minimum"
                        },
                        exclusiveMinimum: {
                            $ref: "#/definitions/exclusiveMinimum"
                        },
                        maxLength: {
                            $ref: "#/definitions/maxLength"
                        },
                        minLength: {
                            $ref: "#/definitions/minLength"
                        },
                        pattern: {
                            $ref: "#/definitions/pattern"
                        },
                        maxItems: {
                            $ref: "#/definitions/maxItems"
                        },
                        minItems: {
                            $ref: "#/definitions/minItems"
                        },
                        uniqueItems: {
                            $ref: "#/definitions/uniqueItems"
                        },
                        enum: {
                            $ref: "#/definitions/enum"
                        },
                        multipleOf: {
                            $ref: "#/definitions/multipleOf"
                        }
                    },
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    }
                },
                security: {
                    type: "array",
                    items: {
                        $ref: "#/definitions/securityRequirement"
                    },
                    uniqueItems: !0
                },
                securityRequirement: {
                    type: "object",
                    additionalProperties: {
                        type: "array",
                        items: {
                            type: "string"
                        },
                        uniqueItems: !0
                    }
                },
                xml: {
                    type: "object",
                    additionalProperties: !1,
                    properties: {
                        name: {
                            type: "string"
                        },
                        namespace: {
                            type: "string"
                        },
                        prefix: {
                            type: "string"
                        },
                        attribute: {
                            type: "boolean",
                            default: !1
                        },
                        wrapped: {
                            type: "boolean",
                            default: !1
                        }
                    },
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    }
                },
                tag: {
                    type: "object",
                    additionalProperties: !1,
                    required: ["name"],
                    properties: {
                        name: {
                            type: "string"
                        },
                        description: {
                            type: "string"
                        },
                        externalDocs: {
                            $ref: "#/definitions/externalDocs"
                        }
                    },
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    }
                },
                securityDefinitions: {
                    type: "object",
                    additionalProperties: {
                        oneOf: [{
                            $ref: "#/definitions/basicAuthenticationSecurity"
                        }, {
                            $ref: "#/definitions/apiKeySecurity"
                        }, {
                            $ref: "#/definitions/oauth2ImplicitSecurity"
                        }, {
                            $ref: "#/definitions/oauth2PasswordSecurity"
                        }, {
                            $ref: "#/definitions/oauth2ApplicationSecurity"
                        }, {
                            $ref: "#/definitions/oauth2AccessCodeSecurity"
                        }]
                    }
                },
                basicAuthenticationSecurity: {
                    type: "object",
                    additionalProperties: !1,
                    required: ["type"],
                    properties: {
                        type: {
                            type: "string",
                            enum: ["basic"]
                        },
                        description: {
                            type: "string"
                        }
                    },
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    }
                },
                apiKeySecurity: {
                    type: "object",
                    additionalProperties: !1,
                    required: ["type", "name", "in"],
                    properties: {
                        type: {
                            type: "string",
                            enum: ["apiKey"]
                        },
                        name: {
                            type: "string"
                        },
                        in: {
                            type: "string",
                            enum: ["header", "query"]
                        },
                        description: {
                            type: "string"
                        }
                    },
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    }
                },
                oauth2ImplicitSecurity: {
                    type: "object",
                    additionalProperties: !1,
                    required: ["type", "flow", "authorizationUrl"],
                    properties: {
                        type: {
                            type: "string",
                            enum: ["oauth2"]
                        },
                        flow: {
                            type: "string",
                            enum: ["implicit"]
                        },
                        scopes: {
                            $ref: "#/definitions/oauth2Scopes"
                        },
                        authorizationUrl: {
                            type: "string",
                            format: "uri"
                        },
                        description: {
                            type: "string"
                        }
                    },
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    }
                },
                oauth2PasswordSecurity: {
                    type: "object",
                    additionalProperties: !1,
                    required: ["type", "flow", "tokenUrl"],
                    properties: {
                        type: {
                            type: "string",
                            enum: ["oauth2"]
                        },
                        flow: {
                            type: "string",
                            enum: ["password"]
                        },
                        scopes: {
                            $ref: "#/definitions/oauth2Scopes"
                        },
                        tokenUrl: {
                            type: "string",
                            format: "uri"
                        },
                        description: {
                            type: "string"
                        }
                    },
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    }
                },
                oauth2ApplicationSecurity: {
                    type: "object",
                    additionalProperties: !1,
                    required: ["type", "flow", "tokenUrl"],
                    properties: {
                        type: {
                            type: "string",
                            enum: ["oauth2"]
                        },
                        flow: {
                            type: "string",
                            enum: ["application"]
                        },
                        scopes: {
                            $ref: "#/definitions/oauth2Scopes"
                        },
                        tokenUrl: {
                            type: "string",
                            format: "uri"
                        },
                        description: {
                            type: "string"
                        }
                    },
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    }
                },
                oauth2AccessCodeSecurity: {
                    type: "object",
                    additionalProperties: !1,
                    required: ["type", "flow", "authorizationUrl", "tokenUrl"],
                    properties: {
                        type: {
                            type: "string",
                            enum: ["oauth2"]
                        },
                        flow: {
                            type: "string",
                            enum: ["accessCode"]
                        },
                        scopes: {
                            $ref: "#/definitions/oauth2Scopes"
                        },
                        authorizationUrl: {
                            type: "string",
                            format: "uri"
                        },
                        tokenUrl: {
                            type: "string",
                            format: "uri"
                        },
                        description: {
                            type: "string"
                        }
                    },
                    patternProperties: {
                        "^x-": {
                            $ref: "#/definitions/vendorExtension"
                        }
                    }
                },
                oauth2Scopes: {
                    type: "object",
                    additionalProperties: {
                        type: "string"
                    }
                },
                mediaTypeList: {
                    type: "array",
                    items: {
                        $ref: "#/definitions/mimeType"
                    },
                    uniqueItems: !0
                },
                parametersList: {
                    type: "array",
                    description: "The parameters needed to send a valid API call.",
                    additionalItems: !1,
                    items: {
                        oneOf: [{
                            $ref: "#/definitions/parameter"
                        }, {
                            $ref: "#/definitions/jsonReference"
                        }]
                    },
                    uniqueItems: !0
                },
                schemesList: {
                    type: "array",
                    description: "The transfer protocol of the API.",
                    items: {
                        type: "string",
                        enum: ["http", "https", "ws", "wss"]
                    },
                    uniqueItems: !0
                },
                collectionFormat: {
                    type: "string",
                    enum: ["csv", "ssv", "tsv", "pipes"],
                    default: "csv"
                },
                collectionFormatWithMulti: {
                    type: "string",
                    enum: ["csv", "ssv", "tsv", "pipes", "multi"],
                    default: "csv"
                },
                title: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/title"
                },
                description: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/description"
                },
                default: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/default"
                },
                multipleOf: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
                },
                maximum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
                },
                exclusiveMaximum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
                },
                minimum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
                },
                exclusiveMinimum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
                },
                maxLength: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
                },
                minLength: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
                },
                pattern: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
                },
                maxItems: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
                },
                minItems: {
                    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
                },
                uniqueItems: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
                },
                enum: {
                    $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
                },
                jsonReference: {
                    type: "object",
                    required: ["$ref"],
                    additionalProperties: !1,
                    properties: {
                        $ref: {
                            type: "string"
                        }
                    }
                }
            }
        },
        "3.0": {
            id: "https://spec.openapis.org/oas/3.0/schema/2021-09-28",
            $schema: "http://json-schema.org/draft-04/schema#",
            description: "The description of OpenAPI v3.0.x documents, as defined by https://spec.openapis.org/oas/v3.0.3",
            type: "object",
            required: ["openapi", "info", "paths"],
            properties: {
                openapi: {
                    type: "string",
                    pattern: "^3\\.0\\.\\d(-.+)?$"
                },
                info: {
                    $ref: "#/definitions/Info"
                },
                externalDocs: {
                    $ref: "#/definitions/ExternalDocumentation"
                },
                servers: {
                    type: "array",
                    items: {
                        $ref: "#/definitions/Server"
                    }
                },
                security: {
                    type: "array",
                    items: {
                        $ref: "#/definitions/SecurityRequirement"
                    }
                },
                tags: {
                    type: "array",
                    items: {
                        $ref: "#/definitions/Tag"
                    },
                    uniqueItems: !0
                },
                paths: {
                    $ref: "#/definitions/Paths"
                },
                components: {
                    $ref: "#/definitions/Components"
                }
            },
            patternProperties: {
                "^x-": {}
            },
            additionalProperties: !1,
            definitions: {
                Reference: {
                    type: "object",
                    required: ["$ref"],
                    patternProperties: {
                        "^\\$ref$": {
                            type: "string",
                            format: "uri-reference"
                        }
                    }
                },
                Info: {
                    type: "object",
                    required: ["title", "version"],
                    properties: {
                        title: {
                            type: "string"
                        },
                        description: {
                            type: "string"
                        },
                        termsOfService: {
                            type: "string",
                            format: "uri-reference"
                        },
                        contact: {
                            $ref: "#/definitions/Contact"
                        },
                        license: {
                            $ref: "#/definitions/License"
                        },
                        version: {
                            type: "string"
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                Contact: {
                    type: "object",
                    properties: {
                        name: {
                            type: "string"
                        },
                        url: {
                            type: "string",
                            format: "uri-reference"
                        },
                        email: {
                            type: "string",
                            format: "email"
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                License: {
                    type: "object",
                    required: ["name"],
                    properties: {
                        name: {
                            type: "string"
                        },
                        url: {
                            type: "string",
                            format: "uri-reference"
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                Server: {
                    type: "object",
                    required: ["url"],
                    properties: {
                        url: {
                            type: "string"
                        },
                        description: {
                            type: "string"
                        },
                        variables: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/definitions/ServerVariable"
                            }
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                ServerVariable: {
                    type: "object",
                    required: ["default"],
                    properties: {
                        enum: {
                            type: "array",
                            items: {
                                type: "string"
                            }
                        },
                        default: {
                            type: "string"
                        },
                        description: {
                            type: "string"
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                Components: {
                    type: "object",
                    properties: {
                        schemas: {
                            type: "object",
                            patternProperties: {
                                "^[a-zA-Z0-9\\.\\-_]+$": {
                                    oneOf: [{
                                        $ref: "#/definitions/Schema"
                                    }, {
                                        $ref: "#/definitions/Reference"
                                    }]
                                }
                            }
                        },
                        responses: {
                            type: "object",
                            patternProperties: {
                                "^[a-zA-Z0-9\\.\\-_]+$": {
                                    oneOf: [{
                                        $ref: "#/definitions/Reference"
                                    }, {
                                        $ref: "#/definitions/Response"
                                    }]
                                }
                            }
                        },
                        parameters: {
                            type: "object",
                            patternProperties: {
                                "^[a-zA-Z0-9\\.\\-_]+$": {
                                    oneOf: [{
                                        $ref: "#/definitions/Reference"
                                    }, {
                                        $ref: "#/definitions/Parameter"
                                    }]
                                }
                            }
                        },
                        examples: {
                            type: "object",
                            patternProperties: {
                                "^[a-zA-Z0-9\\.\\-_]+$": {
                                    oneOf: [{
                                        $ref: "#/definitions/Reference"
                                    }, {
                                        $ref: "#/definitions/Example"
                                    }]
                                }
                            }
                        },
                        requestBodies: {
                            type: "object",
                            patternProperties: {
                                "^[a-zA-Z0-9\\.\\-_]+$": {
                                    oneOf: [{
                                        $ref: "#/definitions/Reference"
                                    }, {
                                        $ref: "#/definitions/RequestBody"
                                    }]
                                }
                            }
                        },
                        headers: {
                            type: "object",
                            patternProperties: {
                                "^[a-zA-Z0-9\\.\\-_]+$": {
                                    oneOf: [{
                                        $ref: "#/definitions/Reference"
                                    }, {
                                        $ref: "#/definitions/Header"
                                    }]
                                }
                            }
                        },
                        securitySchemes: {
                            type: "object",
                            patternProperties: {
                                "^[a-zA-Z0-9\\.\\-_]+$": {
                                    oneOf: [{
                                        $ref: "#/definitions/Reference"
                                    }, {
                                        $ref: "#/definitions/SecurityScheme"
                                    }]
                                }
                            }
                        },
                        links: {
                            type: "object",
                            patternProperties: {
                                "^[a-zA-Z0-9\\.\\-_]+$": {
                                    oneOf: [{
                                        $ref: "#/definitions/Reference"
                                    }, {
                                        $ref: "#/definitions/Link"
                                    }]
                                }
                            }
                        },
                        callbacks: {
                            type: "object",
                            patternProperties: {
                                "^[a-zA-Z0-9\\.\\-_]+$": {
                                    oneOf: [{
                                        $ref: "#/definitions/Reference"
                                    }, {
                                        $ref: "#/definitions/Callback"
                                    }]
                                }
                            }
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                Schema: {
                    type: "object",
                    properties: {
                        title: {
                            type: "string"
                        },
                        multipleOf: {
                            type: "number",
                            minimum: 0,
                            exclusiveMinimum: !0
                        },
                        maximum: {
                            type: "number"
                        },
                        exclusiveMaximum: {
                            type: "boolean",
                            default: !1
                        },
                        minimum: {
                            type: "number"
                        },
                        exclusiveMinimum: {
                            type: "boolean",
                            default: !1
                        },
                        maxLength: {
                            type: "integer",
                            minimum: 0
                        },
                        minLength: {
                            type: "integer",
                            minimum: 0,
                            default: 0
                        },
                        pattern: {
                            type: "string",
                            format: "regex"
                        },
                        maxItems: {
                            type: "integer",
                            minimum: 0
                        },
                        minItems: {
                            type: "integer",
                            minimum: 0,
                            default: 0
                        },
                        uniqueItems: {
                            type: "boolean",
                            default: !1
                        },
                        maxProperties: {
                            type: "integer",
                            minimum: 0
                        },
                        minProperties: {
                            type: "integer",
                            minimum: 0,
                            default: 0
                        },
                        required: {
                            type: "array",
                            items: {
                                type: "string"
                            },
                            minItems: 1,
                            uniqueItems: !0
                        },
                        enum: {
                            type: "array",
                            items: {},
                            minItems: 1,
                            uniqueItems: !1
                        },
                        type: {
                            type: "string",
                            enum: ["array", "boolean", "integer", "number", "object", "string"]
                        },
                        not: {
                            oneOf: [{
                                $ref: "#/definitions/Schema"
                            }, {
                                $ref: "#/definitions/Reference"
                            }]
                        },
                        allOf: {
                            type: "array",
                            items: {
                                oneOf: [{
                                    $ref: "#/definitions/Schema"
                                }, {
                                    $ref: "#/definitions/Reference"
                                }]
                            }
                        },
                        oneOf: {
                            type: "array",
                            items: {
                                oneOf: [{
                                    $ref: "#/definitions/Schema"
                                }, {
                                    $ref: "#/definitions/Reference"
                                }]
                            }
                        },
                        anyOf: {
                            type: "array",
                            items: {
                                oneOf: [{
                                    $ref: "#/definitions/Schema"
                                }, {
                                    $ref: "#/definitions/Reference"
                                }]
                            }
                        },
                        items: {
                            oneOf: [{
                                $ref: "#/definitions/Schema"
                            }, {
                                $ref: "#/definitions/Reference"
                            }]
                        },
                        properties: {
                            type: "object",
                            additionalProperties: {
                                oneOf: [{
                                    $ref: "#/definitions/Schema"
                                }, {
                                    $ref: "#/definitions/Reference"
                                }]
                            }
                        },
                        additionalProperties: {
                            oneOf: [{
                                $ref: "#/definitions/Schema"
                            }, {
                                $ref: "#/definitions/Reference"
                            }, {
                                type: "boolean"
                            }],
                            default: !0
                        },
                        description: {
                            type: "string"
                        },
                        format: {
                            type: "string"
                        },
                        default: {},
                        nullable: {
                            type: "boolean",
                            default: !1
                        },
                        discriminator: {
                            $ref: "#/definitions/Discriminator"
                        },
                        readOnly: {
                            type: "boolean",
                            default: !1
                        },
                        writeOnly: {
                            type: "boolean",
                            default: !1
                        },
                        example: {},
                        externalDocs: {
                            $ref: "#/definitions/ExternalDocumentation"
                        },
                        deprecated: {
                            type: "boolean",
                            default: !1
                        },
                        xml: {
                            $ref: "#/definitions/XML"
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                Discriminator: {
                    type: "object",
                    required: ["propertyName"],
                    properties: {
                        propertyName: {
                            type: "string"
                        },
                        mapping: {
                            type: "object",
                            additionalProperties: {
                                type: "string"
                            }
                        }
                    }
                },
                XML: {
                    type: "object",
                    properties: {
                        name: {
                            type: "string"
                        },
                        namespace: {
                            type: "string",
                            format: "uri"
                        },
                        prefix: {
                            type: "string"
                        },
                        attribute: {
                            type: "boolean",
                            default: !1
                        },
                        wrapped: {
                            type: "boolean",
                            default: !1
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                Response: {
                    type: "object",
                    required: ["description"],
                    properties: {
                        description: {
                            type: "string"
                        },
                        headers: {
                            type: "object",
                            additionalProperties: {
                                oneOf: [{
                                    $ref: "#/definitions/Header"
                                }, {
                                    $ref: "#/definitions/Reference"
                                }]
                            }
                        },
                        content: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/definitions/MediaType"
                            }
                        },
                        links: {
                            type: "object",
                            additionalProperties: {
                                oneOf: [{
                                    $ref: "#/definitions/Link"
                                }, {
                                    $ref: "#/definitions/Reference"
                                }]
                            }
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                MediaType: {
                    type: "object",
                    properties: {
                        schema: {
                            oneOf: [{
                                $ref: "#/definitions/Schema"
                            }, {
                                $ref: "#/definitions/Reference"
                            }]
                        },
                        example: {},
                        examples: {
                            type: "object",
                            additionalProperties: {
                                oneOf: [{
                                    $ref: "#/definitions/Example"
                                }, {
                                    $ref: "#/definitions/Reference"
                                }]
                            }
                        },
                        encoding: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/definitions/Encoding"
                            }
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1,
                    allOf: [{
                        $ref: "#/definitions/ExampleXORExamples"
                    }]
                },
                Example: {
                    type: "object",
                    properties: {
                        summary: {
                            type: "string"
                        },
                        description: {
                            type: "string"
                        },
                        value: {},
                        externalValue: {
                            type: "string",
                            format: "uri-reference"
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                Header: {
                    type: "object",
                    properties: {
                        description: {
                            type: "string"
                        },
                        required: {
                            type: "boolean",
                            default: !1
                        },
                        deprecated: {
                            type: "boolean",
                            default: !1
                        },
                        allowEmptyValue: {
                            type: "boolean",
                            default: !1
                        },
                        style: {
                            type: "string",
                            enum: ["simple"],
                            default: "simple"
                        },
                        explode: {
                            type: "boolean"
                        },
                        allowReserved: {
                            type: "boolean",
                            default: !1
                        },
                        schema: {
                            oneOf: [{
                                $ref: "#/definitions/Schema"
                            }, {
                                $ref: "#/definitions/Reference"
                            }]
                        },
                        content: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/definitions/MediaType"
                            },
                            minProperties: 1,
                            maxProperties: 1
                        },
                        example: {},
                        examples: {
                            type: "object",
                            additionalProperties: {
                                oneOf: [{
                                    $ref: "#/definitions/Example"
                                }, {
                                    $ref: "#/definitions/Reference"
                                }]
                            }
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1,
                    allOf: [{
                        $ref: "#/definitions/ExampleXORExamples"
                    }, {
                        $ref: "#/definitions/SchemaXORContent"
                    }]
                },
                Paths: {
                    type: "object",
                    patternProperties: {
                        "^\\/": {
                            $ref: "#/definitions/PathItem"
                        },
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                PathItem: {
                    type: "object",
                    properties: {
                        $ref: {
                            type: "string"
                        },
                        summary: {
                            type: "string"
                        },
                        description: {
                            type: "string"
                        },
                        servers: {
                            type: "array",
                            items: {
                                $ref: "#/definitions/Server"
                            }
                        },
                        parameters: {
                            type: "array",
                            items: {
                                oneOf: [{
                                    $ref: "#/definitions/Parameter"
                                }, {
                                    $ref: "#/definitions/Reference"
                                }]
                            },
                            uniqueItems: !0
                        }
                    },
                    patternProperties: {
                        "^(get|put|post|delete|options|head|patch|trace)$": {
                            $ref: "#/definitions/Operation"
                        },
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                Operation: {
                    type: "object",
                    required: ["responses"],
                    properties: {
                        tags: {
                            type: "array",
                            items: {
                                type: "string"
                            }
                        },
                        summary: {
                            type: "string"
                        },
                        description: {
                            type: "string"
                        },
                        externalDocs: {
                            $ref: "#/definitions/ExternalDocumentation"
                        },
                        operationId: {
                            type: "string"
                        },
                        parameters: {
                            type: "array",
                            items: {
                                oneOf: [{
                                    $ref: "#/definitions/Parameter"
                                }, {
                                    $ref: "#/definitions/Reference"
                                }]
                            },
                            uniqueItems: !0
                        },
                        requestBody: {
                            oneOf: [{
                                $ref: "#/definitions/RequestBody"
                            }, {
                                $ref: "#/definitions/Reference"
                            }]
                        },
                        responses: {
                            $ref: "#/definitions/Responses"
                        },
                        callbacks: {
                            type: "object",
                            additionalProperties: {
                                oneOf: [{
                                    $ref: "#/definitions/Callback"
                                }, {
                                    $ref: "#/definitions/Reference"
                                }]
                            }
                        },
                        deprecated: {
                            type: "boolean",
                            default: !1
                        },
                        security: {
                            type: "array",
                            items: {
                                $ref: "#/definitions/SecurityRequirement"
                            }
                        },
                        servers: {
                            type: "array",
                            items: {
                                $ref: "#/definitions/Server"
                            }
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                Responses: {
                    type: "object",
                    properties: {
                        default: {
                            oneOf: [{
                                $ref: "#/definitions/Response"
                            }, {
                                $ref: "#/definitions/Reference"
                            }]
                        }
                    },
                    patternProperties: {
                        "^[1-5](?:\\d{2}|XX)$": {
                            oneOf: [{
                                $ref: "#/definitions/Response"
                            }, {
                                $ref: "#/definitions/Reference"
                            }]
                        },
                        "^x-": {}
                    },
                    minProperties: 1,
                    additionalProperties: !1
                },
                SecurityRequirement: {
                    type: "object",
                    additionalProperties: {
                        type: "array",
                        items: {
                            type: "string"
                        }
                    }
                },
                Tag: {
                    type: "object",
                    required: ["name"],
                    properties: {
                        name: {
                            type: "string"
                        },
                        description: {
                            type: "string"
                        },
                        externalDocs: {
                            $ref: "#/definitions/ExternalDocumentation"
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                ExternalDocumentation: {
                    type: "object",
                    required: ["url"],
                    properties: {
                        description: {
                            type: "string"
                        },
                        url: {
                            type: "string",
                            format: "uri-reference"
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                ExampleXORExamples: {
                    description: "Example and examples are mutually exclusive",
                    not: {
                        required: ["example", "examples"]
                    }
                },
                SchemaXORContent: {
                    description: "Schema and content are mutually exclusive, at least one is required",
                    not: {
                        required: ["schema", "content"]
                    },
                    oneOf: [{
                        required: ["schema"]
                    }, {
                        required: ["content"],
                        description: "Some properties are not allowed if content is present",
                        allOf: [{
                            not: {
                                required: ["style"]
                            }
                        }, {
                            not: {
                                required: ["explode"]
                            }
                        }, {
                            not: {
                                required: ["allowReserved"]
                            }
                        }, {
                            not: {
                                required: ["example"]
                            }
                        }, {
                            not: {
                                required: ["examples"]
                            }
                        }]
                    }]
                },
                Parameter: {
                    type: "object",
                    properties: {
                        name: {
                            type: "string"
                        },
                        in: {
                            type: "string"
                        },
                        description: {
                            type: "string"
                        },
                        required: {
                            type: "boolean",
                            default: !1
                        },
                        deprecated: {
                            type: "boolean",
                            default: !1
                        },
                        allowEmptyValue: {
                            type: "boolean",
                            default: !1
                        },
                        style: {
                            type: "string"
                        },
                        explode: {
                            type: "boolean"
                        },
                        allowReserved: {
                            type: "boolean",
                            default: !1
                        },
                        schema: {
                            oneOf: [{
                                $ref: "#/definitions/Schema"
                            }, {
                                $ref: "#/definitions/Reference"
                            }]
                        },
                        content: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/definitions/MediaType"
                            },
                            minProperties: 1,
                            maxProperties: 1
                        },
                        example: {},
                        examples: {
                            type: "object",
                            additionalProperties: {
                                oneOf: [{
                                    $ref: "#/definitions/Example"
                                }, {
                                    $ref: "#/definitions/Reference"
                                }]
                            }
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1,
                    required: ["name", "in"],
                    allOf: [{
                        $ref: "#/definitions/ExampleXORExamples"
                    }, {
                        $ref: "#/definitions/SchemaXORContent"
                    }, {
                        $ref: "#/definitions/ParameterLocation"
                    }]
                },
                ParameterLocation: {
                    description: "Parameter location",
                    oneOf: [{
                        description: "Parameter in path",
                        required: ["required"],
                        properties: {
                            in: {
                                enum: ["path"]
                            },
                            style: {
                                enum: ["matrix", "label", "simple"],
                                default: "simple"
                            },
                            required: {
                                enum: [!0]
                            }
                        }
                    }, {
                        description: "Parameter in query",
                        properties: {
                            in: {
                                enum: ["query"]
                            },
                            style: {
                                enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"],
                                default: "form"
                            }
                        }
                    }, {
                        description: "Parameter in header",
                        properties: {
                            in: {
                                enum: ["header"]
                            },
                            style: {
                                enum: ["simple"],
                                default: "simple"
                            }
                        }
                    }, {
                        description: "Parameter in cookie",
                        properties: {
                            in: {
                                enum: ["cookie"]
                            },
                            style: {
                                enum: ["form"],
                                default: "form"
                            }
                        }
                    }]
                },
                RequestBody: {
                    type: "object",
                    required: ["content"],
                    properties: {
                        description: {
                            type: "string"
                        },
                        content: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/definitions/MediaType"
                            }
                        },
                        required: {
                            type: "boolean",
                            default: !1
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                SecurityScheme: {
                    oneOf: [{
                        $ref: "#/definitions/APIKeySecurityScheme"
                    }, {
                        $ref: "#/definitions/HTTPSecurityScheme"
                    }, {
                        $ref: "#/definitions/OAuth2SecurityScheme"
                    }, {
                        $ref: "#/definitions/OpenIdConnectSecurityScheme"
                    }]
                },
                APIKeySecurityScheme: {
                    type: "object",
                    required: ["type", "name", "in"],
                    properties: {
                        type: {
                            type: "string",
                            enum: ["apiKey"]
                        },
                        name: {
                            type: "string"
                        },
                        in: {
                            type: "string",
                            enum: ["header", "query", "cookie"]
                        },
                        description: {
                            type: "string"
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                HTTPSecurityScheme: {
                    type: "object",
                    required: ["scheme", "type"],
                    properties: {
                        scheme: {
                            type: "string"
                        },
                        bearerFormat: {
                            type: "string"
                        },
                        description: {
                            type: "string"
                        },
                        type: {
                            type: "string",
                            enum: ["http"]
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1,
                    oneOf: [{
                        description: "Bearer",
                        properties: {
                            scheme: {
                                type: "string",
                                pattern: "^[Bb][Ee][Aa][Rr][Ee][Rr]$"
                            }
                        }
                    }, {
                        description: "Non Bearer",
                        not: {
                            required: ["bearerFormat"]
                        },
                        properties: {
                            scheme: {
                                not: {
                                    type: "string",
                                    pattern: "^[Bb][Ee][Aa][Rr][Ee][Rr]$"
                                }
                            }
                        }
                    }]
                },
                OAuth2SecurityScheme: {
                    type: "object",
                    required: ["type", "flows"],
                    properties: {
                        type: {
                            type: "string",
                            enum: ["oauth2"]
                        },
                        flows: {
                            $ref: "#/definitions/OAuthFlows"
                        },
                        description: {
                            type: "string"
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                OpenIdConnectSecurityScheme: {
                    type: "object",
                    required: ["type", "openIdConnectUrl"],
                    properties: {
                        type: {
                            type: "string",
                            enum: ["openIdConnect"]
                        },
                        openIdConnectUrl: {
                            type: "string",
                            format: "uri-reference"
                        },
                        description: {
                            type: "string"
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                OAuthFlows: {
                    type: "object",
                    properties: {
                        implicit: {
                            $ref: "#/definitions/ImplicitOAuthFlow"
                        },
                        password: {
                            $ref: "#/definitions/PasswordOAuthFlow"
                        },
                        clientCredentials: {
                            $ref: "#/definitions/ClientCredentialsFlow"
                        },
                        authorizationCode: {
                            $ref: "#/definitions/AuthorizationCodeOAuthFlow"
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                ImplicitOAuthFlow: {
                    type: "object",
                    required: ["authorizationUrl", "scopes"],
                    properties: {
                        authorizationUrl: {
                            type: "string",
                            format: "uri-reference"
                        },
                        refreshUrl: {
                            type: "string",
                            format: "uri-reference"
                        },
                        scopes: {
                            type: "object",
                            additionalProperties: {
                                type: "string"
                            }
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                PasswordOAuthFlow: {
                    type: "object",
                    required: ["tokenUrl", "scopes"],
                    properties: {
                        tokenUrl: {
                            type: "string",
                            format: "uri-reference"
                        },
                        refreshUrl: {
                            type: "string",
                            format: "uri-reference"
                        },
                        scopes: {
                            type: "object",
                            additionalProperties: {
                                type: "string"
                            }
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                ClientCredentialsFlow: {
                    type: "object",
                    required: ["tokenUrl", "scopes"],
                    properties: {
                        tokenUrl: {
                            type: "string",
                            format: "uri-reference"
                        },
                        refreshUrl: {
                            type: "string",
                            format: "uri-reference"
                        },
                        scopes: {
                            type: "object",
                            additionalProperties: {
                                type: "string"
                            }
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                AuthorizationCodeOAuthFlow: {
                    type: "object",
                    required: ["authorizationUrl", "tokenUrl", "scopes"],
                    properties: {
                        authorizationUrl: {
                            type: "string",
                            format: "uri-reference"
                        },
                        tokenUrl: {
                            type: "string",
                            format: "uri-reference"
                        },
                        refreshUrl: {
                            type: "string",
                            format: "uri-reference"
                        },
                        scopes: {
                            type: "object",
                            additionalProperties: {
                                type: "string"
                            }
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1
                },
                Link: {
                    type: "object",
                    properties: {
                        operationId: {
                            type: "string"
                        },
                        operationRef: {
                            type: "string",
                            format: "uri-reference"
                        },
                        parameters: {
                            type: "object",
                            additionalProperties: {}
                        },
                        requestBody: {},
                        description: {
                            type: "string"
                        },
                        server: {
                            $ref: "#/definitions/Server"
                        }
                    },
                    patternProperties: {
                        "^x-": {}
                    },
                    additionalProperties: !1,
                    not: {
                        description: "Operation Id and Operation Ref are mutually exclusive",
                        required: ["operationId", "operationRef"]
                    }
                },
                Callback: {
                    type: "object",
                    additionalProperties: {
                        $ref: "#/definitions/PathItem"
                    },
                    patternProperties: {
                        "^x-": {}
                    }
                },
                Encoding: {
                    type: "object",
                    properties: {
                        contentType: {
                            type: "string"
                        },
                        headers: {
                            type: "object",
                            additionalProperties: {
                                oneOf: [{
                                    $ref: "#/definitions/Header"
                                }, {
                                    $ref: "#/definitions/Reference"
                                }]
                            }
                        },
                        style: {
                            type: "string",
                            enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"]
                        },
                        explode: {
                            type: "boolean"
                        },
                        allowReserved: {
                            type: "boolean",
                            default: !1
                        }
                    },
                    additionalProperties: !1
                }
            }
        },
        3.1: {
            $id: "https://spec.openapis.org/oas/3.1/schema/2022-10-07",
            $schema: "https://json-schema.org/draft/2020-12/schema",
            description: "The description of OpenAPI v3.1.x documents without schema validation, as defined by https://spec.openapis.org/oas/v3.1.0",
            type: "object",
            properties: {
                openapi: {
                    type: "string",
                    pattern: "^3\\.1\\.\\d+(-.+)?$"
                },
                info: {
                    $ref: "#/$defs/info"
                },
                jsonSchemaDialect: {
                    type: "string",
                    format: "uri",
                    default: "https://spec.openapis.org/oas/3.1/dialect/base"
                },
                servers: {
                    type: "array",
                    items: {
                        $ref: "#/$defs/server"
                    },
                    default: [{
                        url: "/"
                    }]
                },
                paths: {
                    $ref: "#/$defs/paths"
                },
                webhooks: {
                    type: "object",
                    additionalProperties: {
                        $ref: "#/$defs/path-item-or-reference"
                    }
                },
                components: {
                    $ref: "#/$defs/components"
                },
                security: {
                    type: "array",
                    items: {
                        $ref: "#/$defs/security-requirement"
                    }
                },
                tags: {
                    type: "array",
                    items: {
                        $ref: "#/$defs/tag"
                    }
                },
                externalDocs: {
                    $ref: "#/$defs/external-documentation"
                }
            },
            required: ["openapi", "info"],
            anyOf: [{
                required: ["paths"]
            }, {
                required: ["components"]
            }, {
                required: ["webhooks"]
            }],
            $ref: "#/$defs/specification-extensions",
            unevaluatedProperties: !1,
            $defs: {
                info: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#info-object",
                    type: "object",
                    properties: {
                        title: {
                            type: "string"
                        },
                        summary: {
                            type: "string"
                        },
                        description: {
                            type: "string"
                        },
                        termsOfService: {
                            type: "string",
                            format: "uri"
                        },
                        contact: {
                            $ref: "#/$defs/contact"
                        },
                        license: {
                            $ref: "#/$defs/license"
                        },
                        version: {
                            type: "string"
                        }
                    },
                    required: ["title", "version"],
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1
                },
                contact: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#contact-object",
                    type: "object",
                    properties: {
                        name: {
                            type: "string"
                        },
                        url: {
                            type: "string",
                            format: "uri"
                        },
                        email: {
                            type: "string",
                            format: "email"
                        }
                    },
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1
                },
                license: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#license-object",
                    type: "object",
                    properties: {
                        name: {
                            type: "string"
                        },
                        identifier: {
                            type: "string"
                        },
                        url: {
                            type: "string",
                            format: "uri"
                        }
                    },
                    required: ["name"],
                    dependentSchemas: {
                        identifier: {
                            not: {
                                required: ["url"]
                            }
                        }
                    },
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1
                },
                server: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#server-object",
                    type: "object",
                    properties: {
                        url: {
                            type: "string",
                            format: "uri-reference"
                        },
                        description: {
                            type: "string"
                        },
                        variables: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/$defs/server-variable"
                            }
                        }
                    },
                    required: ["url"],
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1
                },
                "server-variable": {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#server-variable-object",
                    type: "object",
                    properties: {
                        enum: {
                            type: "array",
                            items: {
                                type: "string"
                            },
                            minItems: 1
                        },
                        default: {
                            type: "string"
                        },
                        description: {
                            type: "string"
                        }
                    },
                    required: ["default"],
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1
                },
                components: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#components-object",
                    type: "object",
                    properties: {
                        schemas: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/$defs/schema"
                            }
                        },
                        responses: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/$defs/response-or-reference"
                            }
                        },
                        parameters: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/$defs/parameter-or-reference"
                            }
                        },
                        examples: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/$defs/example-or-reference"
                            }
                        },
                        requestBodies: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/$defs/request-body-or-reference"
                            }
                        },
                        headers: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/$defs/header-or-reference"
                            }
                        },
                        securitySchemes: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/$defs/security-scheme-or-reference"
                            }
                        },
                        links: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/$defs/link-or-reference"
                            }
                        },
                        callbacks: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/$defs/callbacks-or-reference"
                            }
                        },
                        pathItems: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/$defs/path-item-or-reference"
                            }
                        }
                    },
                    patternProperties: {
                        "^(schemas|responses|parameters|examples|requestBodies|headers|securitySchemes|links|callbacks|pathItems)$": {
                            $comment: "Enumerating all of the property names in the regex above is necessary for unevaluatedProperties to work as expected",
                            propertyNames: {
                                pattern: "^[a-zA-Z0-9._-]+$"
                            }
                        }
                    },
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1
                },
                paths: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#paths-object",
                    type: "object",
                    patternProperties: {
                        "^/": {
                            $ref: "#/$defs/path-item"
                        }
                    },
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1
                },
                "path-item": {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#path-item-object",
                    type: "object",
                    properties: {
                        summary: {
                            type: "string"
                        },
                        description: {
                            type: "string"
                        },
                        servers: {
                            type: "array",
                            items: {
                                $ref: "#/$defs/server"
                            }
                        },
                        parameters: {
                            type: "array",
                            items: {
                                $ref: "#/$defs/parameter-or-reference"
                            }
                        },
                        get: {
                            $ref: "#/$defs/operation"
                        },
                        put: {
                            $ref: "#/$defs/operation"
                        },
                        post: {
                            $ref: "#/$defs/operation"
                        },
                        delete: {
                            $ref: "#/$defs/operation"
                        },
                        options: {
                            $ref: "#/$defs/operation"
                        },
                        head: {
                            $ref: "#/$defs/operation"
                        },
                        patch: {
                            $ref: "#/$defs/operation"
                        },
                        trace: {
                            $ref: "#/$defs/operation"
                        }
                    },
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1
                },
                "path-item-or-reference": {
                    if: {
                        type: "object",
                        required: ["$ref"]
                    },
                    then: {
                        $ref: "#/$defs/reference"
                    },
                    else: {
                        $ref: "#/$defs/path-item"
                    }
                },
                operation: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#operation-object",
                    type: "object",
                    properties: {
                        tags: {
                            type: "array",
                            items: {
                                type: "string"
                            }
                        },
                        summary: {
                            type: "string"
                        },
                        description: {
                            type: "string"
                        },
                        externalDocs: {
                            $ref: "#/$defs/external-documentation"
                        },
                        operationId: {
                            type: "string"
                        },
                        parameters: {
                            type: "array",
                            items: {
                                $ref: "#/$defs/parameter-or-reference"
                            }
                        },
                        requestBody: {
                            $ref: "#/$defs/request-body-or-reference"
                        },
                        responses: {
                            $ref: "#/$defs/responses"
                        },
                        callbacks: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/$defs/callbacks-or-reference"
                            }
                        },
                        deprecated: {
                            default: !1,
                            type: "boolean"
                        },
                        security: {
                            type: "array",
                            items: {
                                $ref: "#/$defs/security-requirement"
                            }
                        },
                        servers: {
                            type: "array",
                            items: {
                                $ref: "#/$defs/server"
                            }
                        }
                    },
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1
                },
                "external-documentation": {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#external-documentation-object",
                    type: "object",
                    properties: {
                        description: {
                            type: "string"
                        },
                        url: {
                            type: "string",
                            format: "uri"
                        }
                    },
                    required: ["url"],
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1
                },
                parameter: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#parameter-object",
                    type: "object",
                    properties: {
                        name: {
                            type: "string"
                        },
                        in: {
                            enum: ["query", "header", "path", "cookie"]
                        },
                        description: {
                            type: "string"
                        },
                        required: {
                            default: !1,
                            type: "boolean"
                        },
                        deprecated: {
                            default: !1,
                            type: "boolean"
                        },
                        schema: {
                            $ref: "#/$defs/schema"
                        },
                        content: {
                            $ref: "#/$defs/content",
                            minProperties: 1,
                            maxProperties: 1
                        }
                    },
                    required: ["name", "in"],
                    oneOf: [{
                        required: ["schema"]
                    }, {
                        required: ["content"]
                    }],
                    if: {
                        properties: {
                            in: {
                                const: "query"
                            }
                        },
                        required: ["in"]
                    },
                    then: {
                        properties: {
                            allowEmptyValue: {
                                default: !1,
                                type: "boolean"
                            }
                        }
                    },
                    dependentSchemas: {
                        schema: {
                            properties: {
                                style: {
                                    type: "string"
                                },
                                explode: {
                                    type: "boolean"
                                }
                            },
                            allOf: [{
                                $ref: "#/$defs/examples"
                            }, {
                                $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-path"
                            }, {
                                $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-header"
                            }, {
                                $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-query"
                            }, {
                                $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-cookie"
                            }, {
                                $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-form"
                            }],
                            $defs: {
                                "styles-for-path": {
                                    if: {
                                        properties: {
                                            in: {
                                                const: "path"
                                            }
                                        },
                                        required: ["in"]
                                    },
                                    then: {
                                        properties: {
                                            name: {
                                                pattern: "[^/#?]+$"
                                            },
                                            style: {
                                                default: "simple",
                                                enum: ["matrix", "label", "simple"]
                                            },
                                            required: {
                                                const: !0
                                            }
                                        },
                                        required: ["required"]
                                    }
                                },
                                "styles-for-header": {
                                    if: {
                                        properties: {
                                            in: {
                                                const: "header"
                                            }
                                        },
                                        required: ["in"]
                                    },
                                    then: {
                                        properties: {
                                            style: {
                                                default: "simple",
                                                const: "simple"
                                            }
                                        }
                                    }
                                },
                                "styles-for-query": {
                                    if: {
                                        properties: {
                                            in: {
                                                const: "query"
                                            }
                                        },
                                        required: ["in"]
                                    },
                                    then: {
                                        properties: {
                                            style: {
                                                default: "form",
                                                enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"]
                                            },
                                            allowReserved: {
                                                default: !1,
                                                type: "boolean"
                                            }
                                        }
                                    }
                                },
                                "styles-for-cookie": {
                                    if: {
                                        properties: {
                                            in: {
                                                const: "cookie"
                                            }
                                        },
                                        required: ["in"]
                                    },
                                    then: {
                                        properties: {
                                            style: {
                                                default: "form",
                                                const: "form"
                                            }
                                        }
                                    }
                                },
                                "styles-for-form": {
                                    if: {
                                        properties: {
                                            style: {
                                                const: "form"
                                            }
                                        },
                                        required: ["style"]
                                    },
                                    then: {
                                        properties: {
                                            explode: {
                                                default: !0
                                            }
                                        }
                                    },
                                    else: {
                                        properties: {
                                            explode: {
                                                default: !1
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1
                },
                "parameter-or-reference": {
                    if: {
                        type: "object",
                        required: ["$ref"]
                    },
                    then: {
                        $ref: "#/$defs/reference"
                    },
                    else: {
                        $ref: "#/$defs/parameter"
                    }
                },
                "request-body": {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#request-body-object",
                    type: "object",
                    properties: {
                        description: {
                            type: "string"
                        },
                        content: {
                            $ref: "#/$defs/content"
                        },
                        required: {
                            default: !1,
                            type: "boolean"
                        }
                    },
                    required: ["content"],
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1
                },
                "request-body-or-reference": {
                    if: {
                        type: "object",
                        required: ["$ref"]
                    },
                    then: {
                        $ref: "#/$defs/reference"
                    },
                    else: {
                        $ref: "#/$defs/request-body"
                    }
                },
                content: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#fixed-fields-10",
                    type: "object",
                    additionalProperties: {
                        $ref: "#/$defs/media-type"
                    },
                    propertyNames: {
                        format: "media-range"
                    }
                },
                "media-type": {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#media-type-object",
                    type: "object",
                    properties: {
                        schema: {
                            $ref: "#/$defs/schema"
                        },
                        encoding: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/$defs/encoding"
                            }
                        }
                    },
                    allOf: [{
                        $ref: "#/$defs/specification-extensions"
                    }, {
                        $ref: "#/$defs/examples"
                    }],
                    unevaluatedProperties: !1
                },
                encoding: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#encoding-object",
                    type: "object",
                    properties: {
                        contentType: {
                            type: "string",
                            format: "media-range"
                        },
                        headers: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/$defs/header-or-reference"
                            }
                        },
                        style: {
                            default: "form",
                            enum: ["form", "spaceDelimited", "pipeDelimited", "deepObject"]
                        },
                        explode: {
                            type: "boolean"
                        },
                        allowReserved: {
                            default: !1,
                            type: "boolean"
                        }
                    },
                    allOf: [{
                        $ref: "#/$defs/specification-extensions"
                    }, {
                        $ref: "#/$defs/encoding/$defs/explode-default"
                    }],
                    unevaluatedProperties: !1,
                    $defs: {
                        "explode-default": {
                            if: {
                                properties: {
                                    style: {
                                        const: "form"
                                    }
                                },
                                required: ["style"]
                            },
                            then: {
                                properties: {
                                    explode: {
                                        default: !0
                                    }
                                }
                            },
                            else: {
                                properties: {
                                    explode: {
                                        default: !1
                                    }
                                }
                            }
                        }
                    }
                },
                responses: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#responses-object",
                    type: "object",
                    properties: {
                        default: {
                            $ref: "#/$defs/response-or-reference"
                        }
                    },
                    patternProperties: {
                        "^[1-5](?:[0-9]{2}|XX)$": {
                            $ref: "#/$defs/response-or-reference"
                        }
                    },
                    minProperties: 1,
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1
                },
                response: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#response-object",
                    type: "object",
                    properties: {
                        description: {
                            type: "string"
                        },
                        headers: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/$defs/header-or-reference"
                            }
                        },
                        content: {
                            $ref: "#/$defs/content"
                        },
                        links: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/$defs/link-or-reference"
                            }
                        }
                    },
                    required: ["description"],
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1
                },
                "response-or-reference": {
                    if: {
                        type: "object",
                        required: ["$ref"]
                    },
                    then: {
                        $ref: "#/$defs/reference"
                    },
                    else: {
                        $ref: "#/$defs/response"
                    }
                },
                callbacks: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#callback-object",
                    type: "object",
                    $ref: "#/$defs/specification-extensions",
                    additionalProperties: {
                        $ref: "#/$defs/path-item-or-reference"
                    }
                },
                "callbacks-or-reference": {
                    if: {
                        type: "object",
                        required: ["$ref"]
                    },
                    then: {
                        $ref: "#/$defs/reference"
                    },
                    else: {
                        $ref: "#/$defs/callbacks"
                    }
                },
                example: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#example-object",
                    type: "object",
                    properties: {
                        summary: {
                            type: "string"
                        },
                        description: {
                            type: "string"
                        },
                        value: !0,
                        externalValue: {
                            type: "string",
                            format: "uri"
                        }
                    },
                    not: {
                        required: ["value", "externalValue"]
                    },
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1
                },
                "example-or-reference": {
                    if: {
                        type: "object",
                        required: ["$ref"]
                    },
                    then: {
                        $ref: "#/$defs/reference"
                    },
                    else: {
                        $ref: "#/$defs/example"
                    }
                },
                link: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#link-object",
                    type: "object",
                    properties: {
                        operationRef: {
                            type: "string",
                            format: "uri-reference"
                        },
                        operationId: {
                            type: "string"
                        },
                        parameters: {
                            $ref: "#/$defs/map-of-strings"
                        },
                        requestBody: !0,
                        description: {
                            type: "string"
                        },
                        body: {
                            $ref: "#/$defs/server"
                        }
                    },
                    oneOf: [{
                        required: ["operationRef"]
                    }, {
                        required: ["operationId"]
                    }],
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1
                },
                "link-or-reference": {
                    if: {
                        type: "object",
                        required: ["$ref"]
                    },
                    then: {
                        $ref: "#/$defs/reference"
                    },
                    else: {
                        $ref: "#/$defs/link"
                    }
                },
                header: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#header-object",
                    type: "object",
                    properties: {
                        description: {
                            type: "string"
                        },
                        required: {
                            default: !1,
                            type: "boolean"
                        },
                        deprecated: {
                            default: !1,
                            type: "boolean"
                        },
                        schema: {
                            $ref: "#/$defs/schema"
                        },
                        content: {
                            $ref: "#/$defs/content",
                            minProperties: 1,
                            maxProperties: 1
                        }
                    },
                    oneOf: [{
                        required: ["schema"]
                    }, {
                        required: ["content"]
                    }],
                    dependentSchemas: {
                        schema: {
                            properties: {
                                style: {
                                    default: "simple",
                                    const: "simple"
                                },
                                explode: {
                                    default: !1,
                                    type: "boolean"
                                }
                            },
                            $ref: "#/$defs/examples"
                        }
                    },
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1
                },
                "header-or-reference": {
                    if: {
                        type: "object",
                        required: ["$ref"]
                    },
                    then: {
                        $ref: "#/$defs/reference"
                    },
                    else: {
                        $ref: "#/$defs/header"
                    }
                },
                tag: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#tag-object",
                    type: "object",
                    properties: {
                        name: {
                            type: "string"
                        },
                        description: {
                            type: "string"
                        },
                        externalDocs: {
                            $ref: "#/$defs/external-documentation"
                        }
                    },
                    required: ["name"],
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1
                },
                reference: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#reference-object",
                    type: "object",
                    properties: {
                        $ref: {
                            type: "string",
                            format: "uri-reference"
                        },
                        summary: {
                            type: "string"
                        },
                        description: {
                            type: "string"
                        }
                    },
                    unevaluatedProperties: !1
                },
                schema: {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#schema-object",
                    $dynamicAnchor: "meta",
                    type: ["object", "boolean"]
                },
                "security-scheme": {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#security-scheme-object",
                    type: "object",
                    properties: {
                        type: {
                            enum: ["apiKey", "http", "mutualTLS", "oauth2", "openIdConnect"]
                        },
                        description: {
                            type: "string"
                        }
                    },
                    required: ["type"],
                    allOf: [{
                        $ref: "#/$defs/specification-extensions"
                    }, {
                        $ref: "#/$defs/security-scheme/$defs/type-apikey"
                    }, {
                        $ref: "#/$defs/security-scheme/$defs/type-http"
                    }, {
                        $ref: "#/$defs/security-scheme/$defs/type-http-bearer"
                    }, {
                        $ref: "#/$defs/security-scheme/$defs/type-oauth2"
                    }, {
                        $ref: "#/$defs/security-scheme/$defs/type-oidc"
                    }],
                    unevaluatedProperties: !1,
                    $defs: {
                        "type-apikey": {
                            if: {
                                properties: {
                                    type: {
                                        const: "apiKey"
                                    }
                                },
                                required: ["type"]
                            },
                            then: {
                                properties: {
                                    name: {
                                        type: "string"
                                    },
                                    in: {
                                        enum: ["query", "header", "cookie"]
                                    }
                                },
                                required: ["name", "in"]
                            }
                        },
                        "type-http": {
                            if: {
                                properties: {
                                    type: {
                                        const: "http"
                                    }
                                },
                                required: ["type"]
                            },
                            then: {
                                properties: {
                                    scheme: {
                                        type: "string"
                                    }
                                },
                                required: ["scheme"]
                            }
                        },
                        "type-http-bearer": {
                            if: {
                                properties: {
                                    type: {
                                        const: "http"
                                    },
                                    scheme: {
                                        type: "string",
                                        pattern: "^[Bb][Ee][Aa][Rr][Ee][Rr]$"
                                    }
                                },
                                required: ["type", "scheme"]
                            },
                            then: {
                                properties: {
                                    bearerFormat: {
                                        type: "string"
                                    }
                                }
                            }
                        },
                        "type-oauth2": {
                            if: {
                                properties: {
                                    type: {
                                        const: "oauth2"
                                    }
                                },
                                required: ["type"]
                            },
                            then: {
                                properties: {
                                    flows: {
                                        $ref: "#/$defs/oauth-flows"
                                    }
                                },
                                required: ["flows"]
                            }
                        },
                        "type-oidc": {
                            if: {
                                properties: {
                                    type: {
                                        const: "openIdConnect"
                                    }
                                },
                                required: ["type"]
                            },
                            then: {
                                properties: {
                                    openIdConnectUrl: {
                                        type: "string",
                                        format: "uri"
                                    }
                                },
                                required: ["openIdConnectUrl"]
                            }
                        }
                    }
                },
                "security-scheme-or-reference": {
                    if: {
                        type: "object",
                        required: ["$ref"]
                    },
                    then: {
                        $ref: "#/$defs/reference"
                    },
                    else: {
                        $ref: "#/$defs/security-scheme"
                    }
                },
                "oauth-flows": {
                    type: "object",
                    properties: {
                        implicit: {
                            $ref: "#/$defs/oauth-flows/$defs/implicit"
                        },
                        password: {
                            $ref: "#/$defs/oauth-flows/$defs/password"
                        },
                        clientCredentials: {
                            $ref: "#/$defs/oauth-flows/$defs/client-credentials"
                        },
                        authorizationCode: {
                            $ref: "#/$defs/oauth-flows/$defs/authorization-code"
                        }
                    },
                    $ref: "#/$defs/specification-extensions",
                    unevaluatedProperties: !1,
                    $defs: {
                        implicit: {
                            type: "object",
                            properties: {
                                authorizationUrl: {
                                    type: "string",
                                    format: "uri"
                                },
                                refreshUrl: {
                                    type: "string",
                                    format: "uri"
                                },
                                scopes: {
                                    $ref: "#/$defs/map-of-strings"
                                }
                            },
                            required: ["authorizationUrl", "scopes"],
                            $ref: "#/$defs/specification-extensions",
                            unevaluatedProperties: !1
                        },
                        password: {
                            type: "object",
                            properties: {
                                tokenUrl: {
                                    type: "string",
                                    format: "uri"
                                },
                                refreshUrl: {
                                    type: "string",
                                    format: "uri"
                                },
                                scopes: {
                                    $ref: "#/$defs/map-of-strings"
                                }
                            },
                            required: ["tokenUrl", "scopes"],
                            $ref: "#/$defs/specification-extensions",
                            unevaluatedProperties: !1
                        },
                        "client-credentials": {
                            type: "object",
                            properties: {
                                tokenUrl: {
                                    type: "string",
                                    format: "uri"
                                },
                                refreshUrl: {
                                    type: "string",
                                    format: "uri"
                                },
                                scopes: {
                                    $ref: "#/$defs/map-of-strings"
                                }
                            },
                            required: ["tokenUrl", "scopes"],
                            $ref: "#/$defs/specification-extensions",
                            unevaluatedProperties: !1
                        },
                        "authorization-code": {
                            type: "object",
                            properties: {
                                authorizationUrl: {
                                    type: "string",
                                    format: "uri"
                                },
                                tokenUrl: {
                                    type: "string",
                                    format: "uri"
                                },
                                refreshUrl: {
                                    type: "string",
                                    format: "uri"
                                },
                                scopes: {
                                    $ref: "#/$defs/map-of-strings"
                                }
                            },
                            required: ["authorizationUrl", "tokenUrl", "scopes"],
                            $ref: "#/$defs/specification-extensions",
                            unevaluatedProperties: !1
                        }
                    }
                },
                "security-requirement": {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#security-requirement-object",
                    type: "object",
                    additionalProperties: {
                        type: "array",
                        items: {
                            type: "string"
                        }
                    }
                },
                "specification-extensions": {
                    $comment: "https://spec.openapis.org/oas/v3.1.0#specification-extensions",
                    patternProperties: {
                        "^x-": !0
                    }
                },
                examples: {
                    properties: {
                        example: !0,
                        examples: {
                            type: "object",
                            additionalProperties: {
                                $ref: "#/$defs/example-or-reference"
                            }
                        }
                    }
                },
                "map-of-strings": {
                    type: "object",
                    additionalProperties: {
                        type: "string"
                    }
                }
            }
        }
    }
      , pK = Object.keys(dK)
      , hK = {
        EMPTY_OR_INVALID: "Cannot find JSON, YAML or filename in data",
        OPENAPI_VERSION_NOT_SUPPORTED: "Cannot find supported Swagger/OpenAPI version in specification, version must be a string.",
        INVALID_REFERENCE: "Can’t resolve reference: %s",
        EXTERNAL_REFERENCE_NOT_FOUND: "Can’t resolve external reference: %s",
        FILE_DOES_NOT_EXIST: "File does not exist: %s"
    };
    function fK(e) {
        for (const t of new Set(pK)) {
            const n = "2.0" === t ? "swagger" : "openapi"
              , r = e[n];
            if ("string" == typeof r && r.startsWith(t))
                return {
                    version: t,
                    specificationType: n,
                    specificationVersion: r
                }
        }
        return {
            version: void 0,
            specificationType: void 0,
            specificationVersion: void 0
        }
    }
    function mK(e) {
        return decodeURI(e.replace(/~1/g, "/").replace(/~0/g, "~"))
    }
    function gK(e, t, n) {
        void 0 === n && (n = []);
        const r = uK(structuredClone(e))
          , o = iK(r);
        return i((null == t ? void 0 : t.specification) ?? o.specification, r, t ?? o),
        i((null == t ? void 0 : t.specification) ?? o.specification, r, t ?? o),
        n = n.filter(((e,t,n)=>t === n.findIndex((t=>t.message === e.message && t.code === e.code)))),
        {
            valid: 0 === n.length,
            errors: n,
            schema: (t ?? iK(r)).specification
        };
        function i(e, t, r) {
            let o;
            return Object.entries(e ?? {}).forEach((([a,s])=>{
                if (void 0 !== e.$ref) {
                    const o = bK(e.$ref, r, t, n);
                    if (void 0 === o)
                        return;
                    delete e.$ref,
                    "object" == typeof o && Object.keys(o).forEach((t=>{
                        void 0 === e[t] && (e[t] = o[t])
                    }
                    ))
                }
                "object" != typeof s || function(e) {
                    try {
                        return JSON.stringify(e),
                        !1
                    } catch (t) {
                        return !0
                    }
                }(s) || (o = i(s, t, r))
            }
            )),
            {
                errors: (null == o ? void 0 : o.errors) ?? []
            }
        }
    }
    function bK(e, t, n, r) {
        if ("string" != typeof e)
            return void r.push({
                code: "INVALID_REFERENCE",
                message: hK.INVALID_REFERENCE.replace("%s", e)
            });
        const [o,i] = e.split("#", 2);
        if (o) {
            const e = n.find((e=>e.filename === o));
            if (!e)
                return void r.push({
                    code: "EXTERNAL_REFERENCE_NOT_FOUND",
                    message: hK.EXTERNAL_REFERENCE_NOT_FOUND.replace("%s", o)
                });
            const t = gK(n, e, r);
            return void 0 === i ? t.schema : bK(`#${i}`, e, n, r)
        }
        const a = function(e) {
            return e.split("/").slice(1).map(mK)
        }(i);
        try {
            return a.reduce(((e,t)=>e[t]), t.specification)
        } catch (s) {
            r.push({
                code: "INVALID_REFERENCE",
                message: hK.INVALID_REFERENCE.replace("%s", e)
            })
        }
    }
    async function OK(e, t) {
        var n, r;
        if ((null == t ? void 0 : t.filesystem) && (null == t ? void 0 : t.filesystem.find((t=>t.filename === e))))
            return {
                filesystem: t.filesystem
            };
        const o = null == (n = null == t ? void 0 : t.plugins) ? void 0 : n.find((t=>t.check(e)))
          , i = cK(o ? await o.get(e) : e);
        if (void 0 === i)
            return {
                filesystem: []
            };
        let a = uK(i, {
            filename: (null == t ? void 0 : t.filename) ?? null
        });
        const s = ((null == t ? void 0 : t.filename) ? a.find((e=>e.filename === (null == t ? void 0 : t.filename))) : iK(a)).references ?? sK(i);
        if (0 === s.length)
            return {
                filesystem: a
            };
        for (const l of s) {
            const n = null == (r = null == t ? void 0 : t.plugins) ? void 0 : r.find((e=>e.check(l)));
            if (!n)
                continue;
            const o = n.check(l) && n.resolvePath ? n.resolvePath(e, l) : l;
            if (a.find((e=>e.filename === l)))
                continue;
            const {filesystem: i} = await OK(o, {
                ...t,
                filename: l
            });
            a = [...a, ...i.map((e=>({
                ...e,
                isEntrypoint: !1
            })))]
        }
        return {
            filesystem: a
        }
    }
    const vK = {
        limit: 20
    }
      , yK = e=>{
        let t = 0;
        const n = {
            ...vK,
            ...e
        };
        return {
            check: e=>"string" == typeof e && !(!e.startsWith("http://") && !e.startsWith("https://")),
            async get(e) {
                if (!1 !== (null == n ? void 0 : n.limit) && t >= (null == n ? void 0 : n.limit))
                    console.warn(`[fetchUrls] Maximum number of requests reeached (${null == n ? void 0 : n.limit}), skipping request`);
                else
                    try {
                        t++;
                        const r = await ((null == n ? void 0 : n.fetch) ? n.fetch(e) : fetch(e));
                        return await r.text()
                    } catch (r) {
                        console.error("[fetchUrls]", r.message, `(${e})`)
                    }
            }
        }
    }
      , wK = (e,{proxy: t}={})=>new Promise((async(n,r)=>{
        var o;
        try {
            if (!e)
                return n(_K({
                    info: {
                        title: "",
                        description: "",
                        termsOfService: "",
                        version: "",
                        license: {
                            name: "",
                            url: ""
                        },
                        contact: {
                            email: ""
                        }
                    },
                    externalDocs: {
                        description: "",
                        url: ""
                    },
                    servers: [],
                    tags: []
                }));
            const i = performance.now()
              , {filesystem: a} = await OK(e, {
                plugins: [yK({
                    fetch: e=>fetch(t ? WZ(t, e) : e)
                })]
            })
              , {schema: s, errors: l} = await async function(e) {
                const t = uK(e)
                  , n = iK(t)
                  , r = gK(t);
                return {
                    specification: n.specification,
                    errors: r.errors,
                    schema: r.schema,
                    ...fK(n.specification)
                }
            }(a)
              , c = performance.now();
            return console.log(`dereference: ${Math.round(c - i)} ms`),
            (null == l ? void 0 : l.length) && console.warn("Please open an issue on https://github.com/scalar/scalar\n", "Scalar OpenAPI Parser Warning:\n", l),
            void 0 === s ? (r((null == (o = null == l ? void 0 : l[0]) ? void 0 : o.message) ?? "Failed to parse the OpenAPI file."),
            n(_K({
                info: {
                    title: "",
                    description: "",
                    termsOfService: "",
                    version: "",
                    license: {
                        name: "",
                        url: ""
                    },
                    contact: {
                        email: ""
                    }
                },
                externalDocs: {
                    description: "",
                    url: ""
                },
                servers: [],
                tags: []
            }))) : n(_K(s))
        } catch (i) {
            r(i)
        }
        return n(_K({
            info: {
                title: "",
                description: "",
                termsOfService: "",
                version: "",
                license: {
                    name: "",
                    url: ""
                },
                contact: {
                    email: ""
                }
            },
            externalDocs: {
                description: "",
                url: ""
            },
            servers: [],
            tags: []
        }))
    }
    ))
      , _K = e=>{
        let t = {};
        t = e && "object" == typeof e ? structuredClone(e) : {
            info: {
                title: "",
                description: "",
                termsOfService: "",
                version: "",
                license: {
                    name: "",
                    url: ""
                },
                contact: {
                    email: ""
                }
            },
            externalDocs: {
                description: "",
                url: ""
            },
            servers: [],
            tags: []
        },
        t.tags || (t.tags = []),
        t.paths || (t.paths = {});
        const n = {};
        Object.keys(t.webhooks ?? {}).forEach((e=>{
            var r;
            Object.keys((null == (r = t.webhooks) ? void 0 : r[e]) ?? {}).forEach((r=>{
                var o, i, a;
                const s = null == (o = t.webhooks) ? void 0 : o[e][r];
                !0 !== (null == s ? void 0 : s["x-internal"]) && (void 0 === n[e] && (n[e] = {}),
                n[e][r] = {
                    httpVerb: VZ(r),
                    path: e,
                    operationId: (null == s ? void 0 : s.operationId) || e,
                    name: (null == s ? void 0 : s.summary) || e || "",
                    description: (null == s ? void 0 : s.description) || "",
                    pathParameters: null == (a = null == (i = t.paths) ? void 0 : i[e]) ? void 0 : a.parameters,
                    information: {
                        ...s
                    }
                })
            }
            ))
        }
        )),
        Object.keys(t.paths).forEach((e=>{
            Object.keys(t.paths[e]).filter((e=>Ll.includes(e.toUpperCase()))).forEach((n=>{
                var r, o, i, a, s, l;
                const c = t.paths[e][n];
                if (void 0 === c)
                    return;
                if (!0 === c["x-internal"])
                    return;
                const u = {
                    httpVerb: VZ(n),
                    path: e,
                    operationId: c.operationId || e,
                    name: c.summary || e || "",
                    description: c.description || "",
                    information: {
                        ...c
                    },
                    pathParameters: null == (o = null == (r = t.paths) ? void 0 : r[e]) ? void 0 : o.parameters
                };
                if (c.tags && 0 !== c.tags.length)
                    c.tags.forEach((e=>{
                        var n, r, o;
                        const i = null == (n = t.tags) ? void 0 : n.findIndex((t=>t.name === e));
                        -1 === i && (null == (r = t.tags) || r.push({
                            name: e,
                            description: ""
                        }));
                        const a = -1 !== i ? i : t.tags.length - 1;
                        void 0 === (null == (o = t.tags[a]) ? void 0 : o.operations) && (t.tags[a].operations = []),
                        t.tags[a].operations.push(u)
                    }
                    ));
                else {
                    (null == (i = t.tags) ? void 0 : i.find((e=>"default" === e.name))) || null == (a = t.tags) || a.push({
                        name: "default",
                        description: "",
                        operations: []
                    });
                    const e = null == (s = t.tags) ? void 0 : s.findIndex((e=>"default" === e.name));
                    e >= 0 && (null == (l = t.tags[e]) || l.operations.push(u))
                }
            }
            ))
        }
        ));
        return {
            ...t,
            webhooks: n
        }
    }
      , kK = Symbol()
      , SK = Symbol()
      , EK = async e=>{
        var t;
        null == (t = document.getElementById(e)) || t.scrollIntoView()
    }
      , xK = e=>new Promise((t=>setTimeout(t, e)))
      , TK = $l(Symbol("downloadSpec"));
    const AK = (...e)=>{
        let t = {
            httpVersion: "1.1",
            method: "GET",
            url: "",
            path: "",
            headers: [],
            headersSize: -1,
            queryString: [],
            cookies: [],
            bodySize: -1
        };
        e.forEach((e=>{
            t = {
                ...t,
                ...e,
                headers: [...t.headers, ...e.headers ?? []],
                queryString: [...t.queryString, ...e.queryString ?? []],
                cookies: [...t.cookies, ...e.cookies ?? []]
            }
        }
        ));
        const n = t.headers.reduce(((e,{name: t, value: n})=>(e[t] = n,
        e)), {})
          , r = jZ.from(n).normalize(!0);
        t.headers = Object.entries(r).map((([e,t])=>({
            name: e,
            value: t
        })));
        const {path: o, ...i} = t;
        return o ? {
            ...i,
            url: `${t.url}${o}`
        } : i
    }
      , CK = async({url: e, content: t},n)=>{
        if (e)
            return function(e) {
                try {
                    return Boolean(new URL(e))
                } catch (Aa) {
                    return !1
                }
            }(e) ? await QT(e, n) : await QT(e);
        const r = "function" == typeof t ? t() : t;
        return "string" == typeof r ? r : "object" == typeof r ? zT(r) : void 0
    }
    ;
    function PK({specConfig: e, proxy: t}) {
        const n = Et("")
          , r = ut({
            info: {
                title: "",
                description: "",
                termsOfService: "",
                version: "",
                license: {
                    name: "",
                    url: ""
                },
                contact: {
                    email: ""
                }
            },
            externalDocs: {
                description: "",
                url: ""
            },
            servers: [],
            tags: []
        })
          , o = Et(null);
        return zr((()=>Pt(e)), (async e=>{
            var r;
            if (e) {
                const o = null == (r = await CK(e, Pt(t))) ? void 0 : r.trim();
                "string" == typeof o && (n.value = o)
            }
        }
        ), {
            immediate: !0,
            deep: !0
        }),
        zr(n, (()=>{
            var e;
            (e = n.value) ? wK(e, {
                proxy: t ? Pt(t) : void 0
            }).then((e=>{
                o.value = null,
                Object.assign(r, {
                    servers: [],
                    ...e
                })
            }
            )).catch((e=>{
                o.value = e.toString()
            }
            )) : Object.assign(r, {
                info: {
                    title: "",
                    description: "",
                    termsOfService: "",
                    version: "",
                    license: {
                        name: "",
                        url: ""
                    },
                    contact: {
                        email: ""
                    }
                },
                externalDocs: {
                    description: "",
                    url: ""
                },
                servers: [],
                tags: []
            })
        }
        )),
        {
            rawSpec: n,
            parsedSpec: r,
            specErrors: o
        }
    }
    function DK(e) {
        const t = ei((()=>{
            if (!e.information)
                return [];
            const {responses: t} = e.information
              , n = [];
            return t && Object.keys(t).forEach((e=>{
                n.push({
                    name: e,
                    description: t[e].description
                })
            }
            )),
            n
        }
        ));
        return {
            responses: t
        }
    }
    const {getHeadingId: RK, getModelId: NK, getOperationId: $K, getSectionId: IK, getTagId: MK, getWebhookId: LK, hash: QK} = LY()
      , BK = Et(void 0);
    function UK(e) {
        return BK.value = e
    }
    const FK = Et(!1)
      , jK = ut(qT["useSidebarContent-collapsedSidebarItems"] ?? {});
    function zK(e) {
        jK[e] = !jK[e]
    }
    function qK(e, t) {
        jK[e] = t
    }
    const HK = Et([])
      , ZK = ei((()=>{
        var e, t, n, r, o, i, a, s, l, c;
        const {state: u} = eY()
          , d = {}
          , {openApi: {globalSecurity: p}} = Dq()
          , h = [];
        let f = null;
        HK.value.forEach((e=>{
            var t;
            e.depth === WY(HK.value) ? (f = {
                id: RK(e),
                title: e.value,
                show: !u.showApiClient,
                children: []
            },
            h.push(f)) : f && (null == (t = f.children) || t.push({
                id: RK(e),
                title: e.value,
                show: !u.showApiClient
            }))
        }
        ));
        const m = null == (t = null == (e = BK.value) ? void 0 : e.tags) ? void 0 : t[0]
          , g = m && (1 !== (null == (b = null == (n = BK.value) ? void 0 : n.tags) ? void 0 : b.length) || "default" !== b[0].name || "" !== b[0].description) ? null == (o = null == (r = BK.value) ? void 0 : r.tags) ? void 0 : o.filter((e=>{
            var t;
            return (null == (t = e.operations) ? void 0 : t.length) > 0
        }
        )).map((e=>{
            var t;
            return {
                id: MK(e),
                title: e.name,
                displayTitle: e["x-displayName"] ?? e.name,
                show: !0,
                children: null == (t = e.operations) ? void 0 : t.map((t=>{
                    var n;
                    const r = $K(t, e)
                      , o = t.name ?? t.path;
                    return d[r] = o,
                    {
                        id: r,
                        title: o,
                        httpVerb: t.httpVerb,
                        deprecated: (null == (n = t.information) ? void 0 : n.deprecated) ?? !1,
                        show: !0,
                        select: ()=>{
                            u.showApiClient && oK(t, p)
                        }
                    }
                }
                ))
            }
        }
        )) : null == (i = null == m ? void 0 : m.operations) ? void 0 : i.map((e=>{
            var t;
            const n = $K(e, m)
              , r = e.name ?? e.path;
            return d[n] = r,
            {
                id: n,
                title: r,
                httpVerb: e.httpVerb,
                deprecated: (null == (t = e.information) ? void 0 : t.deprecated) ?? !1,
                show: !0,
                select: ()=>{
                    u.showApiClient && oK(e, p)
                }
            }
        }
        ));
        var b;
        const O = VY(BK.value) && !FK.value ? [{
            id: NK(),
            title: "Models",
            show: !u.showApiClient,
            children: Object.keys(XY(BK.value) ?? {}).map((e=>{
                var t;
                const n = NK(e);
                return d[n] = e,
                {
                    id: n,
                    title: (null == (t = XY(BK.value)) ? void 0 : t[e]).title ?? e,
                    show: !u.showApiClient
                }
            }
            ))
        }] : []
          , v = (null == (a = BK.value) ? void 0 : a["x-tagGroups"]) ? null == (l = null == (s = BK.value) ? void 0 : s["x-tagGroups"]) ? void 0 : l.map((e=>{
            const t = [];
            e.tags.map((e=>{
                if ("models" === e && O.length > 0)
                    t.push(O[0]);
                else {
                    const n = null == g ? void 0 : g.find((t=>t.title === e));
                    n && t.push(n)
                }
            }
            ));
            return {
                id: e.name,
                title: e.name,
                children: t,
                show: !0,
                isGroup: !0
            }
        }
        )) : void 0
          , y = (w = BK.value) && Object.keys((null == w ? void 0 : w.webhooks) ?? {}).length ? [{
            id: LK(),
            title: "Webhook",
            show: !u.showApiClient,
            children: Object.keys((null == (c = BK.value) ? void 0 : c.webhooks) ?? {}).map((e=>{
                var t, n;
                const r = LK(e);
                return d[r] = e,
                Object.keys((null == (n = null == (t = BK.value) ? void 0 : t.webhooks) ? void 0 : n[e]) ?? {}).map((t=>{
                    var n, r, o;
                    return {
                        id: LK(e, t),
                        title: null == (o = null == (r = null == (n = BK.value) ? void 0 : n.webhooks) ? void 0 : r[e][t]) ? void 0 : o.name,
                        httpVerb: t,
                        show: !u.showApiClient
                    }
                }
                ))
            }
            )).flat()
        }] : [];
        var w;
        return {
            entries: [...h, ...v ?? g ?? [], ...v ? [] : y, ...v ? [] : O],
            titles: d
        }
    }
    ))
      , WK = Et(!1)
      , XK = ei((()=>{
        var e, t;
        return (null == (t = null == (e = ZK.value) ? void 0 : e.titles) ? void 0 : t[QK.value]) ?? ""
    }
    ));
    function VK(e) {
        return (null == e ? void 0 : e.parsedSpec) && (BK.value = e.parsedSpec,
        zr((()=>{
            var e, t;
            return null == (t = null == (e = BK.value) ? void 0 : e.tags) ? void 0 : t.length
        }
        ), (()=>{
            var e, t;
            if (QK.value) {
                const e = IK(QK.value);
                e && qK(e, !0)
            } else {
                const n = null == (t = null == (e = BK.value) ? void 0 : e.tags) ? void 0 : t[0];
                n && qK(MK(n), !0)
            }
        }
        )),
        zr((()=>{
            var e, t;
            return null == (t = null == (e = BK.value) ? void 0 : e.info) ? void 0 : t.description
        }
        ), (async()=>{
            var e, t;
            const n = null == (t = null == (e = BK.value) ? void 0 : e.info) ? void 0 : t.description;
            return HK.value = n ? await (async e=>{
                const t = await ZY(e)
                  , n = WY(t);
                return t.filter((e=>e.depth === n || e.depth === n + 1))
            }
            )(n) : []
        }
        ))),
        {
            breadcrumb: XK,
            items: ZK,
            isSidebarOpen: WK,
            collapsedSidebarItems: jK,
            toggleCollapsedSidebarItem: zK,
            setCollapsedSidebarItem: qK,
            hideModels: FK,
            setParsedSpec: UK
        }
    }
    const GK = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : window
      , {FormData: YK, Blob: KK, File: JK} = GK
      , eJ = "\r\n"
      , tJ = "-".repeat(2)
      , nJ = Symbol.toStringTag
      , rJ = (e,t,n)=>{
        let r = "";
        return r += `${tJ}${e}${eJ}`,
        r += `Content-Disposition: form-data; name="${t}"`,
        "string" != typeof n && "blob" !== n.name && (r += `; filename="${n.name}"${eJ}`,
        r += `Content-Type: ${n.type || "application/octet-stream"}`),
        `${r}${eJ.repeat(2)}`
    }
      , oJ = async function*(e, t) {
        for (const [n,r] of e)
            yield rJ(t, n, r),
            "string" == typeof r ? yield r : yield await r.text(),
            yield eJ;
        yield(e=>`${tJ}${e}${tJ}${eJ.repeat(1)}`)(t)
    }
      , iJ = (e,t)=>Object.keys(e).find((e=>e.toLowerCase() === t.toLowerCase()))
      , aJ = (e,t)=>{
        const n = iJ(e, t);
        if (n)
            return e[n]
    }
      , sJ = (e,t)=>Boolean(iJ(e, t))
      , lJ = ["application/json", "application/x-json", "text/json", "text/x-json", "+json"]
      , cJ = (e,t)=>{
        if (void 0 === t.value)
            return e;
        const n = e[t.name];
        return void 0 === n ? (e[t.name] = t.value,
        e) : Array.isArray(n) ? (n.push(t.value),
        e) : (e[t.name] = [n, t.value],
        e)
    }
    ;
    function uJ(e) {
        return new URLSearchParams(Object.entries(e).map((([e,t])=>Array.isArray(t) ? t.map((t=>[e, t])) : [[e, t]])).flat(1))
    }
    class dJ extends URL {
        get path() {
            return this.pathname + this.search
        }
    }
    class pJ {
        constructor({indent: e, join: t}={}) {
            this.postProcessors = [],
            this.code = [],
            this.indentationCharacter = "",
            this.lineJoin = "\n",
            this.indentLine = (e,t=0)=>`${this.indentationCharacter.repeat(t)}${e}`,
            this.unshift = (e,t)=>{
                const n = this.indentLine(e, t);
                this.code.unshift(n)
            }
            ,
            this.push = (e,t)=>{
                const n = this.indentLine(e, t);
                this.code.push(n)
            }
            ,
            this.blank = ()=>{
                this.code.push("")
            }
            ,
            this.join = ()=>{
                const e = this.code.join(this.lineJoin);
                return this.postProcessors.reduce(((e,t)=>t(e)), e)
            }
            ,
            this.addPostProcessor = e=>{
                this.postProcessors = [...this.postProcessors, e]
            }
            ,
            this.indentationCharacter = e || "",
            this.lineJoin = null != t ? t : "\n"
        }
    }
    function hJ(e, t={}) {
        const {delimiter: n='"', escapeChar: r="\\", escapeNewlines: o=!0} = t;
        return [...e.toString()].map((e=>"\b" === e ? `${r}b` : "\t" === e ? `${r}t` : "\n" === e ? o ? `${r}n` : e : "\f" === e ? `${r}f` : "\r" === e ? o ? `${r}r` : e : e === r ? r + r : e === n ? r + n : e < " " || e > "~" ? JSON.stringify(e).slice(1, -1) : e)).join("")
    }
    const fJ = e=>hJ(e, {
        delimiter: "'"
    })
      , mJ = e=>hJ(e, {
        delimiter: '"'
    })
      , gJ = {
        info: {
            key: "c",
            title: "C",
            extname: ".c",
            default: "libcurl"
        },
        clientsById: {
            libcurl: {
                info: {
                    key: "libcurl",
                    title: "Libcurl",
                    link: "http://curl.haxx.se/libcurl",
                    description: "Simple REST and HTTP API Client for C"
                },
                convert: ({method: e, fullUrl: t, headersObj: n, allHeaders: r, postData: o})=>{
                    const {push: i, blank: a, join: s} = new pJ;
                    i("CURL *hnd = curl_easy_init();"),
                    a(),
                    i(`curl_easy_setopt(hnd, CURLOPT_CUSTOMREQUEST, "${e.toUpperCase()}");`),
                    i(`curl_easy_setopt(hnd, CURLOPT_URL, "${t}");`);
                    const l = Object.keys(n);
                    return l.length && (a(),
                    i("struct curl_slist *headers = NULL;"),
                    l.forEach((e=>{
                        i(`headers = curl_slist_append(headers, "${e}: ${mJ(n[e])}");`)
                    }
                    )),
                    i("curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, headers);")),
                    r.cookie && (a(),
                    i(`curl_easy_setopt(hnd, CURLOPT_COOKIE, "${r.cookie}");`)),
                    (null == o ? void 0 : o.text) && (a(),
                    i(`curl_easy_setopt(hnd, CURLOPT_POSTFIELDS, ${JSON.stringify(o.text)});`)),
                    a(),
                    i("CURLcode ret = curl_easy_perform(hnd);"),
                    s()
                }
            }
        }
    };
    class bJ {
        constructor(e) {
            this.name = "",
            this.toString = ()=>`:${this.name}`,
            this.name = e
        }
    }
    class OJ {
        constructor(e) {
            this.path = "",
            this.toString = ()=>`(clojure.java.io/file "${this.path}")`,
            this.path = e
        }
    }
    const vJ = e=>void 0 === e ? null : null === e ? "null" : e.constructor.name.toLowerCase()
      , yJ = e=>"object" === vJ(e) && 0 === Object.keys(e).length
      , wJ = e=>(Object.keys(e).filter((t=>yJ(e[t]))).forEach((t=>{
        delete e[t]
    }
    )),
    e)
      , _J = (e,t)=>{
        const n = " ".repeat(e);
        return t.replace(/\n/g, `\n${n}`)
    }
      , kJ = e=>{
        switch (vJ(e)) {
        case "string":
            return `"${e.replace(/"/g, '\\"')}"`;
        case "file":
        case "keyword":
        default:
            return e.toString();
        case "null":
            return "nil";
        case "regexp":
            return `#"${e.source}"`;
        case "object":
            {
                const t = Object.keys(e).reduce(((t,n)=>`${t}:${n} ${_J(n.length + 2, kJ(e[n]))}\n `), "").trim();
                return `{${_J(1, t)}}`
            }
        case "array":
            {
                const t = e.reduce(((e,t)=>`${e} ${kJ(t)}`), "").trim();
                return `[${_J(1, t)}]`
            }
        }
    }
      , SJ = {
        info: {
            key: "clojure",
            title: "Clojure",
            extname: ".clj",
            default: "clj_http"
        },
        clientsById: {
            clj_http: {
                info: {
                    key: "clj_http",
                    title: "clj-http",
                    link: "https://github.com/dakrone/clj-http",
                    description: "An idiomatic clojure http client wrapping the apache client."
                },
                convert: ({queryObj: e, method: t, postData: n, url: r, allHeaders: o},i)=>{
                    const {push: a, join: s} = new pJ({
                        indent: null == i ? void 0 : i.indent
                    });
                    if (t = t.toLowerCase(),
                    !["get", "post", "put", "delete", "patch", "head", "options"].includes(t))
                        return a("Method not supported"),
                        s();
                    const l = {
                        headers: o,
                        "query-params": e
                    };
                    switch (null == n ? void 0 : n.mimeType) {
                    case "application/json":
                        {
                            l["content-type"] = new bJ("json"),
                            l["form-params"] = n.jsonObj;
                            const e = iJ(l.headers, "content-type");
                            e && delete l.headers[e]
                        }
                        break;
                    case "application/x-www-form-urlencoded":
                        {
                            l["form-params"] = n.paramsObj;
                            const e = iJ(l.headers, "content-type");
                            e && delete l.headers[e]
                        }
                        break;
                    case "text/plain":
                        {
                            l.body = n.text;
                            const e = iJ(l.headers, "content-type");
                            e && delete l.headers[e]
                        }
                        break;
                    case "multipart/form-data":
                        if (n.params) {
                            l.multipart = n.params.map((e=>e.fileName && !e.value ? {
                                name: e.name,
                                content: new OJ(e.fileName)
                            } : {
                                name: e.name,
                                content: e.value
                            }));
                            const e = iJ(l.headers, "content-type");
                            e && delete l.headers[e]
                        }
                    }
                    if ("application/json" === aJ(l.headers, "accept")) {
                        l.accept = new bJ("json");
                        const e = iJ(l.headers, "accept");
                        e && delete l.headers[e]
                    }
                    if (a("(require '[clj-http.client :as client])\n"),
                    yJ(wJ(l)))
                        a(`(client/${t} "${r}")`);
                    else {
                        const e = 11 + t.length + r.length;
                        a(`(client/${t} "${r}" ${_J(e, kJ(wJ(l)))})`)
                    }
                    return s()
                }
            }
        }
    }
      , EJ = {
        info: {
            key: "csharp",
            title: "C#",
            extname: ".cs",
            default: "restsharp"
        },
        clientsById: {
            httpclient: {
                info: {
                    key: "httpclient",
                    title: "HttpClient",
                    link: "https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient",
                    description: ".NET Standard HTTP Client"
                },
                convert: ({allHeaders: e, postData: t, method: n, fullUrl: r},o)=>{
                    var i, a;
                    const s = {
                        indent: "    ",
                        ...o
                    }
                      , {push: l, join: c} = new pJ({
                        indent: s.indent
                    });
                    l("using System.Net.Http.Headers;");
                    let u = "";
                    const d = Boolean(e.cookie)
                      , p = (e=>{
                        let t = aJ(e, "accept-encoding");
                        if (!t)
                            return [];
                        const n = {
                            gzip: "DecompressionMethods.GZip",
                            deflate: "DecompressionMethods.Deflate"
                        }
                          , r = [];
                        return "string" == typeof t && (t = [t]),
                        t.forEach((e=>{
                            e.split(",").forEach((e=>{
                                const t = /\s*([^;\s]+)/.exec(e);
                                if (t) {
                                    const e = n[t[1]];
                                    e && r.push(e)
                                }
                            }
                            ))
                        }
                        )),
                        r
                    }
                    )(e);
                    (d || p.length) && (u = "clientHandler",
                    l("var clientHandler = new HttpClientHandler"),
                    l("{"),
                    d && l("UseCookies = false,", 1),
                    p.length && l(`AutomaticDecompression = ${p.join(" | ")},`, 1),
                    l("};")),
                    l(`var client = new HttpClient(${u});`),
                    l("var request = new HttpRequestMessage"),
                    l("{");
                    n = (n = n.toUpperCase()) && ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS", "TRACE"].includes(n) ? `HttpMethod.${n[0]}${n.substring(1).toLowerCase()}` : `new HttpMethod("${n}")`,
                    l(`Method = ${n},`, 1),
                    l(`RequestUri = new Uri("${r}"),`, 1);
                    const h = Object.keys(e).filter((e=>{
                        switch (e.toLowerCase()) {
                        case "content-type":
                        case "content-length":
                        case "accept-encoding":
                            return !1;
                        default:
                            return !0
                        }
                    }
                    ));
                    if (h.length && (l("Headers =", 1),
                    l("{", 1),
                    h.forEach((t=>{
                        l(`{ "${t}", "${mJ(e[t])}" },`, 2)
                    }
                    )),
                    l("},", 1)),
                    null == t ? void 0 : t.text) {
                        const e = t.mimeType;
                        switch (e) {
                        case "application/x-www-form-urlencoded":
                            l("Content = new FormUrlEncodedContent(new Dictionary<string, string>", 1),
                            l("{", 1),
                            null === (i = t.params) || void 0 === i || i.forEach((e=>{
                                l(`{ "${e.name}", "${e.value}" },`, 2)
                            }
                            )),
                            l("}),", 1);
                            break;
                        case "multipart/form-data":
                            l("Content = new MultipartFormDataContent", 1),
                            l("{", 1),
                            null === (a = t.params) || void 0 === a || a.forEach((e=>{
                                l(`new StringContent(${JSON.stringify(e.value || "")})`, 2),
                                l("{", 2),
                                l("Headers =", 3),
                                l("{", 3),
                                e.contentType && l(`ContentType = new MediaTypeHeaderValue("${e.contentType}"),`, 4),
                                l('ContentDisposition = new ContentDispositionHeaderValue("form-data")', 4),
                                l("{", 4),
                                l(`Name = "${e.name}",`, 5),
                                e.fileName && l(`FileName = "${e.fileName}",`, 5),
                                l("}", 4),
                                l("}", 3),
                                l("},", 2)
                            }
                            )),
                            l("},", 1);
                            break;
                        default:
                            l(`Content = new StringContent(${JSON.stringify((null == t ? void 0 : t.text) || "")})`, 1),
                            l("{", 1),
                            l("Headers =", 2),
                            l("{", 2),
                            l(`ContentType = new MediaTypeHeaderValue("${e}")`, 3),
                            l("}", 2),
                            l("}", 1)
                        }
                    }
                    return l("};"),
                    l("using (var response = await client.SendAsync(request))"),
                    l("{"),
                    l("response.EnsureSuccessStatusCode();", 1),
                    l("var body = await response.Content.ReadAsStringAsync();", 1),
                    l("Console.WriteLine(body);", 1),
                    l("}"),
                    c()
                }
            },
            restsharp: {
                info: {
                    key: "restsharp",
                    title: "RestSharp",
                    link: "http://restsharp.org/",
                    description: "Simple REST and HTTP API Client for .NET"
                },
                convert: ({allHeaders: e, method: t, fullUrl: n, headersObj: r, cookies: o, postData: i})=>{
                    const {push: a, join: s} = new pJ;
                    if (!["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"].includes(t.toUpperCase()))
                        return "Method not supported";
                    if (a(`var client = new RestClient("${n}");`),
                    a(`var request = new RestRequest(Method.${t.toUpperCase()});`),
                    Object.keys(r).forEach((e=>{
                        a(`request.AddHeader("${e}", "${mJ(r[e])}");`)
                    }
                    )),
                    null == o || o.forEach((({name: e, value: t})=>{
                        a(`request.AddCookie("${e}", "${t}");`)
                    }
                    )),
                    null == i ? void 0 : i.text) {
                        const t = aJ(e, "content-type")
                          , n = JSON.stringify(i.text);
                        a(`request.AddParameter("${t}", ${n}, ParameterType.RequestBody);`)
                    }
                    return a("IRestResponse response = client.Execute(request);"),
                    s()
                }
            }
        }
    }
      , xJ = {
        info: {
            key: "go",
            title: "Go",
            extname: ".go",
            default: "native"
        },
        clientsById: {
            native: {
                info: {
                    key: "native",
                    title: "NewRequest",
                    link: "http://golang.org/pkg/net/http/#NewRequest",
                    description: "Golang HTTP client request"
                },
                convert: ({postData: e, method: t, allHeaders: n, fullUrl: r},o={})=>{
                    const {blank: i, push: a, join: s} = new pJ({
                        indent: "\t"
                    })
                      , {showBoilerplate: l=!0, checkErrors: c=!1, printBody: u=!0, timeout: d=-1, insecureSkipVerify: p=!1} = o
                      , h = c ? "err" : "_"
                      , f = l ? 1 : 0
                      , m = ()=>{
                        c && (a("if err != nil {", f),
                        a("panic(err)", f + 1),
                        a("}", f))
                    }
                    ;
                    l && (a("package main"),
                    i(),
                    a("import ("),
                    a('"fmt"', f),
                    d > 0 && a('"time"', f),
                    p && a('"crypto/tls"', f),
                    (null == e ? void 0 : e.text) && a('"strings"', f),
                    a('"net/http"', f),
                    u && a('"io"', f),
                    a(")"),
                    i(),
                    a("func main() {"),
                    i()),
                    p && (a("insecureTransport := http.DefaultTransport.(*http.Transport).Clone()", f),
                    a("insecureTransport.TLSClientConfig = &tls.Config{InsecureSkipVerify: true}", f));
                    const g = d > 0
                      , b = g || p
                      , O = b ? "client" : "http.DefaultClient";
                    return b && (a("client := http.Client{", f),
                    g && a(`Timeout: time.Duration(${d} * time.Second),`, f + 1),
                    p && a("Transport: insecureTransport,", f + 1),
                    a("}", f),
                    i()),
                    a(`url := "${r}"`, f),
                    i(),
                    (null == e ? void 0 : e.text) ? (a(`payload := strings.NewReader(${JSON.stringify(e.text)})`, f),
                    i(),
                    a(`req, ${h} := http.NewRequest("${t}", url, payload)`, f),
                    i()) : (a(`req, ${h} := http.NewRequest("${t}", url, nil)`, f),
                    i()),
                    m(),
                    Object.keys(n).length && (Object.keys(n).forEach((e=>{
                        a(`req.Header.Add("${e}", "${mJ(n[e])}")`, f)
                    }
                    )),
                    i()),
                    a(`res, ${h} := ${O}.Do(req)`, f),
                    m(),
                    u && (i(),
                    a("defer res.Body.Close()", f),
                    a(`body, ${h} := io.ReadAll(res.Body)`, f),
                    m()),
                    i(),
                    a("fmt.Println(res)", f),
                    u && a("fmt.Println(string(body))", f),
                    l && (i(),
                    a("}")),
                    s()
                }
            }
        }
    }
      , TJ = {
        info: {
            key: "http",
            title: "HTTP",
            extname: null,
            default: "1.1"
        },
        clientsById: {
            "http1.1": {
                info: {
                    key: "http1.1",
                    title: "HTTP/1.1",
                    link: "https://tools.ietf.org/html/rfc7230",
                    description: "HTTP/1.1 request string in accordance with RFC 7230"
                },
                convert: ({method: e, fullUrl: t, uriObj: n, httpVersion: r, allHeaders: o, postData: i},a)=>{
                    const s = {
                        absoluteURI: !1,
                        autoContentLength: !0,
                        autoHost: !0,
                        ...a
                    }
                      , {blank: l, push: c, join: u} = new pJ({
                        indent: "",
                        join: "\r\n"
                    })
                      , d = s.absoluteURI ? t : n.path;
                    c(`${e} ${d} ${r}`);
                    const p = Object.keys(o);
                    p.forEach((e=>{
                        const t = e.toLowerCase().replace(/(^|-)(\w)/g, (e=>e.toUpperCase()));
                        c(`${t}: ${o[e]}`)
                    }
                    )),
                    s.autoHost && !p.includes("host") && c(`Host: ${n.host}`),
                    s.autoContentLength && (null == i ? void 0 : i.text) && !p.includes("content-length") && c(`Content-Length: ${i.text.length}`),
                    l();
                    return `${u()}\r\n${(null == i ? void 0 : i.text) || ""}`
                }
            }
        }
    }
      , AJ = {
        info: {
            key: "java",
            title: "Java",
            extname: ".java",
            default: "unirest"
        },
        clientsById: {
            asynchttp: {
                info: {
                    key: "asynchttp",
                    title: "AsyncHttp",
                    link: "https://github.com/AsyncHttpClient/async-http-client",
                    description: "Asynchronous Http and WebSocket Client library for Java"
                },
                convert: ({method: e, allHeaders: t, postData: n, fullUrl: r},o)=>{
                    const i = {
                        indent: "  ",
                        ...o
                    }
                      , {blank: a, push: s, join: l} = new pJ({
                        indent: i.indent
                    });
                    return s("AsyncHttpClient client = new DefaultAsyncHttpClient();"),
                    s(`client.prepare("${e.toUpperCase()}", "${r}")`),
                    Object.keys(t).forEach((e=>{
                        s(`.setHeader("${e}", "${mJ(t[e])}")`, 1)
                    }
                    )),
                    (null == n ? void 0 : n.text) && s(`.setBody(${JSON.stringify(n.text)})`, 1),
                    s(".execute()", 1),
                    s(".toCompletableFuture()", 1),
                    s(".thenAccept(System.out::println)", 1),
                    s(".join();", 1),
                    a(),
                    s("client.close();"),
                    l()
                }
            },
            nethttp: {
                info: {
                    key: "nethttp",
                    title: "java.net.http",
                    link: "https://openjdk.java.net/groups/net/httpclient/intro.html",
                    description: "Java Standardized HTTP Client API"
                },
                convert: ({allHeaders: e, fullUrl: t, method: n, postData: r},o)=>{
                    const i = {
                        indent: "  ",
                        ...o
                    }
                      , {push: a, join: s} = new pJ({
                        indent: i.indent
                    });
                    return a("HttpRequest request = HttpRequest.newBuilder()"),
                    a(`.uri(URI.create("${t}"))`, 2),
                    Object.keys(e).forEach((t=>{
                        a(`.header("${t}", "${mJ(e[t])}")`, 2)
                    }
                    )),
                    (null == r ? void 0 : r.text) ? a(`.method("${n.toUpperCase()}", HttpRequest.BodyPublishers.ofString(${JSON.stringify(r.text)}))`, 2) : a(`.method("${n.toUpperCase()}", HttpRequest.BodyPublishers.noBody())`, 2),
                    a(".build();", 2),
                    a("HttpResponse<String> response = HttpClient.newHttpClient().send(request, HttpResponse.BodyHandlers.ofString());"),
                    a("System.out.println(response.body());"),
                    s()
                }
            },
            okhttp: {
                info: {
                    key: "okhttp",
                    title: "OkHttp",
                    link: "http://square.github.io/okhttp/",
                    description: "An HTTP Request Client Library"
                },
                convert: ({postData: e, method: t, fullUrl: n, allHeaders: r},o)=>{
                    const i = {
                        indent: "  ",
                        ...o
                    }
                      , {push: a, blank: s, join: l} = new pJ({
                        indent: i.indent
                    });
                    return a("OkHttpClient client = new OkHttpClient();"),
                    s(),
                    (null == e ? void 0 : e.text) && (e.boundary ? a(`MediaType mediaType = MediaType.parse("${e.mimeType}; boundary=${e.boundary}");`) : a(`MediaType mediaType = MediaType.parse("${e.mimeType}");`),
                    a(`RequestBody body = RequestBody.create(mediaType, ${JSON.stringify(e.text)});`)),
                    a("Request request = new Request.Builder()"),
                    a(`.url("${n}")`, 1),
                    ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD"].includes(t.toUpperCase()) ? ["POST", "PUT", "DELETE", "PATCH"].includes(t.toUpperCase()) ? (null == e ? void 0 : e.text) ? a(`.${t.toLowerCase()}(body)`, 1) : a(`.${t.toLowerCase()}(null)`, 1) : a(`.${t.toLowerCase()}()`, 1) : (null == e ? void 0 : e.text) ? a(`.method("${t.toUpperCase()}", body)`, 1) : a(`.method("${t.toUpperCase()}", null)`, 1),
                    Object.keys(r).forEach((e=>{
                        a(`.addHeader("${e}", "${mJ(r[e])}")`, 1)
                    }
                    )),
                    a(".build();", 1),
                    s(),
                    a("Response response = client.newCall(request).execute();"),
                    l()
                }
            },
            unirest: {
                info: {
                    key: "unirest",
                    title: "Unirest",
                    link: "http://unirest.io/java.html",
                    description: "Lightweight HTTP Request Client Library"
                },
                convert: ({method: e, allHeaders: t, postData: n, fullUrl: r},o)=>{
                    const i = {
                        indent: "  ",
                        ...o
                    }
                      , {join: a, push: s} = new pJ({
                        indent: i.indent
                    });
                    return ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"].includes(e.toUpperCase()) ? s(`HttpResponse<String> response = Unirest.${e.toLowerCase()}("${r}")`) : s(`HttpResponse<String> response = Unirest.customMethod("${e.toUpperCase()}","${r}")`),
                    Object.keys(t).forEach((e=>{
                        s(`.header("${e}", "${mJ(t[e])}")`, 1)
                    }
                    )),
                    (null == n ? void 0 : n.text) && s(`.body(${JSON.stringify(n.text)})`, 1),
                    s(".asString();", 1),
                    a()
                }
            }
        }
    };
    var CJ = {};
    Object.defineProperty(CJ, "__esModule", {
        value: !0
    }),
    CJ.default = e=>Object.getOwnPropertySymbols(e).filter((t=>Object.prototype.propertyIsEnumerable.call(e, t)));
    const PJ = function(e) {
        return "[object RegExp]" === Object.prototype.toString.call(e)
    }
      , DJ = function(e) {
        var t = typeof e;
        return null !== e && ("object" === t || "function" === t)
    }
      , RJ = CJ.default;
    var NJ = (e,t,n)=>{
        const r = [];
        return function e(t, n, o) {
            let i;
            (n = n || {}).indent = n.indent || "\t",
            o = o || "",
            i = void 0 === n.inlineCharacterLimit ? {
                newLine: "\n",
                newLineOrSpace: "\n",
                pad: o,
                indent: o + n.indent
            } : {
                newLine: "@@__STRINGIFY_OBJECT_NEW_LINE__@@",
                newLineOrSpace: "@@__STRINGIFY_OBJECT_NEW_LINE_OR_SPACE__@@",
                pad: "@@__STRINGIFY_OBJECT_PAD__@@",
                indent: "@@__STRINGIFY_OBJECT_INDENT__@@"
            };
            const a = e=>{
                if (void 0 === n.inlineCharacterLimit)
                    return e;
                const t = e.replace(new RegExp(i.newLine,"g"), "").replace(new RegExp(i.newLineOrSpace,"g"), " ").replace(new RegExp(i.pad + "|" + i.indent,"g"), "");
                return t.length <= n.inlineCharacterLimit ? t : e.replace(new RegExp(i.newLine + "|" + i.newLineOrSpace,"g"), "\n").replace(new RegExp(i.pad,"g"), o).replace(new RegExp(i.indent,"g"), o + n.indent)
            }
            ;
            if (-1 !== r.indexOf(t))
                return '"[Circular]"';
            if (null == t || "number" == typeof t || "boolean" == typeof t || "function" == typeof t || "symbol" == typeof t || PJ(t))
                return String(t);
            if (t instanceof Date)
                return `new Date('${t.toISOString()}')`;
            if (Array.isArray(t)) {
                if (0 === t.length)
                    return "[]";
                r.push(t);
                const s = "[" + i.newLine + t.map(((r,a)=>{
                    const s = t.length - 1 === a ? i.newLine : "," + i.newLineOrSpace;
                    let l = e(r, n, o + n.indent);
                    return n.transform && (l = n.transform(t, a, l)),
                    i.indent + l + s
                }
                )).join("") + i.pad + "]";
                return r.pop(),
                a(s)
            }
            if (DJ(t)) {
                let s = Object.keys(t).concat(RJ(t));
                if (n.filter && (s = s.filter((e=>n.filter(t, e)))),
                0 === s.length)
                    return "{}";
                r.push(t);
                const l = "{" + i.newLine + s.map(((r,a)=>{
                    const l = s.length - 1 === a ? i.newLine : "," + i.newLineOrSpace
                      , c = "symbol" == typeof r
                      , u = !c && /^[a-z$_][a-z$_0-9]*$/i.test(r)
                      , d = c || u ? r : e(r, n);
                    let p = e(t[r], n, o + n.indent);
                    return n.transform && (p = n.transform(t, r, p)),
                    i.indent + String(d) + ": " + p + l
                }
                )).join("") + i.pad + "}";
                return r.pop(),
                a(l)
            }
            return t = String(t).replace(/[\r\n]/g, (e=>"\n" === e ? "\\n" : "\\r")),
            !1 === n.singleQuotes ? `"${t = t.replace(/"/g, '\\"')}"` : `'${t = t.replace(/\\?'/g, "\\'")}'`
        }(e, t, n)
    }
    ;
    const $J = Nd(NJ)
      , IJ = {
        info: {
            key: "javascript",
            title: "JavaScript",
            extname: ".js",
            default: "xhr"
        },
        clientsById: {
            xhr: {
                info: {
                    key: "xhr",
                    title: "XMLHttpRequest",
                    link: "https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest",
                    description: "W3C Standard API that provides scripted client functionality"
                },
                convert: ({postData: e, allHeaders: t, method: n, fullUrl: r},o)=>{
                    var i;
                    const a = {
                        indent: "  ",
                        cors: !0,
                        ...o
                    }
                      , {blank: s, push: l, join: c} = new pJ({
                        indent: a.indent
                    });
                    switch (null == e ? void 0 : e.mimeType) {
                    case "application/json":
                        l(`const data = JSON.stringify(${$J(e.jsonObj, {
                            indent: a.indent
                        })});`),
                        s();
                        break;
                    case "multipart/form-data":
                        if (!e.params)
                            break;
                        if (l("const data = new FormData();"),
                        e.params.forEach((e=>{
                            l(`data.append('${e.name}', '${e.value || e.fileName || ""}');`)
                        }
                        )),
                        sJ(t, "content-type") && (null === (i = aJ(t, "content-type")) || void 0 === i ? void 0 : i.includes("boundary"))) {
                            const e = iJ(t, "content-type");
                            e && delete t[e]
                        }
                        s();
                        break;
                    default:
                        l(`const data = ${(null == e ? void 0 : e.text) ? `'${e.text}'` : "null"};`),
                        s()
                    }
                    return l("const xhr = new XMLHttpRequest();"),
                    a.cors && l("xhr.withCredentials = true;"),
                    s(),
                    l("xhr.addEventListener('readystatechange', function () {"),
                    l("if (this.readyState === this.DONE) {", 1),
                    l("console.log(this.responseText);", 2),
                    l("}", 1),
                    l("});"),
                    s(),
                    l(`xhr.open('${n}', '${r}');`),
                    Object.keys(t).forEach((e=>{
                        l(`xhr.setRequestHeader('${e}', '${fJ(t[e])}');`)
                    }
                    )),
                    s(),
                    l("xhr.send(data);"),
                    c()
                }
            },
            axios: {
                info: {
                    key: "axios",
                    title: "Axios",
                    link: "https://github.com/axios/axios",
                    description: "Promise based HTTP client for the browser and node.js"
                },
                convert: ({allHeaders: e, method: t, url: n, queryObj: r, postData: o},i)=>{
                    const a = {
                        indent: "  ",
                        ...i
                    }
                      , {blank: s, push: l, join: c, addPostProcessor: u} = new pJ({
                        indent: a.indent
                    });
                    l("import axios from 'axios';"),
                    s();
                    const d = {
                        method: t,
                        url: n
                    };
                    switch (Object.keys(r).length && (d.params = r),
                    Object.keys(e).length && (d.headers = e),
                    null == o ? void 0 : o.mimeType) {
                    case "application/x-www-form-urlencoded":
                        o.params && (l("const encodedParams = new URLSearchParams();"),
                        o.params.forEach((e=>{
                            l(`encodedParams.set('${e.name}', '${e.value}');`)
                        }
                        )),
                        s(),
                        d.data = "encodedParams,",
                        u((e=>e.replace(/'encodedParams,'/, "encodedParams,"))));
                        break;
                    case "application/json":
                        o.jsonObj && (d.data = o.jsonObj);
                        break;
                    case "multipart/form-data":
                        if (!o.params)
                            break;
                        l("const form = new FormData();"),
                        o.params.forEach((e=>{
                            l(`form.append('${e.name}', '${e.value || e.fileName || ""}');`)
                        }
                        )),
                        s(),
                        d.data = "[form]";
                        break;
                    default:
                        (null == o ? void 0 : o.text) && (d.data = o.text)
                    }
                    const p = $J(d, {
                        indent: "  ",
                        inlineCharacterLimit: 80
                    }).replace('"[form]"', "form");
                    return l(`const options = ${p};`),
                    s(),
                    l("try {"),
                    l("const { data } = await axios.request(options);", 1),
                    l("console.log(data);", 1),
                    l("} catch (error) {"),
                    l("console.error(error);", 1),
                    l("}"),
                    c()
                }
            },
            fetch: {
                info: {
                    key: "fetch",
                    title: "fetch",
                    link: "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch",
                    description: "Perform asynchronous HTTP requests with the Fetch API"
                },
                convert: ({method: e, allHeaders: t, postData: n, fullUrl: r},o)=>{
                    const i = {
                        indent: "  ",
                        credentials: null,
                        ...o
                    }
                      , {blank: a, join: s, push: l} = new pJ({
                        indent: i.indent
                    })
                      , c = {
                        method: e
                    };
                    switch (Object.keys(t).length && (c.headers = t),
                    null !== i.credentials && (c.credentials = i.credentials),
                    l(`const url = '${r}';`),
                    null == n ? void 0 : n.mimeType) {
                    case "application/x-www-form-urlencoded":
                        c.body = n.paramsObj ? n.paramsObj : n.text;
                        break;
                    case "application/json":
                        c.body = JSON.stringify(n.jsonObj);
                        break;
                    case "multipart/form-data":
                        if (!n.params)
                            break;
                        const e = iJ(t, "content-type");
                        e && delete t[e],
                        l("const form = new FormData();"),
                        n.params.forEach((e=>{
                            l(`form.append('${e.name}', '${e.value || e.fileName || ""}');`)
                        }
                        )),
                        a();
                        break;
                    default:
                        (null == n ? void 0 : n.text) && (c.body = n.text)
                    }
                    return c.headers && !Object.keys(c.headers).length && delete c.headers,
                    l(`const options = ${$J(c, {
                        indent: i.indent,
                        inlineCharacterLimit: 80,
                        transform: (e,t,r)=>"body" === t && n && "application/x-www-form-urlencoded" === n.mimeType ? `new URLSearchParams(${r})` : r
                    })};`),
                    a(),
                    (null == n ? void 0 : n.params) && "multipart/form-data" === n.mimeType && (l("options.body = form;"),
                    a()),
                    l("try {"),
                    l("const response = await fetch(url, options);", 1),
                    l("const data = await response.json();", 1),
                    l("console.log(data);", 1),
                    l("} catch (error) {"),
                    l("console.error(error);", 1),
                    l("}"),
                    s()
                }
            },
            jquery: {
                info: {
                    key: "jquery",
                    title: "jQuery",
                    link: "http://api.jquery.com/jquery.ajax/",
                    description: "Perform an asynchronous HTTP (Ajax) requests with jQuery"
                },
                convert: ({fullUrl: e, method: t, allHeaders: n, postData: r},o)=>{
                    var i;
                    const a = {
                        indent: "  ",
                        ...o
                    }
                      , {blank: s, push: l, join: c} = new pJ({
                        indent: a.indent
                    })
                      , u = {
                        async: !0,
                        crossDomain: !0,
                        url: e,
                        method: t,
                        headers: n
                    };
                    switch (null == r ? void 0 : r.mimeType) {
                    case "application/x-www-form-urlencoded":
                        u.data = r.paramsObj ? r.paramsObj : r.text;
                        break;
                    case "application/json":
                        u.processData = !1,
                        u.data = r.text;
                        break;
                    case "multipart/form-data":
                        if (!r.params)
                            break;
                        if (l("const form = new FormData();"),
                        r.params.forEach((e=>{
                            l(`form.append('${e.name}', '${e.value || e.fileName || ""}');`)
                        }
                        )),
                        u.processData = !1,
                        u.contentType = !1,
                        u.mimeType = "multipart/form-data",
                        u.data = "[form]",
                        sJ(n, "content-type") && (null === (i = aJ(n, "content-type")) || void 0 === i ? void 0 : i.includes("boundary"))) {
                            const e = iJ(n, "content-type");
                            e && delete u.headers[e]
                        }
                        s();
                        break;
                    default:
                        (null == r ? void 0 : r.text) && (u.data = r.text)
                    }
                    const d = $J(u, {
                        indent: a.indent
                    }).replace("'[form]'", "form");
                    return l(`const settings = ${d};`),
                    s(),
                    l("$.ajax(settings).done(function (response) {"),
                    l("console.log(response);", 1),
                    l("});"),
                    c()
                }
            }
        }
    }
      , MJ = {
        info: {
            key: "kotlin",
            title: "Kotlin",
            extname: ".kt",
            default: "okhttp"
        },
        clientsById: {
            okhttp: {
                info: {
                    key: "okhttp",
                    title: "OkHttp",
                    link: "http://square.github.io/okhttp/",
                    description: "An HTTP Request Client Library"
                },
                convert: ({postData: e, fullUrl: t, method: n, allHeaders: r},o)=>{
                    const i = {
                        indent: "  ",
                        ...o
                    }
                      , {blank: a, join: s, push: l} = new pJ({
                        indent: i.indent
                    });
                    return l("val client = OkHttpClient()"),
                    a(),
                    (null == e ? void 0 : e.text) && (e.boundary ? l(`val mediaType = MediaType.parse("${e.mimeType}; boundary=${e.boundary}")`) : l(`val mediaType = MediaType.parse("${e.mimeType}")`),
                    l(`val body = RequestBody.create(mediaType, ${JSON.stringify(e.text)})`)),
                    l("val request = Request.Builder()"),
                    l(`.url("${t}")`, 1),
                    ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD"].includes(n.toUpperCase()) ? ["POST", "PUT", "DELETE", "PATCH"].includes(n.toUpperCase()) ? (null == e ? void 0 : e.text) ? l(`.${n.toLowerCase()}(body)`, 1) : l(`.${n.toLowerCase()}(null)`, 1) : l(`.${n.toLowerCase()}()`, 1) : (null == e ? void 0 : e.text) ? l(`.method("${n.toUpperCase()}", body)`, 1) : l(`.method("${n.toUpperCase()}", null)`, 1),
                    Object.keys(r).forEach((e=>{
                        l(`.addHeader("${e}", "${mJ(r[e])}")`, 1)
                    }
                    )),
                    l(".build()", 1),
                    a(),
                    l("val response = client.newCall(request).execute()"),
                    s()
                }
            }
        }
    }
      , LJ = {
        info: {
            key: "node",
            title: "Node.js",
            extname: ".js",
            default: "native"
        },
        clientsById: {
            native: {
                info: {
                    key: "native",
                    title: "HTTP",
                    link: "http://nodejs.org/api/http.html#http_http_request_options_callback",
                    description: "Node.js native HTTP interface"
                },
                convert: ({uriObj: e, method: t, allHeaders: n, postData: r},o={})=>{
                    const {indent: i="  ", insecureSkipVerify: a=!1} = o
                      , {blank: s, join: l, push: c, unshift: u} = new pJ({
                        indent: i
                    })
                      , d = {
                        method: t,
                        hostname: e.hostname,
                        port: "" === e.port ? null : e.port,
                        path: e.path,
                        headers: n,
                        ...a ? {
                            rejectUnauthorized: !1
                        } : {}
                    };
                    switch (c(`const http = require('${e.protocol.replace(":", "")}');`),
                    s(),
                    c(`const options = ${$J(d, {
                        indent: i
                    })};`),
                    s(),
                    c("const req = http.request(options, function (res) {"),
                    c("const chunks = [];", 1),
                    s(),
                    c("res.on('data', function (chunk) {", 1),
                    c("chunks.push(chunk);", 2),
                    c("});", 1),
                    s(),
                    c("res.on('end', function () {", 1),
                    c("const body = Buffer.concat(chunks);", 2),
                    c("console.log(body.toString());", 2),
                    c("});", 1),
                    c("});"),
                    s(),
                    null == r ? void 0 : r.mimeType) {
                    case "application/x-www-form-urlencoded":
                        r.paramsObj && (u("const qs = require('querystring');"),
                        c(`req.write(qs.stringify(${$J(r.paramsObj, {
                            indent: "  ",
                            inlineCharacterLimit: 80
                        })}));`));
                        break;
                    case "application/json":
                        r.jsonObj && c(`req.write(JSON.stringify(${$J(r.jsonObj, {
                            indent: "  ",
                            inlineCharacterLimit: 80
                        })}));`);
                        break;
                    default:
                        (null == r ? void 0 : r.text) && c(`req.write(${$J(r.text, {
                            indent: i
                        })});`)
                    }
                    return c("req.end();"),
                    l()
                }
            },
            request: {
                info: {
                    key: "request",
                    title: "Request",
                    link: "https://github.com/request/request",
                    description: "Simplified HTTP request client"
                },
                convert: ({method: e, url: t, queryObj: n, postData: r, headersObj: o, cookies: i},a)=>{
                    const s = {
                        indent: "  ",
                        ...a
                    };
                    let l = !1;
                    const {push: c, blank: u, join: d, unshift: p} = new pJ({
                        indent: s.indent
                    });
                    c("const request = require('request');"),
                    u();
                    const h = {
                        method: e,
                        url: t
                    };
                    switch (Object.keys(n).length && (h.qs = n),
                    Object.keys(o).length && (h.headers = o),
                    null == r ? void 0 : r.mimeType) {
                    case "application/x-www-form-urlencoded":
                        h.form = r.paramsObj;
                        break;
                    case "application/json":
                        r.jsonObj && (h.body = r.jsonObj,
                        h.json = !0);
                        break;
                    case "multipart/form-data":
                        if (!r.params)
                            break;
                        h.formData = {},
                        r.params.forEach((e=>{
                            if (!e.fileName && !e.fileName && !e.contentType)
                                return void (h.formData[e.name] = e.value);
                            let t = {};
                            e.fileName ? (l = !0,
                            t = {
                                value: `fs.createReadStream(${e.fileName})`,
                                options: {
                                    filename: e.fileName,
                                    contentType: e.contentType ? e.contentType : null
                                }
                            }) : e.value && (t.value = e.value),
                            h.formData[e.name] = t
                        }
                        ));
                        break;
                    default:
                        (null == r ? void 0 : r.text) && (h.body = r.text)
                    }
                    return i.length && (h.jar = "JAR",
                    c("const jar = request.jar();"),
                    i.forEach((e=>{
                        c(`jar.setCookie(request.cookie('${encodeURIComponent(e.name)}=${encodeURIComponent(e.value)}'), '${t}');`)
                    }
                    )),
                    u()),
                    l && p("const fs = require('fs');"),
                    c(`const options = ${$J(h, {
                        indent: "  ",
                        inlineCharacterLimit: 80
                    })};`),
                    u(),
                    c("request(options, function (error, response, body) {"),
                    c("if (error) throw new Error(error);", 1),
                    u(),
                    c("console.log(body);", 1),
                    c("});"),
                    d().replace("'JAR'", "jar").replace(/'fs\.createReadStream\((.*)\)'/, "fs.createReadStream('$1')")
                }
            },
            unirest: {
                info: {
                    key: "unirest",
                    title: "Unirest",
                    link: "http://unirest.io/nodejs.html",
                    description: "Lightweight HTTP Request Client Library"
                },
                convert: ({method: e, url: t, cookies: n, queryObj: r, postData: o, headersObj: i},a)=>{
                    const s = {
                        indent: "  ",
                        ...a
                    };
                    let l = !1;
                    const {addPostProcessor: c, blank: u, join: d, push: p, unshift: h} = new pJ({
                        indent: s.indent
                    });
                    switch (p("const unirest = require('unirest');"),
                    u(),
                    p(`const req = unirest('${e}', '${t}');`),
                    u(),
                    n.length && (p("const CookieJar = unirest.jar();"),
                    n.forEach((e=>{
                        p(`CookieJar.add('${encodeURIComponent(e.name)}=${encodeURIComponent(e.value)}', '${t}');`)
                    }
                    )),
                    p("req.jar(CookieJar);"),
                    u()),
                    Object.keys(r).length && (p(`req.query(${$J(r, {
                        indent: s.indent
                    })});`),
                    u()),
                    Object.keys(i).length && (p(`req.headers(${$J(i, {
                        indent: s.indent
                    })});`),
                    u()),
                    null == o ? void 0 : o.mimeType) {
                    case "application/x-www-form-urlencoded":
                        o.paramsObj && (p(`req.form(${$J(o.paramsObj, {
                            indent: s.indent
                        })});`),
                        u());
                        break;
                    case "application/json":
                        o.jsonObj && (p("req.type('json');"),
                        p(`req.send(${$J(o.jsonObj, {
                            indent: s.indent
                        })});`),
                        u());
                        break;
                    case "multipart/form-data":
                        {
                            if (!o.params)
                                break;
                            const e = [];
                            o.params.forEach((t=>{
                                const n = {};
                                t.fileName && !t.value ? (l = !0,
                                n.body = `fs.createReadStream('${t.fileName}')`,
                                c((e=>e.replace(/'fs\.createReadStream\(\\'(.+)\\'\)'/, "fs.createReadStream('$1')")))) : t.value && (n.body = t.value),
                                n.body && (t.contentType && (n["content-type"] = t.contentType),
                                e.push(n))
                            }
                            )),
                            p(`req.multipart(${$J(e, {
                                indent: s.indent
                            })});`),
                            u();
                            break
                        }
                    default:
                        (null == o ? void 0 : o.text) && (p(`req.send(${$J(o.text, {
                            indent: s.indent
                        })});`),
                        u())
                    }
                    return l && h("const fs = require('fs');"),
                    p("req.end(function (res) {"),
                    p("if (res.error) throw new Error(res.error);", 1),
                    u(),
                    p("console.log(res.body);", 1),
                    p("});"),
                    d()
                }
            },
            axios: {
                info: {
                    key: "axios",
                    title: "Axios",
                    link: "https://github.com/axios/axios",
                    description: "Promise based HTTP client for the browser and node.js"
                },
                convert: ({method: e, url: t, queryObj: n, allHeaders: r, postData: o},i)=>{
                    const a = {
                        indent: "  ",
                        ...i
                    }
                      , {blank: s, join: l, push: c, addPostProcessor: u} = new pJ({
                        indent: a.indent
                    });
                    c("const axios = require('axios').default;");
                    const d = {
                        method: e,
                        url: t
                    };
                    switch (Object.keys(n).length && (d.params = n),
                    Object.keys(r).length && (d.headers = r),
                    null == o ? void 0 : o.mimeType) {
                    case "application/x-www-form-urlencoded":
                        o.params && (c("const { URLSearchParams } = require('url');"),
                        s(),
                        c("const encodedParams = new URLSearchParams();"),
                        o.params.forEach((e=>{
                            c(`encodedParams.set('${e.name}', '${e.value}');`)
                        }
                        )),
                        s(),
                        d.data = "encodedParams,",
                        u((e=>e.replace(/'encodedParams,'/, "encodedParams,"))));
                        break;
                    case "application/json":
                        s(),
                        o.jsonObj && (d.data = o.jsonObj);
                        break;
                    default:
                        s(),
                        (null == o ? void 0 : o.text) && (d.data = o.text)
                    }
                    const p = $J(d, {
                        indent: "  ",
                        inlineCharacterLimit: 80
                    });
                    return c(`const options = ${p};`),
                    s(),
                    c("try {"),
                    c("const { data } = await axios.request(options);", 1),
                    c("console.log(data);", 1),
                    c("} catch (error) {"),
                    c("console.error(error);", 1),
                    c("}"),
                    l()
                }
            },
            fetch: {
                info: {
                    key: "fetch",
                    title: "Fetch",
                    link: "https://github.com/bitinn/node-fetch",
                    description: "Simplified HTTP node-fetch client"
                },
                convert: ({method: e, fullUrl: t, postData: n, headersObj: r, cookies: o},i)=>{
                    var a;
                    const s = {
                        indent: "  ",
                        ...i
                    };
                    let l = !1;
                    const {blank: c, push: u, join: d, unshift: p} = new pJ({
                        indent: s.indent
                    });
                    u("const fetch = require('node-fetch');"),
                    c();
                    const h = {
                        method: e
                    };
                    switch (Object.keys(r).length && (h.headers = r),
                    null == n ? void 0 : n.mimeType) {
                    case "application/x-www-form-urlencoded":
                        p("const { URLSearchParams } = require('url');"),
                        u("const encodedParams = new URLSearchParams();"),
                        null === (a = n.params) || void 0 === a || a.forEach((e=>{
                            u(`encodedParams.set('${e.name}', '${e.value}');`)
                        }
                        )),
                        c(),
                        h.body = "encodedParams";
                        break;
                    case "application/json":
                        n.jsonObj && (h.body = JSON.stringify(n.jsonObj));
                        break;
                    case "multipart/form-data":
                        if (!n.params)
                            break;
                        const e = iJ(r, "content-type");
                        e && delete r[e],
                        p("const FormData = require('form-data');"),
                        u("const formData = new FormData();"),
                        n.params.forEach((e=>{
                            e.fileName || e.fileName || e.contentType ? e.fileName && (l = !0,
                            u(`formData.append('${e.name}', fs.createReadStream('${e.fileName}'));`)) : u(`formData.append('${e.name}', '${e.value}');`)
                        }
                        )),
                        c();
                        break;
                    default:
                        (null == n ? void 0 : n.text) && (h.body = n.text)
                    }
                    if (o.length) {
                        const e = o.map((e=>`${encodeURIComponent(e.name)}=${encodeURIComponent(e.value)}`)).join("; ");
                        h.headers || (h.headers = {}),
                        h.headers.cookie = e
                    }
                    u(`const url = '${t}';`),
                    h.headers && !Object.keys(h.headers).length && delete h.headers;
                    const f = $J(h, {
                        indent: "  ",
                        inlineCharacterLimit: 80
                    });
                    return u(`const options = ${f};`),
                    l && p("const fs = require('fs');"),
                    (null == n ? void 0 : n.params) && "multipart/form-data" === n.mimeType && u("options.body = formData;"),
                    c(),
                    u("try {"),
                    u("const response = await fetch(url, options);", 1),
                    u("const data = await response.json();", 1),
                    u("console.log(data);", 1),
                    u("} catch (error) {"),
                    u("console.error(error);", 1),
                    u("}"),
                    d().replace(/'encodedParams'/, "encodedParams").replace(/"fs\.createReadStream\(\\"(.+)\\"\)"/, 'fs.createReadStream("$1")')
                }
            }
        }
    }
      , QJ = (e,t,n,r)=>{
        const o = `${e} *${t} = `;
        return `${o}${BJ(n, r ? o.length : void 0)};`
    }
      , BJ = (e,t)=>{
        const n = void 0 === t ? ", " : `,\n   ${" ".repeat(t)}`;
        switch (Object.prototype.toString.call(e)) {
        case "[object Number]":
            return `@${e}`;
        case "[object Array]":
            return `@[ ${e.map((e=>BJ(e))).join(n)} ]`;
        case "[object Object]":
            {
                const t = [];
                for (const n in e)
                    t.push(`@"${n}": ${BJ(e[n])}`);
                return `@{ ${t.join(n)} }`
            }
        case "[object Boolean]":
            return e ? "@YES" : "@NO";
        default:
            return null == e ? "" : `@"${e.toString().replace(/"/g, '\\"')}"`
        }
    }
      , UJ = {
        info: {
            key: "objc",
            title: "Objective-C",
            extname: ".m",
            default: "nsurlsession"
        },
        clientsById: {
            nsurlsession: {
                info: {
                    key: "nsurlsession",
                    title: "NSURLSession",
                    link: "https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSession_class/index.html",
                    description: "Foundation's NSURLSession request"
                },
                convert: ({allHeaders: e, postData: t, method: n, fullUrl: r},o)=>{
                    var i;
                    const a = {
                        indent: "    ",
                        pretty: !0,
                        timeout: 10,
                        ...o
                    }
                      , {push: s, join: l, blank: c} = new pJ({
                        indent: a.indent
                    })
                      , u = {
                        hasHeaders: !1,
                        hasBody: !1
                    };
                    if (s("#import <Foundation/Foundation.h>"),
                    Object.keys(e).length && (u.hasHeaders = !0,
                    c(),
                    s(QJ("NSDictionary", "headers", e, a.pretty))),
                    t && (t.text || t.jsonObj || t.params))
                        switch (u.hasBody = !0,
                        t.mimeType) {
                        case "application/x-www-form-urlencoded":
                            if (null === (i = t.params) || void 0 === i ? void 0 : i.length) {
                                c();
                                const [e,...n] = t.params;
                                s(`NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"${e.name}=${e.value}" dataUsingEncoding:NSUTF8StringEncoding]];`),
                                n.forEach((({name: e, value: t})=>{
                                    s(`[postData appendData:[@"&${e}=${t}" dataUsingEncoding:NSUTF8StringEncoding]];`)
                                }
                                ))
                            } else
                                u.hasBody = !1;
                            break;
                        case "application/json":
                            t.jsonObj && (s(QJ("NSDictionary", "parameters", t.jsonObj, a.pretty)),
                            c(),
                            s("NSData *postData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:nil];"));
                            break;
                        case "multipart/form-data":
                            s(QJ("NSArray", "parameters", t.params || [], a.pretty)),
                            s(`NSString *boundary = @"${t.boundary}";`),
                            c(),
                            s("NSError *error;"),
                            s("NSMutableString *body = [NSMutableString string];"),
                            s("for (NSDictionary *param in parameters) {"),
                            s('[body appendFormat:@"--%@\\r\\n", boundary];', 1),
                            s('if (param[@"fileName"]) {', 1),
                            s('[body appendFormat:@"Content-Disposition:form-data; name=\\"%@\\"; filename=\\"%@\\"\\r\\n", param[@"name"], param[@"fileName"]];', 2),
                            s('[body appendFormat:@"Content-Type: %@\\r\\n\\r\\n", param[@"contentType"]];', 2),
                            s('[body appendFormat:@"%@", [NSString stringWithContentsOfFile:param[@"fileName"] encoding:NSUTF8StringEncoding error:&error]];', 2),
                            s("if (error) {", 2),
                            s('NSLog(@"%@", error);', 3),
                            s("}", 2),
                            s("} else {", 1),
                            s('[body appendFormat:@"Content-Disposition:form-data; name=\\"%@\\"\\r\\n\\r\\n", param[@"name"]];', 2),
                            s('[body appendFormat:@"%@", param[@"value"]];', 2),
                            s("}", 1),
                            s("}"),
                            s('[body appendFormat:@"\\r\\n--%@--\\r\\n", boundary];'),
                            s("NSData *postData = [body dataUsingEncoding:NSUTF8StringEncoding];");
                            break;
                        default:
                            c(),
                            s(`NSData *postData = [[NSData alloc] initWithData:[@"${t.text}" dataUsingEncoding:NSUTF8StringEncoding]];`)
                        }
                    return c(),
                    s(`NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"${r}"]`),
                    s("                                                       cachePolicy:NSURLRequestUseProtocolCachePolicy"),
                    s(`                                                   timeoutInterval:${a.timeout.toFixed(1)}];`),
                    s(`[request setHTTPMethod:@"${n}"];`),
                    u.hasHeaders && s("[request setAllHTTPHeaderFields:headers];"),
                    u.hasBody && s("[request setHTTPBody:postData];"),
                    c(),
                    s("NSURLSession *session = [NSURLSession sharedSession];"),
                    s("NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request"),
                    s("                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {"),
                    s("                                            if (error) {", 1),
                    s('                                            NSLog(@"%@", error);', 2),
                    s("                                            } else {", 1),
                    s("                                            NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;", 2),
                    s('                                            NSLog(@"%@", httpResponse);', 2),
                    s("                                            }", 1),
                    s("                                            }];"),
                    s("[dataTask resume];"),
                    l()
                }
            }
        }
    }
      , FJ = {
        info: {
            key: "ocaml",
            title: "OCaml",
            extname: ".ml",
            default: "cohttp"
        },
        clientsById: {
            cohttp: {
                info: {
                    key: "cohttp",
                    title: "CoHTTP",
                    link: "https://github.com/mirage/ocaml-cohttp",
                    description: "Cohttp is a very lightweight HTTP server using Lwt or Async for OCaml"
                },
                convert: ({fullUrl: e, allHeaders: t, postData: n, method: r},o)=>{
                    const i = {
                        indent: "  ",
                        ...o
                    }
                      , {push: a, blank: s, join: l} = new pJ({
                        indent: i.indent
                    });
                    a("open Cohttp_lwt_unix"),
                    a("open Cohttp"),
                    a("open Lwt"),
                    s(),
                    a(`let uri = Uri.of_string "${e}" in`);
                    const c = Object.keys(t);
                    1 === c.length ? a(`let headers = Header.add (Header.init ()) "${c[0]}" "${mJ(t[c[0]])}" in`) : c.length > 1 && (a("let headers = Header.add_list (Header.init ()) ["),
                    c.forEach((e=>{
                        a(`("${e}", "${mJ(t[e])}");`, 1)
                    }
                    )),
                    a("] in")),
                    (null == n ? void 0 : n.text) && a(`let body = Cohttp_lwt_body.of_string ${JSON.stringify(n.text)} in`),
                    s();
                    const u = c.length ? "~headers " : ""
                      , d = (null == n ? void 0 : n.text) ? "~body " : ""
                      , p = ["get", "post", "head", "delete", "patch", "put", "options"].includes(r.toLowerCase()) ? `\`${r.toUpperCase()}` : `(Code.method_of_string "${r}")`;
                    return a(`Client.call ${u}${d}${p} uri`),
                    a(">>= fun (res, body_stream) ->"),
                    a("(* Do stuff with the result *)", 1),
                    l()
                }
            }
        }
    }
      , jJ = (e,t,n)=>{
        switch (n = n || "",
        t = t || "",
        Object.prototype.toString.call(e)) {
        case "[object Null]":
        case "[object Undefined]":
        default:
            return "null";
        case "[object String]":
            return `'${hJ(e, {
                delimiter: "'",
                escapeNewlines: !1
            })}'`;
        case "[object Number]":
            return e.toString();
        case "[object Array]":
            {
                const r = e.map((e=>jJ(e, `${t}${t}`, t))).join(`,\n${t}`);
                return `[\n${t}${r}\n${n}]`
            }
        case "[object Object]":
            {
                const r = [];
                for (const n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && r.push(`${jJ(n, t)} => ${jJ(e[n], `${t}${t}`, t)}`);
                return `[\n${t}${r.join(`,\n${t}`)}\n ${n}]`
            }
        }
    }
      , zJ = ["ACL", "BASELINE_CONTROL", "CHECKIN", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LABEL", "LOCK", "MERGE", "MKACTIVITY", "MKCOL", "MKWORKSPACE", "MOVE", "OPTIONS", "POST", "PROPFIND", "PROPPATCH", "PUT", "REPORT", "TRACE", "UNCHECKOUT", "UNLOCK", "UPDATE", "VERSION_CONTROL"]
      , qJ = {
        info: {
            key: "php",
            title: "PHP",
            extname: ".php",
            default: "curl"
        },
        clientsById: {
            curl: {
                info: {
                    key: "curl",
                    title: "cURL",
                    link: "http://php.net/manual/en/book.curl.php",
                    description: "PHP with ext-curl"
                },
                convert: ({uriObj: e, postData: t, fullUrl: n, method: r, httpVersion: o, cookies: i, headersObj: a},s={})=>{
                    const {closingTag: l=!1, indent: c="  ", maxRedirects: u=10, namedErrors: d=!1, noTags: p=!1, shortTags: h=!1, timeout: f=30} = s
                      , {push: m, blank: g, join: b} = new pJ({
                        indent: c
                    });
                    p || (m(h ? "<?" : "<?php"),
                    g()),
                    m("$curl = curl_init();"),
                    g();
                    const O = [{
                        escape: !0,
                        name: "CURLOPT_PORT",
                        value: "" === e.port ? null : e.port
                    }, {
                        escape: !0,
                        name: "CURLOPT_URL",
                        value: n
                    }, {
                        escape: !1,
                        name: "CURLOPT_RETURNTRANSFER",
                        value: "true"
                    }, {
                        escape: !0,
                        name: "CURLOPT_ENCODING",
                        value: ""
                    }, {
                        escape: !1,
                        name: "CURLOPT_MAXREDIRS",
                        value: u
                    }, {
                        escape: !1,
                        name: "CURLOPT_TIMEOUT",
                        value: f
                    }, {
                        escape: !1,
                        name: "CURLOPT_HTTP_VERSION",
                        value: "HTTP/1.0" === o ? "CURL_HTTP_VERSION_1_0" : "CURL_HTTP_VERSION_1_1"
                    }, {
                        escape: !0,
                        name: "CURLOPT_CUSTOMREQUEST",
                        value: r
                    }, {
                        escape: !(null == t ? void 0 : t.jsonObj),
                        name: "CURLOPT_POSTFIELDS",
                        value: t ? t.jsonObj ? `json_encode(${jJ(t.jsonObj, c.repeat(2), c)})` : t.text : void 0
                    }];
                    m("curl_setopt_array($curl, [");
                    const v = new pJ({
                        indent: c,
                        join: `\n${c}`
                    });
                    O.forEach((({value: e, name: t, escape: n})=>{
                        null != e && v.push(`${t} => ${n ? JSON.stringify(e) : e},`)
                    }
                    ));
                    const y = i.map((e=>`${encodeURIComponent(e.name)}=${encodeURIComponent(e.value)}`));
                    y.length && v.push(`CURLOPT_COOKIE => "${y.join("; ")}",`);
                    const w = Object.keys(a).sort().map((e=>`"${e}: ${mJ(a[e])}"`));
                    return w.length && (v.push("CURLOPT_HTTPHEADER => ["),
                    v.push(w.join(`,\n${c}${c}`), 1),
                    v.push("],")),
                    m(v.join(), 1),
                    m("]);"),
                    g(),
                    m("$response = curl_exec($curl);"),
                    m("$err = curl_error($curl);"),
                    g(),
                    m("curl_close($curl);"),
                    g(),
                    m("if ($err) {"),
                    m(d ? 'echo array_flip(get_defined_constants(true)["curl"])[$err];' : 'echo "cURL Error #:" . $err;', 1),
                    m("} else {"),
                    m("echo $response;", 1),
                    m("}"),
                    !p && l && (g(),
                    m("?>")),
                    b()
                }
            },
            guzzle: {
                info: {
                    key: "guzzle",
                    title: "Guzzle",
                    link: "http://docs.guzzlephp.org/en/stable/",
                    description: "PHP with Guzzle"
                },
                convert: ({postData: e, fullUrl: t, method: n, cookies: r, headersObj: o},i)=>{
                    var a;
                    const s = {
                        closingTag: !1,
                        indent: "  ",
                        noTags: !1,
                        shortTags: !1,
                        ...i
                    }
                      , {push: l, blank: c, join: u} = new pJ({
                        indent: s.indent
                    })
                      , {code: d, push: p, join: h} = new pJ({
                        indent: s.indent
                    });
                    switch (s.noTags || (l(s.shortTags ? "<?" : "<?php"),
                    c()),
                    null == e ? void 0 : e.mimeType) {
                    case "application/x-www-form-urlencoded":
                        p(`'form_params' => ${jJ(e.paramsObj, s.indent + s.indent, s.indent)},`, 1);
                        break;
                    case "multipart/form-data":
                        {
                            const t = [];
                            if (e.params && e.params.forEach((function(e) {
                                if (e.fileName) {
                                    const n = {
                                        name: e.name,
                                        filename: e.fileName,
                                        contents: e.value
                                    };
                                    e.contentType && (n.headers = {
                                        "Content-Type": e.contentType
                                    }),
                                    t.push(n)
                                } else
                                    e.value && t.push({
                                        name: e.name,
                                        contents: e.value
                                    })
                            }
                            )),
                            t.length && (p(`'multipart' => ${jJ(t, s.indent + s.indent, s.indent)}`, 1),
                            sJ(o, "content-type") && (null === (a = aJ(o, "content-type")) || void 0 === a ? void 0 : a.indexOf("boundary")))) {
                                const e = iJ(o, "content-type");
                                e && delete o[e]
                            }
                            break
                        }
                    default:
                        (null == e ? void 0 : e.text) && p(`'body' => ${jJ(e.text)},`, 1)
                    }
                    const f = Object.keys(o).sort().map((function(e) {
                        return `${s.indent}${s.indent}'${e}' => '${fJ(o[e])}',`
                    }
                    ))
                      , m = r.map((e=>`${encodeURIComponent(e.name)}=${encodeURIComponent(e.value)}`)).join("; ");
                    return m.length && f.push(`${s.indent}${s.indent}'cookie' => '${fJ(m)}',`),
                    f.length && (p("'headers' => [", 1),
                    p(f.join("\n")),
                    p("],", 1)),
                    l("$client = new \\GuzzleHttp\\Client();"),
                    c(),
                    d.length ? (l(`$response = $client->request('${n}', '${t}', [`),
                    l(h()),
                    l("]);")) : l(`$response = $client->request('${n}', '${t}');`),
                    c(),
                    l("echo $response->getBody();"),
                    !s.noTags && s.closingTag && (c(),
                    l("?>")),
                    u()
                }
            },
            http1: {
                info: {
                    key: "http1",
                    title: "HTTP v1",
                    link: "http://php.net/manual/en/book.http.php",
                    description: "PHP with pecl/http v1"
                },
                convert: ({method: e, url: t, postData: n, queryObj: r, headersObj: o, cookiesObj: i},a={})=>{
                    const {closingTag: s=!1, indent: l="  ", noTags: c=!1, shortTags: u=!1} = a
                      , {push: d, blank: p, join: h} = new pJ({
                        indent: l
                    });
                    switch (c || (d(u ? "<?" : "<?php"),
                    p()),
                    zJ.includes(e.toUpperCase()) || d(`HttpRequest::methodRegister('${e}');`),
                    d("$request = new HttpRequest();"),
                    d(`$request->setUrl(${jJ(t)});`),
                    zJ.includes(e.toUpperCase()) ? d(`$request->setMethod(HTTP_METH_${e.toUpperCase()});`) : d(`$request->setMethod(HttpRequest::HTTP_METH_${e.toUpperCase()});`),
                    p(),
                    Object.keys(r).length && (d(`$request->setQueryData(${jJ(r, l)});`),
                    p()),
                    Object.keys(o).length && (d(`$request->setHeaders(${jJ(o, l)});`),
                    p()),
                    Object.keys(i).length && (d(`$request->setCookies(${jJ(i, l)});`),
                    p()),
                    null == n ? void 0 : n.mimeType) {
                    case "application/x-www-form-urlencoded":
                        d(`$request->setContentType(${jJ(n.mimeType)});`),
                        d(`$request->setPostFields(${jJ(n.paramsObj, l)});`),
                        p();
                        break;
                    case "application/json":
                        d(`$request->setContentType(${jJ(n.mimeType)});`),
                        d(`$request->setBody(json_encode(${jJ(n.jsonObj, l)}));`),
                        p();
                        break;
                    default:
                        (null == n ? void 0 : n.text) && (d(`$request->setBody(${jJ(n.text)});`),
                        p())
                    }
                    return d("try {"),
                    d("$response = $request->send();", 1),
                    p(),
                    d("echo $response->getBody();", 1),
                    d("} catch (HttpException $ex) {"),
                    d("echo $ex;", 1),
                    d("}"),
                    !c && s && (p(),
                    d("?>")),
                    h()
                }
            },
            http2: {
                info: {
                    key: "http2",
                    title: "HTTP v2",
                    link: "http://devel-m6w6.rhcloud.com/mdref/http",
                    description: "PHP with pecl/http v2"
                },
                convert: ({postData: e, headersObj: t, method: n, queryObj: r, cookiesObj: o, url: i},a={})=>{
                    var s;
                    const {closingTag: l=!1, indent: c="  ", noTags: u=!1, shortTags: d=!1} = a
                      , {push: p, blank: h, join: f} = new pJ({
                        indent: c
                    });
                    let m = !1;
                    switch (u || (p(d ? "<?" : "<?php"),
                    h()),
                    p("$client = new http\\Client;"),
                    p("$request = new http\\Client\\Request;"),
                    h(),
                    null == e ? void 0 : e.mimeType) {
                    case "application/x-www-form-urlencoded":
                        p("$body = new http\\Message\\Body;"),
                        p(`$body->append(new http\\QueryString(${jJ(e.paramsObj, c)}));`),
                        h(),
                        m = !0;
                        break;
                    case "multipart/form-data":
                        {
                            if (!e.params)
                                break;
                            const n = []
                              , r = {};
                            e.params.forEach((({name: e, fileName: t, value: o, contentType: i})=>{
                                t ? n.push({
                                    name: e,
                                    type: i,
                                    file: t,
                                    data: o
                                }) : o && (r[e] = o)
                            }
                            ));
                            const o = Object.keys(r).length ? jJ(r, c) : "null"
                              , i = n.length ? jJ(n, c) : "null";
                            if (p("$body = new http\\Message\\Body;"),
                            p(`$body->addForm(${o}, ${i});`),
                            sJ(t, "content-type") && (null === (s = aJ(t, "content-type")) || void 0 === s ? void 0 : s.indexOf("boundary"))) {
                                const e = iJ(t, "content-type");
                                e && delete t[e]
                            }
                            h(),
                            m = !0;
                            break
                        }
                    case "application/json":
                        p("$body = new http\\Message\\Body;"),
                        p(`$body->append(json_encode(${jJ(e.jsonObj, c)}));`),
                        m = !0;
                        break;
                    default:
                        (null == e ? void 0 : e.text) && (p("$body = new http\\Message\\Body;"),
                        p(`$body->append(${jJ(e.text)});`),
                        h(),
                        m = !0)
                    }
                    return p(`$request->setRequestUrl(${jJ(i)});`),
                    p(`$request->setRequestMethod(${jJ(n)});`),
                    m && (p("$request->setBody($body);"),
                    h()),
                    Object.keys(r).length && (p(`$request->setQuery(new http\\QueryString(${jJ(r, c)}));`),
                    h()),
                    Object.keys(t).length && (p(`$request->setHeaders(${jJ(t, c)});`),
                    h()),
                    Object.keys(o).length && (h(),
                    p(`$client->setCookies(${jJ(o, c)});`),
                    h()),
                    p("$client->enqueue($request)->send();"),
                    p("$response = $client->getResponse();"),
                    h(),
                    p("echo $response->getBody();"),
                    !u && l && (h(),
                    p("?>")),
                    f()
                }
            }
        }
    }
      , HJ = e=>({method: t, headersObj: n, cookies: r, uriObj: o, fullUrl: i, postData: a, allHeaders: s})=>{
        const {push: l, join: c} = new pJ;
        if (!["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"].includes(t.toUpperCase()))
            return "Method not supported";
        const u = []
          , d = Object.keys(n);
        return d.length && (l("$headers=@{}"),
        d.forEach((e=>{
            "connection" !== e && l(`$headers.Add("${e}", "${hJ(n[e], {
                escapeChar: "`"
            })}")`)
        }
        )),
        u.push("-Headers $headers")),
        r.length && (l("$session = New-Object Microsoft.PowerShell.Commands.WebRequestSession"),
        r.forEach((e=>{
            l("$cookie = New-Object System.Net.Cookie"),
            l(`$cookie.Name = '${e.name}'`),
            l(`$cookie.Value = '${e.value}'`),
            l(`$cookie.Domain = '${o.host}'`),
            l("$session.Cookies.Add($cookie)")
        }
        )),
        u.push("-WebSession $session")),
        (null == a ? void 0 : a.text) && (u.push(`-ContentType '${hJ(aJ(s, "content-type"), {
            delimiter: "'",
            escapeChar: "`"
        })}'`),
        u.push(`-Body '${a.text}'`)),
        l(`$response = ${e} -Uri '${i}' -Method ${t} ${u.join(" ")}`),
        c()
    }
      , ZJ = {
        info: {
            key: "restmethod",
            title: "Invoke-RestMethod",
            link: "https://docs.microsoft.com/en-us/powershell/module/Microsoft.PowerShell.Utility/Invoke-RestMethod",
            description: "Powershell Invoke-RestMethod client"
        },
        convert: HJ("Invoke-RestMethod")
    }
      , WJ = {
        info: {
            key: "webrequest",
            title: "Invoke-WebRequest",
            link: "https://docs.microsoft.com/en-us/powershell/module/Microsoft.PowerShell.Utility/Invoke-WebRequest",
            description: "Powershell Invoke-WebRequest client"
        },
        convert: HJ("Invoke-WebRequest")
    };
    function XJ(e, t, n, r, o) {
        const i = r.repeat(o)
          , a = r.repeat(o - 1)
          , s = n ? `,\n${i}` : ", "
          , l = "object" === e ? "{" : "["
          , c = "object" === e ? "}" : "]";
        return n ? `${l}\n${i}${t.join(s)}\n${a}${c}` : "object" === e && t.length > 0 ? `${l} ${t.join(s)} ${c}` : `${l}${t.join(s)}${c}`
    }
    const VJ = (e,t,n)=>{
        switch (n = void 0 === n ? 1 : n + 1,
        Object.prototype.toString.call(e)) {
        case "[object Number]":
            return e;
        case "[object Array]":
            {
                let r = !1;
                return XJ("array", e.map((e=>("[object Object]" === Object.prototype.toString.call(e) && (r = Object.keys(e).length > 1),
                VJ(e, t, n)))), r, t.indent, n)
            }
        case "[object Object]":
            {
                const r = [];
                for (const o in e)
                    r.push(`"${o}": ${VJ(e[o], t, n)}`);
                return XJ("object", r, t.pretty && r.length > 1, t.indent, n)
            }
        case "[object Null]":
            return "None";
        case "[object Boolean]":
            return e ? "True" : "False";
        default:
            return null == e ? "" : `"${e.toString().replace(/"/g, '\\"')}"`
        }
    }
      , GJ = ["HEAD", "GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"]
      , YJ = {
        info: {
            key: "httr",
            title: "httr",
            link: "https://cran.r-project.org/web/packages/httr/vignettes/quickstart.html",
            description: "httr: Tools for Working with URLs and HTTP"
        },
        convert: ({url: e, queryObj: t, queryString: n, postData: r, allHeaders: o, method: i},a={})=>{
            var s, l;
            const {push: c, blank: u, join: d} = new pJ({
                indent: null !== (s = a.indent) && void 0 !== s ? s : "  "
            });
            c("library(httr)"),
            u(),
            c(`url <- "${e}"`),
            u();
            const p = t;
            delete t.key;
            const h = Object.entries(p)
              , f = h.length;
            if (1 === f) {
                const e = h[0];
                c(`queryString <- list(${e[0]} = "${e[1]}")`),
                u()
            } else
                f > 1 && (c("queryString <- list("),
                h.forEach((([e,t],n)=>{
                    c(`${e} = "${t}"${n !== f - 1 ? "," : ""}`, 1)
                }
                )),
                c(")"),
                u());
            const m = JSON.stringify(null == r ? void 0 : r.text);
            if (m && (c(`payload <- ${m}`),
            u()),
            r && (r.text || r.jsonObj || r.params))
                switch (r.mimeType) {
                case "application/x-www-form-urlencoded":
                    c('encode <- "form"'),
                    u();
                    break;
                case "application/json":
                    c('encode <- "json"'),
                    u();
                    break;
                case "multipart/form-data":
                    c('encode <- "multipart"'),
                    u();
                    break;
                default:
                    c('encode <- "raw"'),
                    u()
                }
            const g = aJ(o, "cookie")
              , b = aJ(o, "accept")
              , O = g ? `set_cookies(\`${String(g).replace(/;/g, '", `').replace(/` /g, "`").replace(/[=]/g, '` = "')}")` : void 0
              , v = b ? `accept("${mJ(b)}")` : void 0
              , y = `content_type("${mJ(null !== (l = null == r ? void 0 : r.mimeType) && void 0 !== l ? l : "application/octet-stream")}")`
              , w = Object.entries(o).filter((([e])=>!["cookie", "accept", "content-type"].includes(e.toLowerCase()))).map((([e,t])=>`'${e}' = '${fJ(t)}'`)).join(", ")
              , _ = w ? `add_headers(${w})` : void 0;
            let k = `response <- VERB("${i}", url`;
            m && (k += ", body = payload"),
            n.length && (k += ", query = queryString");
            const S = [_, y, v, O].filter((e=>!!e)).join(", ");
            return S && (k += `, ${S}`),
            r && (r.text || r.jsonObj || r.params) && (k += ", encode = encode"),
            k += ")",
            c(k),
            u(),
            c('content(response, "text")'),
            d()
        }
    }
      , KJ = (e="")=>/^[a-z0-9-_/.@%^=:]+$/i.test(e) ? e : `'${e.replace(/'/g, "'\\''")}'`
      , JJ = {
        "http1.0": "0",
        "url ": "",
        cookie: "b",
        data: "d",
        form: "F",
        globoff: "g",
        header: "H",
        insecure: "k",
        request: "X"
    }
      , e0 = (e,t)=>t.repeat(e)
      , t0 = (e,t,n,r)=>{
        const o = e0(r, n)
          , i = e0(r - 1, n)
          , a = t ? `,\n${o}` : ", ";
        return t ? `[\n${o}${e.join(a)}\n${i}]` : `[${e.join(a)}]`
    }
      , n0 = (e,t,n)=>`let ${e} = ${r0(t, n)}`
      , r0 = (e,t,n)=>{
        switch (n = void 0 === n ? 1 : n + 1,
        Object.prototype.toString.call(e)) {
        case "[object Number]":
            return e;
        case "[object Array]":
            {
                let r = !1;
                const o = e.map((e=>("[object Object]" === Object.prototype.toString.call(e) && (r = Object.keys(e).length > 1),
                r0(e, t, n))));
                return t0(o, r, t.indent, n)
            }
        case "[object Object]":
            {
                const r = [];
                for (const o in e)
                    r.push(`"${o}": ${r0(e[o], t, n)}`);
                return t0(r, t.pretty && r.length > 1, t.indent, n)
            }
        case "[object Boolean]":
            return e.toString();
        default:
            return null == e ? "" : `"${e.toString().replace(/"/g, '\\"')}"`
        }
    }
      , o0 = {
        c: gJ,
        clojure: SJ,
        csharp: EJ,
        go: xJ,
        http: TJ,
        java: AJ,
        javascript: IJ,
        kotlin: MJ,
        node: LJ,
        objc: UJ,
        ocaml: FJ,
        php: qJ,
        powershell: {
            info: {
                key: "powershell",
                title: "Powershell",
                extname: ".ps1",
                default: "webrequest"
            },
            clientsById: {
                webrequest: WJ,
                restmethod: ZJ
            }
        },
        python: {
            info: {
                key: "python",
                title: "Python",
                extname: ".py",
                default: "python3"
            },
            clientsById: {
                python3: {
                    info: {
                        key: "python3",
                        title: "http.client",
                        link: "https://docs.python.org/3/library/http.client.html",
                        description: "Python3 HTTP Client"
                    },
                    convert: ({uriObj: {path: e, protocol: t, host: n}, postData: r, allHeaders: o, method: i},a={})=>{
                        const {insecureSkipVerify: s=!1} = a
                          , {push: l, blank: c, join: u} = new pJ;
                        if (l("import http.client"),
                        s && l("import ssl"),
                        c(),
                        "https:" === t) {
                            l(`conn = http.client.HTTPSConnection("${n}"${s ? ", context = ssl._create_unverified_context()" : ""})`),
                            c()
                        } else
                            l(`conn = http.client.HTTPConnection("${n}")`),
                            c();
                        const d = JSON.stringify(null == r ? void 0 : r.text);
                        d && (l(`payload = ${d}`),
                        c());
                        const p = o
                          , h = Object.keys(p).length;
                        if (1 === h)
                            for (const f in p)
                                l(`headers = { '${f}': "${mJ(p[f])}" }`),
                                c();
                        else if (h > 1) {
                            let e = 1;
                            l("headers = {");
                            for (const t in p)
                                e++ !== h ? l(`    '${t}': "${mJ(p[t])}",`) : l(`    '${t}': "${mJ(p[t])}"`);
                            l("}"),
                            c()
                        }
                        return l(d && h ? `conn.request("${i}", "${e}", payload, headers)` : d && !h ? `conn.request("${i}", "${e}", payload)` : !d && h ? `conn.request("${i}", "${e}", headers=headers)` : `conn.request("${i}", "${e}")`),
                        c(),
                        l("res = conn.getresponse()"),
                        l("data = res.read()"),
                        c(),
                        l('print(data.decode("utf-8"))'),
                        u()
                    }
                },
                requests: {
                    info: {
                        key: "requests",
                        title: "Requests",
                        link: "http://docs.python-requests.org/en/latest/api/#requests.request",
                        description: "Requests HTTP library"
                    },
                    convert: ({queryObj: e, url: t, postData: n, allHeaders: r, method: o},i)=>{
                        const a = {
                            indent: "    ",
                            pretty: !0,
                            ...i
                        }
                          , {push: s, blank: l, join: c} = new pJ({
                            indent: a.indent
                        });
                        let u;
                        s("import requests"),
                        l(),
                        s(`url = "${t}"`),
                        l(),
                        Object.keys(e).length && (u = `querystring = ${JSON.stringify(e)}`,
                        s(u),
                        l());
                        const d = r;
                        let p = {};
                        const h = {};
                        let f = !1
                          , m = !1
                          , g = !1;
                        switch (null == n ? void 0 : n.mimeType) {
                        case "application/json":
                            n.jsonObj && (s(`payload = ${VJ(n.jsonObj, a)}`),
                            g = !0,
                            m = !0);
                            break;
                        case "multipart/form-data":
                            if (!n.params)
                                break;
                            if (p = {},
                            n.params.forEach((e=>{
                                e.fileName ? (h[e.name] = `open('${e.fileName}', 'rb')`,
                                f = !0) : (p[e.name] = e.value,
                                m = !0)
                            }
                            )),
                            f) {
                                s(`files = ${VJ(h, a)}`),
                                m && s(`payload = ${VJ(p, a)}`);
                                const e = iJ(d, "content-type");
                                e && delete d[e]
                            } else {
                                const e = JSON.stringify(n.text);
                                e && (s(`payload = ${e}`),
                                m = !0)
                            }
                            break;
                        default:
                            {
                                if (!n)
                                    break;
                                if ("application/x-www-form-urlencoded" === n.mimeType && n.paramsObj) {
                                    s(`payload = ${VJ(n.paramsObj, a)}`),
                                    m = !0;
                                    break
                                }
                                const e = JSON.stringify(n.text);
                                e && (s(`payload = ${e}`),
                                m = !0)
                            }
                        }
                        const b = Object.keys(d).length;
                        if (0 === b && (m || f))
                            l();
                        else if (1 === b)
                            for (const v in d)
                                s(`headers = {"${v}": "${mJ(d[v])}"}`),
                                l();
                        else if (b > 1) {
                            let e = 1;
                            s("headers = {");
                            for (const t in d)
                                s(e !== b ? `"${t}": "${mJ(d[t])}",` : `"${t}": "${mJ(d[t])}"`, 1),
                                e += 1;
                            s("}"),
                            l()
                        }
                        let O = GJ.includes(o) ? `response = requests.${o.toLowerCase()}(url` : `response = requests.request("${o}", url`;
                        return m && (O += g ? ", json=payload" : ", data=payload"),
                        f && (O += ", files=files"),
                        b > 0 && (O += ", headers=headers"),
                        u && (O += ", params=querystring"),
                        O += ")",
                        s(O),
                        l(),
                        s("print(response.json())"),
                        c()
                    }
                }
            }
        },
        r: {
            info: {
                key: "r",
                title: "R",
                extname: ".r",
                default: "httr"
            },
            clientsById: {
                httr: YJ
            }
        },
        ruby: {
            info: {
                key: "ruby",
                title: "Ruby",
                extname: ".rb",
                default: "native"
            },
            clientsById: {
                native: {
                    info: {
                        key: "native",
                        title: "net::http",
                        link: "http://ruby-doc.org/stdlib-2.2.1/libdoc/net/http/rdoc/Net/HTTP.html",
                        description: "Ruby HTTP client"
                    },
                    convert: ({uriObj: e, method: t, fullUrl: n, postData: r, allHeaders: o},i={})=>{
                        const {insecureSkipVerify: a=!1} = i
                          , {push: s, blank: l, join: c} = new pJ;
                        s("require 'uri'"),
                        s("require 'net/http'"),
                        l();
                        const u = t.toUpperCase()
                          , d = u.charAt(0) + u.substring(1).toLowerCase();
                        ["GET", "POST", "HEAD", "DELETE", "PATCH", "PUT", "OPTIONS", "COPY", "LOCK", "UNLOCK", "MOVE", "TRACE"].includes(u) || (s(`class Net::HTTP::${d} < Net::HTTPRequest`),
                        s(`  METHOD = '${u.toUpperCase()}'`),
                        s(`  REQUEST_HAS_BODY = '${(null == r ? void 0 : r.text) ? "true" : "false"}'`),
                        s("  RESPONSE_HAS_BODY = true"),
                        s("end"),
                        l()),
                        s(`url = URI("${n}")`),
                        l(),
                        s("http = Net::HTTP.new(url.host, url.port)"),
                        "https:" === e.protocol && (s("http.use_ssl = true"),
                        a && s("http.verify_mode = OpenSSL::SSL::VERIFY_NONE")),
                        l(),
                        s(`request = Net::HTTP::${d}.new(url)`);
                        const p = Object.keys(o);
                        return p.length && p.forEach((e=>{
                            s(`request["${e}"] = '${fJ(o[e])}'`)
                        }
                        )),
                        (null == r ? void 0 : r.text) && s(`request.body = ${JSON.stringify(r.text)}`),
                        l(),
                        s("response = http.request(request)"),
                        s("puts response.read_body"),
                        c()
                    }
                }
            }
        },
        shell: {
            info: {
                key: "shell",
                title: "Shell",
                extname: ".sh",
                default: "curl"
            },
            clientsById: {
                curl: {
                    info: {
                        key: "curl",
                        title: "cURL",
                        link: "http://curl.haxx.se/",
                        description: "cURL is a command line tool and library for transferring data with URL syntax"
                    },
                    convert: ({fullUrl: e, method: t, httpVersion: n, headersObj: r, allHeaders: o, postData: i},a={})=>{
                        var s;
                        const {binary: l=!1, globOff: c=!1, indent: u="  ", insecureSkipVerify: d=!1, prettifyJson: p=!1, short: h=!1} = a
                          , {push: f, join: m} = new pJ({
                            ..."string" == typeof u ? {
                                indent: u
                            } : {},
                            join: !1 !== u ? ` \\\n${u}` : " "
                        })
                          , g = (e=>t=>{
                            if (e) {
                                const e = JJ[t];
                                return e ? `-${e}` : ""
                            }
                            return `--${t}`
                        }
                        )(h);
                        let b = KJ(e);
                        if (f(`curl ${g("request")} ${t}`),
                        c && (b = unescape(b),
                        f(g("globoff"))),
                        f(`${g("url ")}${b}`),
                        d && f(g("insecure")),
                        "HTTP/1.0" === n && f(g("http1.0")),
                        aJ(o, "accept-encoding") && f("--compressed"),
                        "multipart/form-data" === (null == i ? void 0 : i.mimeType)) {
                            const e = iJ(r, "content-type");
                            if (e) {
                                const t = r[e];
                                if (e && t) {
                                    const n = t.replace(/; boundary.+?(?=(;|$))/, "");
                                    r[e] = n,
                                    o[e] = n
                                }
                            }
                        }
                        switch (Object.keys(r).sort().forEach((e=>{
                            const t = `${e}: ${r[e]}`;
                            f(`${g("header")} ${KJ(t)}`)
                        }
                        )),
                        o.cookie && f(`${g("cookie")} ${KJ(o.cookie)}`),
                        null == i ? void 0 : i.mimeType) {
                        case "multipart/form-data":
                            null === (s = i.params) || void 0 === s || s.forEach((e=>{
                                let t = "";
                                t = e.fileName ? `${e.name}=@${e.fileName}` : `${e.name}=${e.value}`,
                                f(`${g("form")} ${KJ(t)}`)
                            }
                            ));
                            break;
                        case "application/x-www-form-urlencoded":
                            i.params ? i.params.forEach((e=>{
                                const t = e.name
                                  , n = encodeURIComponent(e.name)
                                  , r = n !== t;
                                f(`${l ? "--data-binary" : "--data" + (r ? "-urlencode" : "")} ${KJ(`${r ? n : t}=${e.value}`)}`)
                            }
                            )) : f(`${l ? "--data-binary" : g("data")} ${KJ(i.text)}`);
                            break;
                        default:
                            {
                                if (!i)
                                    break;
                                if (!i.text)
                                    break;
                                const e = l ? "--data-binary" : g("data");
                                let t = !1;
                                if (O = i.mimeType,
                                lJ.some((e=>O.includes(e)))) {
                                    if (i.text.length > 2 && p)
                                        try {
                                            const n = JSON.parse(i.text);
                                            t = !0;
                                            const r = JSON.stringify(n, void 0, u);
                                            i.text.indexOf("'") > 0 ? f(`${e} @- <<EOF\n${r}\nEOF`) : f(`${e} '\n${r}\n'`)
                                        } catch (v) {}
                                }
                                t || f(`${e} ${KJ(i.text)}`)
                            }
                        }
                        var O;
                        return m()
                    }
                },
                httpie: {
                    info: {
                        key: "httpie",
                        title: "HTTPie",
                        link: "http://httpie.org/",
                        description: "a CLI, cURL-like tool for humans"
                    },
                    convert: ({allHeaders: e, postData: t, queryObj: n, fullUrl: r, method: o, url: i},a)=>{
                        const s = {
                            body: !1,
                            cert: !1,
                            headers: !1,
                            indent: "  ",
                            pretty: !1,
                            print: !1,
                            queryParams: !1,
                            short: !1,
                            style: !1,
                            timeout: !1,
                            verbose: !1,
                            verify: !1,
                            ...a
                        }
                          , {push: l, join: c, unshift: u} = new pJ({
                            indent: s.indent,
                            join: !1 !== s.indent ? ` \\\n${s.indent}` : " "
                        });
                        let d = !1;
                        const p = [];
                        s.headers && p.push(s.short ? "-h" : "--headers"),
                        s.body && p.push(s.short ? "-b" : "--body"),
                        s.verbose && p.push(s.short ? "-v" : "--verbose"),
                        s.print && p.push(`${s.short ? "-p" : "--print"}=${s.print}`),
                        s.verify && p.push(`--verify=${s.verify}`),
                        s.cert && p.push(`--cert=${s.cert}`),
                        s.pretty && p.push(`--pretty=${s.pretty}`),
                        s.style && p.push(`--style=${s.style}`),
                        s.timeout && p.push(`--timeout=${s.timeout}`),
                        s.queryParams && Object.keys(n).forEach((e=>{
                            const t = n[e];
                            Array.isArray(t) ? t.forEach((t=>{
                                l(`${e}==${KJ(t)}`)
                            }
                            )) : l(`${e}==${KJ(t)}`)
                        }
                        )),
                        Object.keys(e).sort().forEach((t=>{
                            l(`${t}:${KJ(e[t])}`)
                        }
                        )),
                        "application/x-www-form-urlencoded" === (null == t ? void 0 : t.mimeType) ? t.params && t.params.length && (p.push(s.short ? "-f" : "--form"),
                        t.params.forEach((e=>{
                            l(`${e.name}=${KJ(e.value)}`)
                        }
                        ))) : d = !0;
                        if (u(`http ${p.length ? `${p.join(" ")} ` : ""}${o} ${i = KJ(s.queryParams ? i : r)}`),
                        d && (null == t ? void 0 : t.text)) {
                            u(`echo ${KJ(t.text)} | `)
                        }
                        return c()
                    }
                },
                wget: {
                    info: {
                        key: "wget",
                        title: "Wget",
                        link: "https://www.gnu.org/software/wget/",
                        description: "a free software package for retrieving files using HTTP, HTTPS"
                    },
                    convert: ({method: e, postData: t, allHeaders: n, fullUrl: r},o)=>{
                        const i = {
                            indent: "  ",
                            short: !1,
                            verbose: !1,
                            ...o
                        }
                          , {push: a, join: s} = new pJ({
                            indent: i.indent,
                            join: !1 !== i.indent ? ` \\\n${i.indent}` : " "
                        });
                        var l;
                        return i.verbose ? a("wget " + (i.short ? "-v" : "--verbose")) : a("wget " + (i.short ? "-q" : "--quiet")),
                        a(`--method ${KJ(e)}`),
                        Object.keys(n).forEach((e=>{
                            const t = `${e}: ${n[e]}`;
                            a(`--header ${KJ(t)}`)
                        }
                        )),
                        (null == t ? void 0 : t.text) && a(`--body-data ${l = KJ(t.text),
                        l.replace(/\r/g, "\\r").replace(/\n/g, "\\n")}`),
                        a(i.short ? "-O" : "--output-document"),
                        a(`- ${KJ(r)}`),
                        s()
                    }
                }
            }
        },
        swift: {
            info: {
                key: "swift",
                title: "Swift",
                extname: ".swift",
                default: "nsurlsession"
            },
            clientsById: {
                nsurlsession: {
                    info: {
                        key: "nsurlsession",
                        title: "NSURLSession",
                        link: "https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSession_class/index.html",
                        description: "Foundation's NSURLSession request"
                    },
                    convert: ({allHeaders: e, postData: t, fullUrl: n, method: r},o)=>{
                        var i;
                        const a = {
                            indent: "  ",
                            pretty: !0,
                            timeout: "10",
                            ...o
                        }
                          , {push: s, blank: l, join: c} = new pJ({
                            indent: a.indent
                        })
                          , u = {
                            hasHeaders: !1,
                            hasBody: !1
                        };
                        if (s("import Foundation"),
                        Object.keys(e).length && (u.hasHeaders = !0,
                        l(),
                        s(n0("headers", e, a))),
                        t && (t.text || t.jsonObj || t.params))
                            switch (u.hasBody = !0,
                            t.mimeType) {
                            case "application/x-www-form-urlencoded":
                                if (l(),
                                null === (i = t.params) || void 0 === i ? void 0 : i.length) {
                                    const [e,...n] = t.params;
                                    s(`let postData = NSMutableData(data: "${e.name}=${e.value}".data(using: String.Encoding.utf8)!)`),
                                    n.forEach((({name: e, value: t})=>{
                                        s(`postData.append("&${e}=${t}".data(using: String.Encoding.utf8)!)`)
                                    }
                                    ))
                                } else
                                    u.hasBody = !1;
                                break;
                            case "application/json":
                                t.jsonObj && (s(`${n0("parameters", t.jsonObj, a)} as [String : Any]`),
                                l(),
                                s("let postData = JSONSerialization.data(withJSONObject: parameters, options: [])"));
                                break;
                            case "multipart/form-data":
                                s(n0("parameters", t.params, a)),
                                l(),
                                s(`let boundary = "${t.boundary}"`),
                                l(),
                                s('var body = ""'),
                                s("var error: NSError? = nil"),
                                s("for param in parameters {"),
                                s('let paramName = param["name"]!', 1),
                                s('body += "--\\(boundary)\\r\\n"', 1),
                                s('body += "Content-Disposition:form-data; name=\\"\\(paramName)\\""', 1),
                                s('if let filename = param["fileName"] {', 1),
                                s('let contentType = param["content-type"]!', 2),
                                s("let fileContent = String(contentsOfFile: filename, encoding: String.Encoding.utf8)", 2),
                                s("if (error != nil) {", 2),
                                s("print(error as Any)", 3),
                                s("}", 2),
                                s('body += "; filename=\\"\\(filename)\\"\\r\\n"', 2),
                                s('body += "Content-Type: \\(contentType)\\r\\n\\r\\n"', 2),
                                s("body += fileContent", 2),
                                s('} else if let paramValue = param["value"] {', 1),
                                s('body += "\\r\\n\\r\\n\\(paramValue)"', 2),
                                s("}", 1),
                                s("}");
                                break;
                            default:
                                l(),
                                s(`let postData = NSData(data: "${t.text}".data(using: String.Encoding.utf8)!)`)
                            }
                        return l(),
                        s(`let request = NSMutableURLRequest(url: NSURL(string: "${n}")! as URL,`),
                        s("                                        cachePolicy: .useProtocolCachePolicy,"),
                        s(`                                    timeoutInterval: ${parseInt(a.timeout, 10).toFixed(1)})`),
                        s(`request.httpMethod = "${r}"`),
                        u.hasHeaders && s("request.allHTTPHeaderFields = headers"),
                        u.hasBody && s("request.httpBody = postData as Data"),
                        l(),
                        s("let session = URLSession.shared"),
                        s("let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in"),
                        s("if (error != nil) {", 1),
                        s("print(error as Any)", 2),
                        s("} else {", 1),
                        s("let httpResponse = response as? HTTPURLResponse", 2),
                        s("print(httpResponse)", 2),
                        s("}", 1),
                        s("})"),
                        l(),
                        s("dataTask.resume()"),
                        c()
                    }
                }
            }
        }
    };
    class i0 {
        constructor(e) {
            let t = [];
            var n;
            t = "object" == typeof (n = e) && "log"in n && "object" == typeof n.log && "entries"in n.log && Array.isArray(n.log.entries) ? e.log.entries : [{
                request: e
            }],
            this.requests = Promise.all(t.map((({request: e})=>{
                var t;
                const n = {
                    bodySize: 0,
                    headersSize: 0,
                    headers: [],
                    cookies: [],
                    httpVersion: "HTTP/1.1",
                    queryString: [],
                    postData: {
                        mimeType: (null === (t = e.postData) || void 0 === t ? void 0 : t.mimeType) || "application/octet-stream"
                    },
                    ...e
                };
                return this.prepare(n)
            }
            )))
        }
        async prepare(e) {
            var t, n, r, o;
            const i = {
                ...e,
                fullUrl: "",
                queryObj: {},
                headersObj: {},
                cookiesObj: {},
                allHeaders: {}
            };
            if (i.queryString && i.queryString.length && (i.queryObj = i.queryString.reduce(cJ, {})),
            i.headers && i.headers.length) {
                const e = /^HTTP\/2/;
                i.headersObj = i.headers.reduce(((t,{name: n, value: r})=>{
                    const o = e.exec(i.httpVersion) ? n.toLocaleLowerCase() : n;
                    return {
                        ...t,
                        [o]: r
                    }
                }
                ), {})
            }
            i.cookies && i.cookies.length && (i.cookiesObj = i.cookies.reduceRight(((e,{name: t, value: n})=>({
                ...e,
                [t]: n
            })), {}));
            const a = null === (t = i.cookies) || void 0 === t ? void 0 : t.map((({name: e, value: t})=>`${encodeURIComponent(e)}=${encodeURIComponent(t)}`));
            switch ((null == a ? void 0 : a.length) && (i.allHeaders.cookie = a.join("; ")),
            null === (n = i.postData) || void 0 === n ? void 0 : n.mimeType) {
            case "multipart/mixed":
            case "multipart/related":
            case "multipart/form-data":
            case "multipart/alternative":
                if (i.postData.text = "",
                i.postData.mimeType = "multipart/form-data",
                null === (r = i.postData) || void 0 === r ? void 0 : r.params) {
                    const e = new YK
                      , t = "---011000010111000001101001";
                    null === (o = i.postData) || void 0 === o || o.params.forEach((t=>{
                        const n = t.name
                          , r = t.value || ""
                          , o = t.fileName;
                        var i;
                        "object" == typeof (i = r) && "function" == typeof i.arrayBuffer && "string" == typeof i.type && "function" == typeof i.stream && "function" == typeof i.constructor && /^(Blob|File)$/.test(i[nJ]) ? e.append(n, r, o) : e.append(n, new KK([r],{
                            type: t.contentType
                        }), o ? function(e) {
                            const t = e.split("/");
                            return t[t.length - 1]
                        }(o) : o)
                    }
                    ));
                    const {postData: n} = i;
                    for await(const o of oJ(e, t))
                        n.text += o;
                    i.postData.boundary = t;
                    const r = iJ(i.headersObj, "content-type") || "content-type";
                    i.headersObj[r] = `multipart/form-data; boundary=${t}`
                }
                break;
            case "application/x-www-form-urlencoded":
                i.postData.params ? (i.postData.paramsObj = i.postData.params.reduce(cJ, {}),
                i.postData.text = uJ(i.postData.paramsObj).toString()) : i.postData.text = "";
                break;
            case "text/json":
            case "text/x-json":
            case "application/json":
            case "application/x-json":
                if (i.postData.mimeType = "application/json",
                i.postData.text)
                    try {
                        i.postData.jsonObj = JSON.parse(i.postData.text)
                    } catch (Aa) {
                        i.postData.mimeType = "text/plain"
                    }
            }
            const s = {
                ...i.allHeaders,
                ...i.headersObj
            }
              , l = new URL(i.url)
              , c = Object.fromEntries(l.searchParams);
            i.queryObj = {
                ...i.queryObj,
                ...c
            };
            const u = uJ(i.queryObj)
              , d = new URL(i.url);
            return d.search = u.toString(),
            l.search = "",
            {
                ...i,
                allHeaders: s,
                fullUrl: d.toString(),
                url: l.toString(),
                uriObj: new dJ(d.toString())
            }
        }
        async convert(e, t, n) {
            !n && t && (n = t);
            const r = o0[e];
            if (!r)
                return null;
            const {convert: o} = r.clientsById[t || r.info.default]
              , i = (await this.requests).map((e=>o(e, n)));
            return 1 === i.length ? i[0] : i
        }
    }
    function a0(e) {
        var t;
        return (null == (t = u0.value.find((t=>t.key === e.targetKey))) ? void 0 : t.title) ?? e.targetKey
    }
    function s0(e) {
        var t, n;
        return (null == (n = null == (t = u0.value.find((t=>t.key === e.targetKey))) ? void 0 : t.clients.find((t=>t.key === e.clientKey))) ? void 0 : n.title) ?? e.clientKey
    }
    const l0 = ei((()=>a0(f0)))
      , c0 = ei((()=>s0(f0)));
    const u0 = ei((()=>{
        var e;
        const t = Object.keys(o0).map((e=>({
            ...o0[e].info,
            clients: Object.keys(o0[e].clientsById).map((t=>o0[e].clientsById[t].info))
        })));
        return null == (e = t.find((e=>"node" === e.key))) || e.clients.unshift({
            description: "An HTTP/1.1 client, written from scratch for Node.js.",
            key: "undici",
            link: "https://github.com/nodejs/undici",
            title: "undici"
        }),
        function(e, t) {
            return !0 === t.value ? [] : e.flatMap((e=>{
                var n;
                return "object" != typeof t.value ? [] : Array.isArray(t.value) ? (e.clients = e.clients.filter((e=>!t.value.includes(e.key))),
                [e]) : !0 === t.value[e.key] ? [] : (Array.isArray(t.value[e.key]) && (e.clients = e.clients.filter((n=>!t.value[e.key].includes(n.key)))),
                (null == (n = null == e ? void 0 : e.clients) ? void 0 : n.length) ? [e] : [])
            }
            ))
        }(t, p0)
    }
    ))
      , d0 = {
        node: ["unirest"]
    }
      , p0 = Et({
        ...!0 === d0 ? {} : d0
    })
      , h0 = ()=>{
        var e, t, n, r;
        return u0.value.find((e=>"shell" === e.key && e.clients.find((e=>"curl" === e.key)))) ? {
            targetKey: "shell",
            clientKey: "curl"
        } : {
            targetKey: null == (e = u0.value[0]) ? void 0 : e.key,
            clientKey: null == (r = null == (n = null == (t = u0.value[0]) ? void 0 : t.clients) ? void 0 : n[0]) ? void 0 : r.key
        }
    }
      , f0 = ut(h0());
    function m0() {
        jT(f0, h0())
    }
    const g0 = e=>{
        Object.assign(f0, {
            ...f0,
            ...e
        })
    }
      , b0 = ()=>({
        httpClient: dt(f0),
        resetState: m0,
        setHttpClient: g0,
        excludedClients: dt(p0),
        setExcludedClients: e=>{
            p0.value = e,
            jT(f0, h0())
        }
        ,
        availableTargets: u0,
        getClientTitle: s0,
        getTargetTitle: a0,
        httpTargetTitle: l0,
        httpClientTitle: c0
    });
    const O0 = "true" === {
        BASE_URL: "/",
        MODE: "production",
        DEV: !1,
        PROD: !0,
        SSR: !1
    }.VITE_NEW_API_CLIENT
      , v0 = {
        key: 0
    }
      , y0 = {
        class: "authentication-header"
    }
      , w0 = {
        class: "selector"
    }
      , _0 = {
        key: 0,
        class: "authentication-content"
    }
      , k0 = (e,t)=>{
        const n = e.__vccOpts || e;
        for (const [r,o] of t)
            n[r] = o;
        return n
    }
      , S0 = k0(Ln({
        __name: "Authentication",
        props: {
            parsedSpec: {},
            proxy: {}
        },
        setup(e) {
            const t = e
              , {authentication: n, setAuthentication: r} = xq()
              , o = ei((()=>{
                var e, r, o;
                if (!n.preferredSecurityScheme)
                    return !1;
                const i = null == (o = null == (r = null == (e = t.parsedSpec) ? void 0 : e.components) ? void 0 : r.securitySchemes) ? void 0 : o[n.preferredSecurityScheme];
                return !!i && "type"in i && !!i.type
            }
            ));
            return zr((()=>{
                var e, n;
                return null == (n = null == (e = t.parsedSpec) ? void 0 : e.components) ? void 0 : n.securitySchemes
            }
            ), (()=>{
                var e, n;
                r({
                    securitySchemes: null == (n = null == (e = t.parsedSpec) ? void 0 : e.components) ? void 0 : n.securitySchemes
                })
            }
            ), {
                deep: !0,
                immediate: !0
            }),
            Cn((async()=>{
                const e = Ur();
                await xK(1),
                e.payload.data["useGlobalStore-authentication"] = n
            }
            )),
            (e,t)=>{
                var r, i, a, s, l;
                return Ct(GY)(e.parsedSpec) ? (mo(),
                vo("div", v0, [Eo("div", y0, [Eo("div", w0, [xo(Ct(jV), {
                    value: null == (i = null == (r = e.parsedSpec) ? void 0 : r.components) ? void 0 : i.securitySchemes
                }, null, 8, ["value"])])]), o.value ? (mo(),
                vo("div", _0, [Ct(n).preferredSecurityScheme ? (mo(),
                yo(Ct(NV), {
                    key: 0,
                    proxy: e.proxy,
                    value: null == (l = null == (s = null == (a = e.parsedSpec) ? void 0 : a.components) ? void 0 : s.securitySchemes) ? void 0 : l[Ct(n).preferredSecurityScheme]
                }, null, 8, ["proxy", "value"])) : Do("", !0)])) : Do("", !0)])) : Do("", !0)
            }
        }
    }), [["__scopeId", "data-v-4ada77f4"]])
      , E0 = ["title", "innerHTML"]
      , x0 = k0(Ln({
        __name: "ServerItem",
        props: {
            value: {},
            variables: {}
        },
        setup(e) {
            const t = e
              , {copyToClipboard: n} = OY()
              , r = ei((()=>{
                var e;
                return eW(((null == (e = t.value) ? void 0 : e.url) ?? "").replace(/(<([^>]+)>)/gi, ""), (e=>{
                    var n;
                    const r = null == (n = t.variables) ? void 0 : n.find((t=>t.name === e));
                    return `<span class="base-url-variable">${"" !== ((null == r ? void 0 : r.value) ?? "") ? null == r ? void 0 : r.value : `{${e}}`}</span>`
                }
                ))
            }
            ))
              , o = ei((()=>r.value.replace(/(<([^>]+)>)/gi, "")));
            return (e,t)=>e.value ? (mo(),
            vo("a", {
                key: 0,
                class: "base-url",
                title: e.value.description,
                onClick: t[0] || (t[0] = e=>Ct(n)(o.value)),
                innerHTML: r.value
            }, null, 8, E0)) : Do("", !0)
        }
    }), [["__scopeId", "data-v-41c016dc"]])
      , T0 = {
        key: 0
    }
      , A0 = ["for"]
      , C0 = ["id", "value", "onInput"]
      , P0 = ["value"]
      , D0 = {
        class: "input-value"
    }
      , R0 = ["id", "value", "onInput"]
      , N0 = k0(Ln({
        __name: "ServerVariables",
        props: {
            value: {}
        },
        setup(e) {
            const {server: t, setServer: n} = DV()
              , r = (e,r)=>{
                const o = r.target.value
                  , i = [...t.variables]
                  , a = i.findIndex((t=>t.name === e));
                i[a].value = o,
                n({
                    variables: i
                })
            }
              , o = e=>{
                const n = t.variables.findIndex((t=>t.name === e));
                return t.variables[n].value ?? ""
            }
            ;
            return (e,t)=>e.value ? (mo(),
            vo("div", T0, [(mo(!0),
            vo(lo, null, In(e.value, (e=>(mo(),
            vo("div", {
                key: e.name,
                class: "input"
            }, [Eo("label", {
                for: `variable-${e.name}`
            }, [Eo("code", null, K(e.name), 1)], 8, A0), e.enum ? (mo(),
            vo(lo, {
                key: 0
            }, [Eo("select", {
                id: `variable-${e.name}`,
                value: o(e.name),
                onInput: t=>r(e.name, t)
            }, [(mo(!0),
            vo(lo, null, In(e.enum, (e=>(mo(),
            vo("option", {
                key: e,
                value: e
            }, K(e), 9, P0)))), 128))], 40, C0), Eo("div", D0, K(e.default), 1)], 64)) : (mo(),
            vo("input", {
                key: 1,
                id: `variable-${e.name}`,
                autocomplete: "off",
                placeholder: "value",
                spellcheck: "false",
                type: "text",
                value: o(e.name),
                onInput: t=>r(e.name, t)
            }, null, 40, R0))])))), 128))])) : Do("", !0)
        }
    }), [["__scopeId", "data-v-2e5f4fe1"]])
      , $0 = e=>(cn("data-v-2bf97807"),
    e = e(),
    un(),
    e)
      , I0 = {
        key: 0
    }
      , M0 = $0((()=>Eo("span", {
        class: "scalar-card-serverlist-title"
    }, "Base URL", -1)))
      , L0 = {
        class: "scalar-card-serverlist"
    }
      , Q0 = {
        class: "scalar-card-serverlist-container"
    }
      , B0 = {
        class: "server-item"
    }
      , U0 = {
        class: "server-selector"
    }
      , F0 = ["value"]
      , j0 = ["value"]
      , z0 = {
        key: 0,
        muted: ""
    }
      , q0 = {
        class: "description"
    }
      , H0 = k0(Ln({
        __name: "BaseUrl",
        setup(e) {
            const {server: t, setServer: n} = DV()
              , r = Et(0);
            return zr([r, ()=>t.servers], (()=>{
                var e, o, i;
                if (!t.servers.length)
                    return;
                const a = (null == (e = t.servers[r.value]) ? void 0 : e.variables) ?? {}
                  , s = a ? Object.keys(a).map((e=>{
                    var t;
                    return {
                        name: e,
                        value: (null == (t = a[e].default) ? void 0 : t.toString()) ?? ""
                    }
                }
                )) : [];
                XG(null == (o = t.servers[r.value]) ? void 0 : o.url).filter((e=>!a[e])).forEach((e=>{
                    s.push({
                        name: e,
                        value: ""
                    })
                }
                )),
                n({
                    selectedServer: r.value,
                    description: null == (i = t.servers[r.value]) ? void 0 : i.description,
                    variables: s
                })
            }
            ), {
                immediate: !0,
                deep: !0
            }),
            (e,n)=>Ct(t).servers.length > 0 ? (mo(),
            vo("div", I0, [M0, Eo("div", L0, [Eo("div", Q0, [Eo("div", B0, [Eo("div", U0, [Ct(t).servers.length > 1 ? (mo(),
            vo("select", {
                key: 0,
                value: r.value,
                onInput: n[0] || (n[0] = e=>r.value = parseInt(e.target.value, 10))
            }, [(mo(!0),
            vo(lo, null, In(Ct(t).servers, ((e,t)=>(mo(),
            vo("option", {
                key: t,
                value: t
            }, K(e.url), 9, j0)))), 128))], 40, F0)) : Do("", !0), xo(x0, {
                value: Ct(t).servers[r.value],
                variables: Ct(t).variables
            }, null, 8, ["value", "variables"]), Ct(t).servers.length > 1 ? (mo(),
            yo(Ct(rC), {
                key: 1,
                icon: "ChevronDown"
            })) : Do("", !0)])]), xo(N0, {
                value: Ct(t).variables
            }, null, 8, ["value"])])]), Ct(t).description ? (mo(),
            vo("div", z0, [Eo("div", q0, [xo(Ct(XT), {
                value: Ct(t).description
            }, null, 8, ["value"])])])) : Do("", !0)])) : Do("", !0)
        }
    }), [["__scopeId", "data-v-2bf97807"]])
      , Z0 = e=>(cn("data-v-ab6bf947"),
    e = e(),
    un(),
    e)
      , W0 = ["onClick"]
      , X0 = ["value"]
      , V0 = ["label"]
      , G0 = ["value"]
      , Y0 = {
        class: "client-libraries-icon__more"
    }
      , K0 = {
        key: 1,
        class: "client-libraries-icon",
        height: "50",
        viewBox: "0 0 50 50",
        width: "50",
        xmlns: "http://www.w3.org/2000/svg"
    }
      , J0 = [Z0((()=>Eo("g", {
        fill: "currentColor",
        "fill-rule": "nonzero"
    }, [Eo("path", {
        d: "M10.71 25.3a3.87 3.87 0 1 0 7.74 0 3.87 3.87 0 0 0-7.74 0M21.13 25.3a3.87 3.87 0 1 0 7.74 0 3.87 3.87 0 0 0-7.74 0M31.55 25.3a3.87 3.87 0 1 0 7.74 0 3.87 3.87 0 0 0-7.74 0"
    })], -1)))]
      , e1 = {
        key: 0
    }
      , t1 = k0(Ln({
        __name: "ClientSelector",
        setup(e) {
            const {httpClient: t, setHttpClient: n, availableTargets: r, getClientTitle: o, getTargetTitle: i} = b0()
              , a = Et()
              , s = [{
                targetKey: "shell",
                clientKey: "curl"
            }, {
                targetKey: "ruby",
                clientKey: "native"
            }, {
                targetKey: "node",
                clientKey: "undici"
            }, {
                targetKey: "php",
                clientKey: "guzzle"
            }, {
                targetKey: "python",
                clientKey: "python3"
            }].filter((e=>r.value.find((t=>t.key === e.targetKey && t.clients.find((t=>t.key === e.clientKey))))))
              , l = e=>`programming-language-${e}`
              , c = e=>s.some((t=>t.targetKey === e.targetKey && t.clientKey === e.clientKey));
            return (e,u)=>(mo(),
            vo("div", {
                ref_key: "containerRef",
                ref: a,
                class: "client-libraries-content"
            }, [(mo(!0),
            vo(lo, null, In(Ct(s), (e=>{
                return mo(),
                vo("div", {
                    key: e.clientKey,
                    class: Z(["client-libraries rendered-code-sdks", {
                        "client-libraries__active": (r = e,
                        r.targetKey === t.targetKey && r.clientKey === t.clientKey)
                    }]),
                    onClick: ()=>Ct(n)(e)
                }, [Eo("div", {
                    class: Z(`client-libraries-icon__${e.targetKey}`)
                }, [xo(Ct(rC), {
                    class: "client-libraries-icon",
                    icon: l(e.targetKey)
                }, null, 8, ["icon"])], 2), Eo("span", null, K(Ct(i)(e)), 1)], 10, W0);
                var r
            }
            )), 128)), Eo("div", {
                class: Z(["client-libraries client-libraries__select", {
                    "client-libraries__active": Ct(t) && !c(Ct(t))
                }])
            }, [Eo("select", {
                class: "language-select",
                value: JSON.stringify(Ct(t)),
                onInput: u[0] || (u[0] = e=>Ct(n)(JSON.parse(e.target.value)))
            }, [(mo(!0),
            vo(lo, null, In(Ct(r), (e=>(mo(),
            vo("optgroup", {
                key: e.key,
                label: e.title
            }, [(mo(!0),
            vo(lo, null, In(e.clients, (t=>(mo(),
            vo("option", {
                key: t.key,
                value: JSON.stringify({
                    targetKey: e.key,
                    clientKey: t.key
                })
            }, K(Ct(o)({
                targetKey: e.key,
                clientKey: t.key
            })), 9, G0)))), 128))], 8, V0)))), 128))], 40, X0), Eo("div", Y0, [Ct(t) && !c(Ct(t)) ? (mo(),
            vo("div", {
                key: 0,
                class: Z(`client-libraries-icon__${Ct(t).targetKey}`)
            }, [xo(Ct(rC), {
                class: "client-libraries-icon",
                icon: l(Ct(t).targetKey)
            }, null, 8, ["icon"])], 2)) : (mo(),
            vo("svg", K0, J0))]), Ct(r).length ? (mo(),
            vo("span", e1, "More")) : Do("", !0)], 2)], 512))
        }
    }), [["__scopeId", "data-v-ab6bf947"]])
      , n1 = e=>(cn("data-v-301043da"),
    e = e(),
    un(),
    e)
      , r1 = n1((()=>Eo("div", {
        class: "client-libraries-heading"
    }, "Client Libraries", -1)))
      , o1 = {
        class: "selected-client card-footer",
        muted: ""
    }
      , i1 = k0(Ln({
        __name: "ClientLibraries",
        setup(e) {
            const {availableTargets: t, httpTargetTitle: n, httpClientTitle: r} = b0();
            return (e,o)=>(mo(),
            vo("div", null, [Ct(t).length ? (mo(),
            vo(lo, {
                key: 0
            }, [r1, Eo("div", null, [xo(t1)]), Eo("div", o1, K(Ct(r)) + " " + K(Ct(n)), 1)], 64)) : Do("", !0)]))
        }
    }), [["__scopeId", "data-v-301043da"]])
      , a1 = {
        class: "badge"
    };
    const s1 = k0({}, [["render", function(e, t) {
        return mo(),
        vo("div", a1, [Fn(e.$slots, "default", {}, void 0, !0)])
    }
    ], ["__scopeId", "data-v-190574ac"]])
      , l1 = Ln({
        __name: "IntersectionObserver",
        props: {
            id: {},
            is: {}
        },
        emits: ["intersecting"],
        setup(e, {emit: t}) {
            const n = e
              , r = t
              , o = Et()
              , i = e=>{
                const t = e.offsetHeight;
                return `${t / 2}px 0px ${t / 2}px 0px`
            }
            ;
            return Sn((()=>{
                if (o.value) {
                    const t = {
                        rootMargin: i(o.value),
                        threshold: (e = o.value,
                        e.offsetHeight < window.innerHeight ? .8 : .5)
                    };
                    !function(e, t, n={}) {
                        const {root: r, rootMargin: o="0px", threshold: i=.1, window: a=Cl, immediate: s=!0} = n
                          , l = Dl((()=>a && "IntersectionObserver"in a))
                          , c = ei((()=>{
                            const t = vl(e);
                            return (Array.isArray(t) ? t : [t]).map(Al).filter(wl)
                        }
                        ));
                        let u = Sl;
                        const d = Et(s)
                          , p = l.value ? zr((()=>[c.value, Al(r), d.value]), (([e,n])=>{
                            if (u(),
                            !d.value)
                                return;
                            if (!e.length)
                                return;
                            const r = new IntersectionObserver(t,{
                                root: Al(n),
                                rootMargin: o,
                                threshold: i
                            });
                            e.forEach((e=>e && r.observe(e))),
                            u = ()=>{
                                r.disconnect(),
                                u = Sl
                            }
                        }
                        ), {
                            immediate: s,
                            flush: "post"
                        }) : Sl
                          , h = ()=>{
                            u(),
                            p(),
                            d.value = !1
                        }
                        ;
                        Ol(h)
                    }(o, (([{isIntersecting: e}])=>{
                        e && n.id && r("intersecting")
                    }
                    ), t)
                }
                var e
            }
            )),
            (e,t)=>(mo(),
            yo(On(e.is ?? "div"), {
                id: e.id,
                ref_key: "intersectionObserverRef",
                ref: o
            }, {
                default: dn((()=>[Fn(e.$slots, "default")])),
                _: 3
            }, 8, ["id"]))
        }
    })
      , c1 = k0(Ln({
        __name: "Section",
        props: {
            id: {},
            label: {}
        },
        setup(e) {
            const t = e
              , {getSectionId: n, hash: r, isIntersectionEnabled: o, pathRouting: i} = LY()
              , {setCollapsedSidebarItem: a} = VK();
            function s() {
                var e, s;
                if (!t.label || !o.value)
                    return;
                const l = new URL(window.location.href)
                  , c = t.id ?? "";
                i.value ? l.pathname = YY(i.value.basePath, c) : l.hash = c,
                r.value = c,
                window.history.replaceState({}, "", l),
                ((null == (e = t.id) ? void 0 : e.startsWith("model")) || (null == (s = t.id) ? void 0 : s.startsWith("webhook"))) && a(n(t.id), !0)
            }
            return (e,t)=>(mo(),
            yo(l1, {
                is: "section",
                id: e.id,
                class: "section",
                onIntersecting: s
            }, {
                default: dn((()=>[Fn(e.$slots, "default", {}, void 0, !0)])),
                _: 3
            }, 8, ["id"]))
        }
    }), [["__scopeId", "data-v-7bdc2dab"]])
      , u1 = {
        class: "section-accordion-button-content"
    }
      , d1 = {
        key: 0,
        class: "section-accordion-button-actions"
    }
      , p1 = {
        key: 0,
        class: "section-accordion-description"
    }
      , h1 = {
        class: "section-accordion-content-card"
    }
      , f1 = k0(Ln({
        __name: "SectionAccordion",
        props: {
            id: {},
            transparent: {
                type: Boolean
            }
        },
        setup(e) {
            const t = Et()
              , n = function(e, t={}) {
                const {delayEnter: n=0, delayLeave: r=0, window: o=Cl} = t
                  , i = Et(!1);
                let a;
                const s = e=>{
                    const t = e ? n : r;
                    a && (clearTimeout(a),
                    a = void 0),
                    t ? a = setTimeout((()=>i.value = e), t) : i.value = e
                }
                ;
                return o ? (Pl(e, "mouseenter", (()=>s(!0)), {
                    passive: !0
                }),
                Pl(e, "mouseleave", (()=>s(!1)), {
                    passive: !0
                }),
                i) : i
            }(t);
            return (e,r)=>(mo(),
            yo(l1, {
                id: e.id,
                class: "section-wrapper"
            }, {
                default: dn((()=>[xo(Ct(Ms), {
                    as: "section",
                    class: Z(["section-accordion", {
                        "section-accordion-transparent": e.transparent
                    }])
                }, {
                    default: dn((({open: r})=>[xo(Ct(Ls), {
                        ref_key: "button",
                        ref: t,
                        class: "section-accordion-button"
                    }, {
                        default: dn((()=>[Eo("div", u1, [Fn(e.$slots, "title", {}, void 0, !0)]), e.$slots.actions ? (mo(),
                        vo("div", d1, [Fn(e.$slots, "actions", {
                            active: Ct(n) || r
                        }, void 0, !0)])) : Do("", !0), xo(Ct(rC), {
                            class: "section-accordion-chevron",
                            icon: r ? "ChevronDown" : "ChevronRight"
                        }, null, 8, ["icon"])])),
                        _: 2
                    }, 1536), xo(Ct(Qs), {
                        class: "section-accordion-content"
                    }, {
                        default: dn((()=>[e.$slots.description ? (mo(),
                        vo("div", p1, [Fn(e.$slots, "description", {}, void 0, !0)])) : Do("", !0), Eo("div", h1, [Fn(e.$slots, "default", {}, void 0, !0)])])),
                        _: 3
                    })])),
                    _: 3
                }, 8, ["class"])])),
                _: 3
            }, 8, ["id"]))
        }
    }), [["__scopeId", "data-v-07cabcb0"]])
      , m1 = {
        class: "section-column"
    };
    const g1 = k0({}, [["render", function(e, t) {
        return mo(),
        vo("div", m1, [Fn(e.$slots, "default", {}, void 0, !0)])
    }
    ], ["__scopeId", "data-v-d64e7382"]])
      , b1 = {
        class: "section-columns"
    };
    const O1 = k0({}, [["render", function(e, t) {
        return mo(),
        vo("div", b1, [Fn(e.$slots, "default", {}, void 0, !0)])
    }
    ], ["__scopeId", "data-v-8b9602bf"]])
      , v1 = {
        class: "section-container"
    };
    const y1 = k0({}, [["render", function(e, t) {
        return mo(),
        vo("div", v1, [Fn(e.$slots, "default", {}, void 0, !0)])
    }
    ], ["__scopeId", "data-v-34b26958"]])
      , w1 = {
        class: "section-accordion-wrapper"
    }
      , _1 = {
        class: "section-accordion-title"
    }
      , k1 = k0(Ln({
        __name: "SectionContainerAccordion",
        setup: e=>(e,t)=>(mo(),
        vo("div", w1, [xo(Ct(Ms), {
            as: "div",
            class: "section-accordion",
            defaultOpen: ""
        }, {
            default: dn((({open: t})=>[xo(Ct(Ls), {
                class: "section-accordion-button"
            }, {
                default: dn((()=>[xo(Ct(rC), {
                    class: "section-accordion-chevron",
                    icon: t ? "ChevronDown" : "ChevronRight"
                }, null, 8, ["icon"]), Eo("div", _1, [Fn(e.$slots, "title", {}, void 0, !0)])])),
                _: 2
            }, 1024), xo(Ct(Qs), {
                class: "section-accordion-content"
            }, {
                default: dn((()=>[Fn(e.$slots, "default", {}, void 0, !0)])),
                _: 3
            })])),
            _: 3
        })]))
    }), [["__scopeId", "data-v-2049975e"]])
      , S1 = k0(Ln({
        __name: "LoadingSkeleton",
        props: {
            lines: {
                default: 1
            }
        },
        setup: e=>(e,t)=>(mo(!0),
        vo(lo, null, In([...Array(e.lines).keys()], (t=>(mo(),
        vo("div", {
            key: t,
            class: Z(["loading", {
                "single-line": 1 === e.lines
            }])
        }, null, 2)))), 128))
    }), [["__scopeId", "data-v-c90b2c46"]])
      , E1 = {
        class: "section-content"
    }
      , x1 = k0(Ln({
        __name: "SectionContent",
        props: {
            loading: {
                type: Boolean,
                default: !1
            }
        },
        setup: e=>(e,t)=>(mo(),
        vo("div", E1, [e.loading ? (mo(),
        yo(S1, {
            key: 1,
            lines: 8
        })) : Fn(e.$slots, "default", {
            key: 0
        }, void 0, !0)]))
    }), [["__scopeId", "data-v-9735459e"]])
      , T1 = k0(Ln({
        __name: "SectionHeader",
        props: {
            loading: {
                type: Boolean,
                default: !1
            },
            tight: {
                type: Boolean,
                default: !1
            },
            level: {
                default: 1
            }
        },
        setup: e=>(e,t)=>e.loading ? (mo(),
        yo(S1, {
            key: 0
        })) : (mo(),
        yo(On(`h${e.level}`), {
            key: 1,
            class: Z(["section-header", {
                tight: e.tight
            }])
        }, {
            default: dn((()=>[Fn(e.$slots, "default", {}, void 0, !0)])),
            _: 3
        }, 8, ["class"]))
    }), [["__scopeId", "data-v-3bd1b9f0"]])
      , A1 = {
        key: 0,
        class: "introduction-description"
    }
      , C1 = k0(Ln({
        __name: "Description",
        props: {
            value: {}
        },
        setup(e) {
            const t = e
              , n = `components-Content-Introduction-Description-sections${PS(t.value)}`
              , r = Tl((async()=>{
                if (!t.value)
                    return [];
                const e = await ZY(t.value)
                  , n = WY(e);
                return await Promise.all(function(e, t=1) {
                    const n = new RegExp(`^(?=#{${t}} )`,"m");
                    return e.split(n).map((e=>e.trim())).filter(Boolean)
                }(t.value, n).map((async e=>({
                    heading: (await ZY(e))[0],
                    content: e
                }))))
            }
            ), qT[n] ?? [])
              , {getHeadingId: o, hash: i, isIntersectionEnabled: a, pathRouting: s} = LY();
            return Cn((async()=>{
                const e = Ur();
                await xK(1),
                e.payload.data[n] = r.value
            }
            )),
            (e,t)=>e.value ? (mo(),
            vo("div", A1, [(mo(!0),
            vo(lo, null, In(Ct(r), ((e,t)=>(mo(),
            vo(lo, {
                key: t
            }, [e.heading ? (mo(),
            yo(l1, {
                key: 0,
                id: Ct(o)(e.heading),
                class: "introduction-description-heading",
                onIntersecting: ()=>function(e="") {
                    if (!a.value)
                        return;
                    const t = new URL(window.location.href);
                    s.value ? t.pathname = YY(s.value.basePath, e) : t.hash = e,
                    i.value = e,
                    window.history.replaceState({}, "", t)
                }(Ct(o)(e.heading))
            }, {
                default: dn((()=>[xo(Ct(XT), {
                    value: e.content,
                    withImages: ""
                }, null, 8, ["value"])])),
                _: 2
            }, 1032, ["id", "onIntersecting"])) : (mo(),
            yo(Ct(XT), {
                key: 1,
                value: e.content,
                withImages: ""
            }, null, 8, ["value"]))], 64)))), 128))])) : Do("", !0)
        }
    }), [["__scopeId", "data-v-764b63f7"]])
      , P1 = {
        class: "download"
    }
      , D1 = {
        class: "download-cta"
    }
      , R1 = k0(Ln({
        __name: "DownloadSpec",
        props: {
            specTitle: {}
        },
        setup(e) {
            const t = e
              , n = pr(SK)
              , r = ()=>{
                TK.emit({
                    id: "",
                    specTitle: t.specTitle
                })
            }
            ;
            return (e,t)=>{
                var o;
                return mo(),
                vo("div", P1, [Eo("div", D1, [(null == (o = Ct(n)) ? void 0 : o()) ? Do("", !0) : (mo(),
                vo("button", {
                    key: 0,
                    class: "download-button",
                    type: "button",
                    onClick: r
                }, " Download OpenAPI Spec "))])])
            }
        }
    }), [["__scopeId", "data-v-810904a4"]])
      , N1 = {
        class: "badges"
    }
      , $1 = {
        class: "sticky-cards"
    }
      , I1 = k0(Ln({
        __name: "Introduction",
        props: {
            info: {},
            parsedSpec: {}
        },
        setup(e) {
            const t = e
              , n = new SY
              , r = ei((()=>t.parsedSpec.openapi ?? t.parsedSpec.swagger ?? ""))
              , o = ei((()=>n.slug(t.info.title ?? "")));
            return (e,t)=>(mo(),
            yo(Ct(y1), null, {
                default: dn((()=>[xo(Ct(c1), {
                    class: "introduction-section"
                }, {
                    default: dn((()=>[xo(Ct(x1), {
                        loading: !e.info.description && !e.info.title
                    }, {
                        default: dn((()=>[xo(Ct(O1), null, {
                            default: dn((()=>[xo(Ct(g1), null, {
                                default: dn((()=>[Eo("div", N1, [e.info.version ? (mo(),
                                yo(Ct(s1), {
                                    key: 0
                                }, {
                                    default: dn((()=>[Co(K(e.info.version), 1)])),
                                    _: 1
                                })) : Do("", !0), r.value ? (mo(),
                                yo(Ct(s1), {
                                    key: 1
                                }, {
                                    default: dn((()=>[Co(" OAS " + K(r.value), 1)])),
                                    _: 1
                                })) : Do("", !0)]), xo(Ct(T1), {
                                    level: 1,
                                    loading: !e.info.title,
                                    tight: ""
                                }, {
                                    default: dn((()=>[Co(K(e.info.title), 1)])),
                                    _: 1
                                }, 8, ["loading"]), xo(R1, {
                                    specTitle: o.value
                                }, null, 8, ["specTitle"]), xo(C1, {
                                    value: e.info.description
                                }, null, 8, ["value"])])),
                                _: 1
                            }), e.$slots.aside ? (mo(),
                            yo(Ct(g1), {
                                key: 0
                            }, {
                                default: dn((()=>[Eo("div", $1, [Fn(e.$slots, "aside", {}, void 0, !0)])])),
                                _: 3
                            })) : Do("", !0)])),
                            _: 3
                        })])),
                        _: 3
                    }, 8, ["loading"]), Fn(e.$slots, "after", {}, void 0, !0)])),
                    _: 3
                })])),
                _: 3
            }))
        }
    }), [["__scopeId", "data-v-83f73a98"]])
      , M1 = $l(Symbol())
      , L1 = Ln({
        __name: "Lazy",
        props: {
            id: {},
            isLazy: {
                type: Boolean,
                default: !0
            },
            lazyTimeout: {
                default: 0
            }
        },
        setup(e) {
            const t = e
              , n = Et(!t.isLazy);
            return t.isLazy ? ((e=(()=>{}
            ))=>{
                "undefined" == typeof window || ("requestIdleCallback"in window ? setTimeout((()=>window.requestIdleCallback(e)), t.lazyTimeout) : setTimeout((()=>Xt(e)), t.lazyTimeout ?? 300))
            }
            )((()=>{
                n.value = !0,
                t.id && Xt((()=>M1.emit({
                    id: t.id
                })))
            }
            )) : t.id && Xt((()=>M1.emit({
                id: t.id
            }))),
            (e,t)=>n.value ? Fn(e.$slots, "default", {
                key: 0
            }) : Do("", !0)
        }
    })
      , Q1 = {
        key: 0,
        class: "screenreader-only"
    }
      , B1 = k0(Ln({
        __name: "ScreenReader",
        props: {
            if: {
                type: Boolean,
                default: !0
            }
        },
        setup: e=>(e,t)=>e.$props.if ? (mo(),
        vo("span", Q1, [Fn(e.$slots, "default", {}, void 0, !0)])) : Fn(e.$slots, "default", {
            key: 1
        }, void 0, !0)
    }), [["__scopeId", "data-v-681ebf2c"]])
      , U1 = e=>(cn("data-v-d9801d4e"),
    e = e(),
    un(),
    e)
      , F1 = {
        class: "label"
    }
      , j1 = {
        class: "anchor"
    }
      , z1 = U1((()=>Eo("span", null, "​", -1)))
      , q1 = k0(Ln({
        __name: "Anchor",
        props: {
            id: {}
        },
        setup(e) {
            const {copyToClipboard: t} = OY();
            return (e,n)=>(mo(),
            vo("span", F1, [Fn(e.$slots, "default", {}, void 0, !0), Eo("span", j1, [z1, Eo("button", {
                class: "anchor-copy",
                type: "button",
                onClick: n[0] || (n[0] = zi((n=>Ct(t)((e=>{
                    const t = new URL(window.location.href);
                    return t.hash = e,
                    t.toString()
                }
                )(e.id))), ["stop"]))
            }, [Co(" # "), xo(B1, null, {
                default: dn((()=>[Co('Copy link to "'), Fn(e.$slots, "default", {}, void 0, !0), Co('"')])),
                _: 3
            })])])]))
        }
    }), [["__scopeId", "data-v-d9801d4e"]])
      , H1 = {
        class: "scalar-card"
    };
    const Z1 = k0({}, [["render", function(e, t) {
        return mo(),
        vo("div", H1, [Fn(e.$slots, "default", {}, void 0, !0)])
    }
    ], ["__scopeId", "data-v-dcabb131"]])
      , W1 = k0(Ln({
        __name: "CardContent",
        props: {
            muted: {
                type: Boolean
            },
            contrast: {
                type: Boolean
            },
            frameless: {
                type: Boolean
            },
            transparent: {
                type: Boolean
            },
            borderless: {
                type: Boolean
            }
        },
        setup: e=>(e,t)=>(mo(),
        vo("div", {
            class: Z(["scalar-card-content", {
                "scalar-card--muted": e.muted,
                "scalar-card--contrast": e.contrast,
                "scalar-card--frameless": e.frameless,
                "scalar-card--transparent": e.transparent,
                "scalar-card--borderless": e.borderless
            }])
        }, [Fn(e.$slots, "default", {}, void 0, !0)], 2))
    }), [["__scopeId", "data-v-5312c2e0"]])
      , X1 = {
        class: "scalar-card-header-slots"
    }
      , V1 = {
        class: "scalar-card-header-slot scalar-card-header-title"
    }
      , G1 = {
        class: "scalar-card-header-slot scalar-card-header-actions"
    }
      , Y1 = k0(Ln({
        __name: "CardHeader",
        props: {
            muted: {
                type: Boolean
            },
            contrast: {
                type: Boolean
            },
            frameless: {
                type: Boolean
            },
            transparent: {
                type: Boolean
            },
            borderless: {
                type: Boolean
            }
        },
        setup(e) {
            const t = e;
            return (e,n)=>(mo(),
            yo(W1, Io(t, {
                class: "scalar-card-header"
            }), {
                default: dn((()=>[Eo("div", X1, [Eo("div", V1, [Fn(e.$slots, "default", {}, void 0, !0)]), Eo("div", G1, [Fn(e.$slots, "actions", {}, void 0, !0)])])])),
                _: 3
            }, 16))
        }
    }), [["__scopeId", "data-v-bbd0c20a"]])
      , K1 = k0(Ln({
        __name: "CardFooter",
        props: {
            muted: {
                type: Boolean
            },
            contrast: {
                type: Boolean
            },
            frameless: {
                type: Boolean
            },
            transparent: {
                type: Boolean
            },
            borderless: {
                type: Boolean
            }
        },
        setup(e) {
            const t = e;
            return (e,n)=>(mo(),
            yo(W1, W(To(t)), {
                default: dn((()=>[Fn(e.$slots, "default", {}, void 0, !0)])),
                _: 3
            }, 16))
        }
    }), [["__scopeId", "data-v-918ab8d6"]])
      , J1 = k0(Ln({
        __name: "CardTabHeader",
        emits: ["change"],
        setup(e, {emit: t}) {
            const n = t
              , r = e=>{
                n("change", e)
            }
            ;
            return (e,t)=>(mo(),
            yo(Y1, {
                class: "scalar-card-header scalar-card-header-tabs"
            }, {
                actions: dn((()=>[Fn(e.$slots, "actions", {}, void 0, !0)])),
                default: dn((()=>[xo(Ct(al), {
                    onChange: r
                }, {
                    default: dn((()=>[xo(Ct(sl), {
                        class: "tab-list custom-scroll"
                    }, {
                        default: dn((()=>[Fn(e.$slots, "default", {}, void 0, !0)])),
                        _: 3
                    })])),
                    _: 3
                })])),
                _: 3
            }))
        }
    }), [["__scopeId", "data-v-03fdb072"]])
      , e2 = k0(Ln({
        __name: "CardTab",
        setup: e=>(e,t)=>(mo(),
        yo(Ct(ll), {
            as: "template"
        }, {
            default: dn((({selected: t})=>[Eo("button", {
                class: Z({
                    tab: !0,
                    "tab-selected": t
                }),
                type: "button"
            }, [Eo("span", null, [Fn(e.$slots, "default", {}, void 0, !0)])], 2)])),
            _: 3
        }))
    }), [["__scopeId", "data-v-f373ecc2"]])
      , t2 = ["value"]
      , n2 = ["label"]
      , r2 = ["value"]
      , o2 = ["value"]
      , i2 = Ln({
        __name: "TextSelect",
        props: {
            modelValue: {},
            options: {}
        },
        emits: ["update:modelValue"],
        setup: e=>(e,t)=>(mo(),
        vo("div", {
            class: Z(["text-select", 1 === e.options.length ? "text-select--single-option" : ""])
        }, [Eo("span", null, [Fn(e.$slots, "default")]), Eo("select", {
            value: e.modelValue,
            onInput: t[0] || (t[0] = t=>e.$emit("update:modelValue", t.target.value))
        }, [(mo(!0),
        vo(lo, null, In(e.options, (e=>(mo(),
        vo(lo, {
            key: e.value
        }, [e.options ? (mo(),
        vo("optgroup", {
            key: 0,
            label: e.label
        }, [(mo(!0),
        vo(lo, null, In(e.options, (e=>(mo(),
        vo("option", {
            key: e.value,
            value: e.value
        }, K(e.label), 9, r2)))), 128))], 8, n2)) : (mo(),
        vo("option", {
            key: e.value,
            value: e.value
        }, K(e.label), 9, o2))], 64)))), 128))], 40, t2)], 2))
    })
      , a2 = {
        class: "request-header"
    }
      , s2 = k0(Ln({
        __name: "CustomRequestExamples",
        props: {
            operation: {},
            examples: {}
        },
        setup(e) {
            const t = e
              , n = Et(0)
              , r = ei((()=>({
                C: "c",
                "C#": "csharp",
                Go: "go",
                HTML: "html",
                Java: "java",
                JavaScript: "javascript",
                Kotlin: "kotlin",
                "Objective-C": "objc",
                PHP: "php",
                PowerShell: "powershell",
                Python: "python",
                Ruby: "ruby",
                Shell: "shell",
                Swift: "swift",
                TypeScript: "typescript",
                cURL: "curl"
            }[t.examples[n.value].lang] ?? t.examples[n.value].lang)))
              , o = ei((()=>t.examples[n.value]));
            zr(t.examples, (()=>{
                "undefined" === t.examples[n.value] && (n.value = 0)
            }
            ));
            const {copyToClipboard: i} = OY();
            return (e,t)=>(mo(),
            yo(Ct(Z1), {
                class: "dark-mode"
            }, {
                default: dn((()=>[xo(Ct(Y1), {
                    muted: ""
                }, {
                    actions: dn((()=>[xo(i2, {
                        class: "request-client-picker",
                        modelValue: n.value,
                        options: e.examples.map(((e,t)=>({
                            value: t.toString(),
                            label: e.label
                        }))),
                        "onUpdate:modelValue": t[0] || (t[0] = e=>(n.value = parseInt(e),
                        10))
                    }, {
                        default: dn((()=>[Co(K(o.value.label), 1)])),
                        _: 1
                    }, 8, ["modelValue", "options"]), Eo("button", {
                        class: "copy-button",
                        type: "button",
                        onClick: t[1] || (t[1] = e=>Ct(i)(o.value.source.trim()))
                    }, [xo(Ct(rC), {
                        icon: "Clipboard",
                        width: "10px"
                    })])])),
                    default: dn((()=>[Eo("div", a2, [xo(Ct(Fl), {
                        class: "request-method",
                        method: e.operation.httpVerb
                    }, null, 8, ["method"]), Fn(e.$slots, "header", {}, void 0, !0)])])),
                    _: 3
                }), xo(Ct(W1), {
                    borderless: "",
                    class: "request-editor-section custom-scroll",
                    frameless: ""
                }, {
                    default: dn((()=>[xo(Ct(ZT), {
                        content: o.value.source.trim(),
                        lang: r.value,
                        lineNumbers: ""
                    }, null, 8, ["content", "lang"])])),
                    _: 1
                }), e.$slots.footer ? (mo(),
                yo(Ct(K1), {
                    key: 0,
                    class: "scalar-card-footer",
                    contrast: ""
                }, {
                    default: dn((()=>[Fn(e.$slots, "footer", {}, void 0, !0)])),
                    _: 3
                })) : Do("", !0)])),
                _: 3
            }))
        }
    }), [["__scopeId", "data-v-a6cfe179"]])
      , l2 = {
        key: 0,
        class: "schema-type"
    }
      , c2 = ["title"]
      , u2 = k0(Ln({
        __name: "SchemaHeading",
        props: {
            value: {
                type: [Object, Boolean]
            },
            name: {}
        },
        setup: e=>(e,t)=>{
            var n, r, o, i, a, s;
            return "object" == typeof e.value ? (mo(),
            vo("span", l2, [Eo("span", {
                class: "schema-type-icon",
                title: "string" == typeof e.value.type ? e.value.type : Array.isArray(e.value.type) ? e.value.type.join(" | ") : "unkown type"
            }, ["object" === e.value.type ? (mo(),
            vo(lo, {
                key: 0
            }, [Co(" {} ")], 64)) : Do("", !0), "array" === e.value.type ? (mo(),
            vo(lo, {
                key: 1
            }, [Co(" [] ")], 64)) : Do("", !0), e.value.enum ? (mo(),
            vo(lo, {
                key: 2
            }, [Co(" enum ")], 64)) : Do("", !0)], 8, c2), (null == (r = null == (n = e.value) ? void 0 : n.xml) ? void 0 : r.name) && "##default" !== (null == (i = null == (o = e.value) ? void 0 : o.xml) ? void 0 : i.name) ? (mo(),
            vo(lo, {
                key: 0
            }, [Co(" <" + K(null == (s = null == (a = e.value) ? void 0 : a.xml) ? void 0 : s.name) + " /> ", 1)], 64)) : e.name ? (mo(),
            vo(lo, {
                key: 1
            }, [Co(K(e.name), 1)], 64)) : (mo(),
            vo(lo, {
                key: 2
            }, [Co(K(e.value.type), 1)], 64))])) : Do("", !0)
        }
    }), [["__scopeId", "data-v-c0a69ad0"]])
      , d2 = {
        key: 0,
        class: "property-detail-prefix"
    }
      , p2 = {
        key: 1,
        class: "property-detail-value"
    }
      , h2 = {
        key: 2,
        class: "property-detail-value"
    }
      , f2 = k0(Ln({
        __name: "SchemaPropertyDetail",
        props: {
            truncate: {
                type: Boolean
            },
            code: {
                type: Boolean
            }
        },
        setup: e=>(e,t)=>(mo(),
        vo("span", {
            class: Z(["property-detail", {
                "property-detail-truncate": e.truncate
            }])
        }, [e.$slots.prefix ? (mo(),
        vo("div", d2, [Fn(e.$slots, "prefix", {}, void 0, !0), Co("  ")])) : Do("", !0), e.code ? (mo(),
        vo("code", p2, [Fn(e.$slots, "default", {}, void 0, !0)])) : (mo(),
        vo("span", h2, [Fn(e.$slots, "default", {}, void 0, !0)]))], 2))
    }), [["__scopeId", "data-v-16d94ef5"]])
      , m2 = {
        class: "property-heading"
    }
      , g2 = {
        key: 0,
        class: "property-name"
    }
      , b2 = {
        key: 1,
        class: "property-additional"
    }
      , O2 = {
        key: 2,
        class: "property-deprecated"
    }
      , v2 = {
        key: 3,
        class: "property-required"
    }
      , y2 = {
        key: 4,
        class: "property-const"
    }
      , w2 = {
        key: 5,
        class: "property-details"
    }
      , _2 = {
        key: 6,
        class: "property-write-only"
    }
      , k2 = {
        key: 7,
        class: "property-read-only"
    }
      , S2 = Ln({
        __name: "SchemaPropertyHeading",
        props: {
            value: {},
            enum: {
                type: Boolean
            },
            required: {
                type: Boolean,
                default: !1
            },
            additional: {
                type: Boolean
            }
        },
        setup(e) {
            const t = ["oneOf", "anyOf", "allOf", "not"];
            return (e,n)=>{
                var r, o, i, a, s, l, c;
                return mo(),
                vo("div", m2, [e.$slots.name ? (mo(),
                vo("div", g2, [Fn(e.$slots, "name", {}, void 0, !0)])) : Do("", !0), e.additional ? (mo(),
                vo("div", b2, [(null == (r = e.value) ? void 0 : r["x-additionalPropertiesName"]) ? (mo(),
                vo(lo, {
                    key: 0
                }, [Co(K(e.value["x-additionalPropertiesName"]), 1)], 64)) : (mo(),
                vo(lo, {
                    key: 1
                }, [Co(" additional properties ")], 64))])) : Do("", !0), (null == (o = e.value) ? void 0 : o.deprecated) ? (mo(),
                vo("div", O2, [xo(Ct(s1), null, {
                    default: dn((()=>[Co("deprecated")])),
                    _: 1
                })])) : Do("", !0), e.required ? (mo(),
                vo("div", v2, " required ")) : Do("", !0), (null == (i = e.value) ? void 0 : i.const) || (null == (a = e.value) ? void 0 : a.enum) && 1 === e.value.enum.length ? (mo(),
                vo("div", y2, [xo(f2, {
                    truncate: ""
                }, {
                    prefix: dn((()=>[Co("const:")])),
                    default: dn((()=>[Co(" " + K(e.value.const ?? e.value.enum[0]), 1)])),
                    _: 1
                })])) : (null == (s = e.value) ? void 0 : s.type) ? (mo(),
                vo("div", w2, [e.additional ? (mo(),
                yo(f2, {
                    key: 0
                }, {
                    prefix: dn((()=>[Co("key:")])),
                    default: dn((()=>[Co(" string ")])),
                    _: 1
                })) : Do("", !0), xo(f2, null, Mn({
                    default: dn((()=>{
                        var t, n, r;
                        return [(null == (n = null == (t = e.value) ? void 0 : t.items) ? void 0 : n.type) ? (mo(),
                        vo(lo, {
                            key: 0
                        }, [Co(K(e.value.type) + " " + K(e.value.items.type) + "[] ", 1)], 64)) : (mo(),
                        vo(lo, {
                            key: 1
                        }, [Co(K(Array.isArray(e.value.type) ? e.value.type.join(" | ") : e.value.type) + " " + K((null == (r = e.value) ? void 0 : r.nullable) ? " | nullable" : ""), 1)], 64)), e.value.minItems || e.value.maxItems ? (mo(),
                        vo(lo, {
                            key: 2
                        }, [Co(K(e.value.minItems) + "…" + K(e.value.maxItems), 1)], 64)) : Do("", !0)]
                    }
                    )),
                    _: 2
                }, [e.additional ? {
                    name: "prefix",
                    fn: dn((()=>[Co("value:")])),
                    key: "0"
                } : void 0]), 1024), e.value.minLength ? (mo(),
                yo(f2, {
                    key: 1
                }, {
                    prefix: dn((()=>[Co("min:")])),
                    default: dn((()=>[Co(" " + K(e.value.minLength), 1)])),
                    _: 1
                })) : Do("", !0), e.value.maxLength ? (mo(),
                yo(f2, {
                    key: 2
                }, {
                    prefix: dn((()=>[Co("max:")])),
                    default: dn((()=>[Co(" " + K(e.value.maxLength), 1)])),
                    _: 1
                })) : Do("", !0), e.value.uniqueItems ? (mo(),
                yo(f2, {
                    key: 3
                }, {
                    default: dn((()=>[Co(" unique! ")])),
                    _: 1
                })) : Do("", !0), e.value.format ? (mo(),
                yo(f2, {
                    key: 4
                }, {
                    default: dn((()=>[Co(K(e.value.format), 1)])),
                    _: 1
                })) : Do("", !0), void 0 !== e.value.minimum && e.value.exclusiveMinimum ? (mo(),
                yo(f2, {
                    key: 5
                }, {
                    prefix: dn((()=>[Co("greater than:")])),
                    default: dn((()=>[Co(" " + K(e.value.minimum), 1)])),
                    _: 1
                })) : Do("", !0), void 0 === e.value.minimum || e.value.exclusiveMinimum ? Do("", !0) : (mo(),
                yo(f2, {
                    key: 6
                }, {
                    prefix: dn((()=>[Co("min:")])),
                    default: dn((()=>[Co(" " + K(e.value.minimum), 1)])),
                    _: 1
                })), void 0 !== e.value.maximum && e.value.exclusiveMaximum ? (mo(),
                yo(f2, {
                    key: 7
                }, {
                    prefix: dn((()=>[Co("less than:")])),
                    default: dn((()=>[Co(" " + K(e.value.maximum), 1)])),
                    _: 1
                })) : Do("", !0), void 0 === e.value.maximum || e.value.exclusiveMaximum ? Do("", !0) : (mo(),
                yo(f2, {
                    key: 8
                }, {
                    prefix: dn((()=>[Co("max:")])),
                    default: dn((()=>[Co(" " + K(e.value.maximum), 1)])),
                    _: 1
                })), e.value.pattern ? (mo(),
                yo(f2, {
                    key: 9,
                    code: "",
                    truncate: ""
                }, {
                    default: dn((()=>[Co(K(e.value.pattern), 1)])),
                    _: 1
                })) : Do("", !0), e.$props.enum ? (mo(),
                yo(f2, {
                    key: 10
                }, {
                    default: dn((()=>[Co("enum")])),
                    _: 1
                })) : Do("", !0), e.value.default ? (mo(),
                yo(f2, {
                    key: 11,
                    truncate: ""
                }, {
                    prefix: dn((()=>[Co("default:")])),
                    default: dn((()=>[Co(" " + K(e.value.default), 1)])),
                    _: 1
                })) : Do("", !0)])) : Do("", !0), (null == (l = e.value) ? void 0 : l.writeOnly) ? (mo(),
                vo("div", _2, " write-only ")) : (null == (c = e.value) ? void 0 : c.readOnly) ? (mo(),
                vo("div", k2, " read-only ")) : Do("", !0), (mo(!0),
                vo(lo, null, In(t.filter((t=>{
                    var n, r, o;
                    return (null == (n = e.value) ? void 0 : n[t]) || (null == (o = null == (r = e.value) ? void 0 : r.items) ? void 0 : o[t])
                }
                )), (e=>(mo(),
                yo(Ct(s1), {
                    key: e
                }, {
                    default: dn((()=>[Co(K(e), 1)])),
                    _: 2
                }, 1024)))), 128))])
            }
        }
    })
      , E2 = k0(S2, [["__scopeId", "data-v-2489a259"]])
      , x2 = e=>(cn("data-v-fb06e93b"),
    e = e(),
    un(),
    e)
      , T2 = {
        key: 0,
        class: "property-description"
    }
      , A2 = {
        key: 1,
        class: "property-description"
    }
      , C2 = {
        key: 2,
        class: "property-example custom-scroll"
    }
      , P2 = x2((()=>Eo("span", {
        class: "property-example-label"
    }, "Example", -1)))
      , D2 = {
        class: "property-example-value"
    }
      , R2 = {
        key: 3,
        class: "property-enum"
    }
      , N2 = {
        key: 0,
        class: "property-list"
    }
      , $2 = {
        class: "property-heading"
    }
      , I2 = {
        class: "property-name"
    }
      , M2 = {
        class: "property-description"
    }
      , L2 = {
        key: 1,
        class: "property-enum-values"
    }
      , Q2 = {
        key: 4,
        class: "children"
    }
      , B2 = {
        key: 0,
        class: "children"
    }
      , U2 = {
        key: 0,
        class: "property-rule"
    }
      , F2 = {
        key: 1,
        class: "property-rule"
    }
      , j2 = k0(Ln({
        __name: "SchemaProperty",
        props: {
            value: {},
            level: {
                default: 0
            },
            name: {},
            required: {
                type: Boolean,
                default: !1
            },
            compact: {
                type: Boolean,
                default: !1
            },
            description: {},
            additional: {
                type: Boolean
            }
        },
        setup(e) {
            const t = {
                integer: {
                    _default: "Integer numbers.",
                    int32: "Signed 32-bit integers (commonly used integer type).",
                    int64: "Signed 64-bit integers (long type)."
                },
                string: {
                    date: "full-date notation as defined by RFC 3339, section 5.6, for example, 2017-07-21",
                    "date-time": "the date-time notation as defined by RFC 3339, section 5.6, for example, 2017-07-21T17:32:28Z",
                    password: "a hint to UIs to mask the input",
                    byte: "base64-encoded characters, for example, U3dhZ2dlciByb2Nrcw==",
                    binary: "binary data, used to describe files"
                }
            }
              , n = function(e, t) {
                return (null == t ? void 0 : t.properties) || (null == t ? void 0 : t.additionalProperties) ? null : e || (null == t ? void 0 : t.description) || null
            }
              , r = function(e) {
                return e && t[e.type] ? t[e.type][e.format || "_default"] : null
            }
              , o = function(e) {
                var t;
                return (null == e ? void 0 : e.enum) || (null == (t = null == e ? void 0 : e.items) ? void 0 : t.enum) || []
            }
              , i = ["oneOf", "anyOf", "allOf", "not"];
            return (e,t)=>{
                var a, s, l, c, u, d, p, h, f, m, g;
                return mo(),
                vo("div", {
                    class: Z(["property", [`property--level-${e.level}`, {
                        "property--compact": e.compact,
                        "property--deprecated": null == (a = e.value) ? void 0 : a.deprecated
                    }]])
                }, [xo(E2, {
                    additional: e.additional,
                    enum: o(e.value).length > 1,
                    required: e.required,
                    value: e.value
                }, Mn({
                    _: 2
                }, [e.name ? {
                    name: "name",
                    fn: dn((()=>[Co(K(e.name), 1)])),
                    key: "0"
                } : void 0]), 1032, ["additional", "enum", "required", "value"]), n(e.description, e.value) ? (mo(),
                vo("div", T2, [xo(Ct(XT), {
                    value: n(e.description, e.value)
                }, null, 8, ["value"])])) : r(e.value) ? (mo(),
                vo("div", A2, [xo(Ct(XT), {
                    value: r(e.value) || ""
                }, null, 8, ["value"])])) : Do("", !0), (null == (s = e.value) ? void 0 : s.example) || (null == (c = null == (l = e.value) ? void 0 : l.items) ? void 0 : c.example) ? (mo(),
                vo("div", C2, [P2, Eo("code", D2, K(e.value.example || (null == (u = e.value) ? void 0 : u.items.example)), 1)])) : Do("", !0), (null == (d = o(e.value)) ? void 0 : d.length) > 1 ? (mo(),
                vo("div", R2, [(null == (p = e.value) ? void 0 : p["x-enumDescriptions"]) ? (mo(),
                vo("div", N2, [(mo(!0),
                vo(lo, null, In(o(e.value), (t=>(mo(),
                vo("div", {
                    key: t,
                    class: "property"
                }, [Eo("div", $2, [Eo("div", I2, K(t), 1)]), Eo("div", M2, [xo(Ct(XT), {
                    value: e.value["x-enumDescriptions"][t]
                }, null, 8, ["value"])])])))), 128))])) : (mo(),
                vo("ul", L2, [(mo(!0),
                vo(lo, null, In(o(e.value), (e=>(mo(),
                vo("li", {
                    key: e,
                    class: "property-enum-value"
                }, K(e), 1)))), 128))]))])) : Do("", !0), "object" === (null == (h = e.value) ? void 0 : h.type) && ((null == (f = e.value) ? void 0 : f.properties) || (null == (m = e.value) ? void 0 : m.additionalProperties)) ? (mo(),
                vo("div", Q2, [xo(W2, {
                    compact: e.compact,
                    level: e.level + 1,
                    value: e.value
                }, null, 8, ["compact", "level", "value"])])) : Do("", !0), (null == (g = e.value) ? void 0 : g.items) ? (mo(),
                vo(lo, {
                    key: 5
                }, [["object"].includes(e.value.items.type) ? (mo(),
                vo("div", B2, [xo(W2, {
                    compact: e.compact,
                    level: e.level + 1,
                    value: e.value.items
                }, null, 8, ["compact", "level", "value"])])) : Do("", !0)], 64)) : Do("", !0), (mo(),
                vo(lo, null, In(i, (t=>{
                    var n, r, o;
                    return mo(),
                    vo(lo, {
                        key: t
                    }, [(null == (n = e.value) ? void 0 : n[t]) ? (mo(),
                    vo("div", U2, [(mo(!0),
                    vo(lo, null, In(e.value[t], ((t,n)=>(mo(),
                    yo(W2, {
                        key: n,
                        compact: e.compact,
                        level: e.level + 1,
                        value: t
                    }, null, 8, ["compact", "level", "value"])))), 128))])) : Do("", !0), (null == (o = null == (r = e.value) ? void 0 : r.items) ? void 0 : o[t]) && e.level < 3 ? (mo(),
                    vo("div", F2, [(mo(!0),
                    vo(lo, null, In(e.value.items[t], ((t,n)=>(mo(),
                    yo(W2, {
                        key: n,
                        compact: e.compact,
                        level: e.level + 1,
                        value: t
                    }, null, 8, ["compact", "level", "value"])))), 128))])) : Do("", !0)], 64)
                }
                )), 64))], 2)
            }
        }
    }), [["__scopeId", "data-v-fb06e93b"]])
      , z2 = e=>(cn("data-v-25443e6c"),
    e = e(),
    un(),
    e)
      , q2 = {
        key: 0,
        class: "schema-card-description"
    }
      , H2 = [z2((()=>Eo("polygon", {
        "fill-rule": "nonzero",
        points: "14 8 8 8 8 14 6 14 6 8 0 8 0 6 6 6 6 0 8 0 8 6 14 6"
    }, null, -1)))]
      , Z2 = Ln({
        __name: "Schema",
        props: {
            value: {
                type: [Object, Boolean]
            },
            level: {
                default: 0
            },
            name: {},
            compact: {
                type: Boolean
            },
            noncollapsible: {
                type: Boolean
            }
        },
        setup(e) {
            const t = e
              , n = ei((()=>!t.noncollapsible && 0 !== t.level))
              , r = e=>t.noncollapsible && e.stopPropagation();
            return (e,t)=>"object" == typeof e.value && Object.keys(e.value).length ? (mo(),
            yo(Ct(Ms), {
                key: 0,
                defaultOpen: e.noncollapsible
            }, {
                default: dn((({open: t})=>{
                    var o;
                    return [Eo("div", {
                        class: Z(["schema-card", [`schema-card--level-${e.level}`, {
                            "schema-card--compact": e.compact,
                            "schema-card--open": t
                        }]])
                    }, [(null == (o = e.value) ? void 0 : o.description) && "string" == typeof e.value.description ? (mo(),
                    vo("div", q2, [xo(Ct(XT), {
                        value: e.value.description
                    }, null, 8, ["value"])])) : Do("", !0), Eo("div", {
                        class: Z(["schema-properties", {
                            "schema-properties-open": t
                        }])
                    }, [Nn(xo(Ct(Ls), {
                        as: e.noncollapsible ? "div" : "button",
                        class: Z(["schema-card-title", {
                            "schema-card-title--compact": e.compact
                        }]),
                        style: F({
                            top: `calc(var(--refs-header-height) +  calc(var(--schema-title-height) * ${e.level}))`
                        }),
                        onClickCapture: r
                    }, {
                        default: dn((()=>{
                            var r, o, i;
                            return [e.compact ? (mo(),
                            vo(lo, {
                                key: 0
                            }, [n.value ? (mo(),
                            vo("svg", {
                                key: 0,
                                class: Z(["schema-card-title-icon", {
                                    "schema-card-title-icon--open": t
                                }]),
                                fill: "currentColor",
                                height: "14",
                                viewBox: "0 0 14 14",
                                width: "14",
                                xmlns: "http://www.w3.org/2000/svg"
                            }, H2, 2)) : Do("", !0), t ? (mo(),
                            vo(lo, {
                                key: 1
                            }, [Co(" Hide " + K((null == (r = e.value) ? void 0 : r.title) ?? "Child Attributes"), 1)], 64)) : (mo(),
                            vo(lo, {
                                key: 2
                            }, [Co(" Show " + K((null == (o = e.value) ? void 0 : o.title) ?? "Child Attributes"), 1)], 64))], 64)) : (mo(),
                            vo(lo, {
                                key: 1
                            }, [n.value ? (mo(),
                            yo(Ct(rC), {
                                key: 0,
                                class: Z(["schema-card-title-icon", {
                                    "schema-card-title-icon--open": t
                                }]),
                                icon: "ChevronRight",
                                size: "md"
                            }, null, 8, ["class"])) : Do("", !0), xo(u2, {
                                name: (null == (i = e.value) ? void 0 : i.title) ?? e.name,
                                value: e.value
                            }, null, 8, ["name", "value"])], 64))]
                        }
                        )),
                        _: 2
                    }, 1032, ["as", "class", "style"]), [[ci, !(e.noncollapsible && e.compact)]]), xo(Ct(Qs), {
                        static: e.noncollapsible
                    }, {
                        default: dn((()=>{
                            var t;
                            return [e.value.properties || e.value.additionalProperties ? (mo(),
                            vo(lo, {
                                key: 0
                            }, [e.value.properties ? (mo(!0),
                            vo(lo, {
                                key: 0
                            }, In(Object.keys(null == (t = e.value) ? void 0 : t.properties), (t=>{
                                var n, r, o, i;
                                return mo(),
                                yo(j2, {
                                    key: t,
                                    compact: e.compact,
                                    level: e.level,
                                    name: t,
                                    required: (null == (n = e.value.required) ? void 0 : n.includes(t)) || !0 === (null == (o = null == (r = e.value.properties) ? void 0 : r[t]) ? void 0 : o.required),
                                    value: null == (i = e.value.properties) ? void 0 : i[t]
                                }, null, 8, ["compact", "level", "name", "required", "value"])
                            }
                            )), 128)) : Do("", !0), e.value.additionalProperties ? (mo(),
                            vo(lo, {
                                key: 1
                            }, [!0 !== e.value.additionalProperties && 0 !== Object.keys(e.value.additionalProperties).length && e.value.additionalProperties.type ? (mo(),
                            yo(j2, {
                                key: 1,
                                additional: "",
                                compact: e.compact,
                                level: e.level,
                                noncollapsible: "",
                                value: e.value.additionalProperties
                            }, null, 8, ["compact", "level", "value"])) : (mo(),
                            yo(j2, {
                                key: 0,
                                additional: "",
                                compact: e.compact,
                                level: e.level,
                                noncollapsible: "",
                                value: {
                                    type: "any",
                                    ..."object" == typeof e.value.additionalProperties ? e.value.additionalProperties : {}
                                }
                            }, null, 8, ["compact", "level", "value"]))], 64)) : Do("", !0)], 64)) : (mo(),
                            yo(j2, {
                                key: 1,
                                compact: e.compact,
                                level: e.level,
                                name: e.value.name,
                                value: e.value
                            }, null, 8, ["compact", "level", "name", "value"]))]
                        }
                        )),
                        _: 1
                    }, 8, ["static"])], 2)], 2)]
                }
                )),
                _: 1
            }, 8, ["defaultOpen"])) : Do("", !0)
        }
    })
      , W2 = k0(Z2, [["__scopeId", "data-v-25443e6c"]])
      , X2 = {
        class: "parameter-item"
    }
      , V2 = {
        class: "parameter-item-container"
    }
      , G2 = k0(Ln({
        __name: "ParameterItem",
        props: {
            parameter: {},
            showChildren: {
                type: Boolean,
                default: !1
            }
        },
        setup: e=>(e,t)=>(mo(),
        vo("li", X2, [Eo("div", V2, [xo(Ct(j2), {
            compact: "",
            description: e.parameter.description,
            level: 0,
            name: e.parameter.name,
            noncollapsible: e.showChildren,
            required: e.parameter.required,
            value: e.parameter.schema
        }, null, 8, ["description", "name", "noncollapsible", "required", "value"])])]))
    }), [["__scopeId", "data-v-f70ee55c"]])
      , Y2 = {
        key: 0,
        class: "parameters"
    }
      , K2 = {
        class: "parameters-title"
    }
      , J2 = {
        class: "parameter-list"
    }
      , e5 = k0(Ln({
        __name: "Parameters",
        props: {
            parameters: {},
            showChildren: {
                type: Boolean,
                default: !1
            }
        },
        setup: e=>(e,t)=>{
            var n;
            return (null == (n = e.parameters) ? void 0 : n.length) ? (mo(),
            vo("div", Y2, [Eo("div", K2, [Fn(e.$slots, "title", {}, void 0, !0)]), Eo("ul", J2, [(mo(!0),
            vo(lo, null, In(e.parameters, (t=>(mo(),
            yo(G2, {
                key: t.name,
                parameter: t,
                showChildren: e.showChildren
            }, null, 8, ["parameter", "showChildren"])))), 128))])])) : Do("", !0)
        }
    }), [["__scopeId", "data-v-45fca787"]])
      , t5 = {
        key: 0
    }
      , n5 = {
        class: "request-body-title"
    }
      , r5 = ["value"]
      , o5 = {
        key: 0,
        class: "request-body-description"
    }
      , i5 = {
        key: 0,
        class: "request-body-schema"
    }
      , a5 = k0(Ln({
        __name: "RequestBody",
        props: {
            requestBody: {}
        },
        setup(e) {
            var t;
            const n = e
              , r = ei((()=>{
                var e;
                return (null == (e = n.requestBody) ? void 0 : e.content) ? Object.keys(n.requestBody.content) : []
            }
            ))
              , o = Et("application/json");
            return (null == (t = n.requestBody) ? void 0 : t.content) && r.value.length > 0 && (o.value = r.value[0]),
            (e,t)=>{
                var i, a, s, l;
                return (null == n ? void 0 : n.requestBody) ? (mo(),
                vo("div", t5, [Eo("div", n5, [Fn(e.$slots, "title", {}, void 0, !0), Eo("div", {
                    class: Z(["request-body-title-select", {
                        "request-body-title-no-select": r.value.length <= 1
                    }])
                }, [Eo("span", null, K(o.value), 1), (null == n ? void 0 : n.requestBody) && r.value.length > 1 ? Nn((mo(),
                vo("select", {
                    key: 0,
                    "onUpdate:modelValue": t[0] || (t[0] = e=>o.value = e)
                }, [(mo(!0),
                vo(lo, null, In(null == (i = n.requestBody) ? void 0 : i.content, ((e,t)=>(mo(),
                vo("option", {
                    key: t,
                    value: t
                }, K(t), 9, r5)))), 128))], 512)), [[Li, o.value]]) : Do("", !0)], 2), (null == n ? void 0 : n.requestBody.description) ? (mo(),
                vo("div", o5, [xo(Ct(XT), {
                    value: n.requestBody.description
                }, null, 8, ["value"])])) : Do("", !0)]), (null == (a = null == n ? void 0 : n.requestBody.content) ? void 0 : a[o.value]) ? (mo(),
                vo("div", i5, [xo(Ct(W2), {
                    compact: "",
                    noncollapsible: "",
                    value: null == (l = null == (s = null == n ? void 0 : n.requestBody.content) ? void 0 : s[o.value]) ? void 0 : l.schema
                }, null, 8, ["value"])])) : Do("", !0)])) : Do("", !0)
            }
        }
    }), [["__scopeId", "data-v-23ed11af"]])
      , s5 = {
        class: "endpoint-details"
    }
      , l5 = {
        class: "endpoint-description"
    }
      , c5 = Ln({
        __name: "EndpointDetails",
        props: {
            operation: {}
        },
        setup(e) {
            const t = e
              , {parameterMap: n} = QY(t)
              , {responses: r} = DK(t.operation);
            return (e,t)=>{
                var o, i;
                return mo(),
                vo("div", s5, [Eo("div", l5, [xo(Ct(XT), {
                    value: e.operation.description,
                    withImages: ""
                }, null, 8, ["value"])]), xo(e5, {
                    parameters: Ct(n).path
                }, {
                    title: dn((()=>[Co("Path Parameters")])),
                    _: 1
                }, 8, ["parameters"]), xo(e5, {
                    parameters: Ct(n).query
                }, {
                    title: dn((()=>[Co("Query Parameters")])),
                    _: 1
                }, 8, ["parameters"]), xo(e5, {
                    parameters: Ct(n).header
                }, {
                    title: dn((()=>[Co("Headers")])),
                    _: 1
                }, 8, ["parameters"]), xo(e5, {
                    parameters: Ct(n).body,
                    showChildren: ""
                }, {
                    title: dn((()=>[Co("Body Parameters")])),
                    _: 1
                }, 8, ["parameters"]), xo(e5, {
                    parameters: Ct(n).formData
                }, {
                    title: dn((()=>[Co("Form Data")])),
                    _: 1
                }, 8, ["parameters"]), (null == (o = e.operation.information) ? void 0 : o.requestBody) ? (mo(),
                yo(a5, {
                    key: 0,
                    requestBody: null == (i = e.operation.information) ? void 0 : i.requestBody
                }, {
                    title: dn((()=>[Co("Body")])),
                    _: 1
                }, 8, ["requestBody"])) : Do("", !0), xo(e5, {
                    parameters: Ct(r)
                }, {
                    title: dn((()=>[Co("Responses")])),
                    _: 1
                }, 8, ["parameters"])])
            }
        }
    })
      , u5 = {
        key: 0
    }
      , d5 = Ln({
        __name: "EndpointPath",
        props: {
            path: {},
            deprecated: {
                type: Boolean
            }
        },
        setup(e) {
            const t = e
              , n = e=>e.startsWith("{") && e.endsWith("}")
              , r = ei((()=>t.path.split(/({[^}]+})/)));
            return (e,t)=>(mo(),
            vo("span", {
                class: Z(["endpoint-path", {
                    deprecated: e.deprecated
                }])
            }, [(mo(!0),
            vo(lo, null, In(r.value, ((e,t)=>(mo(),
            vo(lo, {
                key: t
            }, [n(e) ? (mo(),
            vo("em", u5, K(e), 1)) : (mo(),
            vo(lo, {
                key: 1
            }, [Co(K(e), 1)], 64))], 64)))), 128))], 2))
        }
    })
      , p5 = k0(d5, [["__scopeId", "data-v-a4eadd9b"]]);
    function h5(e) {
        return e.reduce(((e,t)=>(e[t.name] = t.value,
        e)), {})
    }
    function f5(e) {
        return /\s|-/.test(e)
    }
    function m5(e, t=0) {
        let n = []
          , r = " ".repeat(t)
          , o = " ".repeat(t + 2);
        for (const [i,a] of Object.entries(e)) {
            let e = f5(i) ? `'${i}'` : i;
            if (Array.isArray(a)) {
                const r = a.map((e=>"string" == typeof e ? `'${e}'` : e && "object" == typeof e ? m5(e, t + 2) : e)).join(`, ${o}`);
                n.push(`${o}${e}: [${r}]`)
            } else if (a && "object" == typeof a)
                n.push(`${o}${e}: ${m5(a, t + 2)}`);
            else if ("string" == typeof a) {
                let t = `${a}`;
                if (a.startsWith("JSON.stringify")) {
                    const e = a.split("\n");
                    e.length > 1 && (t = e.map(((e,t)=>0 === t ? e : `${o}${e}`)).join("\n"))
                } else
                    t = `'${a}'`;
                n.push(`${o}${e}: ${t}`)
            } else
                n.push(`${o}${e}: ${a}`)
        }
        return `{\n${n.join(",\n")}\n${r}}`
    }
    function g5(e) {
        var t, n;
        const r = {
            method: "GET",
            ...e
        };
        r.method = r.method.toUpperCase();
        const o = {
            method: "GET" === r.method ? void 0 : r.method
        }
          , i = new URLSearchParams(r.queryString ? h5(r.queryString) : void 0)
          , a = i.size ? `?${i.toString()}` : "";
        null != (t = r.headers) && t.length && (o.headers = {},
        r.headers.forEach((e=>{
            o.headers[e.name] = e.value
        }
        ))),
        null != (n = r.cookies) && n.length && (o.headers = o.headers || {},
        r.cookies.forEach((e=>{
            o.headers["Set-Cookie"] = o.headers["Set-Cookie"] ? `${o.headers["Set-Cookie"]}; ${e.name}=${e.value}` : `${e.name}=${e.value}`
        }
        ))),
        Object.keys(o).forEach((e=>{
            void 0 === o[e] && delete o[e]
        }
        )),
        r.postData && (o.body = r.postData.text,
        "application/json" === r.postData.mimeType && (o.body = `JSON.stringify(${m5(JSON.parse(o.body))})`));
        const s = Object.keys(o).length ? `, ${m5(o)}` : "";
        return {
            target: "node",
            client: "undici",
            code: `import { request } from 'undici'\n\nconst { statusCode, body } = await request('${r.url}${a}'${s})`
        }
    }
    function b5(e) {
        var t, n;
        const r = {
            method: "GET",
            ...e
        };
        r.method = r.method.toUpperCase();
        const o = {
            method: "GET" === r.method ? void 0 : r.method
        }
          , i = new URLSearchParams(r.queryString ? h5(r.queryString) : void 0)
          , a = i.size ? `?${i.toString()}` : "";
        null != (t = r.headers) && t.length && (o.headers = {},
        r.headers.forEach((e=>{
            o.headers[e.name] = e.value
        }
        ))),
        null != (n = r.cookies) && n.length && (o.headers = o.headers || {},
        r.cookies.forEach((e=>{
            o.headers["Set-Cookie"] = o.headers["Set-Cookie"] ? `${o.headers["Set-Cookie"]}; ${e.name}=${e.value}` : `${e.name}=${e.value}`
        }
        ))),
        Object.keys(o).forEach((e=>{
            void 0 === o[e] && delete o[e]
        }
        )),
        r.postData && (o.body = r.postData.text,
        "application/json" === r.postData.mimeType && (o.body = `JSON.stringify(${m5(JSON.parse(o.body))})`));
        const s = Object.keys(o).length ? `, ${m5(o)}` : "";
        return {
            target: "node",
            client: "fetch",
            code: `fetch('${r.url}${a}'${s})`
        }
    }
    function O5(e) {
        var t, n;
        const r = {
            method: "GET",
            ...e
        };
        r.method = r.method.toUpperCase();
        const o = {
            method: "GET" === r.method ? void 0 : r.method
        }
          , i = new URLSearchParams(r.queryString ? h5(r.queryString) : void 0)
          , a = i.size ? `?${i.toString()}` : "";
        null != (t = r.headers) && t.length && (o.headers = {},
        r.headers.forEach((e=>{
            o.headers[e.name] = e.value
        }
        ))),
        null != (n = r.cookies) && n.length && (o.headers = o.headers || {},
        r.cookies.forEach((e=>{
            o.headers["Set-Cookie"] = o.headers["Set-Cookie"] ? `${o.headers["Set-Cookie"]}; ${e.name}=${e.value}` : `${e.name}=${e.value}`
        }
        ))),
        Object.keys(o).forEach((e=>{
            void 0 === o[e] && delete o[e]
        }
        )),
        r.postData && (o.body = r.postData.text,
        "application/json" === r.postData.mimeType && (o.body = `JSON.stringify(${m5(JSON.parse(o.body))})`));
        const s = Object.keys(o).length ? `, ${m5(o)}` : "";
        return {
            target: "js",
            client: "fetch",
            code: `fetch('${r.url}${a}'${s})`
        }
    }
    function v5(e) {
        var t, n;
        const r = {
            method: "GET",
            ...e
        };
        r.method = r.method.toUpperCase();
        const o = {
            method: "GET" === r.method ? void 0 : r.method
        }
          , i = new URLSearchParams(r.queryString ? h5(r.queryString) : void 0);
        i.size && (o.query = {},
        i.forEach(((e,t)=>{
            o.query[t] = e
        }
        ))),
        null != (t = r.headers) && t.length && (o.headers = {},
        r.headers.forEach((e=>{
            o.headers[e.name] = e.value
        }
        ))),
        null != (n = r.cookies) && n.length && (o.headers = o.headers || {},
        r.cookies.forEach((e=>{
            o.headers["Set-Cookie"] = o.headers["Set-Cookie"] ? `${o.headers["Set-Cookie"]}; ${e.name}=${e.value}` : `${e.name}=${e.value}`
        }
        ))),
        Object.keys(o).forEach((e=>{
            void 0 === o[e] && delete o[e]
        }
        )),
        r.postData && (o.body = r.postData.text,
        "application/json" === r.postData.mimeType && (o.body = JSON.parse(o.body)));
        const a = Object.keys(o).length ? `, ${m5(o)}` : "";
        return {
            target: "js",
            client: "ofetch",
            code: `ofetch('${r.url}'${a})`
        }
    }
    function y5(e) {
        var t, n;
        const r = {
            method: "GET",
            ...e
        };
        r.method = r.method.toUpperCase();
        const o = {
            method: "GET" === r.method ? void 0 : r.method
        }
          , i = new URLSearchParams(r.queryString ? h5(r.queryString) : void 0);
        i.size && (o.query = {},
        i.forEach(((e,t)=>{
            o.query[t] = e
        }
        ))),
        null != (t = r.headers) && t.length && (o.headers = {},
        r.headers.forEach((e=>{
            o.headers[e.name] = e.value
        }
        ))),
        null != (n = r.cookies) && n.length && (o.headers = o.headers || {},
        r.cookies.forEach((e=>{
            o.headers["Set-Cookie"] = o.headers["Set-Cookie"] ? `${o.headers["Set-Cookie"]}; ${e.name}=${e.value}` : `${e.name}=${e.value}`
        }
        ))),
        Object.keys(o).forEach((e=>{
            void 0 === o[e] && delete o[e]
        }
        )),
        r.postData && (o.body = r.postData.text,
        "application/json" === r.postData.mimeType && (o.body = JSON.parse(o.body)));
        const a = Object.keys(o).length ? `, ${m5(o)}` : "";
        return {
            target: "node",
            client: "ofetch",
            code: `ofetch('${r.url}'${a})`
        }
    }
    function w5() {
        const e = [g5, b5, O5, v5, y5];
        return {
            get(e, t, n) {
                const r = this.findPlugin(e, t);
                if (r)
                    return r(n)
            },
            print(e, t, n) {
                var r;
                return null == (r = this.get(e, t, n)) ? void 0 : r.code
            },
            targets: ()=>e.map((e=>e().target)).filter(((e,t,n)=>n.indexOf(e) === t)),
            clients: ()=>e.map((e=>e().client)),
            plugins: ()=>e.map((e=>{
                const t = e();
                return {
                    target: t.target,
                    client: t.client
                }
            }
            )),
            findPlugin: (t,n)=>e.find((e=>{
                const r = e();
                return r.target === t && r.client === n
            }
            )),
            hasPlugin(e, t) {
                return !!this.findPlugin(e, t)
            }
        }
    }
    const _5 = k0(Ln({
        __name: "ExamplePicker",
        props: {
            examples: {}
        },
        emits: ["update:modelValue"],
        setup(e, {emit: t}) {
            const n = e
              , r = t
              , o = Et(Object.keys(n.examples)[0]);
            function i(e) {
                if (!e)
                    return "Select an example";
                const t = n.examples[e];
                return (null == t ? void 0 : t.summary) ?? e
            }
            return zr((()=>n.examples), (()=>{
                var e;
                (e = Object.keys(n.examples)[0]) && (o.value = e)
            }
            ), {
                immediate: !0
            }),
            zr(o, (()=>{
                o.value && r("update:modelValue", o.value)
            }
            ), {
                immediate: !0
            }),
            (e,t)=>(mo(),
            yo(i2, {
                modelValue: o.value,
                "onUpdate:modelValue": t[0] || (t[0] = e=>o.value = e),
                class: "example-selector",
                options: Object.keys(e.examples).map((e=>({
                    label: i(e),
                    value: e
                })))
            }, {
                default: dn((()=>[Co(K(i(o.value)), 1)])),
                _: 1
            }, 8, ["modelValue", "options"]))
        }
    }), [["__scopeId", "data-v-652a7e14"]])
      , k5 = {
        class: "request-header"
    }
      , S5 = {
        class: "code-snippet"
    }
      , E5 = {
        key: 0,
        class: "request-card-footer-addon"
    }
      , x5 = Ln({
        __name: "ExampleRequest",
        props: {
            operation: {}
        },
        setup(e) {
            const t = e
              , n = `components-Content-Operation-Example-Request${PS(t.operation.path + t.operation.httpVerb + t.operation.operationId)}`
              , r = Et()
              , {copyToClipboard: o} = OY()
              , {httpClient: i, setHttpClient: a, availableTargets: s, httpTargetTitle: l, httpClientTitle: c} = b0()
              , {server: u} = DV()
              , {authentication: d} = xq()
              , p = ei((()=>{
                var e, n, r, o;
                return Object.keys((null == (o = null == (r = null == (n = null == (e = t.operation.information) ? void 0 : e.requestBody) ? void 0 : n.content) ? void 0 : r["application/json"]) ? void 0 : o.examples) ?? {}).length > 1
            }
            ))
              , h = pr(kK);
            async function f() {
                var e;
                const n = AK({
                    url: TV(u)
                }, zY(t.operation, {
                    replaceVariables: !0
                }, r.value), yq(d, (null == (e = t.operation.information) ? void 0 : e.security) ?? (null == h ? void 0 : h())))
                  , o = "undici" === i.clientKey || "fetch" === i.clientKey || "ofetch" === i.clientKey ? i.clientKey : null
                  , a = i.targetKey.replace("javascript", "js");
                if (o && w5().hasPlugin(a, o) && ("node" === a || "js" === a))
                    return w5().print(a, o, n) ?? "";
                try {
                    const e = new i0(n);
                    return await e.convert(i.targetKey, i.clientKey)
                } catch (Aa) {
                    return console.error("[ExampleRequest]", Aa),
                    ""
                }
            }
            const m = Tl(f, qT[n] ?? "");
            Cn((async()=>{
                Ur().payload.data[n] = await f()
            }
            )),
            ei((()=>qY({
                serverState: u,
                authenticationState: d,
                operation: t.operation,
                globalSecurity: null == h ? void 0 : h()
            })));
            const g = ei((()=>{
                const e = i.targetKey;
                return "shell" === e && m.value.includes("curl") ? "curl" : "c" === e || "csharp" === e ? "cpp" : e
            }
            ));
            return (e,t)=>(mo(),
            yo(Ct(Z1), {
                class: "dark-mode"
            }, {
                default: dn((()=>[xo(Ct(Y1), {
                    muted: ""
                }, {
                    actions: dn((()=>[xo(i2, {
                        class: "request-client-picker",
                        modelValue: JSON.stringify(Ct(i)),
                        options: Ct(s).map((e=>({
                            value: e.key,
                            label: e.title,
                            options: e.clients.map((t=>({
                                value: JSON.stringify({
                                    targetKey: e.key,
                                    clientKey: t.key
                                }),
                                label: t.title
                            })))
                        }))),
                        "onUpdate:modelValue": t[0] || (t[0] = e=>Ct(a)(JSON.parse(e)))
                    }, {
                        default: dn((()=>[Co(K(Ct(l)) + " " + K(Ct(c)), 1)])),
                        _: 1
                    }, 8, ["modelValue", "options"]), Eo("button", {
                        class: "copy-button",
                        type: "button",
                        onClick: t[1] || (t[1] = e=>Ct(o)(Ct(m)))
                    }, [xo(Ct(rC), {
                        icon: "Clipboard",
                        width: "10px"
                    })])])),
                    default: dn((()=>[Eo("div", k5, [xo(Ct(Fl), {
                        as: "span",
                        class: "request-method",
                        method: e.operation.httpVerb
                    }, null, 8, ["method"]), Fn(e.$slots, "header", {}, void 0, !0)])])),
                    _: 3
                }), xo(Ct(W1), {
                    borderless: "",
                    class: "request-editor-section custom-scroll",
                    frameless: ""
                }, {
                    default: dn((()=>[Eo("div", S5, [xo(Ct(ZT), {
                        content: Ct(m),
                        hideCredentials: Ct(_q)(Ct(d)),
                        lang: g.value,
                        lineNumbers: ""
                    }, null, 8, ["content", "hideCredentials", "lang"])])])),
                    _: 1
                }), p.value || e.$slots.footer ? (mo(),
                yo(Ct(K1), {
                    key: 0,
                    class: "request-card-footer",
                    contrast: ""
                }, {
                    default: dn((()=>{
                        var n, o, i, a;
                        return [p.value ? (mo(),
                        vo("div", E5, [xo(_5, {
                            class: "request-example-selector",
                            examples: (null == (a = null == (i = null == (o = null == (n = e.operation.information) ? void 0 : n.requestBody) ? void 0 : o.content) ? void 0 : i["application/json"]) ? void 0 : a.examples) ?? [],
                            "onUpdate:modelValue": t[2] || (t[2] = e=>r.value = e)
                        }, null, 8, ["examples"])])) : Do("", !0), Fn(e.$slots, "footer", {}, void 0, !0)]
                    }
                    )),
                    _: 3
                })) : Do("", !0)])),
                _: 3
            }))
        }
    })
      , T5 = k0(x5, [["__scopeId", "data-v-0981194a"]])
      , A5 = {
        key: 0
    }
      , C5 = {
        key: 1
    }
      , P5 = {
        key: 0,
        class: "rule"
    }
      , D5 = {
        class: "rule-title"
    }
      , R5 = {
        class: "rule-items"
    }
      , N5 = {
        key: 2,
        class: "empty-state"
    }
      , $5 = k0(Ln({
        __name: "ExampleResponse",
        props: {
            response: {}
        },
        setup(e) {
            const t = ["oneOf", "anyOf", "not"];
            return (e,n)=>{
                var r, o, i, a, s, l, c, u;
                return (null == (r = e.response) ? void 0 : r.example) ? (mo(),
                vo("div", A5, [xo(Ct(ZT), {
                    content: Ct(zT)(null == (o = e.response) ? void 0 : o.example),
                    lang: "json"
                }, null, 8, ["content"])])) : (null == (i = e.response) ? void 0 : i.schema) ? (mo(),
                vo("div", C5, [(null == (a = e.response) ? void 0 : a.schema.type) ? (mo(),
                yo(Ct(ZT), {
                    key: 0,
                    content: Ct(zT)(Ct(UY)(null == (s = e.response) ? void 0 : s.schema, {
                        emptyString: "…",
                        mode: "read"
                    })),
                    lang: "json"
                }, null, 8, ["content"])) : Do("", !0), (mo(),
                vo(lo, null, In(t, (t=>{
                    var n, r, o, i, a, s;
                    return mo(),
                    vo(lo, {
                        key: t
                    }, [(null == (n = e.response) ? void 0 : n.schema[t]) && ((null == (r = e.response) ? void 0 : r.schema[t].length) > 1 || "not" === t) ? (mo(),
                    vo("div", P5, [Eo("div", D5, K(t), 1), Eo("ol", R5, [(mo(!0),
                    vo(lo, null, In(null == (o = e.response) ? void 0 : o.schema[t], ((e,t)=>(mo(),
                    vo("li", {
                        key: t,
                        class: "rule-item"
                    }, [xo(Ct(ZT), {
                        content: Ct(UY)(e, {
                            emptyString: "…",
                            mode: "read"
                        }),
                        lang: "json"
                    }, null, 8, ["content"])])))), 128))])])) : (null == (i = e.response) ? void 0 : i.schema[t]) && 1 === (null == (a = e.response) ? void 0 : a.schema[t].length) ? (mo(),
                    yo(Ct(ZT), {
                        key: 1,
                        content: Ct(UY)(null == (s = e.response) ? void 0 : s.schema[t][0], {
                            emptyString: "…",
                            mode: "read"
                        }),
                        lang: "json"
                    }, null, 8, ["content"])) : Do("", !0)], 64)
                }
                )), 64)), (null == (l = e.response) ? void 0 : l.schema.allOf) ? (mo(),
                yo(Ct(ZT), {
                    key: 1,
                    content: (u = null == (c = e.response) ? void 0 : c.schema.allOf.map((e=>Ct(UY)(e, {
                        emptyString: "…",
                        mode: "read"
                    }))),
                    u.reduce(((e,t)=>({
                        ...e,
                        ...t
                    })), {})),
                    lang: "json"
                }, null, 8, ["content"])) : Do("", !0)])) : (mo(),
                vo("div", N5, " No Body "))
            }
        }
    }), [["__scopeId", "data-v-a29f0b4f"]])
      , I5 = e=>(cn("data-v-357c6dd1"),
    e = e(),
    un(),
    e)
      , M5 = {
        key: 1,
        class: "scalar-card-checkbox"
    }
      , L5 = I5((()=>Eo("span", {
        class: "scalar-card-checkbox-checkmark"
    }, null, -1)))
      , Q5 = {
        class: "scalar-card-container custom-scroll"
    }
      , B5 = {
        key: 1,
        class: "response-description"
    }
      , U5 = k0(Ln({
        __name: "PathResponses",
        props: {
            operation: {}
        },
        setup(e) {
            const t = e
              , {copyToClipboard: n} = OY()
              , r = Et()
              , o = ei((()=>{
                var e, n;
                return Object.keys((null == (n = null == (e = null == t ? void 0 : t.operation) ? void 0 : e.information) ? void 0 : n.responses) ?? {}).sort()
            }
            ))
              , i = ei((()=>!!l.value.examples))
              , a = Et(0)
              , s = ei((()=>{
                var e, n;
                const r = o.value[a.value];
                return null == (n = null == (e = t.operation.information) ? void 0 : e.responses) ? void 0 : n[r]
            }
            ))
              , l = ei((()=>{
                var e;
                const t = FT(null == (e = s.value) ? void 0 : e.content);
                return (null == t ? void 0 : t["application/json"]) ?? (null == t ? void 0 : t["text/plain"]) ?? s.value
            }
            ))
              , c = ()=>{
                if (i.value) {
                    if (Array.isArray(l.value.examples))
                        return l.value.examples[0];
                    {
                        const e = Object.keys(l.value.examples)[0];
                        return l.value.examples[e]
                    }
                }
                return l.value.example
            }
              , u = ei((()=>({
                ...l.value,
                example: i.value && r.value ? l.value.examples[r.value].value ?? l.value.examples[r.value] : c()
            })))
              , d = e=>{
                a.value = e,
                r.value = void 0
            }
              , p = Et(!1);
            return (e,t)=>o.value.length ? (mo(),
            yo(Ct(Z1), {
                key: 0
            }, {
                default: dn((()=>{
                    var e;
                    return [xo(Ct(J1), {
                        muted: "",
                        x: "as",
                        onChange: d
                    }, {
                        actions: dn((()=>{
                            var e, r;
                            return [(null == (e = l.value) ? void 0 : e.example) ? (mo(),
                            vo("button", {
                                key: 0,
                                class: "code-copy",
                                type: "button",
                                onClick: t[0] || (t[0] = ()=>{
                                    var e;
                                    return Ct(n)(null == (e = l.value) ? void 0 : e.example)
                                }
                                )
                            }, [xo(Ct(rC), {
                                icon: "Clipboard",
                                width: "10px",
                                x: "asd"
                            })])) : Do("", !0), (null == (r = l.value) ? void 0 : r.schema) ? (mo(),
                            vo("label", M5, [Co(" Show Schema "), Nn(Eo("input", {
                                "onUpdate:modelValue": t[1] || (t[1] = e=>p.value = e),
                                class: "scalar-card-checkbox-input",
                                type: "checkbox"
                            }, null, 512), [[Ii, p.value]]), L5])) : Do("", !0)]
                        }
                        )),
                        default: dn((()=>[(mo(!0),
                        vo(lo, null, In(o.value, (e=>(mo(),
                        yo(Ct(e2), {
                            key: e
                        }, {
                            default: dn((()=>[Co(K(e), 1)])),
                            _: 2
                        }, 1024)))), 128))])),
                        _: 1
                    }), Eo("div", Q5, [xo(Ct(W1), {
                        muted: ""
                    }, {
                        default: dn((()=>{
                            var e;
                            return [(null == (e = l.value) ? void 0 : e.schema) ? (mo(),
                            vo(lo, {
                                key: 0
                            }, [p.value && u.value ? (mo(),
                            yo(Ct(ZT), {
                                key: 0,
                                content: u.value,
                                lang: "json"
                            }, null, 8, ["content"])) : (mo(),
                            yo($5, {
                                key: 1,
                                response: u.value
                            }, null, 8, ["response"]))], 64)) : (mo(),
                            yo($5, {
                                key: 1,
                                response: u.value
                            }, null, 8, ["response"]))]
                        }
                        )),
                        _: 1
                    })]), (null == (e = s.value) ? void 0 : e.description) || i.value ? (mo(),
                    yo(Ct(K1), {
                        key: 0,
                        class: "response-card-footer",
                        muted: ""
                    }, {
                        default: dn((()=>{
                            var e, n;
                            return [i.value ? (mo(),
                            yo(_5, {
                                key: 0,
                                class: "response-example-selector",
                                examples: null == (e = l.value) ? void 0 : e.examples,
                                "onUpdate:modelValue": t[2] || (t[2] = e=>r.value = e)
                            }, null, 8, ["examples"])) : (null == (n = s.value) ? void 0 : n.description) ? (mo(),
                            vo("div", B5, [xo(Ct(XT), {
                                class: "markdown",
                                value: s.value.description
                            }, null, 8, ["value"])])) : Do("", !0)]
                        }
                        )),
                        _: 1
                    })) : Do("", !0)]
                }
                )),
                _: 1
            })) : Do("", !0)
        }
    }), [["__scopeId", "data-v-357c6dd1"]])
      , F5 = $l(Symbol())
      , j5 = $l("modalState")
      , z5 = e=>(cn("data-v-4b36d4bc"),
    e = e(),
    un(),
    e)
      , q5 = z5((()=>Eo("span", null, "Test Request", -1)))
      , H5 = k0(Ln({
        __name: "TestRequestButton",
        props: {
            operation: {}
        },
        setup(e) {
            const t = pr(kK);
            return (e,n)=>(mo(),
            yo(Ct(Fl), {
                as: "button",
                class: "show-api-client-button",
                method: e.operation.httpVerb,
                type: "button",
                onClick: n[0] || (n[0] = zi((n=>{
                    var r;
                    return Ct(O0) ? Ct(F5).emit({
                        path: e.operation.path,
                        method: e.operation.httpVerb
                    }) : Ct(oK)(e.operation, null == (r = Ct(t)) ? void 0 : r())
                }
                ), ["stop"]))
            }, {
                default: dn((()=>[xo(Ct(rC), {
                    icon: "PaperAirplane"
                }), q5])),
                _: 1
            }, 8, ["method"]))
        }
    }), [["__scopeId", "data-v-4b36d4bc"]])
      , Z5 = {
        class: "examples"
    }
      , W5 = k0(Ln({
        __name: "Operation",
        props: {
            id: {},
            operation: {}
        },
        setup(e) {
            const t = e
              , {availableTargets: n} = b0()
              , r = ei((()=>{
                var e;
                const n = ["x-custom-examples", "x-codeSamples", "x-code-samples"];
                for (const r of n)
                    if (null == (e = t.operation.information) ? void 0 : e[r])
                        return t.operation.information[r];
                return null
            }
            ));
            return (e,t)=>(mo(),
            yo(Ct(c1), {
                id: e.id,
                label: e.operation.name
            }, {
                default: dn((()=>[xo(Ct(x1), null, {
                    default: dn((()=>[xo(Ct(O1), null, {
                        default: dn((()=>[xo(Ct(g1), null, {
                            default: dn((()=>{
                                var t, n;
                                return [(null == (t = e.operation.information) ? void 0 : t.deprecated) ? (mo(),
                                yo(Ct(s1), {
                                    key: 0
                                }, {
                                    default: dn((()=>[Co(" Deprecated ")])),
                                    _: 1
                                })) : Do("", !0), Eo("div", {
                                    class: Z((null == (n = e.operation.information) ? void 0 : n.deprecated) ? "deprecated" : "")
                                }, [xo(Ct(T1), {
                                    level: 3
                                }, {
                                    default: dn((()=>[xo(Ct(q1), {
                                        id: e.id ?? ""
                                    }, {
                                        default: dn((()=>[Co(K(e.operation.name), 1)])),
                                        _: 1
                                    }, 8, ["id"])])),
                                    _: 1
                                })], 2), xo(c5, {
                                    operation: e.operation
                                }, null, 8, ["operation"])]
                            }
                            )),
                            _: 1
                        }), xo(Ct(g1), null, {
                            default: dn((()=>[Eo("div", Z5, [r.value ? (mo(),
                            yo(s2, {
                                key: 0,
                                examples: r.value,
                                operation: e.operation
                            }, {
                                header: dn((()=>{
                                    var t;
                                    return [xo(p5, {
                                        class: "example-path",
                                        deprecated: null == (t = e.operation.information) ? void 0 : t.deprecated,
                                        path: e.operation.path
                                    }, null, 8, ["deprecated", "path"])]
                                }
                                )),
                                footer: dn((()=>[xo(H5, {
                                    operation: e.operation
                                }, null, 8, ["operation"])])),
                                _: 1
                            }, 8, ["examples", "operation"])) : Ct(n).length ? (mo(),
                            yo(T5, {
                                key: 1,
                                operation: e.operation
                            }, {
                                header: dn((()=>{
                                    var t;
                                    return [xo(p5, {
                                        class: "example-path",
                                        deprecated: null == (t = e.operation.information) ? void 0 : t.deprecated,
                                        path: e.operation.path
                                    }, null, 8, ["deprecated", "path"])]
                                }
                                )),
                                footer: dn((()=>[xo(H5, {
                                    operation: e.operation
                                }, null, 8, ["operation"])])),
                                _: 1
                            }, 8, ["operation"])) : Do("", !0), xo(Ct(U5), {
                                operation: e.operation,
                                style: {
                                    "margin-top": "12px"
                                }
                            }, null, 8, ["operation"])])])),
                            _: 1
                        })])),
                        _: 1
                    })])),
                    _: 1
                })])),
                _: 1
            }, 8, ["id", "label"]))
        }
    }), [["__scopeId", "data-v-b9dd22f0"]])
      , X5 = {
        class: "endpoint-details-card"
    }
      , V5 = k0(Ln({
        __name: "EndpointDetailsCard",
        props: {
            operation: {}
        },
        setup(e) {
            const t = e
              , {parameterMap: n} = QY(t)
              , {responses: r} = DK(t.operation);
            return (e,t)=>{
                var o;
                return mo(),
                vo("div", X5, [xo(e5, {
                    class: "endpoint-details-card-item",
                    parameters: Ct(n).path
                }, {
                    title: dn((()=>[Co("Path Parameters")])),
                    _: 1
                }, 8, ["parameters"]), xo(e5, {
                    class: "endpoint-details-card-item",
                    parameters: Ct(n).query
                }, {
                    title: dn((()=>[Co("Query Parameters")])),
                    _: 1
                }, 8, ["parameters"]), xo(e5, {
                    class: "endpoint-details-card-item",
                    parameters: Ct(n).header
                }, {
                    title: dn((()=>[Co("Headers")])),
                    _: 1
                }, 8, ["parameters"]), xo(a5, {
                    class: "endpoint-details-card-item",
                    requestBody: null == (o = e.operation.information) ? void 0 : o.requestBody
                }, {
                    title: dn((()=>[Co("Body")])),
                    _: 1
                }, 8, ["requestBody"]), xo(e5, {
                    class: "endpoint-details-card-item",
                    parameters: Ct(r)
                }, {
                    title: dn((()=>[Co("Responses")])),
                    _: 1
                }, 8, ["parameters"])])
            }
        }
    }), [["__scopeId", "data-v-f94bee14"]])
      , G5 = {
        class: "endpoint-header"
    }
      , Y5 = {
        class: "endpoint-details"
    }
      , K5 = {
        class: "endpoint-label"
    }
      , J5 = {
        class: "endpoint-label-path"
    }
      , e3 = {
        class: "endpoint-label-name"
    }
      , t3 = {
        class: "endpoint-content"
    }
      , n3 = k0(Ln({
        __name: "OperationAccordion",
        props: {
            id: {},
            operation: {}
        },
        setup(e) {
            const {copyToClipboard: t} = OY();
            return (e,n)=>(mo(),
            yo(Ct(f1), {
                id: e.id,
                class: "reference-endpoint",
                transparent: ""
            }, Mn({
                title: dn((()=>[Eo("h3", G5, [Eo("div", Y5, [xo(Ct(Fl), {
                    class: "endpoint-type",
                    method: e.operation.httpVerb,
                    short: ""
                }, null, 8, ["method"]), xo(Ct(q1), {
                    id: e.id ?? "",
                    class: "endpoint-anchor"
                }, {
                    default: dn((()=>{
                        var t;
                        return [Eo("div", K5, [Eo("div", J5, [xo(p5, {
                            deprecated: null == (t = e.operation.information) ? void 0 : t.deprecated,
                            path: e.operation.path
                        }, null, 8, ["deprecated", "path"])]), Eo("div", e3, K(e.operation.name), 1)])]
                    }
                    )),
                    _: 1
                }, 8, ["id"])])])])),
                actions: dn((({active: r})=>[r ? (mo(),
                yo(H5, {
                    key: 0,
                    operation: e.operation
                }, null, 8, ["operation"])) : (mo(),
                yo(Ct(rC), {
                    key: 1,
                    class: "endpoint-try-hint",
                    icon: "PaperAirplane"
                })), xo(Ct(aC), {
                    class: "endpoint-copy",
                    icon: "Clipboard",
                    label: "Copy endpoint URL",
                    size: "xs",
                    variant: "ghost",
                    onClick: n[0] || (n[0] = zi((n=>Ct(t)(e.operation.path)), ["stop"]))
                })])),
                default: dn((()=>[Eo("div", t3, [xo(V5, {
                    operation: e.operation
                }, null, 8, ["operation"]), xo(Ct(U5), {
                    operation: e.operation
                }, null, 8, ["operation"]), xo(T5, {
                    operation: e.operation
                }, null, 8, ["operation"])])])),
                _: 2
            }, [e.operation.description ? {
                name: "description",
                fn: dn((()=>[xo(Ct(XT), {
                    value: e.operation.description,
                    withImages: ""
                }, null, 8, ["value"])])),
                key: "0"
            } : void 0]), 1032, ["id"]))
        }
    }), [["__scopeId", "data-v-e54314ae"]])
      , r3 = k0(Ln({
        __name: "ShowMoreButton",
        props: {
            id: {}
        },
        setup(e) {
            const {setCollapsedSidebarItem: t} = VK();
            return (e,n)=>(mo(),
            vo("button", {
                class: "show-more",
                type: "button",
                onClick: n[0] || (n[0] = n=>Ct(t)(e.id, !0))
            }, [Co(" Show More "), xo(Ct(rC), {
                class: "show-more-icon",
                icon: "ChevronDown"
            })]))
        }
    }), [["__scopeId", "data-v-60a9fbab"]])
      , o3 = {
        class: "endpoints"
    }
      , i3 = ["onClick"]
      , a3 = k0(Ln({
        __name: "Endpoints",
        props: {
            id: {},
            tag: {}
        },
        emits: ["observeAndNavigate"],
        setup(e, {emit: t}) {
            const n = e
              , r = t
              , {getOperationId: o, getTagId: i} = LY()
              , {setCollapsedSidebarItem: a} = VK();
            async function s(e) {
                var t;
                t = o(e, n.tag),
                r("observeAndNavigate", t),
                a(i(n.tag), !0)
            }
            return (e,t)=>(mo(),
            yo(Ct(c1), {
                id: e.id,
                label: e.tag.name.toUpperCase()
            }, {
                default: dn((()=>[xo(Ct(x1), null, {
                    default: dn((()=>[xo(Ct(O1), null, {
                        default: dn((()=>[xo(Ct(g1), null, {
                            default: dn((()=>[xo(Ct(T1), {
                                level: 2
                            }, {
                                default: dn((()=>[xo(Ct(q1), {
                                    id: Ct(i)(e.tag)
                                }, {
                                    default: dn((()=>[Co(K(e.tag["x-displayName"] ?? e.tag.name), 1)])),
                                    _: 1
                                }, 8, ["id"])])),
                                _: 1
                            }), xo(Ct(XT), {
                                value: e.tag.description,
                                withImages: ""
                            }, null, 8, ["value"])])),
                            _: 1
                        }), xo(Ct(g1), null, {
                            default: dn((()=>{
                                var t;
                                return [(null == (t = e.tag.operations) ? void 0 : t.length) > 0 ? (mo(),
                                yo(Ct(Z1), {
                                    key: 0,
                                    class: "scalar-card-sticky"
                                }, {
                                    default: dn((()=>[xo(Ct(Y1), {
                                        muted: ""
                                    }, {
                                        default: dn((()=>[Co("Endpoints")])),
                                        _: 1
                                    }), xo(Ct(W1), {
                                        class: "custom-scroll",
                                        muted: ""
                                    }, {
                                        default: dn((()=>[Eo("div", o3, [(mo(!0),
                                        vo(lo, null, In(e.tag.operations, (t=>(mo(),
                                        vo("a", {
                                            key: Ct(o)(t, e.tag),
                                            class: "endpoint",
                                            onClick: e=>s(t)
                                        }, [xo(Ct(Fl), {
                                            method: t.httpVerb
                                        }, null, 8, ["method"]), Eo("span", null, K(t.path), 1)], 8, i3)))), 128))])])),
                                        _: 1
                                    })])),
                                    _: 1
                                })) : Do("", !0)]
                            }
                            )),
                            _: 1
                        })])),
                        _: 1
                    })])),
                    _: 1
                })])),
                _: 1
            }, 8, ["id", "label"]))
        }
    }), [["__scopeId", "data-v-9fc68fdd"]])
      , s3 = (e,t)=>{
        !function(e, t, n={}) {
            const {window: r=Cl, ...o} = n;
            let i;
            const a = Dl((()=>r && "MutationObserver"in r))
              , s = ()=>{
                i && (i.disconnect(),
                i = void 0)
            }
              , l = ei((()=>{
                const t = vl(e)
                  , n = (Array.isArray(t) ? t : [t]).map(Al).filter(wl);
                return new Set(n)
            }
            ))
              , c = zr((()=>l.value), (e=>{
                s(),
                a.value && e.size && (i = new MutationObserver(t),
                e.forEach((e=>i.observe(e, o))))
            }
            ), {
                immediate: !0,
                flush: "post"
            })
              , u = ()=>{
                s(),
                c()
            }
            ;
            Ol(u)
        }(e, t, {
            childList: !0,
            subtree: !0
        })
    }
      , l3 = k0(Ln({
        __name: "Tag",
        props: {
            id: {},
            tag: {},
            spec: {}
        },
        setup(e) {
            const t = e
              , n = Et(null)
              , {collapsedSidebarItems: r} = VK()
              , {getTagId: o} = LY()
              , i = e=>{
                var n;
                return 1 !== (null == (n = t.spec.tags) ? void 0 : n.length) || "default" !== (null == e ? void 0 : e.name) || "" !== (null == e ? void 0 : e.description)
            }
              , a = e=>{
                window.location.href = `#${e}`
            }
              , s = e=>{
                document.getElementById(e) ? a(e) : (e=>{
                    s3(n, ((t,n)=>{
                        t.forEach((t=>{
                            Array.from(t.addedNodes).some((t=>t instanceof HTMLElement && t.id === e)) && (a(e),
                            n.disconnect())
                        }
                        ))
                    }
                    ))
                }
                )(e)
            }
            ;
            return (e,t)=>(mo(),
            yo(Ct(y1), {
                ref_key: "sectionContainerRef",
                ref: n,
                class: "tag-section-container"
            }, {
                default: dn((()=>{
                    var t;
                    return [i(e.tag) ? (mo(),
                    yo(a3, {
                        key: 0,
                        id: e.id,
                        tag: e.tag,
                        onObserveAndNavigate: s
                    }, null, 8, ["id", "tag"])) : Do("", !0), !Ct(r)[Ct(o)(e.tag)] && (null == (t = e.tag.operations) ? void 0 : t.length) > 1 ? (mo(),
                    yo(r3, {
                        key: 1,
                        id: e.id ?? ""
                    }, null, 8, ["id"])) : Fn(e.$slots, "default", {
                        key: 2
                    }, void 0, !0)]
                }
                )),
                _: 3
            }, 512))
        }
    }), [["__scopeId", "data-v-f193be30"]])
      , c3 = k0(Ln({
        __name: "TagAccordion",
        props: {
            tag: {},
            spec: {}
        },
        setup(e) {
            const {getTagId: t} = LY();
            return (e,n)=>(mo(),
            yo(Ct(k1), {
                class: "tag-section"
            }, {
                title: dn((()=>[xo(Ct(T1), {
                    class: "tag-name",
                    level: 2
                }, {
                    default: dn((()=>[xo(Ct(q1), {
                        id: Ct(t)(e.tag)
                    }, {
                        default: dn((()=>[Co(K(e.tag.name), 1)])),
                        _: 1
                    }, 8, ["id"])])),
                    _: 1
                }), xo(Ct(XT), {
                    class: "tag-description",
                    value: e.tag.description,
                    withImages: ""
                }, null, 8, ["value"])])),
                default: dn((()=>[Fn(e.$slots, "default", {}, void 0, !0)])),
                _: 3
            }))
        }
    }), [["__scopeId", "data-v-2a212e36"]])
      , u3 = Ln({
        __name: "Loading",
        props: {
            layout: {
                default: "default"
            },
            parsedSpec: {}
        },
        setup(e) {
            const t = e
              , n = Et(!1)
              , r = Et([])
              , o = Et([])
              , {getModelId: i, getSectionId: a, getTagId: s, hash: l, isIntersectionEnabled: c} = LY()
              , u = Et("accordion" !== t.layout && l.value);
            zr((()=>{
                var e;
                return null == (e = t.parsedSpec.tags) ? void 0 : e.length
            }
            ), (e=>{
                var i, u;
                if (!l.value || "number" != typeof e || !t.parsedSpec.tags)
                    return;
                const d = a();
                if (d.startsWith("tag")) {
                    let e = 0;
                    const o = (null == (i = t.parsedSpec.tags) ? void 0 : i.findIndex((e=>s(e) === d))) ?? 0
                      , a = l.value.match(/tag\/([^/]+)\/([^/]+)\/(.+)/);
                    if (4 === (null == a ? void 0 : a.length)) {
                        const n = a[2]
                          , r = "/" + a[3];
                        e = null == (u = t.parsedSpec.tags[o]) ? void 0 : u.operations.findIndex((({httpVerb: e, path: t})=>n === e && r === t))
                    }
                    const c = t.parsedSpec.tags[o];
                    if (!c)
                        return;
                    "default" !== c.name && (n.value = d !== l.value && d.startsWith("tag")),
                    r.value.push({
                        ...c,
                        lazyOperations: c.operations.slice(e, e + 2)
                    })
                } else if (l.value.startsWith("model")) {
                    const e = Object.keys(XY(t.parsedSpec) ?? {})
                      , [,n] = l.value.toLowerCase().split("/")
                      , r = "models" === l.value ? 0 : e.findIndex((e=>e.toLowerCase() === n));
                    if (-1 === r)
                        return;
                    o.value = e.slice(r, r + 3)
                } else
                    EK(l.value),
                    setTimeout((()=>c.value = !0), 1e3)
            }
            ), {
                immediate: !0
            });
            const d = M1.on((({id: e})=>{
                const t = l.value;
                t && e === t && (d(),
                setTimeout((()=>{
                    "undefined" != typeof window && EK(t),
                    u.value = !1,
                    setTimeout((()=>c.value = !0), 1e3)
                }
                ), 300))
            }
            ));
            return Sn((()=>{
                l.value || setTimeout((()=>c.value = !0), 1e3)
            }
            )),
            (e,t)=>Nn((mo(),
            vo("div", {
                class: Z(["references-loading", {
                    "references-loading-hidden-tag": n.value,
                    "references-loading-top-spacer": r.value.length
                }])
            }, [(mo(!0),
            vo(lo, null, In(r.value, ((t,n)=>(mo(),
            vo(lo, {
                key: t.name + n
            }, [t.operations && t.operations.length > 0 ? (mo(),
            yo(Ct(l3), {
                key: 0,
                spec: e.parsedSpec,
                tag: t
            }, {
                default: dn((()=>[(mo(!0),
                vo(lo, null, In(t.lazyOperations, (e=>(mo(),
                yo(Ct(W5), {
                    key: `${e.httpVerb}-${e.operationId}`,
                    operation: e,
                    tag: t
                }, null, 8, ["operation", "tag"])))), 128))])),
                _: 2
            }, 1032, ["spec", "tag"])) : Do("", !0)], 64)))), 128)), o.value.length ? (mo(),
            yo(Ct(y1), {
                key: 0
            }, {
                default: dn((()=>[(mo(!0),
                vo(lo, null, In(o.value, (t=>(mo(),
                yo(Ct(c1), {
                    key: t,
                    label: t
                }, {
                    default: dn((()=>{
                        var n;
                        return [(null == (n = Ct(XY)(e.parsedSpec)) ? void 0 : n[t]) ? (mo(),
                        yo(Ct(x1), {
                            key: 0
                        }, {
                            default: dn((()=>{
                                var n;
                                return [xo(Ct(T1), {
                                    level: 2
                                }, {
                                    default: dn((()=>[xo(Ct(q1), {
                                        id: Ct(i)(t)
                                    }, {
                                        default: dn((()=>{
                                            var n;
                                            return [Co(K((null == (n = Ct(XY)(e.parsedSpec)) ? void 0 : n[t]).title ?? t), 1)]
                                        }
                                        )),
                                        _: 2
                                    }, 1032, ["id"])])),
                                    _: 2
                                }, 1024), xo(Ct(W2), {
                                    name: t,
                                    noncollapsible: "",
                                    value: null == (n = Ct(XY)(e.parsedSpec)) ? void 0 : n[t]
                                }, null, 8, ["name", "value"])]
                            }
                            )),
                            _: 2
                        }, 1024)) : Do("", !0)]
                    }
                    )),
                    _: 2
                }, 1032, ["label"])))), 128))])),
                _: 1
            })) : Do("", !0)], 2)), [[ci, u.value]])
        }
    })
      , d3 = e=>(cn("data-v-f19478dd"),
    e = e(),
    un(),
    e)
      , p3 = d3((()=>Eo("div", {
        id: "models"
    }, null, -1)))
      , h3 = k0(Ln({
        __name: "Models",
        props: {
            schemas: {}
        },
        setup(e) {
            const t = e
              , {collapsedSidebarItems: n} = VK()
              , {getModelId: r} = LY()
              , o = ei((()=>Object.keys(t.schemas ?? {}).length <= 3 || n[r()]))
              , i = ei((()=>{
                const e = Object.keys(t.schemas ?? {});
                return o.value ? e : e.slice(0, 3)
            }
            ));
            return (e,t)=>e.schemas ? (mo(),
            yo(Ct(y1), {
                key: 0
            }, {
                default: dn((()=>[xo(Ct(L1), {
                    id: "models",
                    isLazy: !1
                }, {
                    default: dn((()=>[p3])),
                    _: 1
                }), (mo(!0),
                vo(lo, null, In(i.value, ((t,n)=>(mo(),
                yo(Ct(L1), {
                    id: Ct(r)(t),
                    key: t,
                    isLazy: ""
                }, {
                    default: dn((()=>[xo(Ct(c1), {
                        id: Ct(r)(t),
                        label: t
                    }, {
                        default: dn((()=>[e.schemas[t] ? (mo(),
                        yo(Ct(x1), {
                            key: 0
                        }, {
                            default: dn((()=>[xo(Ct(T1), {
                                level: 2
                            }, {
                                default: dn((()=>[xo(Ct(q1), {
                                    id: Ct(r)(t)
                                }, {
                                    default: dn((()=>[Co(K(e.schemas[t].title ?? t), 1)])),
                                    _: 2
                                }, 1032, ["id"])])),
                                _: 2
                            }, 1024), xo(Ct(W2), {
                                name: t,
                                noncollapsible: "",
                                value: e.schemas[t]
                            }, null, 8, ["name", "value"]), o.value || n !== i.value.length - 1 ? Do("", !0) : (mo(),
                            yo(r3, {
                                key: 0,
                                id: Ct(r)(),
                                class: "something-special"
                            }, null, 8, ["id"]))])),
                            _: 2
                        }, 1024)) : Do("", !0)])),
                        _: 2
                    }, 1032, ["id", "label"])])),
                    _: 2
                }, 1032, ["id"])))), 128))])),
                _: 1
            })) : Do("", !0)
        }
    }), [["__scopeId", "data-v-f19478dd"]])
      , f3 = {
        key: 0,
        class: "properties"
    }
      , m3 = {
        key: 1
    }
      , g3 = k0(Ln({
        __name: "ModelsAccordion",
        props: {
            schemas: {}
        },
        setup(e) {
            const t = e
              , n = ei((()=>t.schemas ? Object.entries(t.schemas).map((([e,t])=>({
                name: e,
                schema: t
            }))) : []))
              , {getModelId: r} = LY();
            return (e,o)=>t.schemas ? (mo(),
            yo(Ct(k1), {
                key: 0,
                class: "reference-models"
            }, {
                title: dn((()=>[xo(Ct(T1), {
                    level: 2
                }, {
                    default: dn((()=>[Co("Models")])),
                    _: 1
                })])),
                default: dn((()=>[(mo(!0),
                vo(lo, null, In(n.value, (({name: e, schema: t})=>(mo(),
                yo(Ct(f1), {
                    id: Ct(r)(e),
                    key: e,
                    label: e
                }, {
                    title: dn((()=>[xo(Ct(q1), {
                        id: Ct(r)(e),
                        class: "reference-models-anchor"
                    }, {
                        default: dn((()=>[xo(Ct(u2), {
                            class: "reference-models-label",
                            name: e,
                            value: t
                        }, null, 8, ["name", "value"])])),
                        _: 2
                    }, 1032, ["id"])])),
                    default: dn((()=>[(null == t ? void 0 : t.properties) ? (mo(),
                    vo("div", f3, [(mo(!0),
                    vo(lo, null, In(Object.entries(t.properties), (([e,n])=>{
                        var r, o, i;
                        return mo(),
                        yo(Ct(j2), {
                            key: e,
                            name: e,
                            required: (null == (r = t.required) ? void 0 : r.includes(e)) || !0 === (null == (i = null == (o = t.properties) ? void 0 : o[e]) ? void 0 : i.required),
                            value: n
                        }, null, 8, ["name", "required", "value"])
                    }
                    )), 128))])) : (mo(),
                    vo("div", m3, [xo(Ct(j2), {
                        value: t
                    }, null, 8, ["value"])]))])),
                    _: 2
                }, 1032, ["id", "label"])))), 128))])),
                _: 1
            })) : Do("", !0)
        }
    }), [["__scopeId", "data-v-304ad700"]])
      , b3 = Ln({
        __name: "Webhook",
        props: {
            webhook: {}
        },
        setup(e) {
            const t = e
              , {responses: n} = DK(t.webhook);
            return (e,t)=>{
                var r;
                return e.webhook ? (mo(),
                vo(lo, {
                    key: 0
                }, [xo(a5, {
                    requestBody: null == (r = e.webhook.information) ? void 0 : r.requestBody
                }, {
                    title: dn((()=>[Co("Payload")])),
                    _: 1
                }, 8, ["requestBody"]), xo(e5, {
                    parameters: Ct(n)
                }, {
                    title: dn((()=>[Co("Responses")])),
                    _: 1
                }, 8, ["parameters"])], 64)) : Do("", !0)
            }
        }
    })
      , O3 = Ln({
        __name: "Webhooks",
        props: {
            webhooks: {}
        },
        setup(e) {
            const t = e
              , n = ei((()=>Object.keys(t.webhooks ?? {})))
              , {getWebhookId: r} = LY();
            return (e,t)=>n.value.length ? (mo(),
            yo(Ct(y1), {
                key: 0
            }, {
                default: dn((()=>[(mo(!0),
                vo(lo, null, In(n.value, (t=>{
                    var n;
                    return mo(),
                    vo(lo, {
                        key: t
                    }, [(mo(!0),
                    vo(lo, null, In(Object.keys(null == (n = e.webhooks) ? void 0 : n[t]), (n=>(mo(),
                    yo(Ct(c1), {
                        id: Ct(r)(t, n),
                        key: n,
                        label: t
                    }, {
                        default: dn((()=>{
                            var o;
                            return [(null == (o = e.webhooks) ? void 0 : o[t]) ? (mo(),
                            yo(Ct(x1), {
                                key: 0
                            }, {
                                default: dn((()=>{
                                    var o, i;
                                    return [xo(Ct(T1), {
                                        level: 2
                                    }, {
                                        default: dn((()=>[xo(Ct(q1), {
                                            id: Ct(r)(t, n)
                                        }, {
                                            default: dn((()=>{
                                                var r;
                                                return [Co(K(null == (r = e.webhooks[t][n]) ? void 0 : r.name), 1)]
                                            }
                                            )),
                                            _: 2
                                        }, 1032, ["id"])])),
                                        _: 2
                                    }, 1024), (null == (o = e.webhooks[t][n]) ? void 0 : o.description) ? (mo(),
                                    yo(Ct(XT), {
                                        key: 0,
                                        value: null == (i = e.webhooks[t][n]) ? void 0 : i.description,
                                        withImages: ""
                                    }, null, 8, ["value"])) : Do("", !0), xo(b3, {
                                        webhook: e.webhooks[t][n]
                                    }, null, 8, ["webhook"])]
                                }
                                )),
                                _: 2
                            }, 1024)) : Do("", !0)]
                        }
                        )),
                        _: 2
                    }, 1032, ["id", "label"])))), 128))], 64)
                }
                )), 128))])),
                _: 1
            })) : Do("", !0)
        }
    })
      , v3 = Po('<div class="section-flare" data-v-54f6ce8b><div class="section-flare-item" data-v-54f6ce8b></div><div class="section-flare-item" data-v-54f6ce8b></div><div class="section-flare-item" data-v-54f6ce8b></div><div class="section-flare-item" data-v-54f6ce8b></div><div class="section-flare-item" data-v-54f6ce8b></div><div class="section-flare-item" data-v-54f6ce8b></div><div class="section-flare-item" data-v-54f6ce8b></div><div class="section-flare-item" data-v-54f6ce8b></div></div>', 1)
      , y3 = {
        class: "narrow-references-container"
    }
      , w3 = k0(Ln({
        __name: "Content",
        props: {
            parsedSpec: {},
            layout: {},
            baseServerURL: {},
            proxy: {},
            servers: {}
        },
        setup(e) {
            const t = e
              , {getOperationId: n, getTagId: r, hash: o} = LY()
              , {setServer: i} = DV()
              , {hideModels: a, collapsedSidebarItems: s} = VK()
              , l = e=>{
                if (e.url.match(/^(?!(https?|file):\/\/|{).+/)) {
                    let n = t.baseServerURL ?? window.location.origin;
                    n = n.replace(/\/$/, "");
                    const r = e.url.startsWith("/") ? e.url : `/${e.url}`;
                    e.url = `${n}${r}`.replace(/\/$/, "")
                }
                return e
            }
            ;
            zr((()=>t.parsedSpec), (e=>{
                var n, r;
                let o = [{
                    url: "undefined" != typeof window ? window.location.origin : "/"
                }];
                if (t.servers)
                    o = t.servers;
                else if (e.servers && e.servers.length > 0)
                    o = e.servers;
                else if (t.parsedSpec.host) {
                    o = [{
                        url: `${(null == (n = t.parsedSpec.schemes) ? void 0 : n[0]) ?? "http"}://${t.parsedSpec.host}${(null == (r = t.parsedSpec) ? void 0 : r.basePath) ?? ""}`
                    }]
                }
                (t.baseServerURL || "undefined" != typeof window) && (o = o.map(l)),
                i({
                    servers: o
                })
            }
            ), {
                deep: !0,
                immediate: !0
            });
            const c = ei((()=>"accordion" === t.layout ? c3 : l3))
              , u = ei((()=>"accordion" === t.layout ? n3 : W5))
              , d = ei((()=>"accordion" === t.layout ? "after" : "aside"))
              , p = "accordion" !== t.layout && !o.value.startsWith("model");
            return (e,t)=>{
                var o, i, l, h;
                return mo(),
                vo(lo, null, [v3, Eo("div", y3, [Fn(e.$slots, "start", {}, void 0, !0), xo(Ct(u3), {
                    layout: e.layout,
                    parsedSpec: e.parsedSpec
                }, null, 8, ["layout", "parsedSpec"]), (null == (i = null == (o = e.parsedSpec) ? void 0 : o.info) ? void 0 : i.title) || (null == (h = null == (l = e.parsedSpec) ? void 0 : l.info) ? void 0 : h.description) ? (mo(),
                yo(Ct(I1), {
                    key: 0,
                    info: e.parsedSpec.info,
                    parsedSpec: e.parsedSpec
                }, {
                    [d.value]: dn((()=>[Eo("div", {
                        class: Z(["introduction-card", {
                            "introduction-card-row": "accordion" === e.layout
                        }])
                    }, [xo(Ct(H0)), xo(Ct(S0), {
                        parsedSpec: e.parsedSpec,
                        proxy: e.proxy
                    }, null, 8, ["parsedSpec", "proxy"]), xo(Ct(i1))], 2)])),
                    _: 2
                }, 1032, ["info", "parsedSpec"])) : Fn(e.$slots, "empty-state", {
                    key: 1
                }, void 0, !0), (mo(!0),
                vo(lo, null, In(e.parsedSpec.tags, (t=>(mo(),
                yo(Ct(L1), {
                    id: Ct(r)(t),
                    key: Ct(r)(t),
                    isLazy: Ct(p) && !Ct(s)[Ct(r)(t)]
                }, {
                    default: dn((()=>[(mo(),
                    yo(On(c.value), {
                        id: Ct(r)(t),
                        spec: e.parsedSpec,
                        tag: t
                    }, {
                        default: dn((()=>[(mo(!0),
                        vo(lo, null, In(t.operations, ((e,r)=>(mo(),
                        yo(Ct(L1), {
                            id: Ct(n)(e, t),
                            key: `${e.httpVerb}-${e.operationId}`,
                            isLazy: r > 0
                        }, {
                            default: dn((()=>[(mo(),
                            yo(On(u.value), {
                                id: Ct(n)(e, t),
                                operation: e,
                                tag: t
                            }, null, 8, ["id", "operation", "tag"]))])),
                            _: 2
                        }, 1032, ["id", "isLazy"])))), 128))])),
                        _: 2
                    }, 1032, ["id", "spec", "tag"]))])),
                    _: 2
                }, 1032, ["id", "isLazy"])))), 128)), e.parsedSpec.webhooks ? (mo(),
                yo(Ct(O3), {
                    key: 2,
                    webhooks: e.parsedSpec.webhooks
                }, null, 8, ["webhooks"])) : Do("", !0), Ct(VY)(e.parsedSpec) && !Ct(a) ? (mo(),
                vo(lo, {
                    key: 3
                }, ["accordion" === e.layout ? (mo(),
                yo(Ct(g3), {
                    key: 0,
                    schemas: Ct(XY)(e.parsedSpec)
                }, null, 8, ["schemas"])) : (mo(),
                yo(Ct(h3), {
                    key: 1,
                    schemas: Ct(XY)(e.parsedSpec)
                }, null, 8, ["schemas"]))], 64)) : Do("", !0), Fn(e.$slots, "end", {}, void 0, !0)])], 64)
            }
        }
    }), [["__scopeId", "data-v-54f6ce8b"]])
      , _3 = e=>(cn("data-v-391b4e37"),
    e = e(),
    un(),
    e)
      , k3 = {
        class: "start custom-scroll"
    }
      , S3 = {
        class: "start-copy"
    }
      , E3 = Po('<div class="start-logo" data-v-391b4e37><svg height="36" viewBox="0 0 36 36" width="36" xmlns="http://www.w3.org/2000/svg" data-v-391b4e37><path d="M18 0a18 18 0 1 1 0 36 18 18 0 0 1 0-36Zm11.2 6.5c-3.3-3.3-11.1-1-17.4 5.3-6.2 6.3-8.6 14-5.3 17.4 3.3 3.3 11 .9 17.3-5.4 6.3-6.2 8.7-14 5.4-17.3ZM17.6 12a6.3 6.3 0 1 1 0 12.7 6.3 6.3 0 0 1 0-12.7Z" fill="currentColor" fill-rule="evenodd" data-v-391b4e37></path></svg></div><h1 class="start-h1" data-v-391b4e37>Swagger Editor</h1><p class="start-p" data-v-391b4e37> Welcome to the Scalar API References + Swagger Editor, a Free &amp; Open-Source tool that takes your Swagger/OAS file and generates Beautiful API references. </p>', 3)
      , x3 = {
        class: "start-cta"
    }
      , T3 = {
        class: "start-row"
    }
      , A3 = Po('<div class="start-section start-section-integrations" data-v-391b4e37><div class="start-h2" data-v-391b4e37>INTEGRATIONS</div><a class="start-item" href="https://github.com/scalar/scalar/tree/main/packages/fastify-api-reference#readme" target="_blank" data-v-391b4e37><svg fill="currentColor" height="16" viewBox="0 0 19 16" width="19" xmlns="http://www.w3.org/2000/svg" data-v-391b4e37><path d="m18.2 3.1.8-2V.9l-4.7 1.3C15.2 1 15 0 15 0s-2.5 1.6-4.3 1.5c-2 0-3.6.8-4 1-1.8 1.2-2.5 3.3-3.2 3.8L0 8.9 2.3 8l-2 2.5c.2.3 1.2 1.6 2.1 1.3l.4-.1 1.6.5-.7-1 .2-.2.9.3-.1-.8.9.3-.1-.8.3-.1 1-3.5 3.7-2.6-.3.7A4 4 0 0 1 8 7l-.6.2c-.5.5-.7.7-.8 2.5a2 2 0 0 1 1 0c1.6.4 2.2 2.3 1.7 2.9l-.7.6H8v.6h-.7v.5l-.2.2c-.7 0-1.4-.6-1.4-.6 0 .5.4 1.3.4 1.3s1.7 1.1 2.7.7c1-.4.7-2.3 2.8-3.2l3.3-.9.8-2.2-1.7.5v-2l2.5-.6.9-2.2-3.4.9v-2l4.2-1.1Z" fill="currentColor" fill-rule="nonzero" data-v-391b4e37></path></svg><span data-v-391b4e37>Fastify</span></a><a class="start-item" href="https://github.com/scalar/scalar/tree/main#from-a-cdn" target="_blank" data-v-391b4e37><svg fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" data-v-391b4e37><g data-v-391b4e37><path d="M22.5 1.5h-21A1.5 1.5 0 0 0 0 3v3a1.5 1.5 0 0 0 1.5 1.5h21A1.5 1.5 0 0 0 24 6V3a1.5 1.5 0 0 0-1.5-1.5Zm-19.25 3A1.25 1.25 0 1 1 4.5 5.75 1.25 1.25 0 0 1 3.25 4.5ZM8.5 5.75A1.25 1.25 0 1 1 9.75 4.5 1.25 1.25 0 0 1 8.5 5.75Z" fill="currentColor" data-v-391b4e37></path><path d="M22.5 9h-21A1.5 1.5 0 0 0 0 10.5v3A1.5 1.5 0 0 0 1.5 15h21a1.5 1.5 0 0 0 1.5-1.5v-3A1.5 1.5 0 0 0 22.5 9ZM3.25 12a1.25 1.25 0 1 1 1.25 1.25A1.25 1.25 0 0 1 3.25 12Zm5.25 1.25A1.25 1.25 0 1 1 9.75 12a1.25 1.25 0 0 1-1.25 1.25Z" fill="currentColor" data-v-391b4e37></path><path d="M22.5 16.5h-21A1.5 1.5 0 0 0 0 18v3a1.5 1.5 0 0 0 1.5 1.5h21A1.5 1.5 0 0 0 24 21v-3a1.5 1.5 0 0 0-1.5-1.5Zm-19.25 3a1.25 1.25 0 1 1 1.25 1.25 1.25 1.25 0 0 1-1.25-1.25Zm5.25 1.25a1.25 1.25 0 1 1 1.25-1.25 1.25 1.25 0 0 1-1.25 1.25Z" fill="currentColor" data-v-391b4e37></path></g></svg><span data-v-391b4e37>CDN</span></a><a class="start-item" href="https://github.com/scalar/scalar/tree/main#with-vuejs" target="_blank" data-v-391b4e37><svg height="170" viewBox="0 0 196.3 170" width="196.3" xmlns="http://www.w3.org/2000/svg" data-v-391b4e37><g fill="currentColor" fill-rule="nonzero" data-v-391b4e37><polygon points="39.23 0 0 0 2.9450761 5.1010782 98.16 170.02 196.32 0 157.06 0 98.16 102.01 42.175701 5.0991171" data-v-391b4e37></polygon><polygon points="75.5 2.009956e-14 0 2.009956e-14 2.94 5.1 78.44871 5.1 98.16 39.26 117.87937 5.1 193.38 5.1 196.325 0 120.82 7.8065636e-15 114.97322 2.009956e-14 98.16 29.037153 81.35 2.009956e-14" data-v-391b4e37></polygon></g></svg><span data-v-391b4e37>Vue</span></a><a class="start-item" href="https://github.com/scalar/scalar/tree/main#with-react" target="_blank" data-v-391b4e37><svg height="23.3" viewBox="0 0 22 23.3" width="22" xmlns="http://www.w3.org/2000/svg" data-v-391b4e37><g fill="none" fill-rule="evenodd" data-v-391b4e37><circle cx="11" cy="11.6" fill="currentColor" fill-rule="nonzero" r="2" data-v-391b4e37></circle><g stroke="currentColor" data-v-391b4e37><ellipse cx="11" cy="11.6" rx="11" ry="4.2" data-v-391b4e37></ellipse><ellipse cx="11" cy="11.6" rx="11" ry="4.2" transform="rotate(60 11 11.6)" data-v-391b4e37></ellipse><ellipse cx="11" cy="11.6" rx="11" ry="4.2" transform="rotate(120 11 11.6)" data-v-391b4e37></ellipse></g></g></svg><span data-v-391b4e37>React</span></a></div>', 1)
      , C3 = {
        class: "start-section start-section-colors"
    }
      , P3 = _3((()=>Eo("p", {
        class: "start-h2"
    }, "THEMING", -1)))
      , D3 = ["onClick"]
      , R3 = Po('<p class="start-h1" data-v-391b4e37>Features</p><ul class="start-ul" data-v-391b4e37><li data-v-391b4e37><p class="start-h3" data-v-391b4e37>Customize</p> Bring your typography &amp; color palettes, or use our themes! </li><li data-v-391b4e37><p class="start-h3" data-v-391b4e37>Testing</p> A deeply integrated Rest API Client (Also Free &amp; Open-Source) </li><li data-v-391b4e37><p class="start-h3" data-v-391b4e37>Search</p> Fully integrated Search (Using fuse.js) </li><li data-v-391b4e37><p class="start-h3" data-v-391b4e37>Hosting</p> Free subdomain hosting on https://apidocumentation.com </li><li data-v-391b4e37><p class="start-h3" data-v-391b4e37>OpenAPI &amp; Swagger</p> Support for OpenAPI 3.1, OpenAPI 3.0, and Swagger 2.0 </li><li data-v-391b4e37><p class="start-h3" data-v-391b4e37>Code Samples</p> Code samples to show off your API in most popular languages </li></ul>', 2)
      , N3 = k0(Ln({
        __name: "GettingStarted",
        props: {
            theme: {}
        },
        emits: ["changeTheme", "loadSwaggerFile", "linkSwaggerFile", "updateContent"],
        setup(e, {emit: t}) {
            const n = t
              , r = ["default", "alternate", "moon", "purple", "solarized", "bluePlanet", "saturn", "kepler", "mars", "deepSpace"];
            async function o() {
                const e = await fetch("https://cdn.jsdelivr.net/npm/@scalar/galaxy/dist/latest.yaml");
                n("updateContent", await e.text())
            }
            return (e,t)=>(mo(),
            vo("div", k3, [Eo("div", S3, [E3, Eo("div", x3, [xo(Ct(Jc), {
                fullWidth: "",
                onClick: o
            }, {
                default: dn((()=>[Co(" Show Example ")])),
                _: 1
            }), xo(Ct(Jc), {
                fullWidth: "",
                variant: "outlined",
                onClick: t[0] || (t[0] = t=>e.$emit("loadSwaggerFile"))
            }, {
                default: dn((()=>[Co(" Upload File ")])),
                _: 1
            })])]), Eo("div", T3, [A3, Eo("div", C3, [P3, (mo(),
            vo(lo, null, In(r, (t=>Eo("div", {
                key: t,
                class: Z(["start-item", {
                    "start-item-active": t === e.theme
                }]),
                onClick: n=>e.$emit("changeTheme", {
                    id: t,
                    label: Ct(fl)[t]
                })
            }, K(Ct(fl)[t]), 11, D3))), 64))])]), R3]))
        }
    }), [["__scopeId", "data-v-391b4e37"]])
      , $3 = k0(Ln({
        __name: "SidebarHttpBadge",
        props: {
            active: {
                type: Boolean
            },
            method: {}
        },
        setup: e=>(e,t)=>(mo(),
        yo(Ct(Fl), {
            class: Z(["sidebar-heading-type", {
                "sidebar-heading-type-active": e.active
            }]),
            method: e.method,
            property: "--method-color",
            short: ""
        }, null, 8, ["class", "method"]))
    }), [["__scopeId", "data-v-9e6d2bc7"]])
      , I3 = ["id"]
      , M3 = {
        key: 0,
        class: "sidebar-heading-chevron"
    }
      , L3 = ["href"]
      , Q3 = {
        class: "sidebar-heading-link-title"
    }
      , B3 = {
        key: 1,
        class: "sidebar-heading-link-method"
    }
      , U3 = {
        key: 1,
        class: "action-menu"
    }
      , F3 = k0(Ln({
        __name: "SidebarElement",
        props: {
            id: {},
            item: {},
            isActive: {
                type: Boolean
            },
            hasChildren: {
                type: Boolean
            },
            open: {
                type: Boolean
            }
        },
        emits: ["toggleOpen"],
        setup(e, {emit: t}) {
            const n = e
              , r = t
              , {hash: o, isIntersectionEnabled: i, pathRouting: a} = LY()
              , s = async()=>{
                var e, t;
                n.hasChildren && r("toggleOpen"),
                null == (t = null == (e = n.item) ? void 0 : e.select) || t.call(e),
                n.open && (i.value = !1,
                await xK(100),
                i.value = !0)
            }
              , l = ()=>{
                if (a.value)
                    return YY(a.value.basePath, n.item.id);
                {
                    const e = new URL(window.location.href);
                    return e.hash = n.item.id,
                    `${e.pathname}${e.search}${e.hash}`
                }
            }
              , c = async e=>{
                var t, s;
                if (a.value) {
                    e.preventDefault(),
                    n.hasChildren && r("toggleOpen"),
                    null == (s = null == (t = n.item) ? void 0 : t.select) || s.call(t),
                    r("toggleOpen"),
                    i.value = !1,
                    o.value = n.item.id;
                    const l = new URL(window.location.href);
                    l.pathname = YY(a.value.basePath, n.item.id),
                    window.history.pushState({}, "", l),
                    EK(n.item.id),
                    await xK(100),
                    i.value = !0
                }
            }
            ;
            return (e,t)=>{
                var n, r;
                return mo(),
                vo("li", {
                    id: e.id,
                    class: "sidebar-group-item"
                }, [Eo("div", {
                    class: Z(["sidebar-heading", {
                        "sidebar-group-item__folder": e.hasChildren,
                        active_page: e.isActive,
                        deprecated: e.item.deprecated ?? !1
                    }]),
                    onClick: s
                }, [e.hasChildren ? (mo(),
                vo("p", M3, [xo(Ct(aC), {
                    class: "toggle-nested-icon",
                    icon: e.open ? "ChevronDown" : "ChevronRight",
                    label: "Toggle group",
                    size: "xs",
                    onClick: zi(s, ["stop"])
                }, null, 8, ["icon"]), Co("   ")])) : Do("", !0), Eo("a", {
                    class: "sidebar-heading-link",
                    href: l(),
                    onClick: c
                }, [(null == (r = null == (n = e.item) ? void 0 : n.icon) ? void 0 : r.src) ? (mo(),
                yo(Ct(rC), {
                    key: 0,
                    class: "sidebar-icon",
                    icon: e.item.icon.src
                }, null, 8, ["icon"])) : Do("", !0), Eo("p", Q3, K(e.item.title), 1), e.item.httpVerb && !e.hasChildren ? (mo(),
                vo("p", B3, [Co("   "), xo($3, {
                    active: e.isActive,
                    method: e.item.httpVerb
                }, null, 8, ["active", "method"])])) : Do("", !0)], 8, L3)], 2), e.open ? Fn(e.$slots, "default", {
                    key: 0
                }, void 0, !0) : Do("", !0), e.$slots["action-menu"] ? (mo(),
                vo("div", U3, [Fn(e.$slots, "action-menu", {}, void 0, !0)])) : Do("", !0)], 8, I3)
            }
        }
    }), [["__scopeId", "data-v-5a18d101"]])
      , j3 = k0(Ln({
        __name: "SidebarGroup",
        props: {
            level: {}
        },
        setup: e=>(e,t)=>(mo(),
        vo("ul", {
            class: "sidebar-group sidebar-indent-nested",
            style: F({
                "--scalar-sidebar-level": e.level
            })
        }, [Fn(e.$slots, "default", {}, void 0, !0)], 4))
    }), [["__scopeId", "data-v-39c84840"]])
      , z3 = {
        class: "sidebar"
    }
      , q3 = {
        class: "sidebar-group-title"
    }
      , H3 = k0(Ln({
        __name: "Sidebar",
        props: {
            parsedSpec: {}
        },
        setup(e) {
            const t = e
              , {hash: n, isIntersectionEnabled: r} = LY()
              , {items: o, toggleCollapsedSidebarItem: i, collapsedSidebarItems: a} = VK({
                parsedSpec: t.parsedSpec
            })
              , s = Et(null)
              , l = Et(!0);
            zr(n, (e=>{
                r.value && !l.value && "undefined" != typeof window && c(e)
            }
            ));
            const c = e=>{
                var t, n, r, o;
                const i = document.getElementById(`sidebar-${e}`);
                if (!i || !s.value)
                    return;
                let a = -160;
                "heading" === i.getAttribute("data-sidebar-type") ? a += i.offsetTop + (null == (t = i.getElementsByClassName("sidebar-heading")) ? void 0 : t[0]).offsetHeight : a += i.offsetTop + ((null == (n = i.parentElement) ? void 0 : n.offsetTop) ?? 0) + ((null == (o = null == (r = i.parentElement) ? void 0 : r.parentElement) ? void 0 : o.offsetTop) ?? 0),
                s.value.scrollTo({
                    top: a,
                    behavior: "smooth"
                })
            }
            ;
            return Sn((()=>{
                setTimeout((()=>c(n.value)), 500),
                l.value = !1
            }
            )),
            (e,t)=>(mo(),
            vo("div", z3, [Fn(e.$slots, "sidebar-start", {}, void 0, !0), Eo("div", {
                ref_key: "scrollerEl",
                ref: s,
                class: "sidebar-pages custom-scroll custom-scroll-self-contain-overflow"
            }, [xo(j3, {
                level: 0
            }, {
                default: dn((()=>[(mo(!0),
                vo(lo, null, In(Ct(o).entries, (e=>(mo(),
                vo(lo, {
                    key: e.id
                }, [e.isGroup ? (mo(),
                vo(lo, {
                    key: 0
                }, [Eo("li", q3, K(e.displayTitle ?? e.title), 1), (mo(!0),
                vo(lo, null, In(e.children, (t=>(mo(),
                yo(F3, {
                    key: t.id,
                    id: `sidebar-${t.id}`,
                    "data-sidebar-type": "heading",
                    hasChildren: t.children && t.children.length > 0,
                    isActive: Ct(n) === t.id,
                    item: {
                        id: t.id,
                        title: t.displayTitle ?? t.title,
                        select: t.select,
                        httpVerb: t.httpVerb,
                        deprecated: t.deprecated ?? !1
                    },
                    open: Ct(a)[t.id] ?? !1,
                    onToggleOpen: async()=>{
                        l.value = !0,
                        Ct(i)(t.id),
                        await Ct(xK)(100),
                        l.value = !1
                    }
                }, {
                    default: dn((()=>{
                        var r;
                        return [t.children && (null == (r = t.children) ? void 0 : r.length) > 0 ? (mo(),
                        yo(j3, {
                            key: 0,
                            level: 1
                        }, {
                            default: dn((()=>[(mo(!0),
                            vo(lo, null, In(t.children, (t=>(mo(),
                            vo(lo, {
                                key: t.id
                            }, [e.show ? (mo(),
                            yo(F3, {
                                key: 0,
                                id: `sidebar-${t.id}`,
                                isActive: Ct(n) === t.id,
                                item: {
                                    id: t.id,
                                    title: t.displayTitle ?? t.title,
                                    select: t.select,
                                    httpVerb: t.httpVerb,
                                    deprecated: t.deprecated ?? !1
                                }
                            }, null, 8, ["id", "isActive", "item"])) : Do("", !0)], 64)))), 128))])),
                            _: 2
                        }, 1024)) : Do("", !0)]
                    }
                    )),
                    _: 2
                }, 1032, ["id", "hasChildren", "isActive", "item", "open", "onToggleOpen"])))), 128))], 64)) : (mo(),
                vo(lo, {
                    key: 1
                }, [e.show ? (mo(),
                yo(F3, {
                    key: 0,
                    id: `sidebar-${e.id}`,
                    "data-sidebar-type": "heading",
                    hasChildren: e.children && e.children.length > 0,
                    isActive: Ct(n) === e.id,
                    item: {
                        id: e.id,
                        title: e.displayTitle ?? e.title,
                        select: e.select,
                        httpVerb: e.httpVerb,
                        deprecated: e.deprecated ?? !1
                    },
                    open: Ct(a)[e.id] ?? !1,
                    onToggleOpen: async()=>{
                        l.value = !0,
                        Ct(i)(e.id),
                        await Ct(xK)(100),
                        l.value = !1
                    }
                }, {
                    default: dn((()=>{
                        var t;
                        return [e.children && (null == (t = e.children) ? void 0 : t.length) > 0 ? (mo(),
                        yo(j3, {
                            key: 0,
                            level: 1
                        }, {
                            default: dn((()=>[(mo(!0),
                            vo(lo, null, In(e.children, (t=>(mo(),
                            vo(lo, {
                                key: t.id
                            }, [e.show ? (mo(),
                            yo(F3, {
                                key: 0,
                                id: `sidebar-${t.id}`,
                                isActive: Ct(n) === t.id,
                                item: {
                                    id: t.id,
                                    title: t.displayTitle ?? t.title,
                                    select: t.select,
                                    httpVerb: t.httpVerb,
                                    deprecated: t.deprecated ?? !1
                                }
                            }, null, 8, ["id", "isActive", "item"])) : Do("", !0)], 64)))), 128))])),
                            _: 2
                        }, 1024)) : Do("", !0)]
                    }
                    )),
                    _: 2
                }, 1032, ["id", "hasChildren", "isActive", "item", "open", "onToggleOpen"])) : Do("", !0)], 64))], 64)))), 128))])),
                _: 1
            })], 512), Fn(e.$slots, "sidebar-end", {}, void 0, !0)]))
        }
    }), [["__scopeId", "data-v-31eb751b"]]);
    const Z3 = k0({}, [["render", function(e, t) {
        return mo(),
        yo(On("style"), null, {
            default: dn((()=>[Fn(e.$slots, "default")])),
            _: 3
        })
    }
    ]])
      , W3 = {
        class: "references-header"
    }
      , X3 = {
        key: 0,
        class: "references-navigation t-doc__sidebar"
    }
      , V3 = {
        class: "references-navigation-list"
    }
      , G3 = {
        class: "references-editor"
    }
      , Y3 = {
        class: "references-editor-textarea"
    }
      , K3 = {
        class: "references-rendered"
    }
      , J3 = {
        key: 0,
        class: "references-footer"
    }
      , e4 = Ln({
        inheritAttrs: !1,
        __name: "ApiReferenceLayout",
        props: {
            configuration: {},
            parsedSpec: {},
            rawSpec: {}
        },
        emits: ["changeTheme", "updateContent", "loadSwaggerFile", "linkSwaggerFile", "toggleDarkMode"],
        setup(e) {
            const t = e
              , n = Bn((()=>O0 ? new Promise((e=>{
                e({
                    render: ()=>null
                })
            }
            )) : Promise.resolve().then((()=>Pie))))
              , r = Rl("(min-width: 1150px)")
              , o = Et("100dvh")
              , i = Et(null);
            !function(e, t, n={}) {
                const {window: r=Cl, ...o} = n;
                let i;
                const a = Dl((()=>r && "ResizeObserver"in r))
                  , s = ()=>{
                    i && (i.disconnect(),
                    i = void 0)
                }
                  , l = zr(ei((()=>Array.isArray(e) ? e.map((e=>Al(e))) : [Al(e)])), (e=>{
                    if (s(),
                    a.value && r) {
                        i = new ResizeObserver(t);
                        for (const t of e)
                            t && i.observe(t, o)
                    }
                }
                ), {
                    immediate: !0,
                    flush: "post"
                })
                  , c = ()=>{
                    s(),
                    l()
                }
                ;
                Ol(c)
            }(i, (e=>{
                o.value = e[0].contentRect.height + "px"
            }
            ));
            const {breadcrumb: a, collapsedSidebarItems: s, isSidebarOpen: l, setCollapsedSidebarItem: c, hideModels: u, setParsedSpec: d} = VK()
              , {getPathRoutingId: p, getSectionId: h, getTagId: f, hash: m, isIntersectionEnabled: g, pathRouting: b, updateHash: O} = LY();
            b.value = t.configuration.pathRouting,
            kn((()=>O()));
            const v = async e=>{
                var t;
                g.value = !1,
                O(),
                e ? EK(e) : null == (t = i.value) || t.scrollTo(0, 0),
                await xK(100),
                g.value = !0
            }
            ;
            kn((()=>{
                const e = new MutationObserver((t=>{
                    const n = t.find((e=>Array.from(e.addedNodes).find((e=>"headlessui-portal-root" === e.id))));
                    n && (n.addedNodes[0].classList.add("scalar-app"),
                    e.disconnect())
                }
                ));
                e.observe(document.body, {
                    childList: !0
                })
            }
            )),
            Sn((()=>{
                TK.on((({specTitle: e})=>{
                    !function(e, t) {
                        const n = LT(e)
                          , r = n ? new Blob([e],{
                            type: "application/json"
                        }) : new Blob([e],{
                            type: "application/x-yaml"
                        })
                          , o = URL.createObjectURL(r)
                          , i = n ? ".json" : ".yaml"
                          , a = t ? t + i : "spec" + i
                          , s = document.createElement("a");
                        s.href = o,
                        s.download = a,
                        s.dispatchEvent(new MouseEvent("click",{
                            bubbles: !0,
                            cancelable: !0,
                            view: window
                        })),
                        setTimeout((()=>{
                            window.URL.revokeObjectURL(o),
                            s.remove()
                        }
                        ), 100)
                    }(t.rawSpec, e)
                }
                )),
                window.onhashchange = ()=>v(decodeURIComponent(window.location.hash.replace(/^#/, ""))),
                window.onpopstate = ()=>b.value && v(p(window.location.pathname))
            }
            ));
            const y = ei((()=>r.value || !t.configuration.isEditable))
              , w = El((e=>{
                if ((e.target.scrollTop ?? 0) < 50) {
                    const e = t.configuration.pathRouting ? t.configuration.pathRouting.basePath : window.location.pathname;
                    window.history.replaceState({}, "", e + window.location.search),
                    m.value = ""
                }
            }
            ))
              , _ = ei((()=>({
                breadcrumb: a.value,
                spec: t.parsedSpec
            })));
            var k;
            return zr((()=>t.parsedSpec), d, {
                deep: !0
            }),
            Cn((()=>{
                var e, n;
                const r = Ur();
                if (r && ((e = r.payload).data || (e.data = {}),
                t.configuration.pathRouting)) {
                    const e = p(r.url);
                    m.value = e,
                    r.payload.data.hash = e;
                    for (const t in s)
                        Object.hasOwn(s, t) && delete s[t];
                    if (e)
                        c(h(e), !0);
                    else {
                        const e = null == (n = t.parsedSpec.tags) ? void 0 : n[0];
                        e && c(f(e), !0)
                    }
                    r.payload.data["useSidebarContent-collapsedSidebarItems"] = s
                }
            }
            )),
            function(e) {
                dr(Yi, e)
            }((()=>{
                var e;
                const t = Uo()
                  , n = "scalar-instance-id";
                if (!t)
                    return n;
                let r = t.uid;
                return "undefined" == typeof window ? (t.attrs || (t.attrs = {}),
                t.attrs[n] = r) : (null == (e = t.vnode.el) ? void 0 : e.getAttribute) && (r = t.vnode.el.getAttribute(n)),
                `${n}-${r}`
            }
            )),
            dr(kK, (()=>t.parsedSpec.security)),
            dr(SK, (()=>t.configuration.hideDownloadButton)),
            u.value = t.configuration.hideModels ?? !1,
            k = t.configuration,
            zr((()=>k), (()=>{
                var e;
                k.proxy === yY ? (console.warn(`[DEPRECATED] Warning: configuration.proxy points to our old proxy (${yY}).`),
                console.warn(`[DEPRECATED] We are overwriting the value and use the new proxy URL (${wY}) instead.`),
                k.proxy = wY,
                console.warn(`[DEPRECATED] Action Required: You should manually update your configuration to use the new URL (${wY}). Read more: https://github.com/scalar/scalar`)) : (null == (e = k.proxy) ? void 0 : e.length) && k.proxy !== wY && "http://localhost:5051" !== k.proxy && (console.warn(`[DEPRECATED] Warning: configuration.proxy points to a custom proxy (${null == k ? void 0 : k.proxy}).`),
                console.warn("[DEPRECATED] Action Required: You need to use our new proxy (written in Go). Read more: https://github.com/scalar/scalar/tree/main/examples/proxy-server"))
            }
            ), {
                immediate: !0
            }),
            (e,t)=>{
                var r, a;
                return mo(),
                vo(lo, null, [xo(Ct(Z3), null, {
                    default: dn((()=>[Co(K(Ct(bl)(e.configuration.theme, {
                        fonts: e.configuration.withDefaultFonts
                    })), 1)])),
                    _: 1
                }), Eo("div", {
                    ref_key: "documentEl",
                    ref: i,
                    class: Z(["scalar-app scalar-api-reference references-layout", [{
                        "references-editable": e.configuration.isEditable,
                        "references-sidebar": e.configuration.showSidebar,
                        "references-sidebar-mobile-open": Ct(l),
                        "references-classic": "classic" === e.configuration.layout
                    }, e.$attrs.class]]),
                    style: F({
                        "--full-height": o.value
                    }),
                    onScrollPassive: t[4] || (t[4] = (...e)=>Ct(w) && Ct(w)(...e))
                }, [Eo("div", W3, [Fn(e.$slots, "header", W(To(_.value)), void 0, !0)]), e.configuration.showSidebar ? (mo(),
                vo("aside", X3, [Eo("div", V3, [xo(Ct(H3), {
                    parsedSpec: e.parsedSpec
                }, {
                    "sidebar-start": dn((()=>[Fn(e.$slots, "sidebar-start", W(To(_.value)), void 0, !0)])),
                    "sidebar-end": dn((()=>[Fn(e.$slots, "sidebar-end", W(To(_.value)), void 0, !0)])),
                    _: 3
                }, 8, ["parsedSpec"])])])) : Do("", !0), Nn(Eo("div", G3, [Eo("div", Y3, [Fn(e.$slots, "editor", W(To(_.value)), void 0, !0)])], 512), [[ci, e.configuration.isEditable]]), y.value ? (mo(),
                vo(lo, {
                    key: 1
                }, [Eo("div", K3, [xo(Ct(w3), {
                    baseServerURL: e.configuration.baseServerURL,
                    layout: "classic" === e.configuration.layout ? "accordion" : "default",
                    parsedSpec: e.parsedSpec,
                    proxy: e.configuration.proxy
                }, Mn({
                    start: dn((()=>[Fn(e.$slots, "content-start", W(To(_.value)), void 0, !0)])),
                    end: dn((()=>[Fn(e.$slots, "content-end", W(To(_.value)), void 0, !0)])),
                    _: 2
                }, [(null == (r = e.configuration) ? void 0 : r.isEditable) ? {
                    name: "empty-state",
                    fn: dn((()=>{
                        var n;
                        return [xo(N3, {
                            theme: (null == (n = e.configuration) ? void 0 : n.theme) || "default",
                            onChangeTheme: t[0] || (t[0] = t=>e.$emit("changeTheme", t)),
                            onLinkSwaggerFile: t[1] || (t[1] = t=>e.$emit("linkSwaggerFile")),
                            onLoadSwaggerFile: t[2] || (t[2] = t=>e.$emit("loadSwaggerFile")),
                            onUpdateContent: t[3] || (t[3] = t=>e.$emit("updateContent", t))
                        }, null, 8, ["theme"])]
                    }
                    )),
                    key: "0"
                } : void 0]), 1032, ["baseServerURL", "layout", "parsedSpec", "proxy"])]), e.$slots.footer ? (mo(),
                vo("div", J3, [Fn(e.$slots, "footer", W(To(_.value)), void 0, !0)])) : Do("", !0)], 64)) : Do("", !0), xo(Ct(n), {
                    parsedSpec: e.parsedSpec,
                    proxyUrl: null == (a = e.configuration) ? void 0 : a.proxy
                }, {
                    "sidebar-start": dn((()=>[Fn(e.$slots, "sidebar-start", W(To(_.value)), void 0, !0)])),
                    "sidebar-end": dn((()=>[Fn(e.$slots, "sidebar-end", W(To(_.value)), void 0, !0)])),
                    _: 3
                }, 8, ["parsedSpec", "proxyUrl"])], 38), xo(Ct(iV))], 64)
            }
        }
    })
      , t4 = k0(e4, [["__scopeId", "data-v-c4323729"]])
      , n4 = {
        class: "references-classic-header-container"
    }
      , r4 = {
        class: "references-classic-header"
    };
    const o4 = k0({}, [["render", function(e, t) {
        return mo(),
        vo("div", n4, [Eo("div", r4, [Fn(e.$slots, "default", {}, void 0, !0), Fn(e.$slots, "dark-mode-toggle", {}, void 0, !0)])])
    }
    ], ["__scopeId", "data-v-a860f78f"]])
      , i4 = e=>(cn("data-v-559a0a79"),
    e = e(),
    un(),
    e)
      , a4 = {
        class: "darklight-reference"
    }
      , s4 = {
        key: 0
    }
      , l4 = {
        key: 1
    }
      , c4 = i4((()=>Eo("a", {
        class: "darklight-reference-promo",
        href: "https://www.scalar.com",
        target: "_blank"
    }, " Powered by scalar.com ", -1)))
      , u4 = k0(Ln({
        __name: "DarkModeToggle",
        props: {
            isDarkMode: {
                type: Boolean
            }
        },
        emits: ["toggleDarkMode"],
        setup: e=>(e,t)=>(mo(),
        vo("div", a4, [Eo("button", {
            class: "darklight",
            type: "button",
            onClick: t[0] || (t[0] = t=>e.$emit("toggleDarkMode"))
        }, [xo(Ct(rC), {
            icon: "LightDarkModeToggle"
        }), e.isDarkMode ? (mo(),
        vo("span", s4, "Light Mode")) : (mo(),
        vo("span", l4, "Dark Mode"))]), c4]))
    }), [["__scopeId", "data-v-559a0a79"]])
      , d4 = k0(Ln({
        __name: "DarkModeIconToggle",
        props: {
            isDarkMode: {
                type: Boolean
            }
        },
        emits: ["toggleDarkMode"],
        setup: e=>(e,t)=>(mo(),
        vo("button", {
            class: "darklight",
            type: "button",
            onClick: t[0] || (t[0] = t=>e.$emit("toggleDarkMode"))
        }, [xo(Ct(rC), {
            icon: e.isDarkMode ? "DarkMode" : "LightMode"
        }, null, 8, ["icon"]), xo(B1, null, {
            default: dn((()=>[Co(" Switch to " + K(e.isDarkMode ? "Light" : "Dark") + " Mode ", 1)])),
            _: 1
        })]))
    }), [["__scopeId", "data-v-8f61ca56"]]);
    function p4(e) {
        return Array.isArray ? Array.isArray(e) : "[object Array]" === w4(e)
    }
    const h4 = 1 / 0;
    function f4(e) {
        return null == e ? "" : function(e) {
            if ("string" == typeof e)
                return e;
            let t = e + "";
            return "0" == t && 1 / e == -h4 ? "-0" : t
        }(e)
    }
    function m4(e) {
        return "string" == typeof e
    }
    function g4(e) {
        return "number" == typeof e
    }
    function b4(e) {
        return !0 === e || !1 === e || function(e) {
            return O4(e) && null !== e
        }(e) && "[object Boolean]" == w4(e)
    }
    function O4(e) {
        return "object" == typeof e
    }
    function v4(e) {
        return null != e
    }
    function y4(e) {
        return !e.trim().length
    }
    function w4(e) {
        return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e)
    }
    const _4 = e=>`Missing ${e} property in key`
      , k4 = e=>`Property 'weight' in key '${e}' must be a positive integer`
      , S4 = Object.prototype.hasOwnProperty;
    class E4 {
        constructor(e) {
            this._keys = [],
            this._keyMap = {};
            let t = 0;
            e.forEach((e=>{
                let n = x4(e);
                this._keys.push(n),
                this._keyMap[n.id] = n,
                t += n.weight
            }
            )),
            this._keys.forEach((e=>{
                e.weight /= t
            }
            ))
        }
        get(e) {
            return this._keyMap[e]
        }
        keys() {
            return this._keys
        }
        toJSON() {
            return JSON.stringify(this._keys)
        }
    }
    function x4(e) {
        let t = null
          , n = null
          , r = null
          , o = 1
          , i = null;
        if (m4(e) || p4(e))
            r = e,
            t = T4(e),
            n = A4(e);
        else {
            if (!S4.call(e, "name"))
                throw new Error(_4("name"));
            const a = e.name;
            if (r = a,
            S4.call(e, "weight") && (o = e.weight,
            o <= 0))
                throw new Error(k4(a));
            t = T4(a),
            n = A4(a),
            i = e.getFn
        }
        return {
            path: t,
            id: n,
            weight: o,
            src: r,
            getFn: i
        }
    }
    function T4(e) {
        return p4(e) ? e : e.split(".")
    }
    function A4(e) {
        return p4(e) ? e.join(".") : e
    }
    const C4 = {
        useExtendedSearch: !1,
        getFn: function(e, t) {
            let n = []
              , r = !1;
            const o = (e,t,i)=>{
                if (v4(e))
                    if (t[i]) {
                        const a = e[t[i]];
                        if (!v4(a))
                            return;
                        if (i === t.length - 1 && (m4(a) || g4(a) || b4(a)))
                            n.push(f4(a));
                        else if (p4(a)) {
                            r = !0;
                            for (let e = 0, n = a.length; e < n; e += 1)
                                o(a[e], t, i + 1)
                        } else
                            t.length && o(a, t, i + 1)
                    } else
                        n.push(e)
            }
            ;
            return o(e, m4(t) ? t.split(".") : t, 0),
            r ? n : n[0]
        },
        ignoreLocation: !1,
        ignoreFieldNorm: !1,
        fieldNormWeight: 1
    };
    var P4 = {
        isCaseSensitive: !1,
        includeScore: !1,
        keys: [],
        shouldSort: !0,
        sortFn: (e,t)=>e.score === t.score ? e.idx < t.idx ? -1 : 1 : e.score < t.score ? -1 : 1,
        includeMatches: !1,
        findAllMatches: !1,
        minMatchCharLength: 1,
        location: 0,
        threshold: .6,
        distance: 100,
        ...C4
    };
    const D4 = /[^ ]+/g;
    class R4 {
        constructor({getFn: e=P4.getFn, fieldNormWeight: t=P4.fieldNormWeight}={}) {
            this.norm = function(e=1, t=3) {
                const n = new Map
                  , r = Math.pow(10, t);
                return {
                    get(t) {
                        const o = t.match(D4).length;
                        if (n.has(o))
                            return n.get(o);
                        const i = 1 / Math.pow(o, .5 * e)
                          , a = parseFloat(Math.round(i * r) / r);
                        return n.set(o, a),
                        a
                    },
                    clear() {
                        n.clear()
                    }
                }
            }(t, 3),
            this.getFn = e,
            this.isCreated = !1,
            this.setIndexRecords()
        }
        setSources(e=[]) {
            this.docs = e
        }
        setIndexRecords(e=[]) {
            this.records = e
        }
        setKeys(e=[]) {
            this.keys = e,
            this._keysMap = {},
            e.forEach(((e,t)=>{
                this._keysMap[e.id] = t
            }
            ))
        }
        create() {
            !this.isCreated && this.docs.length && (this.isCreated = !0,
            m4(this.docs[0]) ? this.docs.forEach(((e,t)=>{
                this._addString(e, t)
            }
            )) : this.docs.forEach(((e,t)=>{
                this._addObject(e, t)
            }
            )),
            this.norm.clear())
        }
        add(e) {
            const t = this.size();
            m4(e) ? this._addString(e, t) : this._addObject(e, t)
        }
        removeAt(e) {
            this.records.splice(e, 1);
            for (let t = e, n = this.size(); t < n; t += 1)
                this.records[t].i -= 1
        }
        getValueForItemAtKeyId(e, t) {
            return e[this._keysMap[t]]
        }
        size() {
            return this.records.length
        }
        _addString(e, t) {
            if (!v4(e) || y4(e))
                return;
            let n = {
                v: e,
                i: t,
                n: this.norm.get(e)
            };
            this.records.push(n)
        }
        _addObject(e, t) {
            let n = {
                i: t,
                $: {}
            };
            this.keys.forEach(((t,r)=>{
                let o = t.getFn ? t.getFn(e) : this.getFn(e, t.path);
                if (v4(o))
                    if (p4(o)) {
                        let e = [];
                        const t = [{
                            nestedArrIndex: -1,
                            value: o
                        }];
                        for (; t.length; ) {
                            const {nestedArrIndex: n, value: r} = t.pop();
                            if (v4(r))
                                if (m4(r) && !y4(r)) {
                                    let t = {
                                        v: r,
                                        i: n,
                                        n: this.norm.get(r)
                                    };
                                    e.push(t)
                                } else
                                    p4(r) && r.forEach(((e,n)=>{
                                        t.push({
                                            nestedArrIndex: n,
                                            value: e
                                        })
                                    }
                                    ))
                        }
                        n.$[r] = e
                    } else if (m4(o) && !y4(o)) {
                        let e = {
                            v: o,
                            n: this.norm.get(o)
                        };
                        n.$[r] = e
                    }
            }
            )),
            this.records.push(n)
        }
        toJSON() {
            return {
                keys: this.keys,
                records: this.records
            }
        }
    }
    function N4(e, t, {getFn: n=P4.getFn, fieldNormWeight: r=P4.fieldNormWeight}={}) {
        const o = new R4({
            getFn: n,
            fieldNormWeight: r
        });
        return o.setKeys(e.map(x4)),
        o.setSources(t),
        o.create(),
        o
    }
    function $4(e, {errors: t=0, currentLocation: n=0, expectedLocation: r=0, distance: o=P4.distance, ignoreLocation: i=P4.ignoreLocation}={}) {
        const a = t / e.length;
        if (i)
            return a;
        const s = Math.abs(r - n);
        return o ? a + s / o : s ? 1 : a
    }
    const I4 = 32;
    function M4(e, t, n, {location: r=P4.location, distance: o=P4.distance, threshold: i=P4.threshold, findAllMatches: a=P4.findAllMatches, minMatchCharLength: s=P4.minMatchCharLength, includeMatches: l=P4.includeMatches, ignoreLocation: c=P4.ignoreLocation}={}) {
        if (t.length > I4)
            throw new Error(`Pattern length exceeds max of ${I4}.`);
        const u = t.length
          , d = e.length
          , p = Math.max(0, Math.min(r, d));
        let h = i
          , f = p;
        const m = s > 1 || l
          , g = m ? Array(d) : [];
        let b;
        for (; (b = e.indexOf(t, f)) > -1; ) {
            let e = $4(t, {
                currentLocation: b,
                expectedLocation: p,
                distance: o,
                ignoreLocation: c
            });
            if (h = Math.min(e, h),
            f = b + u,
            m) {
                let e = 0;
                for (; e < u; )
                    g[b + e] = 1,
                    e += 1
            }
        }
        f = -1;
        let O = []
          , v = 1
          , y = u + d;
        const w = 1 << u - 1;
        for (let k = 0; k < u; k += 1) {
            let r = 0
              , i = y;
            for (; r < i; ) {
                $4(t, {
                    errors: k,
                    currentLocation: p + i,
                    expectedLocation: p,
                    distance: o,
                    ignoreLocation: c
                }) <= h ? r = i : y = i,
                i = Math.floor((y - r) / 2 + r)
            }
            y = i;
            let s = Math.max(1, p - i + 1)
              , l = a ? d : Math.min(p + i, d) + u
              , b = Array(l + 2);
            b[l + 1] = (1 << k) - 1;
            for (let a = l; a >= s; a -= 1) {
                let r = a - 1
                  , i = n[e.charAt(r)];
                if (m && (g[r] = +!!i),
                b[a] = (b[a + 1] << 1 | 1) & i,
                k && (b[a] |= (O[a + 1] | O[a]) << 1 | 1 | O[a + 1]),
                b[a] & w && (v = $4(t, {
                    errors: k,
                    currentLocation: r,
                    expectedLocation: p,
                    distance: o,
                    ignoreLocation: c
                }),
                v <= h)) {
                    if (h = v,
                    f = r,
                    f <= p)
                        break;
                    s = Math.max(1, 2 * p - f)
                }
            }
            if ($4(t, {
                errors: k + 1,
                currentLocation: p,
                expectedLocation: p,
                distance: o,
                ignoreLocation: c
            }) > h)
                break;
            O = b
        }
        const _ = {
            isMatch: f >= 0,
            score: Math.max(.001, v)
        };
        if (m) {
            const e = function(e=[], t=P4.minMatchCharLength) {
                let n = []
                  , r = -1
                  , o = -1
                  , i = 0;
                for (let a = e.length; i < a; i += 1) {
                    let a = e[i];
                    a && -1 === r ? r = i : a || -1 === r || (o = i - 1,
                    o - r + 1 >= t && n.push([r, o]),
                    r = -1)
                }
                return e[i - 1] && i - r >= t && n.push([r, i - 1]),
                n
            }(g, s);
            e.length ? l && (_.indices = e) : _.isMatch = !1
        }
        return _
    }
    function L4(e) {
        let t = {};
        for (let n = 0, r = e.length; n < r; n += 1) {
            const o = e.charAt(n);
            t[o] = (t[o] || 0) | 1 << r - n - 1
        }
        return t
    }
    class Q4 {
        constructor(e, {location: t=P4.location, threshold: n=P4.threshold, distance: r=P4.distance, includeMatches: o=P4.includeMatches, findAllMatches: i=P4.findAllMatches, minMatchCharLength: a=P4.minMatchCharLength, isCaseSensitive: s=P4.isCaseSensitive, ignoreLocation: l=P4.ignoreLocation}={}) {
            if (this.options = {
                location: t,
                threshold: n,
                distance: r,
                includeMatches: o,
                findAllMatches: i,
                minMatchCharLength: a,
                isCaseSensitive: s,
                ignoreLocation: l
            },
            this.pattern = s ? e : e.toLowerCase(),
            this.chunks = [],
            !this.pattern.length)
                return;
            const c = (e,t)=>{
                this.chunks.push({
                    pattern: e,
                    alphabet: L4(e),
                    startIndex: t
                })
            }
              , u = this.pattern.length;
            if (u > I4) {
                let e = 0;
                const t = u % I4
                  , n = u - t;
                for (; e < n; )
                    c(this.pattern.substr(e, I4), e),
                    e += I4;
                if (t) {
                    const e = u - I4;
                    c(this.pattern.substr(e), e)
                }
            } else
                c(this.pattern, 0)
        }
        searchIn(e) {
            const {isCaseSensitive: t, includeMatches: n} = this.options;
            if (t || (e = e.toLowerCase()),
            this.pattern === e) {
                let t = {
                    isMatch: !0,
                    score: 0
                };
                return n && (t.indices = [[0, e.length - 1]]),
                t
            }
            const {location: r, distance: o, threshold: i, findAllMatches: a, minMatchCharLength: s, ignoreLocation: l} = this.options;
            let c = []
              , u = 0
              , d = !1;
            this.chunks.forEach((({pattern: t, alphabet: p, startIndex: h})=>{
                const {isMatch: f, score: m, indices: g} = M4(e, t, p, {
                    location: r + h,
                    distance: o,
                    threshold: i,
                    findAllMatches: a,
                    minMatchCharLength: s,
                    includeMatches: n,
                    ignoreLocation: l
                });
                f && (d = !0),
                u += m,
                f && g && (c = [...c, ...g])
            }
            ));
            let p = {
                isMatch: d,
                score: d ? u / this.chunks.length : 1
            };
            return d && n && (p.indices = c),
            p
        }
    }
    class B4 {
        constructor(e) {
            this.pattern = e
        }
        static isMultiMatch(e) {
            return U4(e, this.multiRegex)
        }
        static isSingleMatch(e) {
            return U4(e, this.singleRegex)
        }
        search() {}
    }
    function U4(e, t) {
        const n = e.match(t);
        return n ? n[1] : null
    }
    class F4 extends B4 {
        constructor(e, {location: t=P4.location, threshold: n=P4.threshold, distance: r=P4.distance, includeMatches: o=P4.includeMatches, findAllMatches: i=P4.findAllMatches, minMatchCharLength: a=P4.minMatchCharLength, isCaseSensitive: s=P4.isCaseSensitive, ignoreLocation: l=P4.ignoreLocation}={}) {
            super(e),
            this._bitapSearch = new Q4(e,{
                location: t,
                threshold: n,
                distance: r,
                includeMatches: o,
                findAllMatches: i,
                minMatchCharLength: a,
                isCaseSensitive: s,
                ignoreLocation: l
            })
        }
        static get type() {
            return "fuzzy"
        }
        static get multiRegex() {
            return /^"(.*)"$/
        }
        static get singleRegex() {
            return /^(.*)$/
        }
        search(e) {
            return this._bitapSearch.searchIn(e)
        }
    }
    class j4 extends B4 {
        constructor(e) {
            super(e)
        }
        static get type() {
            return "include"
        }
        static get multiRegex() {
            return /^'"(.*)"$/
        }
        static get singleRegex() {
            return /^'(.*)$/
        }
        search(e) {
            let t, n = 0;
            const r = []
              , o = this.pattern.length;
            for (; (t = e.indexOf(this.pattern, n)) > -1; )
                n = t + o,
                r.push([t, n - 1]);
            const i = !!r.length;
            return {
                isMatch: i,
                score: i ? 0 : 1,
                indices: r
            }
        }
    }
    const z4 = [class extends B4 {
        constructor(e) {
            super(e)
        }
        static get type() {
            return "exact"
        }
        static get multiRegex() {
            return /^="(.*)"$/
        }
        static get singleRegex() {
            return /^=(.*)$/
        }
        search(e) {
            const t = e === this.pattern;
            return {
                isMatch: t,
                score: t ? 0 : 1,
                indices: [0, this.pattern.length - 1]
            }
        }
    }
    , j4, class extends B4 {
        constructor(e) {
            super(e)
        }
        static get type() {
            return "prefix-exact"
        }
        static get multiRegex() {
            return /^\^"(.*)"$/
        }
        static get singleRegex() {
            return /^\^(.*)$/
        }
        search(e) {
            const t = e.startsWith(this.pattern);
            return {
                isMatch: t,
                score: t ? 0 : 1,
                indices: [0, this.pattern.length - 1]
            }
        }
    }
    , class extends B4 {
        constructor(e) {
            super(e)
        }
        static get type() {
            return "inverse-prefix-exact"
        }
        static get multiRegex() {
            return /^!\^"(.*)"$/
        }
        static get singleRegex() {
            return /^!\^(.*)$/
        }
        search(e) {
            const t = !e.startsWith(this.pattern);
            return {
                isMatch: t,
                score: t ? 0 : 1,
                indices: [0, e.length - 1]
            }
        }
    }
    , class extends B4 {
        constructor(e) {
            super(e)
        }
        static get type() {
            return "inverse-suffix-exact"
        }
        static get multiRegex() {
            return /^!"(.*)"\$$/
        }
        static get singleRegex() {
            return /^!(.*)\$$/
        }
        search(e) {
            const t = !e.endsWith(this.pattern);
            return {
                isMatch: t,
                score: t ? 0 : 1,
                indices: [0, e.length - 1]
            }
        }
    }
    , class extends B4 {
        constructor(e) {
            super(e)
        }
        static get type() {
            return "suffix-exact"
        }
        static get multiRegex() {
            return /^"(.*)"\$$/
        }
        static get singleRegex() {
            return /^(.*)\$$/
        }
        search(e) {
            const t = e.endsWith(this.pattern);
            return {
                isMatch: t,
                score: t ? 0 : 1,
                indices: [e.length - this.pattern.length, e.length - 1]
            }
        }
    }
    , class extends B4 {
        constructor(e) {
            super(e)
        }
        static get type() {
            return "inverse-exact"
        }
        static get multiRegex() {
            return /^!"(.*)"$/
        }
        static get singleRegex() {
            return /^!(.*)$/
        }
        search(e) {
            const t = -1 === e.indexOf(this.pattern);
            return {
                isMatch: t,
                score: t ? 0 : 1,
                indices: [0, e.length - 1]
            }
        }
    }
    , F4]
      , q4 = z4.length
      , H4 = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
    const Z4 = new Set([F4.type, j4.type]);
    class W4 {
        constructor(e, {isCaseSensitive: t=P4.isCaseSensitive, includeMatches: n=P4.includeMatches, minMatchCharLength: r=P4.minMatchCharLength, ignoreLocation: o=P4.ignoreLocation, findAllMatches: i=P4.findAllMatches, location: a=P4.location, threshold: s=P4.threshold, distance: l=P4.distance}={}) {
            this.query = null,
            this.options = {
                isCaseSensitive: t,
                includeMatches: n,
                minMatchCharLength: r,
                findAllMatches: i,
                ignoreLocation: o,
                location: a,
                threshold: s,
                distance: l
            },
            this.pattern = t ? e : e.toLowerCase(),
            this.query = function(e, t={}) {
                return e.split("|").map((e=>{
                    let n = e.trim().split(H4).filter((e=>e && !!e.trim()))
                      , r = [];
                    for (let o = 0, i = n.length; o < i; o += 1) {
                        const e = n[o];
                        let i = !1
                          , a = -1;
                        for (; !i && ++a < q4; ) {
                            const n = z4[a];
                            let o = n.isMultiMatch(e);
                            o && (r.push(new n(o,t)),
                            i = !0)
                        }
                        if (!i)
                            for (a = -1; ++a < q4; ) {
                                const n = z4[a];
                                let o = n.isSingleMatch(e);
                                if (o) {
                                    r.push(new n(o,t));
                                    break
                                }
                            }
                    }
                    return r
                }
                ))
            }(this.pattern, this.options)
        }
        static condition(e, t) {
            return t.useExtendedSearch
        }
        searchIn(e) {
            const t = this.query;
            if (!t)
                return {
                    isMatch: !1,
                    score: 1
                };
            const {includeMatches: n, isCaseSensitive: r} = this.options;
            e = r ? e : e.toLowerCase();
            let o = 0
              , i = []
              , a = 0;
            for (let s = 0, l = t.length; s < l; s += 1) {
                const r = t[s];
                i.length = 0,
                o = 0;
                for (let t = 0, s = r.length; t < s; t += 1) {
                    const s = r[t]
                      , {isMatch: l, indices: c, score: u} = s.search(e);
                    if (!l) {
                        a = 0,
                        o = 0,
                        i.length = 0;
                        break
                    }
                    if (o += 1,
                    a += u,
                    n) {
                        const e = s.constructor.type;
                        Z4.has(e) ? i = [...i, ...c] : i.push(c)
                    }
                }
                if (o) {
                    let e = {
                        isMatch: !0,
                        score: a / o
                    };
                    return n && (e.indices = i),
                    e
                }
            }
            return {
                isMatch: !1,
                score: 1
            }
        }
    }
    const X4 = [];
    function V4(e, t) {
        for (let n = 0, r = X4.length; n < r; n += 1) {
            let r = X4[n];
            if (r.condition(e, t))
                return new r(e,t)
        }
        return new Q4(e,t)
    }
    const G4 = "$and"
      , Y4 = "$or"
      , K4 = "$path"
      , J4 = "$val"
      , e8 = e=>!(!e[G4] && !e[Y4])
      , t8 = e=>({
        [G4]: Object.keys(e).map((t=>({
            [t]: e[t]
        })))
    });
    function n8(e, t, {auto: n=!0}={}) {
        const r = e=>{
            let o = Object.keys(e);
            const i = (e=>!!e[K4])(e);
            if (!i && o.length > 1 && !e8(e))
                return r(t8(e));
            if ((e=>!p4(e) && O4(e) && !e8(e))(e)) {
                const r = i ? e[K4] : o[0]
                  , a = i ? e[J4] : e[r];
                if (!m4(a))
                    throw new Error((e=>`Invalid value for key ${e}`)(r));
                const s = {
                    keyId: A4(r),
                    pattern: a
                };
                return n && (s.searcher = V4(a, t)),
                s
            }
            let a = {
                children: [],
                operator: o[0]
            };
            return o.forEach((t=>{
                const n = e[t];
                p4(n) && n.forEach((e=>{
                    a.children.push(r(e))
                }
                ))
            }
            )),
            a
        }
        ;
        return e8(e) || (e = t8(e)),
        r(e)
    }
    function r8(e, t) {
        const n = e.matches;
        t.matches = [],
        v4(n) && n.forEach((e=>{
            if (!v4(e.indices) || !e.indices.length)
                return;
            const {indices: n, value: r} = e;
            let o = {
                indices: n,
                value: r
            };
            e.key && (o.key = e.key.src),
            e.idx > -1 && (o.refIndex = e.idx),
            t.matches.push(o)
        }
        ))
    }
    function o8(e, t) {
        t.score = e.score
    }
    class i8 {
        constructor(e, t={}, n) {
            this.options = {
                ...P4,
                ...t
            },
            this.options.useExtendedSearch,
            this._keyStore = new E4(this.options.keys),
            this.setCollection(e, n)
        }
        setCollection(e, t) {
            if (this._docs = e,
            t && !(t instanceof R4))
                throw new Error("Incorrect 'index' type");
            this._myIndex = t || N4(this.options.keys, this._docs, {
                getFn: this.options.getFn,
                fieldNormWeight: this.options.fieldNormWeight
            })
        }
        add(e) {
            v4(e) && (this._docs.push(e),
            this._myIndex.add(e))
        }
        remove(e=(()=>!1)) {
            const t = [];
            for (let n = 0, r = this._docs.length; n < r; n += 1) {
                const o = this._docs[n];
                e(o, n) && (this.removeAt(n),
                n -= 1,
                r -= 1,
                t.push(o))
            }
            return t
        }
        removeAt(e) {
            this._docs.splice(e, 1),
            this._myIndex.removeAt(e)
        }
        getIndex() {
            return this._myIndex
        }
        search(e, {limit: t=-1}={}) {
            const {includeMatches: n, includeScore: r, shouldSort: o, sortFn: i, ignoreFieldNorm: a} = this.options;
            let s = m4(e) ? m4(this._docs[0]) ? this._searchStringList(e) : this._searchObjectList(e) : this._searchLogical(e);
            return function(e, {ignoreFieldNorm: t=P4.ignoreFieldNorm}) {
                e.forEach((e=>{
                    let n = 1;
                    e.matches.forEach((({key: e, norm: r, score: o})=>{
                        const i = e ? e.weight : null;
                        n *= Math.pow(0 === o && i ? Number.EPSILON : o, (i || 1) * (t ? 1 : r))
                    }
                    )),
                    e.score = n
                }
                ))
            }(s, {
                ignoreFieldNorm: a
            }),
            o && s.sort(i),
            g4(t) && t > -1 && (s = s.slice(0, t)),
            function(e, t, {includeMatches: n=P4.includeMatches, includeScore: r=P4.includeScore}={}) {
                const o = [];
                return n && o.push(r8),
                r && o.push(o8),
                e.map((e=>{
                    const {idx: n} = e
                      , r = {
                        item: t[n],
                        refIndex: n
                    };
                    return o.length && o.forEach((t=>{
                        t(e, r)
                    }
                    )),
                    r
                }
                ))
            }(s, this._docs, {
                includeMatches: n,
                includeScore: r
            })
        }
        _searchStringList(e) {
            const t = V4(e, this.options)
              , {records: n} = this._myIndex
              , r = [];
            return n.forEach((({v: e, i: n, n: o})=>{
                if (!v4(e))
                    return;
                const {isMatch: i, score: a, indices: s} = t.searchIn(e);
                i && r.push({
                    item: e,
                    idx: n,
                    matches: [{
                        score: a,
                        value: e,
                        norm: o,
                        indices: s
                    }]
                })
            }
            )),
            r
        }
        _searchLogical(e) {
            const t = n8(e, this.options)
              , n = (e,t,r)=>{
                if (!e.children) {
                    const {keyId: n, searcher: o} = e
                      , i = this._findMatches({
                        key: this._keyStore.get(n),
                        value: this._myIndex.getValueForItemAtKeyId(t, n),
                        searcher: o
                    });
                    return i && i.length ? [{
                        idx: r,
                        item: t,
                        matches: i
                    }] : []
                }
                const o = [];
                for (let i = 0, a = e.children.length; i < a; i += 1) {
                    const a = e.children[i]
                      , s = n(a, t, r);
                    if (s.length)
                        o.push(...s);
                    else if (e.operator === G4)
                        return []
                }
                return o
            }
              , r = this._myIndex.records
              , o = {}
              , i = [];
            return r.forEach((({$: e, i: r})=>{
                if (v4(e)) {
                    let a = n(t, e, r);
                    a.length && (o[r] || (o[r] = {
                        idx: r,
                        item: e,
                        matches: []
                    },
                    i.push(o[r])),
                    a.forEach((({matches: e})=>{
                        o[r].matches.push(...e)
                    }
                    )))
                }
            }
            )),
            i
        }
        _searchObjectList(e) {
            const t = V4(e, this.options)
              , {keys: n, records: r} = this._myIndex
              , o = [];
            return r.forEach((({$: e, i: r})=>{
                if (!v4(e))
                    return;
                let i = [];
                n.forEach(((n,r)=>{
                    i.push(...this._findMatches({
                        key: n,
                        value: e[r],
                        searcher: t
                    }))
                }
                )),
                i.length && o.push({
                    idx: r,
                    item: e,
                    matches: i
                })
            }
            )),
            o
        }
        _findMatches({key: e, value: t, searcher: n}) {
            if (!v4(t))
                return [];
            let r = [];
            if (p4(t))
                t.forEach((({v: t, i: o, n: i})=>{
                    if (!v4(t))
                        return;
                    const {isMatch: a, score: s, indices: l} = n.searchIn(t);
                    a && r.push({
                        score: s,
                        key: e,
                        value: t,
                        idx: o,
                        norm: i,
                        indices: l
                    })
                }
                ));
            else {
                const {v: o, n: i} = t
                  , {isMatch: a, score: s, indices: l} = n.searchIn(o);
                a && r.push({
                    score: s,
                    key: e,
                    value: o,
                    norm: i,
                    indices: l
                })
            }
            return r
        }
    }
    function a8(e) {
        var t, n, r;
        try {
            const o = null == (r = null == (n = null == (t = null == e ? void 0 : e.information) ? void 0 : t.requestBody) ? void 0 : n.content) ? void 0 : r["application/json"];
            if (!o)
                throw new Error("Body not found");
            return function(e) {
                var t;
                const n = ["Body"]
                  , r = null == (t = null == e ? void 0 : e.schema) ? void 0 : t.properties;
                return r && Object.keys(r).forEach((t=>{
                    if (!e.schema)
                        return;
                    n.push(function(e, t) {
                        let n = e;
                        return n += t.required && t.required.includes(e) ? " REQUIRED " : " optional ",
                        t.properties[e] && (n += t.properties[e].type,
                        t.properties[e].description && (n += " " + t.properties[e].description)),
                        n
                    }(t, e.schema));
                    const o = r[t];
                    "object" === o.type && o.properties && o.properties && Object.keys(o.properties).forEach((e=>{
                        var t, r;
                        n.push(`${e} ${null == (r = null == (t = o.properties) ? void 0 : t[e]) ? void 0 : r.type}`)
                    }
                    ))
                }
                )),
                n
            }(o)
        } catch (o) {
            return !1
        }
    }
    i8.version = "7.0.0",
    i8.createIndex = N4,
    i8.parseIndex = function(e, {getFn: t=P4.getFn, fieldNormWeight: n=P4.fieldNormWeight}={}) {
        const {keys: r, records: o} = e
          , i = new R4({
            getFn: t,
            fieldNormWeight: n
        });
        return i.setKeys(r),
        i.setIndexRecords(o),
        i
    }
    ,
    i8.config = P4,
    i8.parseQuery = n8,
    function(...e) {
        X4.push(...e)
    }(W4);
    const s8 = e=>(cn("data-v-9def0ef3"),
    e = e(),
    un(),
    e)
      , l8 = s8((()=>Eo("div", {
        class: "ref-search-meta"
    }, [Eo("span", null, "↑↓ Navigate"), Eo("span", null, "⏎ Select")], -1)))
      , c8 = k0(Ln({
        __name: "SearchModal",
        props: {
            parsedSpec: {},
            modalState: {}
        },
        setup(e) {
            const t = e
              , n = It(t, "parsedSpec")
              , r = {
                heading: "DocsPage",
                model: "JsonObject",
                req: "Terminal",
                tag: "CodeFolder",
                webhook: "Terminal"
            }
              , o = Ml()
              , i = Et([])
              , a = Et([])
              , s = Et(0)
              , l = Et("")
              , c = Et(null)
              , u = new i8(i.value,{
                keys: ["title", "description", "body"]
            })
              , d = ()=>{
                s.value = 0,
                a.value = u.search(l.value)
            }
              , p = ei((()=>y.value[s.value]))
              , {getHeadingId: h, getWebhookId: f, getModelId: m, getOperationId: g, getTagId: b} = LY();
            zr((()=>t.modalState.open), (e=>{
                e && (l.value = "",
                s.value = 0,
                a.value = [])
            }
            ));
            const {setCollapsedSidebarItem: O, hideModels: v} = VK();
            zr(n.value, (async()=>{
                var e, n, r, o, a;
                if (i.value = [],
                !(null == (n = null == (e = t.parsedSpec) ? void 0 : e.tags) ? void 0 : n.length) && !(null == (r = t.parsedSpec) ? void 0 : r.webhooks))
                    return void u.setCollection([]);
                const s = []
                  , l = await ZY((null == (o = t.parsedSpec.info) ? void 0 : o.description) ?? "");
                l.length && (l.forEach((e=>{
                    s.push({
                        type: "heading",
                        title: `Info > ${e.value}`,
                        description: "",
                        href: `#${h(e)}`,
                        tag: e.slug,
                        body: ""
                    })
                }
                )),
                i.value = i.value.concat(s)),
                null == (a = t.parsedSpec.tags) || a.forEach((e=>{
                    const t = {
                        title: e["x-displayName"] ?? e.name,
                        href: `#${b(e)}`,
                        description: e.description,
                        type: "tag",
                        tag: e.name,
                        body: ""
                    };
                    i.value.push(t),
                    e.operations && e.operations.forEach((t=>{
                        const {parameterMap: n} = QY({
                            operation: t
                        })
                          , r = a8(t) || n.value;
                        let o = null;
                        "boolean" != typeof r && (o = r);
                        const a = {
                            type: "req",
                            title: t.name ?? t.path,
                            href: `#${g(t, e)}`,
                            operationId: t.operationId,
                            description: t.description ?? "",
                            httpVerb: t.httpVerb,
                            path: t.path,
                            tag: e.name,
                            operation: t
                        };
                        o && (a.body = o),
                        i.value.push(a)
                    }
                    ))
                }
                ));
                const c = t.parsedSpec.webhooks
                  , d = [];
                c && Object.keys(c).forEach((e=>{
                    Object.keys(c[e]).forEach((t=>{
                        var n;
                        d.push({
                            type: "webhook",
                            title: `Webhook: ${null == (n = c[e][t]) ? void 0 : n.name}`,
                            href: `#${f(e, t)}`,
                            description: e,
                            httpVerb: t,
                            tag: e,
                            body: ""
                        })
                    }
                    )),
                    i.value = i.value.concat(d)
                }
                ));
                const p = v.value ? {} : XY(t.parsedSpec)
                  , O = [];
                p && (Object.keys(p).forEach((e=>{
                    O.push({
                        type: "model",
                        title: "Model",
                        href: `#${m(e)}`,
                        description: p[e].title ?? e,
                        tag: e,
                        body: ""
                    })
                }
                )),
                i.value = i.value.concat(O)),
                u.setCollection(i.value)
            }
            ), {
                immediate: !0
            }),
            xl(o.enter, (()=>{
                t.modalState.open && window && (_(p.value),
                window.location.hash = p.value.item.href,
                t.modalState.hide())
            }
            )),
            xl(o.ArrowDown, (()=>{
                var e;
                t.modalState.open && window && (s.value < y.value.length - 1 ? s.value++ : s.value = 0,
                null == (e = document.getElementById(p.value.item.href)) || e.scrollIntoView({
                    behavior: "smooth",
                    block: "center"
                }))
            }
            )),
            xl(o.ArrowUp, (()=>{
                var e;
                t.modalState.open && window && (s.value > 0 ? s.value-- : s.value = y.value.length - 1,
                null == (e = document.getElementById(p.value.item.href)) || e.scrollIntoView({
                    behavior: "smooth",
                    block: "center"
                }))
            }
            ));
            const y = ei((()=>0 === l.value.length ? i.value.map((e=>({
                item: e
            }))) : a.value))
              , w = /#(tag\/[^/]*)/
              , _ = e=>{
                let n = "models";
                const r = e.item.href.match(w);
                (null == r ? void 0 : r.length) && r.length > 1 && (n = r[1]),
                O(n, !0),
                t.modalState.hide()
            }
            ;
            function k(e) {
                const t = new URL(window.location.href);
                return t.hash = e,
                t.toString()
            }
            return (e,t)=>(mo(),
            yo(Ct(qc), {
                state: e.modalState,
                variant: "search"
            }, {
                default: dn((()=>[Eo("div", {
                    ref_key: "searchModalRef",
                    ref: c,
                    class: "ref-search-container"
                }, [xo(Ct(cC), {
                    modelValue: l.value,
                    "onUpdate:modelValue": t[0] || (t[0] = e=>l.value = e),
                    onInput: d
                }, null, 8, ["modelValue"])], 512), xo(Ct(vC), {
                    class: "ref-search-results custom-scroll",
                    noResults: !y.value.length
                }, {
                    query: dn((()=>[Co(K(l.value), 1)])),
                    default: dn((()=>[(mo(!0),
                    vo(lo, null, In(y.value, ((e,t)=>(mo(),
                    yo(Ct(bC), {
                        id: e.item.href,
                        key: e.refIndex,
                        active: s.value === t,
                        href: k(e.item.href),
                        icon: r[e.item.type],
                        onClick: t=>_(e),
                        onFocus: e=>s.value = t
                    }, Mn({
                        default: dn((()=>[Co(K(e.item.title) + " ", 1)])),
                        _: 2
                    }, [(e.item.httpVerb || e.item.path) && e.item.path !== e.item.title ? {
                        name: "description",
                        fn: dn((()=>[Co(K(e.item.path), 1)])),
                        key: "0"
                    } : e.item.description ? {
                        name: "description",
                        fn: dn((()=>[Co(K(e.item.description), 1)])),
                        key: "1"
                    } : void 0, "req" === e.item.type ? {
                        name: "addon",
                        fn: dn((()=>[xo($3, {
                            method: e.item.httpVerb ?? "get"
                        }, null, 8, ["method"])])),
                        key: "2"
                    } : void 0]), 1032, ["id", "active", "href", "icon", "onClick", "onFocus"])))), 128))])),
                    _: 1
                }, 8, ["noResults"]), l8])),
                _: 1
            }, 8, ["state"]))
        }
    }), [["__scopeId", "data-v-9def0ef3"]])
      , u8 = e=>(cn("data-v-af64a87b"),
    e = e(),
    un(),
    e)
      , d8 = {
        class: "sidebar-search-input"
    }
      , p8 = u8((()=>Eo("span", {
        class: "sidebar-search-placeholder"
    }, "Search", -1)))
      , h8 = {
        class: "sidebar-search-shortcut"
    }
      , f8 = {
        class: "sidebar-search-key"
    }
      , m8 = Ln({
        __name: "SearchButton",
        props: {
            spec: {},
            searchHotKey: {
                default: "k"
            }
        },
        setup(e) {
            const t = e
              , n = Fc()
              , r = Et(null)
              , o = Ml({
                passive: !1,
                onEventFired(e) {
                    !$z() && e.ctrlKey && e.key === t.searchHotKey && (e.preventDefault(),
                    e.stopPropagation())
                }
            });
            return Sn((()=>{
                j5.on((e=>{
                    r.value = e
                }
                ))
            }
            )),
            xl(o[`${$z() ? "meta" : "control"}_${t.searchHotKey}`], (()=>{
                var e;
                (null == (e = r.value) ? void 0 : e.open) || (n.open ? n.hide() : n.show())
            }
            )),
            (e,t)=>(mo(),
            vo(lo, null, [Eo("button", {
                class: Z(["sidebar-search", e.$attrs.class]),
                type: "button",
                onClick: t[0] || (t[0] = (...e)=>Ct(n).show && Ct(n).show(...e))
            }, [xo(Ct(rC), {
                class: "search-icon",
                icon: "Search",
                size: "sm"
            }), Eo("div", d8, [p8, Eo("span", h8, [Eo("span", f8, K(Ct($z)() ? "⌘" : "⌃") + K(e.searchHotKey), 1)])])], 2), xo(c8, {
                modalState: Ct(n),
                parsedSpec: e.spec
            }, null, 8, ["modalState", "parsedSpec"])], 64))
        }
    })
      , g8 = k0(m8, [["__scopeId", "data-v-af64a87b"]])
      , b8 = Ln({
        __name: "ClassicLayout",
        props: {
            configuration: {},
            parsedSpec: {},
            rawSpec: {},
            isDark: {
                type: Boolean
            }
        },
        emits: ["toggleDarkMode"],
        setup(e) {
            const t = e
              , n = ei((()=>({
                ...t.configuration,
                showSidebar: !1
            })));
            return (e,t)=>(mo(),
            yo(t4, {
                configuration: n.value,
                parsedSpec: e.parsedSpec,
                rawSpec: e.rawSpec
            }, {
                "content-start": dn((({spec: r})=>[xo(o4, null, {
                    "dark-mode-toggle": dn((()=>[xo(Ct(d4), {
                        isDarkMode: e.isDark,
                        onToggleDarkMode: t[0] || (t[0] = t=>e.$emit("toggleDarkMode"))
                    }, null, 8, ["isDarkMode"])])),
                    default: dn((()=>[xo(g8, {
                        class: "t-doc__sidebar",
                        searchHotKey: n.value.searchHotKey,
                        spec: r
                    }, null, 8, ["searchHotKey", "spec"])])),
                    _: 2
                }, 1024)])),
                "content-end": dn((()=>[Fn(e.$slots, "footer")])),
                _: 3
            }, 8, ["configuration", "parsedSpec", "rawSpec"]))
        }
    })
      , O8 = {
        class: "references-mobile-header t-doc__header"
    }
      , v8 = {
        class: "references-mobile-breadcrumbs"
    }
      , y8 = {
        class: "references-mobile-header-actions"
    }
      , w8 = k0(Ln({
        __name: "MobileHeader",
        props: {
            open: {
                type: Boolean
            }
        },
        emits: ["update:open"],
        setup(e) {
            const {breadcrumb: t} = VK();
            return (e,n)=>(mo(),
            vo("div", O8, [xo(Ct(aC), {
                icon: e.open ? "Close" : "Menu",
                label: e.open ? "Close Menu" : "Open Menu",
                size: "md",
                onClick: n[0] || (n[0] = t=>e.$emit("update:open", !e.open))
            }, null, 8, ["icon", "label"]), Eo("span", v8, K(Ct(t)), 1), Eo("div", y8, [Fn(e.$slots, "actions", {}, void 0, !0)])]))
        }
    }), [["__scopeId", "data-v-0242e3de"]])
      , _8 = {
        class: "scalar-api-references-standalone-search"
    }
      , k8 = Ln({
        __name: "ModernLayout",
        props: {
            configuration: {},
            parsedSpec: {},
            rawSpec: {},
            isDark: {
                type: Boolean
            }
        },
        emits: ["toggleDarkMode"],
        setup(e) {
            const t = e
              , n = Rl("(max-width: 1000px)")
              , {isSidebarOpen: r} = VK();
            zr(n, ((e,t)=>{
                e && !t && (r.value = !1)
            }
            ));
            const {hash: o} = LY();
            return zr(o, ((e,t)=>{
                e && e !== t && (r.value = !1)
            }
            )),
            (e,n)=>(mo(),
            yo(t4, {
                class: Z({
                    "scalar-api-references-standalone-mobile": e.configuration.showSidebar
                }),
                configuration: e.configuration,
                parsedSpec: e.parsedSpec,
                rawSpec: e.rawSpec
            }, {
                header: dn((()=>[t.configuration.showSidebar ? (mo(),
                yo(w8, {
                    key: 0,
                    open: Ct(r),
                    "onUpdate:open": n[0] || (n[0] = e=>St(r) ? r.value = e : null)
                }, null, 8, ["open"])) : Do("", !0)])),
                "sidebar-start": dn((({spec: e})=>{
                    var n;
                    return [Eo("div", _8, [xo(g8, {
                        searchHotKey: null == (n = t.configuration) ? void 0 : n.searchHotKey,
                        spec: e
                    }, null, 8, ["searchHotKey", "spec"])])]
                }
                )),
                "sidebar-end": dn((()=>[xo(Ct(u4), {
                    isDarkMode: e.isDark,
                    onToggleDarkMode: n[1] || (n[1] = t=>e.$emit("toggleDarkMode"))
                }, null, 8, ["isDarkMode"])])),
                "content-end": dn((()=>[Fn(e.$slots, "footer", {}, void 0, !0)])),
                _: 3
            }, 8, ["class", "configuration", "parsedSpec", "rawSpec"]))
        }
    })
      , S8 = {
        modern: k0(k8, [["__scopeId", "data-v-333fecad"]]),
        classic: b8
    }
      , E8 = Ln({
        __name: "ApiReference",
        props: {
            configuration: {}
        },
        emits: ["updateContent"],
        setup(e) {
            var t, n;
            const r = e
              , {toggleDarkMode: o, isDark: i} = function(e) {
                var t;
                return vY.value = ("undefined" == typeof window ? null : JSON.parse((null == (t = window.localStorage) ? void 0 : t.getItem("isDark")) || "null")) ?? e ?? (()=>{
                    var e, t;
                    const n = "undefined" != typeof window ? null == (e = window.localStorage) ? void 0 : e.getItem("isDark") : null;
                    return "string" == typeof n ? !!JSON.parse(n) : !("undefined" == typeof window || !(null == (t = null == window ? void 0 : window.matchMedia("(prefers-color-scheme: dark)")) ? void 0 : t.matches))
                }
                )(),
                zr(vY, (e=>{
                    "undefined" != typeof document && (document.body.classList.toggle("dark-mode", e),
                    document.body.classList.toggle("light-mode", !e))
                }
                ), {
                    immediate: !0
                }),
                {
                    isDark: vY,
                    toggleDarkMode: ()=>{
                        var e;
                        vY.value = !vY.value,
                        "undefined" != typeof window && (null == (e = null == window ? void 0 : window.localStorage) || e.setItem("isDark", JSON.stringify(vY.value)))
                    }
                    ,
                    setDarkMode: function(e) {
                        var t;
                        vY.value = e,
                        "undefined" != typeof window && (null == (t = null == window ? void 0 : window.localStorage) || t.setItem("isDark", JSON.stringify(vY.value)))
                    }
                }
            }(null == (t = r.configuration) ? void 0 : t.darkMode);
            zr((()=>{
                var e;
                return null == (e = r.configuration) ? void 0 : e.darkMode
            }
            ), (e=>{
                e !== i.value && o()
            }
            ));
            const a = ei((()=>{
                var e, t;
                if (null == (e = r.configuration) ? void 0 : e.customCss)
                    return function(e) {
                        return hl.some((t=>e.includes(t))) ? (console.warn("DEPRECATION WARNING: It looks like you're using legacy CSS variables in your custom CSS string. Please migrate them to use the updated prefixes. See https://github.com/scalar/scalar#theme-prefix-changes"),
                        pl.reduce(((e,[t,n])=>e.replaceAll(t, n)), e)) : e
                    }(null == (t = r.configuration) ? void 0 : t.customCss)
            }
            ));
            zr(a, (()=>console.log(a.value)));
            const s = ei((()=>{
                var e;
                return {
                    spec: {
                        content: void 0,
                        url: void 0,
                        ...null == (e = r.configuration) ? void 0 : e.spec
                    },
                    proxy: void 0,
                    theme: "default",
                    showSidebar: !0,
                    isEditable: !1,
                    ...r.configuration,
                    customCss: a.value
                }
            }
            ));
            function l(e, t) {
                zr((()=>{
                    var t;
                    return null == (t = s.value) ? void 0 : t[e]
                }
                ), (e=>{
                    void 0 !== e && t(e)
                }
                ), {
                    immediate: !0
                })
            }
            (null == (n = s.value) ? void 0 : n.metaData) && function(e, t) {
                const {title: n, titleTemplate: r, ...o} = e;
                bY({
                    title: n,
                    titleTemplate: r,
                    _flatMeta: o
                }, {
                    ...t,
                    transform(e) {
                        const t = mY({
                            ...e._flatMeta
                        });
                        return delete e._flatMeta,
                        {
                            ...e,
                            meta: t
                        }
                    }
                })
            }(s.value.metaData);
            const {setAuthentication: c} = xq();
            l("authentication", c);
            const {setExcludedClients: u} = b0();
            l("hiddenClients", u);
            const {parsedSpec: d, rawSpec: p} = PK({
                proxy: It((()=>{
                    var e;
                    return (null == (e = r.configuration) ? void 0 : e.proxy) || ""
                }
                )),
                specConfig: It((()=>{
                    var e;
                    return (null == (e = r.configuration) ? void 0 : e.spec) || {}
                }
                ))
            });
            return (e,t)=>{
                var n, r;
                return mo(),
                vo(lo, null, [(null == (n = s.value) ? void 0 : n.customCss) ? (mo(),
                yo(On("style"), {
                    key: 0
                }, {
                    default: dn((()=>[Co(K(s.value.customCss), 1)])),
                    _: 1
                })) : Do("", !0), (mo(),
                yo(On(Ct(S8)[(null == (r = s.value) ? void 0 : r.layout) || "modern"]), {
                    configuration: s.value,
                    isDark: Ct(i),
                    parsedSpec: Ct(d),
                    rawSpec: Ct(p),
                    onToggleDarkMode: t[0] || (t[0] = ()=>Ct(o)()),
                    onUpdateContent: t[1] || (t[1] = t=>e.$emit("updateContent", t))
                }, {
                    footer: dn((()=>[Fn(e.$slots, "footer")])),
                    _: 3
                }, 40, ["configuration", "isDark", "parsedSpec", "rawSpec"]))], 64)
            }
        }
    })
      , x8 = document.getElementById("api-reference")
      , T8 = document.querySelector("[data-spec]")
      , A8 = document.querySelector("[data-spec-url]")
      , C8 = document.querySelector("#api-reference[data-configuration]")
      , P8 = ()=>{
        if (C8) {
            const e = C8.getAttribute("data-configuration");
            if (e)
                return JSON.parse(e.split("&quot;").join('"'))
        }
        return {}
    }
      , D8 = ()=>{
        var e, t, n;
        if (null == (e = P8().spec) ? void 0 : e.url)
            return null == (t = P8().spec) ? void 0 : t.url;
        if (x8) {
            const e = null == (n = x8.getAttribute("data-url")) ? void 0 : n.trim();
            if (e)
                return e
        }
        if (A8) {
            console.warn('[@scalar/api-reference] The [data-spec-url] HTML API is deprecated. Use the new <script id="api-reference" data-url="/scalar.json" /> API instead.');
            const e = A8.getAttribute("data-spec-url");
            if (e)
                return e
        }
    }
      , R8 = ()=>{
        var e, t;
        if (x8) {
            const t = null == (e = x8.innerHTML) ? void 0 : e.trim();
            if (t)
                return JSON.parse(t)
        }
        if (T8) {
            console.warn('[@scalar/api-reference] The [data-spec] HTML API is deprecated. Use the new <script id="api-reference" type="application/json">{"openapi":"3.1.0","info":{"title":"Example"},"paths":{}}<\/script> API instead.');
            const e = null == (t = T8.getAttribute("data-spec")) ? void 0 : t.trim();
            if (e)
                return JSON.parse(e)
        }
    }
      , N8 = ()=>{
        if (x8) {
            const e = x8.getAttribute("data-proxy-url");
            if (e)
                return e.trim()
        }
    }
      , $8 = ut({});
    if (A8 || T8 || x8) {
        const n = R8() ? {
            content: R8()
        } : {
            url: D8()
        };
        Object.assign($8, {
            configuration: {
                ...P8(),
                spec: {
                    ...n
                },
                proxy: N8()
            }
        }),
        P8().darkMode ? null == (e = document.body) || e.classList.add("dark-mode") : null == (t = document.body) || t.classList.add("light-mode");
        const r = (()=>{
            var e;
            let t = null;
            return x8 ? (t = document.createElement("div"),
            null == (e = null == x8 ? void 0 : x8.parentNode) || e.insertBefore(t, x8)) : t = T8 || A8 || document.body,
            t
        }
        )()
          , o = ()=>{
            const e = Xi((()=>ti(E8, $8)));
            return r ? e.mount(r) : console.error("Could not find a mount point for API References"),
            e
        }
        ;
        let i = o();
        document.addEventListener("scalar:reload-references", (()=>{
            r && !document.body.contains(r) && document.body.appendChild(r),
            i.unmount(),
            i = o()
        }
        ), !1),
        document.addEventListener("scalar:update-references-config", (e=>{
            "detail"in e && Object.assign($8, e.detail)
        }
        ), !1)
    } else
        console.error('Couldn’t find a [data-spec], [data-spec-url] or <script id="api-reference" /> element. Try adding it like this: %c<div data-spec-url="https://cdn.jsdelivr.net/npm/@scalar/galaxy/dist/latest.yaml" />', "font-family: monospace;");
    const I8 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 12 12"
    }
      , M8 = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M6 1v10M1 6h10"
    }, null, -1)];
    function L8(e, t) {
        return mo(),
        vo("svg", I8, [...M8])
    }
    const Q8 = {
        render: L8
    }
      , B8 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Q8,
        render: L8
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , U8 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 14 14"
    }
      , F8 = [Eo("path", {
        "fill-rule": "evenodd",
        d: "M12.6 7.8c.4 0 .8-.3.8-.8 0-.4-.3-.8-.8-.8H3.2l3.1-3.1c.3-.3.3-.8 0-1.1-.3-.2-.8-.2-1 .1L.9 6.5c-.3.3-.3.8 0 1.1L5.3 12c.3.3.8.3 1.1 0s.3-.8 0-1.1L3.2 7.8z",
        "clip-rule": "evenodd"
    }, null, -1)];
    function j8(e, t) {
        return mo(),
        vo("svg", U8, [...F8])
    }
    const z8 = {
        render: j8
    }
      , q8 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: z8,
        render: j8
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , H8 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 14 14"
    }
      , Z8 = [Eo("path", {
        "fill-rule": "evenodd",
        d: "M1.3 6.2c-.4 0-.7.3-.7.7s.3.8.8.8h9.4l-3.2 3.1c-.3.3-.3.8 0 1.1s.8.3 1.1 0l4.4-4.4c.3-.3.3-.8 0-1.1L8.6 2c-.2-.3-.7-.3-1 0s-.3.8 0 1.1l3.1 3.1z",
        "clip-rule": "evenodd"
    }, null, -1)];
    function W8(e, t) {
        return mo(),
        vo("svg", H8, [...Z8])
    }
    const X8 = {
        render: W8
    }
      , V8 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: X8,
        render: W8
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , G8 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , Y8 = [Eo("path", {
        d: "M24 22.21 19.82 2a2.51 2.51 0 0 0-2.45-2H1.5A1.5 1.5 0 0 0 0 1.79l2.46 11.84a.24.24 0 0 1 0 .12L.06 22a1 1 0 0 0 1.94.56l1.07-3.69a.24.24 0 0 1 .25-.18.23.23 0 0 1 .23.2L4.18 22a2.51 2.51 0 0 0 2.45 2H22.5a1.5 1.5 0 0 0 1.5-1.79M3.72 4a.39.39 0 0 1 .4-.49h12.27A.63.63 0 0 1 17 4l3.29 16a.39.39 0 0 1-.4.49H7.61A.63.63 0 0 1 7 20Z"
    }, null, -1), Eo("path", {
        d: "M9 17h8a.51.51 0 0 0 .46-.71L15 10.79a.5.5 0 0 0-.89 0l-1.61 2.8a.22.22 0 0 1-.15.12.24.24 0 0 1-.2 0l-.83-.56a.51.51 0 0 0-.7.14l-2 3A.5.5 0 0 0 9 17m1-6.5A1.5 1.5 0 1 0 8.5 9a1.5 1.5 0 0 0 1.5 1.5"
    }, null, -1)];
    function K8(e, t) {
        return mo(),
        vo("svg", G8, [...Y8])
    }
    const J8 = {
        render: K8
    }
      , e7 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: J8,
        render: K8
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , t7 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 12 12"
    }
      , n7 = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M4.9 1.1h-.3c-.4 0-.8.3-.8.8v2.3c0 .6-.4 1.2-.9 1.4L1.7 6l1.2.5c.6.2.9.8.9 1.4v2.3c0 .4.3.8.8.8h.3m2.2-9.9h.3c.4 0 .8.3.8.8v2.3c0 .6.4 1.2.9 1.4l1.2.4-1.2.5c-.5.2-.9.7-.9 1.4v2.3c0 .4-.3.8-.8.8h-.3"
    }, null, -1)];
    function r7(e, t) {
        return mo(),
        vo("svg", t7, [...n7])
    }
    const o7 = {
        render: r7
    }
      , i7 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: o7,
        render: r7
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , a7 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        viewBox: "0 0 12 12"
    }
      , s7 = [Eo("path", {
        d: "M8.2 3.8v2.4H3.8m0-2.4v4.4"
    }, null, -1), Eo("circle", {
        cx: "3.8",
        cy: "2.2",
        r: "1.2"
    }, null, -1), Eo("circle", {
        cx: "3.8",
        cy: "9.8",
        r: "1.2"
    }, null, -1), Eo("circle", {
        cx: "8.2",
        cy: "2.2",
        r: "1.2"
    }, null, -1)];
    function l7(e, t) {
        return mo(),
        vo("svg", a7, [...s7])
    }
    const c7 = {
        render: l7
    }
      , u7 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: c7,
        render: l7
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , d7 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 14 14"
    }
      , p7 = [Eo("path", {
        "fill-rule": "evenodd",
        d: "M12.639.099a.993.993 0 0 1 1.31.933v10.063a.994.994 0 0 1-1.31.933l-.005-.001-11.585-4.04A1.49 1.49 0 0 1 .051 6.63v-1.1a1.49 1.49 0 0 1 .998-1.4zm-10.61 10.67v-1.13l6.199 2.163a3.186 3.186 0 0 1-6.199-1.034Z",
        "clip-rule": "evenodd"
    }, null, -1)];
    function h7(e, t) {
        return mo(),
        vo("svg", d7, [...p7])
    }
    const f7 = {
        render: h7
    }
      , m7 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: f7,
        render: h7
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , g7 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 12 12"
    }
      , b7 = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M10.7 2.3 5.3 9.7l-4-3.2"
    }, null, -1)];
    function O7(e, t) {
        return mo(),
        vo("svg", g7, [...b7])
    }
    const v7 = {
        render: O7
    }
      , y7 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: v7,
        render: O7
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , w7 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 12 12"
    }
      , _7 = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M2.2 4.1 6 7.9l3.8-3.8"
    }, null, -1)];
    function k7(e, t) {
        return mo(),
        vo("svg", w7, [..._7])
    }
    const S7 = {
        render: k7
    }
      , E7 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: S7,
        render: k7
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , x7 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 12 12"
    }
      , T7 = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M7.9 9.8 4.1 6l3.8-3.8"
    }, null, -1)];
    function A7(e, t) {
        return mo(),
        vo("svg", x7, [...T7])
    }
    const C7 = {
        render: A7
    }
      , P7 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: C7,
        render: A7
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , D7 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 12 12"
    }
      , R7 = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M4.1 9.8 7.9 6 4.1 2.2"
    }, null, -1)];
    function N7(e, t) {
        return mo(),
        vo("svg", D7, [...R7])
    }
    const $7 = {
        render: N7
    }
      , I7 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: $7,
        render: N7
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , M7 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 12 12"
    }
      , L7 = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M9.8 7.9 6 4.1 2.2 7.9"
    }, null, -1)];
    function Q7(e, t) {
        return mo(),
        vo("svg", M7, [...L7])
    }
    const B7 = {
        render: Q7
    }
      , U7 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: B7,
        render: Q7
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , F7 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 16 16"
    }
      , j7 = [Eo("path", {
        d: "M6 5h4c1.7 0 2-1.3 2-3 1.1 0 2 .9 2 2v10c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2 0 1.7.3 3 2 3m0-3V1c0-.6.5-1 1-1h2c.5 0 1 .4 1 1v1.3c0 .6-.4.7-1 .7H7c-.6 0-1-.4-1-1"
    }, null, -1)];
    function z7(e, t) {
        return mo(),
        vo("svg", F7, [...j7])
    }
    const q7 = {
        render: z7
    }
      , H7 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: q7,
        render: z7
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Z7 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 12 12"
    }
      , W7 = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "m10.7 1.3-9.4 9.4m0-9.4 9.4 9.4"
    }, null, -1)];
    function X7(e, t) {
        return mo(),
        vo("svg", Z7, [...W7])
    }
    const V7 = {
        render: X7
    }
      , G7 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: V7,
        render: X7
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Y7 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 12 12"
    }
      , K7 = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M10.5 4.6V3.3c0-.2-.1-.4-.2-.5-.2-.2-.3-.2-.5-.2H4.3v-.7c0-.2-.1-.4-.2-.5s-.3-.2-.5-.2H1.5c-.2 0-.3.1-.5.2-.1.1-.2.3-.2.5V10c0 .2.1.4.2.5s.3.2.5.3c.2 0 .4 0 .5-.1.2-.1.3-.3.3-.4l1.1-5.1c0-.1.1-.3.2-.4.2-.1.4-.2.5-.2zm0 0c.1 0 .2 0 .3.1.1 0 .2.1.2.2.1.1.1.2.1.3v.3l-1 4.8c0 .1-.1.3-.2.4s-.3.1-.4.1H1.6"
    }, null, -1), Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "m6 6.7-1 1 1 1m2.1-2 1 1-1 1"
    }, null, -1)];
    function J7(e, t) {
        return mo(),
        vo("svg", Y7, [...K7])
    }
    const e6 = {
        render: J7
    }
      , t6 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: e6,
        render: J7
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , n6 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 12 12"
    }
      , r6 = [Eo("path", {
        fill: "none",
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M7.9 4.1c-1 .2-2-.5-2.2-1.5-.1-.5 0-1.1.3-1.5-2.7 0-4.9 2.2-4.9 4.9s2.2 4.9 4.9 4.9 4.9-2.2 4.9-4.9v-.4c-.8.6-2 .4-2.6-.4-.3-.3-.4-.7-.4-1.1"
    }, null, -1), Eo("circle", {
        cx: "4.4",
        cy: "7",
        r: ".6"
    }, null, -1), Eo("circle", {
        cx: "6.5",
        cy: "7.6",
        r: ".6"
    }, null, -1), Eo("circle", {
        cx: "5",
        cy: "4.4",
        r: ".6"
    }, null, -1)];
    function o6(e, t) {
        return mo(),
        vo("svg", n6, [...r6])
    }
    const i6 = {
        render: o6
    }
      , a6 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: i6,
        render: o6
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , s6 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 10 10"
    }
      , l6 = [Eo("path", {
        d: "M9.557 7.243a.46.46 0 0 0-.457-.252C9.023 7 8.951 7 8.877 7A4 4 0 0 1 5.546.781a.5.5 0 0 0 .018-.525A.48.48 0 0 0 5.1 0a5 5 0 1 0 4.439 7.767.5.5 0 0 0 .018-.524"
    }, null, -1)];
    function c6(e, t) {
        return mo(),
        vo("svg", s6, [...l6])
    }
    const u6 = {
        render: c6
    }
      , d6 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: u6,
        render: c6
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , p6 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 14 14"
    }
      , h6 = [Eo("path", {
        fill: "currentColor",
        "fill-rule": "evenodd",
        d: "M5.763 2.013a1.75 1.75 0 0 1 2.914.737H5.323a1.75 1.75 0 0 1 .44-.737m-1.974.737a3.25 3.25 0 0 1 6.422 0H13a.75.75 0 0 1 0 1.5h-1v8.25a1.5 1.5 0 0 1-1.5 1.5h-7A1.5 1.5 0 0 1 2 12.5V4.25H1a.75.75 0 1 1 0-1.5zM5 5.876c.345 0 .625.28.625.625v4.002a.625.625 0 0 1-1.25 0V6.501c0-.345.28-.625.625-.625m4.625.625a.625.625 0 0 0-1.25 0v4.002a.625.625 0 0 0 1.25 0z",
        "clip-rule": "evenodd"
    }, null, -1)];
    function f6(e, t) {
        return mo(),
        vo("svg", p6, [...h6])
    }
    const m6 = {
        render: f6
    }
      , g6 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: m6,
        render: f6
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , b6 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , O6 = [Eo("path", {
        d: "M20.317 4.37a19.8 19.8 0 0 0-4.885-1.515.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.3 18.3 0 0 0-5.487 0 13 13 0 0 0-.617-1.25.08.08 0 0 0-.079-.037A19.7 19.7 0 0 0 3.677 4.37a.1.1 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.08.08 0 0 0 .031.057 19.9 19.9 0 0 0 5.993 3.03.08.08 0 0 0 .084-.028 14 14 0 0 0 1.226-1.994.076.076 0 0 0-.041-.106 13 13 0 0 1-1.872-.892.077.077 0 0 1-.008-.128 10 10 0 0 0 .372-.292.07.07 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.07.07 0 0 1 .078.01q.181.149.373.292a.077.077 0 0 1-.006.127 12.3 12.3 0 0 1-1.873.892.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.08.08 0 0 0 .084.028 19.8 19.8 0 0 0 6.002-3.03.08.08 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.06.06 0 0 0-.031-.03M8.02 15.33c-1.182 0-2.157-1.085-2.157-2.419 0-1.333.956-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.956 2.418-2.157 2.418m7.975 0c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.955-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.946 2.418-2.157 2.418"
    }, null, -1)];
    function v6(e, t) {
        return mo(),
        vo("svg", b6, [...O6])
    }
    const y6 = {
        render: v6
    }
      , w6 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: y6,
        render: v6
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , _6 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 12 12"
    }
      , k6 = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M1.8 10.2c0 .2.1.5.3.6q.3.3.6.3h6.6c.2 0 .5-.1.6-.3q.3-.3.3-.6V1.8c0-.2-.1-.5-.3-.6-.1-.3-.3-.4-.6-.4H4.7l-3 3v6.4z"
    }, null, -1), Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M1.8 3.8h2.1c.2 0 .5-.1.6-.3q.3-.3.3-.6V.8zm4.7 0h2m-5 2.5h5m-5 2.4h5"
    }, null, -1)];
    function S6(e, t) {
        return mo(),
        vo("svg", _6, [...k6])
    }
    const E6 = {
        render: S6
    }
      , x6 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: E6,
        render: S6
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , T6 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 10 10"
    }
      , A6 = [Eo("path", {
        d: "M.519 4.193 4.47 6.008a1.3 1.3 0 0 0 .53.117 1.3 1.3 0 0 0 .537-.119l3.947-1.837a.887.887 0 0 0 0-1.612L5.526.741a1.27 1.27 0 0 0-1.069 0L.516 2.58a.889.889 0 0 0 0 1.613Z"
    }, null, -1), Eo("path", {
        d: "M8.774 6.144 5.106 7.851a.24.24 0 0 1-.209 0L1.212 6.159a.75.75 0 1 0-.626 1.363L4.27 9.215a1.75 1.75 0 0 0 1.469 0L9.407 7.5a.75.75 0 1 0-.633-1.36Z"
    }, null, -1)];
    function C6(e, t) {
        return mo(),
        vo("svg", T6, [...A6])
    }
    const P6 = {
        render: C6
    }
      , D6 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: P6,
        render: C6
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , R6 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 14 14"
    }
      , N6 = [Eo("path", {
        fill: "currentColor",
        d: "M10.715-.001a1.5 1.5 0 0 0-1.07.449L1.407 8.645a.5.5 0 0 0-.128.22l-1.26 4.5a.5.5 0 0 0 .616.616l4.5-1.26a.5.5 0 0 0 .22-.128l8.197-8.238.002-.001a1.5 1.5 0 0 0 0-2.128l-.002-.001L11.786.449a1.5 1.5 0 0 0-1.071-.45"
    }, null, -1)];
    function $6(e, t) {
        return mo(),
        vo("svg", R6, [...N6])
    }
    const I6 = {
        render: $6
    }
      , M6 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: I6,
        render: $6
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , L6 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , Q6 = [Eo("path", {
        d: "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2"
    }, null, -1)];
    function B6(e, t) {
        return mo(),
        vo("svg", L6, [...Q6])
    }
    const U6 = {
        render: B6
    }
      , F6 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: U6,
        render: B6
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , j6 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , z6 = [Eo("path", {
        d: "M12 0a12.24 12.24 0 0 0-8.53 3.65A11.85 11.85 0 0 0 0 12.21 11.78 11.78 0 0 0 11.8 24h.2a12.11 12.11 0 0 0 12-12.21A11.77 11.77 0 0 0 12 0m-1.5 16.54A1.48 1.48 0 0 1 12 15a1.53 1.53 0 0 1 1.52 1.47A1.47 1.47 0 0 1 12.05 18a1.53 1.53 0 0 1-1.55-1.46m.5-4v-6a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0"
    }, null, -1)];
    function q6(e, t) {
        return mo(),
        vo("svg", j6, [...z6])
    }
    const H6 = {
        render: q6
    }
      , Z6 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: H6,
        render: q6
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , W6 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 12 12"
    }
      , X6 = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M4 2h6v6m0-6-8 8"
    }, null, -1)];
    function V6(e, t) {
        return mo(),
        vo("svg", W6, [...X6])
    }
    const G6 = {
        render: V6
    }
      , Y6 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: G6,
        render: V6
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , K6 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 15 15"
    }
      , J6 = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M2 4h11M3.2 6.3h8.7m-6 4.7h3.2M4.3 8.7h6.3"
    }, null, -1)];
    function e9(e, t) {
        return mo(),
        vo("svg", K6, [...J6])
    }
    const t9 = {
        render: e9
    }
      , n9 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: t9,
        render: e9
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , r9 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , o9 = [Eo("path", {
        d: "M22.5 4.5H11.74a.5.5 0 0 1-.45-.28l-.95-1.89A1.5 1.5 0 0 0 9 1.5H1.5A1.5 1.5 0 0 0 0 3v18a1.5 1.5 0 0 0 1.5 1.5h21A1.5 1.5 0 0 0 24 21V6a1.5 1.5 0 0 0-1.5-1.5"
    }, null, -1)];
    function i9(e, t) {
        return mo(),
        vo("svg", r9, [...o9])
    }
    const a9 = {
        render: i9
    }
      , s9 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: a9,
        render: i9
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , l9 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 1024 1024"
    }
      , c9 = [Eo("path", {
        d: "M512 0a512 512 0 0 0-162 998c26 4 35-11 35-25l-1-95c-128 23-161-32-172-60-6-15-31-61-52-73-18-10-44-33-1-33 40-1 69 37 78 52 46 78 120 56 149 43 5-33 18-56 33-69-114-13-234-56-234-253 0-56 20-101 53-137-5-13-23-65 5-136 0 0 43-13 141 53a487 487 0 0 1 256 0c98-66 141-53 141-53 28 71 10 123 5 136 33 36 53 81 53 137 0 197-120 240-234 253 18 16 35 47 35 95l-1 140c0 14 9 30 35 25A512 512 0 0 0 512 0"
    }, null, -1)];
    function u9(e, t) {
        return mo(),
        vo("svg", l9, [...c9])
    }
    const d9 = {
        render: u9
    }
      , p9 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: d9,
        render: u9
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , h9 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 12 12"
    }
      , f9 = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "m1.5 10 9.2-8.8M4.5 9.1c.5.1 1 .2 1.5.2 2 0 4-1.4 5.3-2.8.3-.3.3-.8 0-1.1-.5-.5-1-1-1.5-1.3m-1.3-.8c-.8-.4-1.6-.6-2.5-.6C4 2.7 2 4 .7 5.5c-.3.3-.3.8 0 1.1.7.8 1.5 1.4 2.4 2"
    }, null, -1), Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M4.5 7.1c-.6-.8-.4-2 .5-2.6.6-.5 1.6-.5 2.2.1M7.8 6C7.8 7 7 7.8 6 7.8"
    }, null, -1)];
    function m9(e, t) {
        return mo(),
        vo("svg", h9, [...f9])
    }
    const g9 = {
        render: m9
    }
      , b9 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: g9,
        render: m9
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , O9 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 14 14"
    }
      , v9 = [Eo("path", {
        fill: "currentColor",
        "fill-rule": "evenodd",
        d: "M7 2.75a.75.75 0 0 1 .75.75v4a.75.75 0 0 1-.364.643l-2.5 1.5a.75.75 0 1 1-.772-1.286L6.25 7.075V3.5A.75.75 0 0 1 7 2.75",
        "clip-rule": "evenodd"
    }, null, -1), Eo("path", {
        fill: "currentColor",
        "fill-rule": "evenodd",
        d: "M12.5 7a5.5 5.5 0 0 0-9.82-3.405l.966.965a.5.5 0 0 1-.353.854H.5a.5.5 0 0 1-.5-.5V2.12a.5.5 0 0 1 .854-.354l.76.761A7 7 0 1 1 .187 8.614a.75.75 0 0 1 1.46-.344A5.5 5.5 0 0 0 12.5 7",
        "clip-rule": "evenodd"
    }, null, -1)];
    function y9(e, t) {
        return mo(),
        vo("svg", O9, [...v9])
    }
    const w9 = {
        render: y9
    }
      , _9 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: w9,
        render: y9
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , k9 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
    }
      , S9 = [Po('<g clip-path="url(#a)"><g stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" clip-path="url(#b)"><path d="M11.94 17.32V11.2a.88.88 0 0 0-.87-.87h-.88m1.31-2.6a.44.44 0 1 1 0-.88m0 .88a.44.44 0 1 0 0-.88"></path><path d="M12 23.23A11.23 11.23 0 1 0 12 .77a11.23 11.23 0 0 0 0 22.46"></path><path stroke-miterlimit="10" d="M10.2 17.32h3.61"></path></g></g><defs><clipPath id="a"><path fill="currentColor" d="M0 0h24v24H0z"></path></clipPath><clipPath id="b"><path fill="currentColor" d="M0 0h24v24H0z"></path></clipPath></defs>', 2)];
    function E9(e, t) {
        return mo(),
        vo("svg", k9, [...S9])
    }
    const x9 = {
        render: E9
    }
      , T9 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: x9,
        render: E9
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , A9 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 12 12"
    }
      , C9 = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M3.7 1.1h-.2c-.5 0-.9.4-.9.9v3.1c0 .5-.4.9-.9.9h-.3m6.9-4.9h.2c.5 0 .9.4.9.9v3.1c0 .5.4.9.9.9h.3m-6.9 4.9h-.2c-.5 0-.9-.4-.9-.9V6.9c0-.5-.4-.9-.9-.9h-.3m6.9 4.9h.2c.5 0 .9-.4.9-.9V6.9c0-.5.4-.9.9-.9h.3"
    }, null, -1)];
    function P9(e, t) {
        return mo(),
        vo("svg", A9, [...C9])
    }
    const D9 = {
        render: P9
    }
      , R9 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: D9,
        render: P9
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , N9 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 14 14"
    }
      , $9 = [Eo("path", {
        fill: "currentColor",
        "fill-rule": "evenodd",
        d: "M10.293 1.293a1 1 0 0 1 1.414 0l2 2a1 1 0 0 1-1.414 1.414L11 3.414 9.914 4.5l1.293 1.293a1 1 0 0 1-1.414 1.414L8.5 5.914 7.446 6.968a4 4 0 1 1-1.414-1.414l1.757-1.757.004-.004.004-.004zM2 9a2 2 0 1 1 4 0 2 2 0 0 1-4 0",
        "clip-rule": "evenodd"
    }, null, -1)];
    function I9(e, t) {
        return mo(),
        vo("svg", N9, [...$9])
    }
    const M9 = {
        render: I9
    }
      , L9 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: M9,
        render: I9
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Q9 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 14 14"
    }
      , B9 = [Eo("path", {
        fill: "currentColor",
        "fill-rule": "evenodd",
        d: "M1.625.258A.75.75 0 0 0 1.44.75v9.62a1.71 1.71 0 0 0 .942 1.523l.002.001 3.845 1.923.337-.67-.335.67H6.23a1.71 1.71 0 0 0 2.48-1.524v-.214h2.136a1.71 1.71 0 0 0 1.712-1.711V1.712A1.71 1.71 0 0 0 10.847 0H2.191a.75.75 0 0 0-.566.258M8.712 10.58h2.135a.21.21 0 0 0 .212-.211V1.712a.21.21 0 0 0-.212-.212H5.373l2.395 1.195.002.001a1.71 1.71 0 0 1 .942 1.538v.003l-.75-.005h.75z",
        "clip-rule": "evenodd"
    }, null, -1)];
    function U9(e, t) {
        return mo(),
        vo("svg", Q9, [...B9])
    }
    const F9 = {
        render: U9
    }
      , j9 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: F9,
        render: U9
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , z9 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , q9 = [Eo("path", {
        d: "M24 12a1 1 0 0 0-1-1h-3.91a.51.51 0 0 1-.49-.4 6.8 6.8 0 0 0-.94-2.28.5.5 0 0 1 .06-.63l2.77-2.76a1 1 0 1 0-1.42-1.42l-2.76 2.77a.5.5 0 0 1-.63.06 6.8 6.8 0 0 0-2.28-.94.5.5 0 0 1-.4-.49V1a1 1 0 0 0-2 0v3.91a.51.51 0 0 1-.4.49 6.8 6.8 0 0 0-2.28.94.5.5 0 0 1-.63-.06L4.93 3.51a1 1 0 0 0-1.42 1.42l2.77 2.76a.5.5 0 0 1 .06.63 6.8 6.8 0 0 0-.94 2.28.5.5 0 0 1-.49.4H1a1 1 0 0 0 0 2h3.91a.51.51 0 0 1 .49.4 6.8 6.8 0 0 0 .94 2.28.5.5 0 0 1-.06.63l-2.77 2.76a1 1 0 1 0 1.42 1.42l2.76-2.77a.5.5 0 0 1 .63-.06 6.8 6.8 0 0 0 2.28.94.5.5 0 0 1 .4.49V23a1 1 0 0 0 2 0v-3.91a.51.51 0 0 1 .4-.49 6.8 6.8 0 0 0 2.28-.94.5.5 0 0 1 .63.06l2.76 2.77a1 1 0 1 0 1.42-1.42l-2.77-2.76a.5.5 0 0 1-.06-.63 6.8 6.8 0 0 0 .94-2.28.5.5 0 0 1 .49-.4H23a1 1 0 0 0 1-1m-8.74 2.5A5.76 5.76 0 0 1 9.5 8.74a5.7 5.7 0 0 1 .16-1.31.49.49 0 0 1 .34-.36 5.4 5.4 0 0 1 1.8-.31 5.47 5.47 0 0 1 5.46 5.46 5.4 5.4 0 0 1-.31 1.8.49.49 0 0 1-.35.32 5.5 5.5 0 0 1-1.34.16"
    }, null, -1)];
    function H9(e, t) {
        return mo(),
        vo("svg", z9, [...q9])
    }
    const Z9 = {
        render: H9
    }
      , W9 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Z9,
        render: H9
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , X9 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 10 10"
    }
      , V9 = [Eo("path", {
        d: "M3.5 5a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0M5 2.25a.625.625 0 0 1-.625-.625v-1a.625.625 0 0 1 1.25 0v1A.625.625 0 0 1 5 2.25m1.945.805a.623.623 0 0 1 0-.883l.707-.708a.625.625 0 0 1 .884.884l-.708.707a.623.623 0 0 1-.883 0M7.75 5a.625.625 0 0 1 .625-.625h1a.625.625 0 0 1 0 1.25h-1A.625.625 0 0 1 7.75 5m-.805 1.945a.623.623 0 0 1 .883 0l.708.707a.625.625 0 0 1-.884.884l-.707-.708a.623.623 0 0 1 0-.883M5 7.75a.625.625 0 0 1 .625.625v1a.625.625 0 0 1-1.25 0v-1A.625.625 0 0 1 5 7.75m-1.945-.805a.623.623 0 0 1 0 .883l-.707.708a.625.625 0 0 1-.884-.884l.708-.707a.623.623 0 0 1 .883 0M2.25 5a.625.625 0 0 1-.625.625h-1a.625.625 0 0 1 0-1.25h1A.625.625 0 0 1 2.25 5m.805-1.945a.623.623 0 0 1-.883 0l-.708-.707a.625.625 0 0 1 .884-.884l.707.708a.623.623 0 0 1 0 .883"
    }, null, -1)];
    function G9(e, t) {
        return mo(),
        vo("svg", X9, [...V9])
    }
    const Y9 = {
        render: G9
    }
      , K9 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Y9,
        render: G9
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , J9 = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 14 14"
    }
      , eee = [Eo("path", {
        fill: "currentColor",
        "fill-rule": "evenodd",
        d: "M8.635.154a2 2 0 0 1 2.19.438l2.588 2.618a2 2 0 0 1-.003 2.834l-2.299 2.299a1 1 0 1 1-1.414-1.414l2.3-2.3.003-.003-.007-.007L9.404 2l-.003.003-2.33 2.33a1 1 0 0 1-1.414-1.414L7.986.589a2 2 0 0 1 .65-.435ZM4.333 5.627a1 1 0 0 1 0 1.414l-2.33 2.33L2 9.374l.003.003 2.62 2.62.003.003.003-.003 2.33-2.33a1 1 0 0 1 1.414 1.414l-2.329 2.33a2 2 0 0 1-2.837-.001L.59 10.793a2 2 0 0 1 0-2.837l2.329-2.329a1 1 0 0 1 1.414 0m4.874.58a1 1 0 0 0-1.414-1.414l-3 3a1 1 0 0 0 1.414 1.414z",
        "clip-rule": "evenodd"
    }, null, -1)];
    function tee(e, t) {
        return mo(),
        vo("svg", J9, [...eee])
    }
    const nee = {
        render: tee
    }
      , ree = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: nee,
        render: tee
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , oee = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 14 14"
    }
      , iee = [Eo("path", {
        fill: "currentColor",
        "fill-rule": "evenodd",
        d: "M7 2a2 2 0 0 0-2 2v1h4V4a2 2 0 0 0-2-2M3 4v1a1.5 1.5 0 0 0-1.5 1.5v6A1.5 1.5 0 0 0 3 14h8a1.5 1.5 0 0 0 1.5-1.5v-6A1.5 1.5 0 0 0 11 5V4a4 4 0 1 0-8 0m4 6.75a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5",
        "clip-rule": "evenodd"
    }, null, -1)];
    function aee(e, t) {
        return mo(),
        vo("svg", oee, [...iee])
    }
    const see = {
        render: aee
    }
      , lee = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: see,
        render: aee
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , cee = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 593 593"
    }
      , uee = [Eo("path", {
        "fill-rule": "evenodd",
        d: "M347 0c6 0 12 5 12 12v134l94-95c5-5 13-5 17 0l72 72c4 4 5 12 0 16v1l-95 94h134c7 0 12 5 12 12v101c0 7-5 12-12 12H447l95 94c4 5 5 13 0 17l-72 72c-4 4-12 5-16 0h-1l-94-95v134c0 7-5 12-12 12H246c-7 0-12-5-12-12v-70c0-22 9-43 24-59l130-130c14-14 14-37 0-51L259 142a84 84 0 0 1-25-59V12c0-7 5-12 12-12zM138 52h1l219 219c14 14 14 37 0 51L139 542c-4 5-12 5-17 0l-71-70c-4-5-5-12 0-17l95-96H12c-7 0-12-5-12-12V246c0-7 5-12 12-12h134l-95-94c-4-5-4-12 0-17l71-71c4-5 12-5 16 0"
    }, null, -1)];
    function dee(e, t) {
        return mo(),
        vo("svg", cee, [...uee])
    }
    const pee = {
        render: dee
    }
      , hee = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: pee,
        render: dee
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , fee = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 662 662"
    }
      , mee = [Eo("path", {
        "fill-rule": "evenodd",
        d: "M331 0a331 331 0 1 1 0 662 331 331 0 0 1 0-662m148.5 109 .6.9a187 187 0 1 1-297.6-.9 267 267 0 1 0 297 0"
    }, null, -1)];
    function gee(e, t) {
        return mo(),
        vo("svg", fee, [...mee])
    }
    const bee = {
        render: gee
    }
      , Oee = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: bee,
        render: gee
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , vee = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 620 620"
    }
      , yee = [Eo("path", {
        d: "M-.653 309.29c-.078 82.272 31.848 159.735 89.739 218.178l.283.283c122.379 121.247 319.824 121.184 440.16-.283 119.967-121.1 119.409-316.933-.998-437.339l-.99-.99C468.681 30.845 390.716-1.017 307.893-.67c-82.83.354-160.443 32.994-218.814 91.79C31.209 149.555-.724 227.025-.653 309.29m469.271-160.789.778.778c87.9 87.9 88.325 231.005.707 319.33-77.753 78.46-199.786 87.412-288.959 26.862l198.513-198.513-.007 166.361 83.68-.07v-306.22H157.11l-.008 83.6h160.584L121.994 436.323c-59.347-87.689-50.536-208.59 26.51-286.343 87.836-88.686 231.436-89.31 320.106-1.486Z"
    }, null, -1)];
    function wee(e, t) {
        return mo(),
        vo("svg", vee, [...yee])
    }
    const _ee = {
        render: wee
    }
      , kee = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: _ee,
        render: wee
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , See = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 642 642"
    }
      , Eee = [Eo("path", {
        d: "M321 0a321 321 0 1 1 0 642 321 321 0 0 1 0-642m51.3 63L321 189.5 269.7 63l1 136.5-95.8-97.2L228 228l-125.7-53.1 97.2 95.8-136.5-1L189.5 321 63 372.3l136.5-1-97.2 95.8 125.7-53-53.1 125.6 95.8-97.2-1 136.5L321 452.5 372.3 579l-1-136.5 95.8 97.2-53-125.7 125.6 53.1-97.2-95.8 136.5 1L452.5 321 579 269.7l-136.5 1 97.2-95.8L414 228l53.1-125.7-95.8 97.2z"
    }, null, -1)];
    function xee(e, t) {
        return mo(),
        vo("svg", See, [...Eee])
    }
    const Tee = {
        render: xee
    }
      , Aee = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Tee,
        render: xee
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Cee = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 620 620"
    }
      , Pee = [Eo("path", {
        d: "M529.2 90.8A310 310 0 1 0 90.8 529.2 310 310 0 0 0 529.2 90.8M122.4 498.2c-54.9-55-15.4-183.5 88.2-287 103.6-103.7 232.1-143.2 287-88.3 54.9 54.8 15.4 183.4-88.3 287-103.5 103.6-232 143.1-286.9 88.3m261.8-262.7A104.7 104.7 0 1 1 236 383.7a104.7 104.7 0 0 1 148.2-148.2"
    }, null, -1)];
    function Dee(e, t) {
        return mo(),
        vo("svg", Cee, [...Pee])
    }
    const Ree = {
        render: Dee
    }
      , Nee = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Ree,
        render: Dee
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , $ee = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 14 14"
    }
      , Iee = [Eo("path", {
        fill: "currentColor",
        "fill-rule": "evenodd",
        d: "M8.75 0a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0V.75A.75.75 0 0 1 8.75 0m4.03 2.28a.75.75 0 0 0-1.06-1.06l-1 1a.75.75 0 0 0 1.06 1.06zM9.707 5.707a1 1 0 0 0-1.414-1.414l-8 8a1 1 0 1 0 1.414 1.414zM11.75 4.5a.75.75 0 0 0 0 1.5h1.5a.75.75 0 0 0 0-1.5zm-1.53 2.22a.75.75 0 0 1 1.06 0l1 1a.75.75 0 0 1-1.06 1.06l-1-1a.75.75 0 0 1 0-1.06m-3.94-5a.75.75 0 0 0-1.06 1.06l1 1a.75.75 0 0 0 1.06-1.06z",
        "clip-rule": "evenodd"
    }, null, -1)];
    function Mee(e, t) {
        return mo(),
        vo("svg", $ee, [...Iee])
    }
    const Lee = {
        render: Mee
    }
      , Qee = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Lee,
        render: Mee
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Bee = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 12 12"
    }
      , Uee = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M11 3.4H1m10 5.2H1"
    }, null, -1)];
    function Fee(e, t) {
        return mo(),
        vo("svg", Bee, [...Uee])
    }
    const jee = {
        render: Fee
    }
      , zee = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: jee,
        render: Fee
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , qee = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , Hee = [Eo("path", {
        d: "M11.28 6.13a.24.24 0 0 0-.12-.24C9.9 5.1 7 3.86 1.51 3.79a.47.47 0 0 0-.36.14.48.48 0 0 0-.15.36v15.76a.49.49 0 0 0 .49.5c5.15.07 8 1.15 9.39 1.93a.23.23 0 0 0 .25 0 .26.26 0 0 0 .12-.21s-.01-15.84.03-16.14m7.97 11.32a.76.76 0 0 1-.62.74 8.34 8.34 0 0 0-4.3 2.25 8.3 8.3 0 0 0-1 1.43.26.26 0 0 0 0 .3.26.26 0 0 0 .29 0 21.05 21.05 0 0 1 8.88-1.67.49.49 0 0 0 .49-.5V4.29a.48.48 0 0 0-.15-.36.47.47 0 0 0-.36-.14c-1.11 0-2.11.08-3 .17a.26.26 0 0 0-.22.25Z"
    }, null, -1), Eo("path", {
        d: "M17.57 16.9a.25.25 0 0 0 .18-.24V1.73a.24.24 0 0 0-.11-.2.23.23 0 0 0-.23 0 7.74 7.74 0 0 0-3.08 1.94 5.5 5.5 0 0 0-1.58 3v12.84a.24.24 0 0 0 .16.23.26.26 0 0 0 .28-.06 9.3 9.3 0 0 1 4.38-2.58"
    }, null, -1)];
    function Zee(e, t) {
        return mo(),
        vo("svg", qee, [...Hee])
    }
    const Wee = {
        render: Zee
    }
      , Xee = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Wee,
        render: Zee
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Vee = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 14 14"
    }
      , Gee = [Eo("path", {
        fill: "currentColor",
        "fill-rule": "evenodd",
        d: "M11.821.098a1.62 1.62 0 0 1 2.077 2.076l-3.574 10.712a1.62 1.62 0 0 1-1.168 1.069 1.6 1.6 0 0 1-1.52-.434l-1.918-1.909-2.014 1.042a.5.5 0 0 1-.73-.457l.083-3.184 7.045-5.117a.625.625 0 1 0-.735-1.012L2.203 8.088l-1.73-1.73a1.6 1.6 0 0 1-.437-1.447 1.62 1.62 0 0 1 1.069-1.238h.003z",
        "clip-rule": "evenodd"
    }, null, -1)];
    function Yee(e, t) {
        return mo(),
        vo("svg", Vee, [...Gee])
    }
    const Kee = {
        render: Yee
    }
      , Jee = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Kee,
        render: Yee
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , ete = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 14 14"
    }
      , tte = [Eo("path", {
        fill: "currentColor",
        "fill-rule": "evenodd",
        d: "M8 1a1 1 0 0 0-2 0v1.4h-.5A2.7 2.7 0 0 0 2.8 5c0 .5.1 1.1.5 1.6a2.7 2.7 0 0 0 1.7 1L6 8v1.7H4.3a1 1 0 1 0 0 2H6V13a1 1 0 1 0 2 0v-1.3h.5c1.6 0 2.6-1.2 2.7-2.5a2.6 2.6 0 0 0-2.2-3H8V4.3h1.7a1 1 0 0 0 0-2H8zM6 4.5h-.5c-.4 0-.7.3-.7.7s.2.6.5.7H6zM8 8v1.5h.5c.2 0 .4 0 .5-.2l.2-.5-.1-.4-.4-.3H8Z",
        "clip-rule": "evenodd"
    }, null, -1)];
    function nte(e, t) {
        return mo(),
        vo("svg", ete, [...tte])
    }
    const rte = {
        render: nte
    }
      , ote = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: rte,
        render: nte
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , ite = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 10 10"
    }
      , ate = [Eo("path", {
        d: "M8.3 3.6 3.7.3Q3.25 0 2.8 0c-.3 0-.6 0-.9.2s-.5.4-.7.7c-.1.2-.2.5-.2.9v6.5c0 .3.1.6.2.9.2.3.4.5.7.6s.6.2.9.2q.45 0 .9-.3l4.6-3.2c.2-.2.4-.4.5-.6.1-.3.2-.6.2-.9s-.1-.6-.2-.8c-.1-.3-.3-.5-.5-.6"
    }, null, -1)];
    function ste(e, t) {
        return mo(),
        vo("svg", ite, [...ate])
    }
    const lte = {
        render: ste
    }
      , cte = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: lte,
        render: ste
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , ute = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 12 12"
    }
      , dte = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M11 4.3c-.5-.7-1.7-2.2-2.4-2.6C7.9 1.2 7 1 5.9 1s-2.6.5-3.5 1.5C1.5 3.4.9 4.7.9 6s.5 2.6 1.5 3.5c.9.9 2.2 1.5 3.6 1.5s2.6-.6 3.6-1.5c.5-.5.8-.9 1-1.6"
    }, null, -1), Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M11 1v3.3H7.6"
    }, null, -1)];
    function pte(e, t) {
        return mo(),
        vo("svg", ute, [...dte])
    }
    const hte = {
        render: pte
    }
      , fte = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: hte,
        render: pte
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , mte = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 11 11"
    }
      , gte = [Eo("path", {
        "fill-rule": "evenodd",
        d: "M10.1 2.1c.3-.3.3-.8 0-1.1S9.3.7 9 1L2.4 7.6V3.3c0-.4-.3-.8-.7-.8s-.7.3-.7.8v6.2c0 .4.3.8.7.8h6.2c.4 0 .8-.3.8-.8s-.4-.8-.9-.8H3.5z",
        "clip-rule": "evenodd"
    }, null, -1)];
    function bte(e, t) {
        return mo(),
        vo("svg", mte, [...gte])
    }
    const Ote = {
        render: bte
    }
      , vte = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Ote,
        render: bte
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , yte = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 16 16"
    }
      , wte = [Eo("path", {
        "fill-rule": "evenodd",
        d: "M12.6 11.2h.1l3 3a1 1 0 1 1-1.4 1.5l-3-3a1 1 0 0 1-.1-.1 7 7 0 1 1 1.4-1.4M7 12A5 5 0 1 0 7 2a5 5 0 0 0 0 10"
    }, null, -1)];
    function _te(e, t) {
        return mo(),
        vo("svg", yte, [...wte])
    }
    const kte = {
        render: _te
    }
      , Ste = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: kte,
        render: _te
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Ete = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 12 12"
    }
      , xte = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M6 2.7C4 2.7 2 4 .7 5.5c-.3.3-.3.8 0 1.1C2 7.9 4 9.3 6 9.3s4-1.4 5.3-2.8c.3-.3.3-.8 0-1.1C10 4 8 2.7 6 2.7"
    }, null, -1), Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M7.8 6C7.8 7 7 7.8 6 7.8S4.2 7 4.2 6 5 4.2 6 4.2 7.8 5 7.8 6"
    }, null, -1)];
    function Tte(e, t) {
        return mo(),
        vo("svg", Ete, [...xte])
    }
    const Ate = {
        render: Tte
    }
      , Cte = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Ate,
        render: Tte
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Pte = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 14 14"
    }
      , Dte = [Eo("path", {
        d: "M11.7 14H2.3C1 14 0 13 0 11.7V2.3C0 1 1 0 2.3 0h9.3C13 0 14 1 14 2.3v9.3c0 1.4-1 2.4-2.3 2.4M2.3 1.2c-.6 0-1.2.5-1.2 1.2v9.3c0 .6.5 1.2 1.2 1.2h9.3c.6 0 1.2-.5 1.2-1.2V2.3c0-.6-.5-1.2-1.2-1.2H2.3z"
    }, null, -1), Eo("path", {
        d: "M4.7 14c-.3 0-.6-.2-.6-.6V.6q0-.6.6-.6c.6 0 .6.2.6.6v12.8q-.15.6-.6.6m6.1-7.4L9.1 4.8c-.2-.2-.6-.2-.8 0-.3.3-.3.6-.1.8L9.6 7 8.3 8.3c-.3.3-.3.6-.1.8.1.1.2.2.4.2s.3 0 .4-.2l1.8-1.8c.2-.1.3-.5 0-.7"
    }, null, -1)];
    function Rte(e, t) {
        return mo(),
        vo("svg", Pte, [...Dte])
    }
    const Nte = {
        render: Rte
    }
      , $te = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Nte,
        render: Rte
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Ite = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 14 14"
    }
      , Mte = [Eo("path", {
        "fill-rule": "evenodd",
        d: "M11.7 14c1.3 0 2.3-1 2.3-2.3V2.3C14 1 13 0 11.7 0H2.3C1 0 0 1 0 2.3v9.3C0 13 1 14 2.3 14zm-6.5-1.2h6.4c.6 0 1.2-.5 1.2-1.2V2.3c0-.6-.5-1.2-1.2-1.2H5.2z",
        "clip-rule": "evenodd"
    }, null, -1), Eo("path", {
        d: "M7.7 7.4s.1 0 0 0l1.8 1.8c.2.2.6.2.8 0s.2-.6 0-.8L9 7l1.3-1.3c.2-.2.2-.6 0-.8-.1-.1-.2-.2-.4-.2s-.3 0-.4.2L7.8 6.6c-.3.2-.3.6-.1.8"
    }, null, -1)];
    function Lte(e, t) {
        return mo(),
        vo("svg", Ite, [...Mte])
    }
    const Qte = {
        render: Lte
    }
      , Bte = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Qte,
        render: Lte
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Ute = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 15 15"
    }
      , Fte = [Eo("path", {
        d: "M0 12h10v-.7H0zm0-9v.7h15V3zm0 4.8h15v-.6H0z"
    }, null, -1)];
    function jte(e, t) {
        return mo(),
        vo("svg", Ute, [...Fte])
    }
    const zte = {
        render: jte
    }
      , qte = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: zte,
        render: jte
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Hte = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 13 13"
    }
      , Zte = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M7.042 8.125H9.75m-6.5-3.25L5.417 6.5 3.25 8.125"
    }, null, -1), Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M11.39 1.535H1.66a.764.764 0 0 0-.745.744v8.441c0 .398.348.745.745.745h9.682a.764.764 0 0 0 .745-.745V2.28c0-.447-.298-.745-.695-.745"
    }, null, -1)];
    function Wte(e, t) {
        return mo(),
        vo("svg", Hte, [...Zte])
    }
    const Xte = {
        render: Wte
    }
      , Vte = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Xte,
        render: Wte
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Gte = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
    }
      , Yte = [Eo("path", {
        fill: "currentColor",
        "fill-rule": "evenodd",
        d: "M14.333 22.94c-.848 0-1.604-.5-1.96-1.251-1.783-3.772-3.568-6.116-6.2-7.75H5V2.69h1.779l6.5-1.5h7.82a1.375 1.375 0 0 1 0 2.75h-.5a.625.625 0 1 0 0 1.25h1.5a1.375 1.375 0 0 1 0 2.75h-.5a.625.625 0 1 0 0 1.25h1a1.375 1.375 0 0 1 0 2.75h-1a.625.625 0 0 0 0 1.25h1a1.375 1.375 0 0 1 0 2.75h-7.834c.618 1.618 1.2 3.36 1.497 4.743.276 1.28-.77 2.258-1.93 2.258ZM3.5 14.5a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h1.5a1 1 0 0 1 1 1z",
        "clip-rule": "evenodd"
    }, null, -1)];
    function Kte(e, t) {
        return mo(),
        vo("svg", Gte, [...Yte])
    }
    const Jte = {
        render: Kte
    }
      , ene = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Jte,
        render: Kte
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , tne = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
    }
      , nne = [Eo("path", {
        fill: "currentColor",
        "fill-rule": "evenodd",
        d: "M14.333.375c-.848 0-1.604.5-1.96 1.251-1.783 3.772-3.568 6.116-6.2 7.749H5v11.25h1.779l6.5 1.5h7.82a1.375 1.375 0 0 0 0-2.75h-.5a.625.625 0 1 1 0-1.25h1.5a1.375 1.375 0 0 0 0-2.75h-.5a.625.625 0 1 1 0-1.25h1a1.375 1.375 0 0 0 0-2.75h-1a.625.625 0 1 1 0-1.25h1a1.375 1.375 0 0 0 0-2.75h-7.834c.618-1.617 1.2-3.359 1.497-4.742.276-1.28-.77-2.258-1.93-2.258ZM3.5 8.815a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v12.5a1 1 0 0 0 1 1h1.5a1 1 0 0 0 1-1z",
        "clip-rule": "evenodd"
    }, null, -1)];
    function rne(e, t) {
        return mo(),
        vo("svg", tne, [...nne])
    }
    const one = {
        render: rne
    }
      , ine = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: one,
        render: rne
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , ane = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 14 14"
    }
      , sne = [Eo("path", {
        fill: "currentColor",
        "fill-rule": "evenodd",
        d: "M5.763 2.013a1.75 1.75 0 0 1 2.914.737H5.323a1.75 1.75 0 0 1 .44-.737m-1.974.737a3.25 3.25 0 0 1 6.422 0H13a.75.75 0 0 1 0 1.5h-1v8.25a1.5 1.5 0 0 1-1.5 1.5h-7A1.5 1.5 0 0 1 2 12.5V4.25H1a.75.75 0 1 1 0-1.5zM5 5.876c.345 0 .625.28.625.625v4.002a.625.625 0 0 1-1.25 0V6.501c0-.345.28-.625.625-.625m4.625.625a.625.625 0 0 0-1.25 0v4.002a.625.625 0 0 0 1.25 0z",
        "clip-rule": "evenodd"
    }, null, -1)];
    function lne(e, t) {
        return mo(),
        vo("svg", ane, [...sne])
    }
    const cne = {
        render: lne
    }
      , une = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: cne,
        render: lne
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , dne = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , pne = [Eo("path", {
        d: "M19.5 9.5h-.75V6.75A6.75 6.75 0 0 0 5.53 4.81a1.25 1.25 0 0 0 2.4.72 4.25 4.25 0 0 1 8.32 1.22V9a.5.5 0 0 1-.5.5H4.5a2 2 0 0 0-2 2V22a2 2 0 0 0 2 2h15a2 2 0 0 0 2-2V11.5a2 2 0 0 0-2-2m-7.5 9a2 2 0 1 1 2-2 2 2 0 0 1-2 2"
    }, null, -1)];
    function hne(e, t) {
        return mo(),
        vo("svg", dne, [...pne])
    }
    const fne = {
        render: hne
    }
      , mne = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: fne,
        render: hne
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , gne = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , bne = [Eo("path", {
        d: "M12 0a12 12 0 1 0 12 12A12 12 0 0 0 12 0m4.91 10.41A1 1 0 0 1 16 11h-2.25a.25.25 0 0 0-.25.25v7.25a1.5 1.5 0 0 1-3 0v-7.25a.25.25 0 0 0-.25-.25H8a1 1 0 0 1-.75-1.66l4-4.5a1 1 0 0 1 1.5 0l4 4.5a1 1 0 0 1 .16 1.07"
    }, null, -1)];
    function One(e, t) {
        return mo(),
        vo("svg", gne, [...bne])
    }
    const vne = {
        render: One
    }
      , yne = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: vne,
        render: One
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , wne = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , _ne = [Eo("path", {
        d: "M6.5 6.25a5.5 5.5 0 1 0 11 0 5.5 5.5 0 1 0-11 0m5.5 7a9.51 9.51 0 0 0-9.5 9.5.5.5 0 0 0 .5.5h18a.5.5 0 0 0 .5-.5 9.51 9.51 0 0 0-9.5-9.5"
    }, null, -1)];
    function kne(e, t) {
        return mo(),
        vo("svg", wne, [..._ne])
    }
    const Sne = {
        render: kne
    }
      , Ene = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Sne,
        render: kne
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , xne = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , Tne = [Eo("path", {
        d: "M9.931 12.645h4.138l-2.07-4.908m0-7.737L.68 3.982l1.726 14.771L12 24l9.596-5.242L23.32 3.984zm7.064 18.31h-2.638l-1.422-3.503H8.996l-1.422 3.504h-2.64L12 2.65z"
    }, null, -1)];
    function Ane(e, t) {
        return mo(),
        vo("svg", xne, [...Tne])
    }
    const Cne = {
        render: Ane
    }
      , Pne = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Cne,
        render: Ane
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Dne = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , Rne = [Eo("path", {
        d: "M16.074 16.86c-.72.616-2.157 1.035-3.812 1.035-2.032 0-3.735-.632-4.187-1.483-.161.488-.198 1.046-.198 1.402 0 0-.106 1.75 1.111 2.968 0-.632.513-1.145 1.145-1.145 1.083 0 1.082.945 1.081 1.712v.069c0 1.164.711 2.161 1.723 2.582a2.35 2.35 0 0 1-.236-1.029c0-1.11.652-1.523 1.41-2.003.602-.383 1.272-.807 1.733-1.66a3.1 3.1 0 0 0 .378-1.494 3.1 3.1 0 0 0-.148-.954M15.551.6c.196.244.296.572.496 1.229l4.368 14.347a18.2 18.2 0 0 0-5.222-1.768L12.35 4.8a.37.37 0 0 0-.71.002l-2.81 9.603a18.2 18.2 0 0 0-5.245 1.771L7.974 1.827c.2-.656.3-.984.497-1.227a1.6 1.6 0 0 1 .654-.484C9.415 0 9.757 0 10.443 0h3.135c.686 0 1.03 0 1.32.117A1.6 1.6 0 0 1 15.55.6z"
    }, null, -1)];
    function Nne(e, t) {
        return mo(),
        vo("svg", Dne, [...Rne])
    }
    const $ne = {
        render: Nne
    }
      , Ine = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: $ne,
        render: Nne
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Mne = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
    }
      , Lne = [Eo("path", {
        fill: "currentColor",
        "fill-rule": "evenodd",
        d: "M6.335.83a.75.75 0 0 0-.67 0L1.667 2.827a.75.75 0 0 0-.417.672V18c0 .271.146.52.382.654l7.989 4.493a.75.75 0 0 0 .747.007l8-4.5A.75.75 0 0 0 18.75 18v-4.537l3.585-1.792A.75.75 0 0 0 22.75 11V6a.75.75 0 0 0-.417-.672l-3.998-1.999a.75.75 0 0 0-.67 0l-3.997 1.999a.7.7 0 0 0-.246.194.75.75 0 0 0-.172.478v4.561l-2.5 1.407V3.5a.75.75 0 0 0-.43-.678L6.336.829Zm7.686 11.019 2.38 1.19-6.422 3.612-2.38-1.19zm3.229-.063-2.5-1.25V7.215l2.5 1.25zm1.5 0 2.5-1.25V7.215l-2.5 1.25zm-9.5 1.025V4.714l-2.5 1.25v8.254zm-1.005 4.65.743.372c.17.091.262.153.262.183v3.202l-6.5-3.657V4.714l2.5 1.25V15.5a.75.75 0 0 0 .415.67s1.122.591 2.108 1.064zm2.505.478 6.5-3.657v3.28l-6.5 3.656v-3.28ZM6 4.66 3.677 3.5 6 2.339 8.323 3.5zM20.323 6 18 4.839 15.677 6 18 7.161z",
        "clip-rule": "evenodd"
    }, null, -1)];
    function Qne(e, t) {
        return mo(),
        vo("svg", Mne, [...Lne])
    }
    const Bne = {
        render: Qne
    }
      , Une = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Bne,
        render: Qne
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Fne = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , jne = [Eo("path", {
        d: "M11.573 0a5 5 0 0 0-.359.007L10.85.04c-3.407.307-6.6 2.146-8.622 4.972a11.9 11.9 0 0 0-2.119 5.243c-.096.659-.108.854-.108 1.747s.012 1.089.108 1.748c.652 4.506 3.86 8.292 8.209 9.695.779.25 1.6.422 2.534.525.363.04 1.935.04 2.299 0 1.611-.178 2.977-.577 4.323-1.264.207-.106.247-.134.219-.158-.02-.013-.9-1.193-1.955-2.62l-1.919-2.592-2.404-3.558a339 339 0 0 0-2.422-3.556c-.009-.002-.018 1.579-.023 3.51-.007 3.38-.01 3.515-.052 3.595a.43.43 0 0 1-.206.214c-.075.037-.14.044-.495.044H7.81l-.108-.068a.44.44 0 0 1-.157-.171l-.05-.106.006-4.703.007-4.705.072-.092a.7.7 0 0 1 .174-.143c.096-.047.134-.051.54-.051.478 0 .558.018.682.154a467 467 0 0 1 2.895 4.361l4.735 7.17 1.9 2.879.096-.063a12.3 12.3 0 0 0 2.466-2.163 11.94 11.94 0 0 0 2.824-6.134c.096-.66.108-.854.108-1.748 0-.893-.012-1.088-.108-1.747-.652-4.506-3.859-8.292-8.208-9.695a12.6 12.6 0 0 0-2.499-.523A33 33 0 0 0 11.573 0m4.068 7.217c.347 0 .408.005.486.047a.47.47 0 0 1 .237.277c.018.06.023 1.365.018 4.304l-.006 4.218-.744-1.14-.746-1.14v-3.066c0-1.982.01-3.097.023-3.15a.48.48 0 0 1 .233-.296c.096-.05.13-.054.5-.054z"
    }, null, -1)];
    function zne(e, t) {
        return mo(),
        vo("svg", Fne, [...jne])
    }
    const qne = {
        render: zne
    }
      , Hne = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: qne,
        render: zne
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Zne = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , Wne = [Eo("path", {
        d: "M14.23 12.004a2.236 2.236 0 0 1-2.235 2.236 2.236 2.236 0 0 1-2.236-2.236 2.236 2.236 0 0 1 2.235-2.236 2.236 2.236 0 0 1 2.236 2.236m2.648-10.69c-1.346 0-3.107.96-4.888 2.622-1.78-1.653-3.542-2.602-4.887-2.602-.41 0-.783.093-1.106.278-1.375.793-1.683 3.264-.973 6.365C1.98 8.917 0 10.42 0 12.004c0 1.59 1.99 3.097 5.043 4.03-.704 3.113-.39 5.588.988 6.38.32.187.69.275 1.102.275 1.345 0 3.107-.96 4.888-2.624 1.78 1.654 3.542 2.603 4.887 2.603.41 0 .783-.09 1.106-.275 1.374-.792 1.683-3.263.973-6.365C22.02 15.096 24 13.59 24 12.004c0-1.59-1.99-3.097-5.043-4.032.704-3.11.39-5.587-.988-6.38a2.17 2.17 0 0 0-1.092-.278zm-.005 1.09v.006c.225 0 .406.044.558.127.666.382.955 1.835.73 3.704-.054.46-.142.945-.25 1.44a23.5 23.5 0 0 0-3.107-.534A24 24 0 0 0 12.769 4.7c1.592-1.48 3.087-2.292 4.105-2.295zm-9.77.02c1.012 0 2.514.808 4.11 2.28-.686.72-1.37 1.537-2.02 2.442a23 23 0 0 0-3.113.538 15 15 0 0 1-.254-1.42c-.23-1.868.054-3.32.714-3.707.19-.09.4-.127.563-.132zm4.882 3.05q.684.704 1.36 1.564c-.44-.02-.89-.034-1.345-.034q-.691-.001-1.36.034c.44-.572.895-1.096 1.345-1.565zM12 8.1c.74 0 1.477.034 2.202.093q.61.874 1.183 1.86.557.961 1.018 1.946c-.308.655-.646 1.31-1.013 1.95-.38.66-.773 1.288-1.18 1.87a25.6 25.6 0 0 1-4.412.005 27 27 0 0 1-1.183-1.86q-.557-.961-1.018-1.946a25 25 0 0 1 1.013-1.954c.38-.66.773-1.286 1.18-1.868A25 25 0 0 1 12 8.098zm-3.635.254c-.24.377-.48.763-.704 1.16q-.336.585-.635 1.174c-.265-.656-.49-1.31-.676-1.947.64-.15 1.315-.283 2.015-.386zm7.26 0q1.044.153 2.006.387c-.18.632-.405 1.282-.66 1.933a26 26 0 0 0-1.345-2.32zm3.063.675q.727.226 1.375.498c1.732.74 2.852 1.708 2.852 2.476-.005.768-1.125 1.74-2.857 2.475-.42.18-.88.342-1.355.493a24 24 0 0 0-1.1-2.98c.45-1.017.81-2.01 1.085-2.964zm-13.395.004c.278.96.645 1.957 1.1 2.98a23 23 0 0 0-1.086 2.964c-.484-.15-.944-.318-1.37-.5-1.732-.737-2.852-1.706-2.852-2.474s1.12-1.742 2.852-2.476c.42-.18.88-.342 1.356-.494m11.678 4.28c.265.657.49 1.312.676 1.948-.64.157-1.316.29-2.016.39a26 26 0 0 0 1.341-2.338zm-9.945.02c.2.392.41.783.64 1.175q.345.586.705 1.143a22 22 0 0 1-2.006-.386c.18-.63.406-1.282.66-1.933zM17.92 16.32c.112.493.2.968.254 1.423.23 1.868-.054 3.32-.714 3.708-.147.09-.338.128-.563.128-1.012 0-2.514-.807-4.11-2.28.686-.72 1.37-1.536 2.02-2.44 1.107-.118 2.154-.3 3.113-.54zm-11.83.01c.96.234 2.006.415 3.107.532.66.905 1.345 1.727 2.035 2.446-1.595 1.483-3.092 2.295-4.11 2.295a1.2 1.2 0 0 1-.553-.132c-.666-.38-.955-1.834-.73-3.703.054-.46.142-.944.25-1.438zm4.56.64q.661.032 1.345.034.691.001 1.36-.034c-.44.572-.895 1.095-1.345 1.565q-.684-.706-1.36-1.565"
    }, null, -1)];
    function Xne(e, t) {
        return mo(),
        vo("svg", Zne, [...Wne])
    }
    const Vne = {
        render: Xne
    }
      , Gne = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Vne,
        render: Xne
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Yne = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , Kne = [Eo("path", {
        d: "M23.94 3a.5.5 0 0 0-.44-.25h-2.31l-8.55 13.91a.75.75 0 0 1-1.28 0L2.81 2.77H.5A.5.5 0 0 0 .06 3a.54.54 0 0 0 0 .51l11.5 19a.51.51 0 0 0 .86 0l11.5-19a.54.54 0 0 0 .02-.51"
    }, null, -1), Eo("path", {
        d: "m12 14.84 7.43-12.07H16a.47.47 0 0 0-.43.25L12 9.26 8.43 3A.47.47 0 0 0 8 2.77H4.57Z"
    }, null, -1)];
    function Jne(e, t) {
        return mo(),
        vo("svg", Yne, [...Kne])
    }
    const ere = {
        render: Jne
    }
      , tre = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: ere,
        render: Jne
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , nre = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 128 128"
    }
      , rre = [Eo("path", {
        d: "m117.5 33.5.3-.2c-.6-1.1-1.5-2.1-2.4-2.6L67.1 2.9c-.8-.5-1.9-.7-3.1-.7s-2.3.3-3.1.7l-48 27.9c-1.7 1-2.9 3.5-2.9 5.4v55.7c0 1.1.2 2.3.9 3.4l-.2.1c.5.8 1.2 1.5 1.9 1.9l48.2 27.9c.8.5 1.9.7 3.1.7s2.3-.3 3.1-.7l48-27.9c1.7-1 2.9-3.5 2.9-5.4V36.1c.1-.8 0-1.7-.4-2.6M64 88.5c9.1 0 17.1-5 21.3-12.4l12.9 7.6c-6.8 11.8-19.6 19.8-34.2 19.8-21.8 0-39.5-17.7-39.5-39.5S42.2 24.5 64 24.5c14.7 0 27.5 8.1 34.3 20l-13 7.5C81.1 44.5 73.1 39.5 64 39.5c-13.5 0-24.5 11-24.5 24.5s11 24.5 24.5 24.5"
    }, null, -1)];
    function ore(e, t) {
        return mo(),
        vo("svg", nre, [...rre])
    }
    const ire = {
        render: ore
    }
      , are = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: ire,
        render: ore
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , sre = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 128 128"
    }
      , lre = [Eo("path", {
        d: "M60.952.266C27.377.266.065 28.77.065 63.806s27.318 63.54 60.887 63.54c33.576 0 60.893-28.505 60.893-63.54S94.528.266 60.952.266m0 6.117c30.39 0 55.025 25.712 55.025 57.423 0 2.482-.167 4.924-.46 7.321-1.495 6.214-4.194 10.358-7.412 13.19-4.941 4.336-11.524 5.738-17.62 5.733a41 41 0 0 1-4.973-.289C97.506 77.4 99.336 57.866 89.864 43.315 80.39 28.763 62.315 23.338 46.882 30.416a24 24 0 0 0-1.68-1.114c-2.41-1.413-7.439-3.482-13.837-3.505-5.361-.022-10.615 1.568-15.133 4.58C26.554 15.317 43.21 6.386 60.952 6.394zM51.341 84.6c.894-4.07 3.343-10.431 5.548-15.655.623-1.481 1.23-2.872 1.777-4.104 3.451 12.822 5.635 20.449 9.546 25.65a18 18 0 0 0 1.913 2.114 28 28 0 0 1-9.173 1.56 28.2 28.2 0 0 1-10.023-1.86q-.098-1.227-.103-2.459a24.5 24.5 0 0 1 .515-5.24zm-7.444 3.77c-7.555-5.703-12.031-14.84-12.04-24.57.008-9.88 4.625-19.138 12.375-24.813 1.637.984 3.121 2.143 4.34 3.477 2.395 2.56 5.077 8.214 6.94 13.082.51 1.312.965 2.567 1.36 3.709C50.16 73.502 45.685 80.608 43.898 88.37zm21.802-18.226c-1.501-4.037-2.374-7.079-2.379-7.084l-.005-.012c-2.747-10.984-5.592-21.025-11.497-28.052a28 28 0 0 1 9.134-1.55c16.06.022 29.074 13.602 29.095 30.36-.007 9.673-4.432 18.764-11.914 24.474a15 15 0 0 1-2.184-.78c-1.137-.514-2.812-2.267-4.329-4.698-2.313-3.635-4.437-8.622-5.927-12.653zm-4.747 51.08c-30.39 0-55.025-25.707-55.025-57.424 0-2.086.114-4.144.32-6.173 4.508-16 15.338-21.92 25.595-22.02 2.08-.007 4.117.282 6.068.774-13.182 12.081-15.74 32.487-5.979 47.7 9.762 15.213 28.817 20.518 44.544 12.403 2.78 1.023 5.96 1.633 9.812 2.137 1.447.186 3.007.277 4.665.277a61.6 61.6 0 0 0 14.997-2.087c-10.29 15.308-27.088 24.417-45.007 24.407z"
    }, null, -1)];
    function cre(e, t) {
        return mo(),
        vo("svg", sre, [...lre])
    }
    const ure = {
        render: cre
    }
      , dre = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: ure,
        render: cre
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , pre = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 128 128"
    }
      , hre = [Eo("path", {
        d: "m117.5 33.5.3-.2c-.6-1.1-1.5-2.1-2.4-2.6L67.1 2.9c-.8-.5-1.9-.7-3.1-.7s-2.3.3-3.1.7l-48 27.9c-1.7 1-2.9 3.5-2.9 5.4v55.7c0 1.1.2 2.3.9 3.4l-.2.1c.5.8 1.2 1.5 1.9 1.9l48.2 27.9c.8.5 1.9.7 3.1.7s2.3-.3 3.1-.7l48-27.9c1.7-1 2.9-3.5 2.9-5.4V36.1c.1-.8 0-1.7-.4-2.6m-53.5 70c-21.8 0-39.5-17.7-39.5-39.5S42.2 24.5 64 24.5c14.7 0 27.5 8.1 34.3 20l-13 7.5C81.1 44.5 73.1 39.5 64 39.5c-13.5 0-24.5 11-24.5 24.5s11 24.5 24.5 24.5c9.1 0 17.1-5 21.3-12.4l12.9 7.6c-6.8 11.8-19.6 19.8-34.2 19.8M115 62h-3.2l-.9 4h4.1v5h-5l-1.2 6h-4.9l1.2-6h-3.8l-1.2 6h-4.8l1.2-6H94v-5h3.5l.9-4H94v-5h5.3l1.2-6h4.9l-1.2 6h3.8l1.2-6h4.8l-1.2 6h2.2zm-12.7 4h3.8l.9-4h-3.8z"
    }, null, -1)];
    function fre(e, t) {
        return mo(),
        vo("svg", pre, [...hre])
    }
    const mre = {
        render: fre
    }
      , gre = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: mre,
        render: fre
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , bre = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , Ore = [Eo("path", {
        d: "M1.5 0h21l-1.91 21.563L11.977 24l-8.565-2.438zm17.09 4.413L5.41 4.41l.213 2.622 10.125.002-.255 2.716h-6.64l.24 2.573h6.182l-.366 3.523-2.91.804-2.956-.81-.188-2.11h-2.61l.29 3.855L12 19.288l5.373-1.53z"
    }, null, -1)];
    function vre(e, t) {
        return mo(),
        vo("svg", bre, [...Ore])
    }
    const yre = {
        render: vre
    }
      , wre = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: yre,
        render: vre
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , _re = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 128 128"
    }
      , kre = [Eo("path", {
        d: "M108.2 64.8c-.1-.1-.2-.2-.4-.2l-.1-.1c-.1-.1-.2-.1-.2-.2l-.1-.1c-.1 0-.2-.1-.2-.1l-.2-.1c-.1 0-.2-.1-.2-.1l-.2-.1c-.1 0-.2-.1-.2-.1-.1 0-.1 0-.2-.1l-.3-.1c-.1 0-.1 0-.2-.1l-.3-.1h-.1l-.4-.1h-.2c-.1 0-.2 0-.3-.1h-2.3c-.6-13.3.6-26.8-2.8-39.6 12.9-4.6 2.8-22.3-8.4-14.4-7.4-6.4-17.6-7.8-28.3-7.8-10.5.7-20.4 2.9-27.4 8.4-2.8-1.4-5.5-1.8-7.9-1.1v.1c-.1 0-.3.1-.4.2-.1 0-.3.1-.4.2h-.1c-.1 0-.2.1-.4.2h-.1l-.3.2h-.1l-.3.2h-.1l-.3.2s-.1 0-.1.1l-.3.2s-.1 0-.1.1l-.3.2s-.1 0-.1.1l-.3.2-.1.1c-.1.1-.2.1-.2.2l-.1.1-.2.2-.1.1c-.1.1-.1.2-.2.2l-.1.1c-.1.1-.1.2-.2.2l-.1.1c-.1.1-.1.2-.2.2l-.1.1c-.1.1-.1.2-.2.2l-.1.1c-.1.1-.1.2-.2.2l-.1.1-.1.3s0 .1-.1.1l-.1.3s0 .1-.1.1l-.1.3s0 .1-.1.1l-.1.3s0 .1-.1.1c.4.3.4.4.4.4v.1l-.1.3v.1c0 .1 0 .2-.1.3v3.1c0 .1 0 .2.1.3v.1l.1.3v.1l.1.3s0 .1.1.1l.1.3s0 .1.1.1l.1.3s0 .1.1.1l.2.3s0 .1.1.1l.2.3s0 .1.1.1l.2.3.1.1.3.3.3.3h.1c1 .9 2 1.6 4 2.2v-.2C23 37.3 26.5 50 26.7 63c-.6 0-.7.4-1.7.5h-.5c-.1 0-.3 0-.5.1-.1 0-.3 0-.4.1l-.4.1h-.1l-.4.1h-.1l-.3.1h-.1l-.3.1s-.1 0-.1.1l-.3.1-.2.1c-.1 0-.2.1-.2.1l-.2.1-.2.1c-.1 0-.2.1-.2.1l-.2.1-.4.3c-.1.1-.2.2-.3.2l-.4.4-.1.1c-.1.2-.3.4-.4.5l-.2.3-.3.6-.1.3v.3c0 .5.2.9.9 1.2.2 3.7 3.9 2 5.6.8l.1-.1c.2-.2.5-.3.6-.3h.1l.2-.1c.1 0 .1 0 .2-.1.2-.1.4-.1.5-.2.1 0 .1-.1.1-.2l.1-.1c.1-.2.2-.6.2-1.2l.1-1.3v1.8c-.5 13.1-4 30.7 3.3 42.5 1.3 2.1 2.9 3.9 4.7 5.4h-.5c-.2.2-.5.4-.8.6l-.9.6-.3.2-.6.4-.9.7-1.1 1c-.2.2-.3.4-.4.5l-.4.6-.2.3c-.1.2-.2.4-.2.6l-.1.3q-.3 1.2.6 2.7l.4.4h.2c.1 0 .2 0 .4.1.2.4 1.2 2.5 3.9.9 2.8-1.5 4.7-4.6 8.1-5.1l-.5-.6c5.9 2.8 12.8 4 19 4.2 8.7.3 18.6-.9 26.5-5.2 2.2.7 3.9 3.9 5.8 5.4l.1.1.1.1.1.1.1.1s.1 0 .1.1c0 0 .1 0 .1.1 0 0 .1 0 .1.1h2.1s.1 0 .1-.1h.1s.1 0 .1-.1h.1s.1 0 .1-.1c0 0 .1 0 .1-.1l.1-.1s.1 0 .1-.1l.1-.1h.1l.2-.2.2-.1h.1l.1-.1h.1l.1-.1.1-.1.1-.1.1-.1.1-.1.1-.1.1-.1v-.1s0-.1.1-.1v-.1s0-.1.1-.1v-.1s0-.1.1-.1v-1.4s-.3 0-.3-.1l-.3-.1v-.1l.3-.1s.2 0 .2-.1l.1-.1v-2.1s0-.1-.1-.1v-.1s0-.1-.1-.1v-.1s0-.1-.1-.1c0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1l-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1v-.1l-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1c2-1.9 3.8-4.2 5.1-6.9 5.9-11.8 4.9-26.2 4.1-39.2h.1c.1 0 .2.1.2.1h.3s.1 0 .1.1h.1s.1 0 .1.1l.2.1c1.7 1.2 5.4 2.9 5.6-.8 1.6.6-.3-1.8-1.3-2.5M36 23C32.8 7 58.4 4 59.3 19.6c.8 13-20 16.3-23.3 3.4m36.1 15c-1.3 1.4-2.7 1.2-4.1.7 0 1.9.4 3.9.1 5.9-.5.9-1.5 1-2.3 1.4-1.2-.2-2.1-.9-2.6-2l-.2-.1c-3.9 5.2-6.3-1.1-5.2-5-1.2.1-2.2-.2-3-1.5-1.4-2.6.7-5.8 3.4-6.3.7 3 8.7 2.6 10.1-.2 3.1 1.5 6.5 4.3 3.8 7.1m-7-17.5c-.9-13.8 20.3-17.5 23.4-4 3.5 15-20.8 18.9-23.4 4M41.7 17c-1.9 0-3.5 1.7-3.5 3.8s1.6 3.8 3.5 3.8 3.5-1.7 3.5-3.8-1.5-3.8-3.5-3.8m1.6 5.7c-.5 0-.8-.4-.8-1 0-.5.4-1 .8-1 .5 0 .8.4.8 1 0 .5-.3 1-.8 1m27.8-6.6c-1.9 0-3.4 1.7-3.4 3.8s1.5 3.8 3.4 3.8 3.4-1.7 3.4-3.8-1.5-3.8-3.4-3.8m1.6 5.6c-.4 0-.8-.4-.8-1 0-.5.4-1 .8-1s.8.4.8 1-.4 1-.8 1"
    }, null, -1)];
    function Sre(e, t) {
        return mo(),
        vo("svg", _re, [...kre])
    }
    const Ere = {
        render: Sre
    }
      , xre = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Ere,
        render: Sre
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Tre = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , Are = [Eo("path", {
        d: "M1.5 0h21l-1.91 21.563L11.977 24l-8.564-2.438zm7.031 9.75-.232-2.718 10.059.003.23-2.622L5.412 4.41l.698 8.01h9.126l-.326 3.426-2.91.804-2.955-.81-.188-2.11H6.248l.33 4.171L12 19.351l5.379-1.443.744-8.157z"
    }, null, -1)];
    function Cre(e, t) {
        return mo(),
        vo("svg", Tre, [...Are])
    }
    const Pre = {
        render: Cre
    }
      , Dre = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Pre,
        render: Cre
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Rre = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 128 128"
    }
      , Nre = [Eo("path", {
        d: "M111.7 29.7 128 64l-16.3 34.3H16.3L0 64l16.3-34.3zm-5.5 5.7H20L6.3 64l13.6 28.6h86.3L119.8 64zm-76.3 19v8h9.2v-8.1h4.8v20.4h-4.7v-8.4H30v8.4h-4.8V54.4zm34.3 0v3.8h-6.5v16.5H53V58.2h-6.5v-3.8zm18.3 0v3.8H76v16.5h-4.7V58.2h-6.5v-3.8zm16.1.9c1.2.5 2.3 1.4 3.1 2.6.7 1.2 1.1 2.5 1 3.9.1 1.4-.3 2.7-1 3.9-.7 1.1-1.8 2-3.1 2.6-1.5.6-3.1.9-4.7.9h-4.1v5.6H85V54.4h8.9c1.6 0 3.2.3 4.7.9m-5.1 2.9h-3.8v7.1h3.8q2.1 0 3.3-.9c.8-.6 1.2-1.6 1.1-2.6 0-1.1-.3-2.1-1.1-2.6-.8-.7-1.9-1-3.3-1"
    }, null, -1)];
    function $re(e, t) {
        return mo(),
        vo("svg", Rre, [...Nre])
    }
    const Ire = {
        render: $re
    }
      , Mre = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Ire,
        render: $re
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Lre = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , Qre = [Eo("path", {
        d: "M11.26 15.27c3.37-.15 7.15-1.09 7-2.21a26 26 0 0 1-4.76.59c-3.62.16-6.58-.24-6.61-.9 0-.2.24-.4.69-.58-2.39-.64-3.67.53-3.69 1.22-.1 1.45 3.22 2.06 7.37 1.88m5.91 1.64a23 23 0 0 1-4.07.5c-3.09.14-5.61-.21-5.64-.77 0-.17.21-.34.59-.49-2-.55-3.13.45-3.15 1-.05 1.24 2.78 1.77 6.33 1.61 2.87-.1 6.25-1 5.94-1.85M3.61 20.8a.93.93 0 0 1 .29-.65c-2.09.1-2.54 1.13-2.51 1.76.07 1.39 4.67 2.31 10 2.05 4.44-.22 9.16-1 9.16-2.34a26.3 26.3 0 0 1-7.2 1.23c-5.35.26-9.67-.66-9.74-2.05"
    }, null, -1), Eo("path", {
        d: "M22.4 12.65c-.55-1.48-2.67-2.34-4.74-1.57a2.47 2.47 0 0 0-1 .81c1.94-.56 3.83 0 4.34 1.41.45 1.21-.3 2.64-1.72 3.54a1.37 1.37 0 0 0 .92-.13c2.25-1.05 2.8-2.58 2.2-4.06m-9.88-1.38s-3.1-2.19-1.92-4.35S14.37 2.43 13.38 0c0 0 .12 1-3.12 3.91s-2.14 6.33 2.26 7.36"
    }, null, -1), Eo("path", {
        d: "M15.17 4.83s-4.24 1.51-2.83 3.53c1 1.43 2.13 2 1.42 4 0 0 2.83-1.51.71-3.53s.7-4 .7-4M8.69 19.26c-1.6-.43-2.46.35-2.47.81 0 1 2.18 1.39 5 1.27 2.26-.11 4.73-.95 4.67-1.49a16.6 16.6 0 0 1-3.2.4c-2.43.11-4.41-.16-4.43-.61-.04-.13.13-.26.43-.38"
    }, null, -1)];
    function Bre(e, t) {
        return mo(),
        vo("svg", Lre, [...Qre])
    }
    const Ure = {
        render: Bre
    }
      , Fre = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Ure,
        render: Bre
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , jre = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , zre = [Eo("path", {
        d: "M0 0h24v24H0zm22.034 18.276c-.175-1.095-.888-2.015-3.003-2.873-.736-.345-1.554-.585-1.797-1.14-.091-.33-.105-.51-.046-.705.15-.646.915-.84 1.515-.66.39.12.75.42.976.9 1.034-.676 1.034-.676 1.755-1.125-.27-.42-.404-.601-.586-.78-.63-.705-1.469-1.065-2.834-1.034l-.705.089c-.676.165-1.32.525-1.71 1.005-1.14 1.291-.811 3.541.569 4.471 1.365 1.02 3.361 1.244 3.616 2.205.24 1.17-.87 1.545-1.966 1.41-.811-.18-1.26-.586-1.755-1.336l-1.83 1.051c.21.48.45.689.81 1.109 1.74 1.756 6.09 1.666 6.871-1.004.029-.09.24-.705.074-1.65zm-8.983-7.245h-2.248c0 1.938-.009 3.864-.009 5.805 0 1.232.063 2.363-.138 2.711-.33.689-1.18.601-1.566.48-.396-.196-.597-.466-.83-.855-.063-.105-.11-.196-.127-.196l-1.825 1.125c.305.63.75 1.172 1.324 1.517.855.51 2.004.675 3.207.405.783-.226 1.458-.691 1.811-1.411.51-.93.402-2.07.397-3.346.012-2.054 0-4.109 0-6.179z"
    }, null, -1)];
    function qre(e, t) {
        return mo(),
        vo("svg", jre, [...zre])
    }
    const Hre = {
        render: qre
    }
      , Zre = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Hre,
        render: qre
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Wre = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , Xre = [Eo("path", {
        d: "M4.56 18.71c-1.41-4-.65-8.94 1.77-11.48A5.47 5.47 0 0 1 12 5.71h.15a.8.8 0 0 1 .22.12c4 1.65 4.28 8.57 1.28 11.41a4.15 4.15 0 0 0 3.08-1.35c2.12-2.23 2.76-6.62 1.49-10.22A7.75 7.75 0 0 0 12.81.54H12a11.5 11.5 0 0 0-5.42 21.6 10 10 0 0 1-2.02-3.43"
    }, null, -1), Eo("path", {
        d: "M23.5 12a11.49 11.49 0 0 0-6.09-10.14 9.9 9.9 0 0 1 2 3.43c1.41 4 .65 9-1.77 11.5a5.42 5.42 0 0 1-4 1.75A6.5 6.5 0 0 1 12 18.3h-.15a.8.8 0 0 1-.22-.12c-4-1.65-4.29-8.57-1.29-11.41a4.14 4.14 0 0 0-3.11 1.32c-2.12 2.22-2.76 6.61-1.49 10.2a7.77 7.77 0 0 0 5.45 5.17H12A11.5 11.5 0 0 0 23.5 12"
    }, null, -1)];
    function Vre(e, t) {
        return mo(),
        vo("svg", Wre, [...Xre])
    }
    const Gre = {
        render: Vre
    }
      , Yre = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Gre,
        render: Vre
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Kre = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 128 128"
    }
      , Jre = [Eo("path", {
        d: "M0 0h61.4L0 60.4zm0 128L128 0H64.6L0 63.7zm128 0L64.6 66.6 3.3 128z"
    }, null, -1)];
    function eoe(e, t) {
        return mo(),
        vo("svg", Kre, [...Jre])
    }
    const toe = {
        render: eoe
    }
      , noe = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: toe,
        render: eoe
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , roe = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , ooe = [Eo("path", {
        d: "M21.75 5.52 13 .28a2 2 0 0 0-2 0L2.25 5.52a2 2 0 0 0-1 1.69v9.58a2 2 0 0 0 1 1.69l2.62 1.57a3.12 3.12 0 0 0 4.73-2.68V8.12a1 1 0 0 0-2 0v9.25a1.13 1.13 0 0 1-.57 1 1.14 1.14 0 0 1-1.13 0l-2.61-1.58V7.24L12 2l8.73 5.21v9.55L12 22l-1.7-1a1 1 0 1 0-1 1.71l1.72 1a2 2 0 0 0 2 0l8.74-5.24a2 2 0 0 0 1-1.69V7.21a2 2 0 0 0-1.01-1.69"
    }, null, -1), Eo("path", {
        d: "M15.51 14.76a9.3 9.3 0 0 1-2.24 0 .85.85 0 0 1-.75-.85 1 1 0 0 0-2 0A2.87 2.87 0 0 0 13 16.75a12 12 0 0 0 1.36.08 12 12 0 0 0 1.37-.08 2.87 2.87 0 0 0 2.5-2.84A2.68 2.68 0 0 0 16 11.26l-2.91-.49a.69.69 0 0 1-.58-.68.85.85 0 0 1 .75-.85 9.3 9.3 0 0 1 2.24 0 .85.85 0 0 1 .75.85 1 1 0 0 0 2 0 2.87 2.87 0 0 0-2.5-2.84 12.5 12.5 0 0 0-2.73 0 2.87 2.87 0 0 0-2.51 2.84 2.68 2.68 0 0 0 2.25 2.65l2.91.49a.68.68 0 0 1 .58.68.85.85 0 0 1-.74.85"
    }, null, -1)];
    function ioe(e, t) {
        return mo(),
        vo("svg", roe, [...ooe])
    }
    const aoe = {
        render: ioe
    }
      , soe = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: aoe,
        render: ioe
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , loe = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 128 128"
    }
      , coe = [Eo("path", {
        d: "M63.877 125.392c-32.671 0-60.37-27.594-60.627-60.469a59.94 59.94 0 0 1 17.506-42.759 60.94 60.94 0 0 1 43.279-18.36 60.08 60.08 0 0 1 42.647 17.71 60.15 60.15 0 0 1 18.157 42.522c.151 33.604-26.864 61.021-60.469 61.363h-.493zm.19-118.406a57.77 57.77 0 0 0-41.01 17.427 56.78 56.78 0 0 0-16.63 40.484c.236 31.159 26.495 57.286 57.43 57.286h.414c31.863-.29 57.504-26.266 57.385-58.128a56.97 56.97 0 0 0-17.217-40.273A56.7 56.7 0 0 0 64.068 6.986z"
    }, null, -1), Eo("path", {
        d: "M16.89 82.383V46.865h8.64v3.183h-4.583v29.218h4.584v3.183zm29.323-18.111c0 6.478-3.933 10.167-9.26 10.167s-8.877-4.156-8.877-9.831c0-5.939 3.722-10.121 9.167-10.121s8.97 4.36 8.97 9.785m-14.415.29c0 3.932 1.973 7.05 5.36 7.05s5.333-3.183 5.333-7.195c0-3.643-1.796-7.083-5.334-7.083s-5.392 3.328-5.392 7.307zm17.407-9.404c1.69-.29 3.407-.434 5.123-.428a9.17 9.17 0 0 1 5.537 1.223 4.06 4.06 0 0 1 2.006 3.61 4.48 4.48 0 0 1-3.183 4.183c2.269.46 3.9 2.46 3.9 4.775a5.02 5.02 0 0 1-1.861 3.978c-1.368 1.21-3.643 1.796-7.162 1.796a34 34 0 0 1-4.327-.257zm3.499 7.622h1.795c2.433 0 3.801-1.145 3.801-2.782s-1.368-2.644-3.61-2.644a9.8 9.8 0 0 0-2.006.145zm0 8.878c.618.065 1.243.092 1.86.078 2.263 0 4.262-.861 4.262-3.182s-1.94-3.183-4.373-3.183h-1.75zM69.54 54.901h3.517v12.554c0 5.334-2.577 7.116-6.365 7.116a9.3 9.3 0 0 1-2.973-.507l.428-2.834c.703.224 1.44.335 2.183.349 2.006 0 3.183-.921 3.183-4.262l.026-12.416zm13.527 10.456v2.434h-7.32v-2.434zm17.091 8.273a12.3 12.3 0 0 1-4.978.862c-6.129 0-9.851-3.834-9.851-9.707-.283-5.353 3.827-9.923 9.18-10.206.375-.02.757-.02 1.131.006a11.1 11.1 0 0 1 4.775.862l-.783 2.801a9.5 9.5 0 0 0-3.788-.75c-3.932 0-6.76 2.467-6.76 7.116 0 4.235 2.499 6.971 6.734 6.971a9.8 9.8 0 0 0 3.834-.717zM111.2 46.766v35.61h-8.641v-3.182h4.583V49.949h-4.583v-3.183h8.64z"
    }, null, -1)];
    function uoe(e, t) {
        return mo(),
        vo("svg", loe, [...coe])
    }
    const doe = {
        render: uoe
    }
      , poe = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: doe,
        render: uoe
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , hoe = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 128 128"
    }
      , foe = [Eo("path", {
        d: "M65.004 115.355c-.461-.894-1.004-2.796-1.356-3.601-.378-.711-1.46-2.692-1.984-3.332-1.164-1.332-1.437-1.438-1.809-3.23-.628-3.067-2.148-8.462-4.042-12.227-1.004-2-2.626-3.606-4.067-5.07-1.246-1.247-4.121-3.31-4.668-3.227-4.766.894-6.226 5.586-8.457 9.27-1.27 2.062-2.516 3.769-3.52 5.937-.898 1.98-.812 4.23-2.331 5.938a15.4 15.4 0 0 0-3.333 5.855c-.195.453-.546 4.957-1.003 6.016l7.02-.438c6.585.461 4.687 2.961 14.858 2.438l16.098-.54a25 25 0 0 0-1.433-3.792zM111.793 8.254H16.207C7.312 8.23.086 15.457.086 24.352v35.105c2.352-.812 5.578-5.75 6.668-6.934 1.789-2.062 2.16-4.77 3.059-6.378 2.062-3.793 2.433-6.477 7.101-6.477 2.164 0 3.063.516 4.5 2.516.996 1.332 2.79 3.957 3.602 5.668 1.004 1.98 2.523 4.582 3.254 5.125.515.351.972.722 1.433.894.707.27 1.356-.27 1.902-.629.622-.539.895-1.52 1.52-2.953.895-2.086 1.813-4.418 2.332-5.312.914-1.461 1.273-3.254 2.25-4.067 1.461-1.246 3.441-1.355 3.957-1.437 2.98-.625 4.336 1.437 5.777 2.707.973.894 2.243 2.605 3.246 4.851.708 1.793 1.606 3.52 2.067 4.5.351.98 1.266 2.606 1.789 4.582.543 1.711 1.809 3.067 2.352 3.961 0 0 .812 2.164 5.476 4.145a35 35 0 0 0 4.336 1.52c2.066.734 4.047.644 6.563.374 1.789 0 2.793-2.625 3.601-4.683.438-1.254.98-4.774 1.25-5.758.27-.996-.437-1.707.192-2.625.722-.977 1.164-1.082 1.519-2.332.914-2.793 5.957-2.875 8.832-2.875 2.414 0 2.063 2.332 6.125 1.52 2.336-.434 4.586.273 7.023.995 2.063.543 4.043 1.168 5.204 2.524.73.898 2.629 5.312.73 5.476.164.188.36.645.625.817-.46 1.707-2.25.46-3.332.27-1.355-.27-2.332 0-3.684.624-2.335.996-5.668.918-7.726 2.625-1.715 1.438-1.715 4.582-2.543 6.371 0 0-2.254 5.696-6.996 9.192-1.278.914-3.715 3.058-8.918 3.871-2.356.355-4.586.355-7.024.27-1.164-.079-2.332-.079-3.52-.079-.706 0-3.062-.109-2.96.164l-.27.645c.024.29.063.602.164.895.102.515.102.976.192 1.437 0 .98-.086 2.063 0 3.066.082 2.063.894 3.957 1.004 6.102.078 2.355 1.246 4.875 2.414 6.77.46.707 1.086.789 1.355 1.71.352.98 0 2.141.188 3.227.625 4.227 1.875 8.73 3.773 12.61v.078c2.332-.352 4.77-1.247 7.836-1.684 5.664-.832 13.5-.461 18.54-.914 12.796-1.168 19.706 5.226 31.148 2.601V24.336c-.063-8.895-7.293-16.102-16.207-16.102zM64.086 83.855q0-.28 0 0m-34.457 14.75c.894-1.98 1.433-4.125 2.144-6.101.73-1.899 1.813-4.61 3.684-5.582-.246-.274-3.957-.375-4.934-.461-1.082-.086-2.171-.273-3.25-.438a135 135 0 0 1-6.125-1.265c-1.168-.274-5.21-1.715-6.02-2.067-2.085-.894-3.421-3.52-4.96-3.246-.977.188-1.98.54-2.605 1.54-.543.812-.731 2.242-1.083 3.226-.437 1.086-1.168 2.164-1.707 3.25-1.277 1.875-3.332 3.582-4.23 5.484-.191.457-.27.895-.457 1.356v21.683c1.082.188 2.16.371 3.328.73 8.996 2.438 11.164 2.606 19.98 1.63l.813-.11c.625-1.437 1.188-6.207 1.629-7.644.352-1.164.812-2.063.996-3.14.164-1.09 0-2.173-.102-3.15-.171-2.628 1.895-3.519 2.899-5.69zm0 0"
    }, null, -1)];
    function moe(e, t) {
        return mo(),
        vo("svg", hoe, [...foe])
    }
    const goe = {
        render: moe
    }
      , boe = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: goe,
        render: moe
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Ooe = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , voe = [Eo("path", {
        d: "M7.01 10.207h-.944l-.515 2.648h.838q.834 0 1.242-.314.408-.315.55-1.049.137-.705-.124-.995-.262-.29-1.047-.29M12 5.688C5.373 5.688 0 8.514 0 12s5.373 6.313 12 6.313S24 15.486 24 12s-5.373-6.312-12-6.312m-3.26 7.451c-.261.25-.575.438-.917.551q-.505.163-1.285.164H5.357l-.327 1.681H3.652l1.23-6.326h2.65q1.195 0 1.744.628.549.627.33 1.752a2.8 2.8 0 0 1-.305.847q-.215.383-.561.703m4.024.715.543-2.799q.094-.478-.068-.651-.16-.174-.687-.174H11.46l-.704 3.625H9.388l1.23-6.327h1.367l-.327 1.682h1.218q1.15 0 1.586.401c.436.401.378.7.263 1.299l-.572 2.944zm7.597-2.265a2.8 2.8 0 0 1-.305.847q-.214.383-.561.703a2.44 2.44 0 0 1-.917.551q-.504.163-1.286.164h-1.18l-.327 1.682h-1.378l1.23-6.326h2.649q1.195 0 1.744.628.55.626.331 1.751m-2.595-1.382h-.943l-.516 2.648h.838q.835 0 1.242-.314.407-.315.551-1.049.137-.705-.125-.995c-.262-.29-.524-.29-1.047-.29"
    }, null, -1)];
    function yoe(e, t) {
        return mo(),
        vo("svg", Ooe, [...voe])
    }
    const woe = {
        render: yoe
    }
      , _oe = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: woe,
        render: yoe
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , koe = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 121 121"
    }
      , Soe = [Eo("path", {
        "fill-rule": "evenodd",
        d: "M73.7 58.9c-1.5-1.8-3.2-3.9-5-5.9C58.5 41.7 48.4 30.3 38 19.2c-4.7-5.1-6.2-10-.6-15.1C43-.9 48.5-.4 53.7 5.3 68.1 21.2 82.4 37.2 97 52.9c5.5 5.9 4.2 9.9-1.8 14.2-23 16.7-46 33.5-68.9 50.4-5.1 3.8-10.1 4.8-14.2-.9-4.6-6.2-.3-9.9 4.4-13.3 17-12.4 34-24.8 50.9-37.4 2.5-1.7 5.9-2.8 6.3-7m7.3 59.8c-6.2 0-12.4.2-18.6-.1-4.9-.2-7.9-3-7.8-8.2.1-4.9 2.5-8.6 7.5-8.7 13.5-.4 27.1-.3 40.7 0 4.3.1 7.5 2.9 7.5 7.4 0 5.1-2.7 9.1-8.2 9.5-7.2.4-14.2.1-21.1.1",
        "clip-rule": "evenodd"
    }, null, -1)];
    function Eoe(e, t) {
        return mo(),
        vo("svg", koe, [...Soe])
    }
    const xoe = {
        render: Eoe
    }
      , Toe = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: xoe,
        render: Eoe
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Aoe = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , Coe = [Eo("path", {
        d: "m14.25.18.9.2.73.26.59.3.45.32.34.34.25.34.16.33.1.3.04.26.02.2-.01.13V8.5l-.05.63-.13.55-.21.46-.26.38-.3.31-.33.25-.35.19-.35.14-.33.1-.3.07-.26.04-.21.02H8.77l-.69.05-.59.14-.5.22-.41.27-.33.32-.27.35-.2.36-.15.37-.1.35-.07.32-.04.27-.02.21v3.06H3.17l-.21-.03-.28-.07-.32-.12-.35-.18-.36-.26-.36-.36-.35-.46-.32-.59-.28-.73-.21-.88-.14-1.05-.05-1.23.06-1.22.16-1.04.24-.87.32-.71.36-.57.4-.44.42-.33.42-.24.4-.16.36-.1.32-.05.24-.01h.16l.06.01h8.16v-.83H6.18l-.01-2.75-.02-.37.05-.34.11-.31.17-.28.25-.26.31-.23.38-.2.44-.18.51-.15.58-.12.64-.1.71-.06.77-.04.84-.02 1.27.05zm-6.3 1.98-.23.33-.08.41.08.41.23.34.33.22.41.09.41-.09.33-.22.23-.34.08-.41-.08-.41-.23-.33-.33-.22-.41-.09-.41.09zm13.09 3.95.28.06.32.12.35.18.36.27.36.35.35.47.32.59.28.73.21.88.14 1.04.05 1.23-.06 1.23-.16 1.04-.24.86-.32.71-.36.57-.4.45-.42.33-.42.24-.4.16-.36.09-.32.05-.24.02-.16-.01h-8.22v.82h5.84l.01 2.76.02.36-.05.34-.11.31-.17.29-.25.25-.31.24-.38.2-.44.17-.51.15-.58.13-.64.09-.71.07-.77.04-.84.01-1.27-.04-1.07-.14-.9-.2-.73-.25-.59-.3-.45-.33-.34-.34-.25-.34-.16-.33-.1-.3-.04-.25-.02-.2.01-.13v-5.34l.05-.64.13-.54.21-.46.26-.38.3-.32.33-.24.35-.2.35-.14.33-.1.3-.06.26-.04.21-.02.13-.01h5.84l.69-.05.59-.14.5-.21.41-.28.33-.32.27-.35.2-.36.15-.36.1-.35.07-.32.04-.28.02-.21V6.07h2.09l.14.01zm-6.47 14.25-.23.33-.08.41.08.41.23.33.33.23.41.08.41-.08.33-.23.23-.33.08-.41-.08-.41-.23-.33-.33-.23-.41-.08-.41.08z"
    }, null, -1)];
    function Poe(e, t) {
        return mo(),
        vo("svg", Aoe, [...Coe])
    }
    const Doe = {
        render: Poe
    }
      , Roe = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Doe,
        render: Poe
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Noe = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 128 128"
    }
      , $oe = [Eo("path", {
        d: "M64 14.648c-35.346 0-64 19.19-64 42.863C0 78.275 22.046 95.589 51.316 99.53V86.699c-15.55-4.89-26.166-14.693-26.166-25.991 0-16.183 21.779-29.303 48.646-29.303 26.866 0 46.693 8.975 46.693 29.303 0 10.486-5.273 17.95-14.066 22.72 1.204.908 2.22 2.072 2.904 3.419l.388.655C121.025 79.772 128 69.189 128 57.51c0-23.672-28.654-42.863-64-42.863zm20.1 74.88c-2.612.257-5.322.41-8.114.462l.002 9.63a88 88 0 0 0 12.474-2.492l-.501-.941c-.68-1.268-1.347-2.543-2.033-3.807a41 41 0 0 0-1.828-2.851z"
    }, null, -1), Eo("path", {
        "fill-rule": "evenodd",
        d: "M97.469 81.036s3.874 1.169 6.124 2.307c.78.396 2.132 1.184 3.106 2.22a8.4 8.4 0 0 1 1.42 2.04l15.266 25.74-24.674.01-11.537-21.666s-2.363-4.06-3.817-5.237c-1.213-.982-1.73-1.331-2.929-1.331h-5.862l.004 28.219-21.834.009V41.263h43.845s19.97.36 19.97 19.359S97.47 81.035 97.47 81.035zm-9.497-24.137-13.218-.009-.006 12.257 13.224-.004s6.124-.019 6.124-6.235c0-6.34-6.124-6.01-6.124-6.01z"
    }, null, -1)];
    function Ioe(e, t) {
        return mo(),
        vo("svg", Noe, [...$oe])
    }
    const Moe = {
        render: Ioe
    }
      , Loe = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Moe,
        render: Ioe
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Qoe = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , Boe = [Eo("path", {
        d: "M20.156.083c3.033.525 3.893 2.598 3.829 4.77L24 4.822 22.635 22.71 4.89 23.926h.016C3.433 23.864.15 23.729 0 19.139l1.645-3 2.819 6.586.503 1.172 2.805-9.144-.03.007.016-.03 9.255 2.956-1.396-5.431-.99-3.9 8.82-.569-.615-.51L16.5 2.114 20.159.073zM5.13 5.073c3.561-3.533 8.157-5.621 9.922-3.84 1.762 1.777-.105 6.105-3.673 9.636-3.563 3.532-8.103 5.734-9.864 3.957-1.766-1.777.045-6.217 3.612-9.75z"
    }, null, -1)];
    function Uoe(e, t) {
        return mo(),
        vo("svg", Qoe, [...Boe])
    }
    const Foe = {
        render: Uoe
    }
      , joe = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Foe,
        render: Uoe
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , zoe = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , qoe = [Eo("path", {
        d: "M4.589 24c4.537 0 13.81-1.516 14.821-3v-5.729c-.957 1.408-10.284 2.912-14.821 2.912zm0-7.635c4.537 0 13.81-1.516 14.821-3V7.636c-.957 1.408-10.284 2.912-14.821 2.912zm0-7.636c4.537 0 13.81-1.516 14.821-3V0C18.453 1.408 9.126 2.912 4.589 2.912z"
    }, null, -1)];
    function Hoe(e, t) {
        return mo(),
        vo("svg", zoe, [...qoe])
    }
    const Zoe = {
        render: Hoe
    }
      , Woe = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Zoe,
        render: Hoe
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Xoe = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 17 17"
    }
      , Voe = [Eo("path", {
        d: "m2.4 11.4 5.1-4.6-5.1-4.7L.7 3.7l3.4 3v.1l-3.4 3zm14.2 3.3v-2.2h-8v2.2z"
    }, null, -1)];
    function Goe(e, t) {
        return mo(),
        vo("svg", Xoe, [...Voe])
    }
    const Yoe = {
        render: Goe
    }
      , Koe = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Yoe,
        render: Goe
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Joe = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 128 128"
    }
      , eie = [Eo("path", {
        d: "M117.3 87.3c.2-.6.4-1.3.5-1.9 7-28-10.1-61.2-39.2-78.6C91.4 24 97 44.9 92 63.2c-.4 1.6-1 3.2-1.6 4.7-.6-.4-1.5-.9-2.5-1.5 0 0-28.9-17.9-60.2-49.4-.9-.8 16.7 25 36.6 46.1-9.4-5.3-35.5-24.3-52-39.4 2 3.4 4.4 6.7 7.1 9.8C33.1 51 51.2 72.6 72.7 89.2c-15.2 9.3-36.6 10-57.9 0C9.5 86.7 4.6 83.7 0 80.3c9 14.4 22.9 26.9 39.9 34.2 20.2 8.7 40.3 8.1 55.2.1.1 0 .1-.1.2-.1.7-.4 1.3-.7 2-1.1 7.2-3.7 21.3-7.4 28.9 7.4 1.7 3.6 5.7-15.6-8.9-33.5"
    }, null, -1)];
    function tie(e, t) {
        return mo(),
        vo("svg", Joe, [...eie])
    }
    const nie = {
        render: tie
    }
      , rie = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: nie,
        render: tie
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , oie = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , iie = [Eo("path", {
        d: "M1.125 0C.502 0 0 .502 0 1.125v21.75C0 23.498.502 24 1.125 24h21.75c.623 0 1.125-.502 1.125-1.125V1.125C24 .502 23.498 0 22.875 0zm17.363 9.75q.918 0 1.627.111a6.4 6.4 0 0 1 1.306.34v2.458a4 4 0 0 0-.643-.361 5 5 0 0 0-.717-.26 5.5 5.5 0 0 0-1.426-.2q-.45 0-.819.086a2.1 2.1 0 0 0-.623.242q-.254.156-.393.374a.9.9 0 0 0-.14.49q0 .294.156.529.156.234.443.444c.287.21.423.276.696.41q.41.203.926.416.705.296 1.266.628.561.333.963.753.402.418.614.957.213.538.214 1.253 0 .986-.373 1.656a3 3 0 0 1-1.012 1.085 4.4 4.4 0 0 1-1.487.596q-.85.18-1.79.18a10 10 0 0 1-1.84-.164 5.5 5.5 0 0 1-1.512-.493v-2.63a5.03 5.03 0 0 0 3.237 1.2q.5 0 .872-.09.373-.09.623-.25.249-.162.373-.38a1.02 1.02 0 0 0-.074-1.089 2.1 2.1 0 0 0-.537-.5 5.6 5.6 0 0 0-.807-.444 28 28 0 0 0-1.007-.436q-1.377-.575-2.053-1.405t-.676-2.005q0-.92.369-1.582.368-.662 1.004-1.089a4.5 4.5 0 0 1 1.47-.629 7.5 7.5 0 0 1 1.77-.201m-15.113.188h9.563v2.166H9.506v9.646H6.789v-9.646H3.375z"
    }, null, -1)];
    function aie(e, t) {
        return mo(),
        vo("svg", oie, [...iie])
    }
    const sie = {
        render: aie
    }
      , lie = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: sie,
        render: aie
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , cie = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 12 12"
    }
      , uie = [Eo("path", {
        stroke: "currentColor",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M3.9 2.3.7 5.5c-.3.3-.3.8 0 1l3.1 3.1m4.3-7.3 3.1 3.1c.3.3.3.8 0 1L8.1 9.7"
    }, null, -1)];
    function die(e, t) {
        return mo(),
        vo("svg", cie, [...uie])
    }
    const pie = {
        render: die
    }
      , hie = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: pie,
        render: die
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , fie = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , mie = [Eo("path", {
        d: "M23.55 10.91 13.09.45a1.55 1.55 0 0 0-2.18 0L8.46 2.9 11 5.48a2.06 2.06 0 0 1 1-.23 2.25 2.25 0 0 1 2.25 2.25 2.2 2.2 0 0 1-.22 1l2.19 2.2a2 2 0 1 1-1.06 1.06L13 9.52a1 1 0 0 1-.21.09v5.54a2 2 0 1 1-1.5 0V9.61A2.24 2.24 0 0 1 9.75 7.5a2.2 2.2 0 0 1 .22-1L7.4 4 .45 11a1.55 1.55 0 0 0 0 2.18l10.46 10.37a1.55 1.55 0 0 0 2.18 0l10.46-10.46a1.55 1.55 0 0 0 0-2.18"
    }, null, -1)];
    function gie(e, t) {
        return mo(),
        vo("svg", fie, [...mie])
    }
    const bie = {
        render: gie
    }
      , Oie = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: bie,
        render: gie
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , vie = {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
        viewBox: "0 0 24 24"
    }
      , yie = [Eo("path", {
        d: "M12.001 4.8q-4.8 0-6 4.8 1.8-2.4 4.2-1.8c.913.228 1.565.89 2.288 1.624C13.666 10.618 15.027 12 18.001 12q4.8 0 6-4.8-1.8 2.4-4.2 1.8c-.913-.228-1.565-.89-2.288-1.624C16.337 6.182 14.976 4.8 12.001 4.8m-6 7.2q-4.8 0-6 4.8 1.8-2.4 4.2-1.8c.913.228 1.565.89 2.288 1.624 1.177 1.194 2.538 2.576 5.512 2.576q4.8 0 6-4.8-1.8 2.4-4.2 1.8c-.913-.228-1.565-.89-2.288-1.624C10.337 13.382 8.976 12 6.001 12"
    }, null, -1)];
    function wie(e, t) {
        return mo(),
        vo("svg", vie, [...yie])
    }
    const _ie = {
        render: wie
    }
      , kie = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: _ie,
        render: wie
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , Sie = {
        key: 0,
        class: "api-client-drawer"
    }
      , Eie = {
        class: "api-client-container"
    }
      , xie = {
        class: "scalar-api-client-height"
    }
      , Tie = {
        class: "scalar-api-client-states"
    }
      , Aie = {
        class: "t-doc__sidebar"
    }
      , Cie = k0(Ln({
        __name: "ApiClientModalOld",
        props: {
            parsedSpec: {},
            overloadShow: {
                type: Boolean
            },
            proxyUrl: {},
            theme: {}
        },
        emits: ["toggleDarkMode"],
        setup(e) {
            const t = Bn((()=>Promise.resolve().then((()=>tY)).then((e=>e.ApiClient))))
              , {hideApiClient: n, state: r} = eY()
              , o = Rl("(max-width: 1000px)")
              , i = Et(!1);
            return (e,a)=>(mo(),
            vo(lo, null, [Ct(r).showApiClient || e.overloadShow ? (mo(),
            vo("div", Sie, [Eo("div", Eie, [Fn(e.$slots, "header", {}, void 0, !0), Eo("div", xie, [xo(Ct(t), {
                proxyUrl: e.proxyUrl,
                showSideBar: i.value,
                theme: e.theme ?? "none",
                withDefaultFonts: !1,
                onEscapeKeyPress: Ct(n),
                onToggleSidebar: a[2] || (a[2] = e=>i.value = !i.value)
            }, {
                "address-bar-controls": dn((()=>[Eo("div", Tie, [Eo("button", {
                    class: "scalar-api-client-states-button scalar-api-client-states-button__endpoints",
                    type: "button",
                    onClick: a[0] || (a[0] = e=>i.value = !i.value)
                }, [xo(Ct(rC), {
                    icon: i.value ? "SideBarClosed" : "SideBarOpen",
                    size: "sm"
                }, null, 8, ["icon"])]), Eo("button", {
                    class: "scalar-api-client-states-button",
                    type: "button",
                    onClick: a[1] || (a[1] = (...e)=>Ct(n) && Ct(n)(...e))
                }, [xo(Ct(rC), {
                    icon: "Close",
                    size: "sm"
                })])])])),
                sidebar: dn((()=>[Eo("div", Aie, [Nn(xo(Ct(H3), {
                    parsedSpec: e.parsedSpec
                }, {
                    "sidebar-start": dn((()=>[Fn(e.$slots, "sidebar-start", {}, void 0, !0)])),
                    _: 3
                }, 8, ["parsedSpec"]), [[ci, !Ct(o)]])])])),
                _: 3
            }, 8, ["proxyUrl", "showSideBar", "theme", "onEscapeKeyPress"])])])])) : Do("", !0), Ct(r).showApiClient ? (mo(),
            vo("div", {
                key: 1,
                class: "api-client-drawer-exit",
                onClick: a[3] || (a[3] = (...e)=>Ct(n) && Ct(n)(...e))
            })) : Do("", !0)], 64))
        }
    }), [["__scopeId", "data-v-ad4018ae"]])
      , Pie = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Cie
    }, Symbol.toStringTag, {
        value: "Module"
    }))
}
));
